{
  "version": 3,
  "sources": [
    "../../../../usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/browser-split/index.js",
    "node_modules/cuid/dist/browser-cuid.js",
    "node_modules/dom-delegator/add-event.js",
    "node_modules/dom-delegator/dom-delegator.js",
    "node_modules/dom-delegator/index.js",
    "node_modules/dom-delegator/proxy-event.js",
    "node_modules/dom-delegator/remove-event.js",
    "node_modules/ev-store/index.js",
    "node_modules/ev-store/node_modules/individual/index.js",
    "node_modules/ev-store/node_modules/individual/one-version.js",
    "node_modules/global/document.js",
    "node_modules/globalx/document.js",
    "node_modules/individual/index.js",
    "node_modules/inherits/inherits_browser.js",
    "node_modules/is-object/index.js",
    "node_modules/vdt/src/index.js",
    "node_modules/vdt/src/lib/parser.js",
    "node_modules/vdt/src/lib/stringifier.js",
    "node_modules/vdt/src/lib/utils.js",
    "node_modules/vdt/src/lib/vdt.js",
    "node_modules/virtual-domx/create-element.js",
    "node_modules/virtual-domx/diff.js",
    "node_modules/virtual-domx/h.js",
    "node_modules/virtual-domx/index.js",
    "node_modules/virtual-domx/patch.js",
    "node_modules/virtual-domx/vdom/apply-properties.js",
    "node_modules/virtual-domx/vdom/create-element.js",
    "node_modules/virtual-domx/vdom/dom-index.js",
    "node_modules/virtual-domx/vdom/patch-op.js",
    "node_modules/virtual-domx/vdom/patch.js",
    "node_modules/virtual-domx/vdom/update-widget.js",
    "node_modules/virtual-domx/virtual-hyperscript/hooks/ev-hook.js",
    "node_modules/virtual-domx/virtual-hyperscript/hooks/soft-set-hook.js",
    "node_modules/virtual-domx/virtual-hyperscript/index.js",
    "node_modules/virtual-domx/virtual-hyperscript/parse-tag.js",
    "node_modules/virtual-domx/vnode/handle-thunk.js",
    "node_modules/virtual-domx/vnode/is-thunk.js",
    "node_modules/virtual-domx/vnode/is-vcomment.js",
    "node_modules/virtual-domx/vnode/is-vhook.js",
    "node_modules/virtual-domx/vnode/is-vnode.js",
    "node_modules/virtual-domx/vnode/is-vtext.js",
    "node_modules/virtual-domx/vnode/is-widget.js",
    "node_modules/virtual-domx/vnode/vcomment.js",
    "node_modules/virtual-domx/vnode/version.js",
    "node_modules/virtual-domx/vnode/vnode.js",
    "node_modules/virtual-domx/vnode/vpatch.js",
    "node_modules/virtual-domx/vnode/vtext.js",
    "node_modules/virtual-domx/vtree/diff-props.js",
    "node_modules/virtual-domx/vtree/diff.js",
    "node_modules/weakmap-shim/create-store.js",
    "node_modules/weakmap-shim/hidden-store.js",
    "node_modules/x-is-array/index.js",
    "src/index.js",
    "src/thunk.js",
    "src/utils.js",
    "../../../../usr/local/lib/node_modules/browserify/node_modules/browser-resolve/empty.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n",
    "/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n  var namespace = 'cuid',\n    c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize),\n\n    pad = function pad(num, size) {\n      var s = \"000000000\" + num;\n      return s.substr(s.length-size);\n    },\n\n    randomBlock = function randomBlock() {\n      return pad((Math.random() *\n            discreteValues << 0)\n            .toString(base), blockSize);\n    },\n\n    safeCounter = function () {\n      c = (c < discreteValues) ? c : 0;\n      c++; // this is not subliminal\n      return c - 1;\n    },\n\n    api = function cuid() {\n      // Starting with a lowercase letter makes\n      // it HTML element ID friendly.\n      var letter = 'c', // hard-coded allows for sequential access\n\n        // timestamp\n        // warning: this exposes the exact date and time\n        // that the uid was created.\n        timestamp = (new Date().getTime()).toString(base),\n\n        // Prevent same-machine collisions.\n        counter,\n\n        // A few chars to generate distinct ids for different\n        // clients (so different computers are far less\n        // likely to generate the same id)\n        fingerprint = api.fingerprint(),\n\n        // Grab some more chars from Math.random()\n        random = randomBlock() + randomBlock();\n\n        counter = pad(safeCounter().toString(base), blockSize);\n\n      return  (letter + timestamp + counter + fingerprint + random);\n    };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n      counter,\n      print = api.fingerprint().slice(0,1) +\n        api.fingerprint().slice(-1),\n      random = randomBlock().slice(-2);\n\n      counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) +\n      counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = (function calc() {\n        var i,\n          count = 0;\n\n        for (i in window) {\n          count++;\n        }\n\n        return count;\n      }());\n\n    api.globalCount = function () { return cache; };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length +\n      navigator.userAgent.length).toString(36) +\n      api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (typeof module !== 'undefined') {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n\n}(this.applitude || this));\n",
    "var EvStore = require(\"ev-store\")\n\nmodule.exports = addEvent\n\nfunction addEvent(target, type, handler) {\n    var events = EvStore(target)\n    var event = events[type]\n\n    if (!event) {\n        events[type] = handler\n    } else if (Array.isArray(event)) {\n        if (event.indexOf(handler) === -1) {\n            event.push(handler)\n        }\n    } else if (event !== handler) {\n        events[type] = [event, handler]\n    }\n}\n",
    "var globalDocument = require(\"global/document\")\nvar EvStore = require(\"ev-store\")\nvar createStore = require(\"weakmap-shim/create-store\")\n\nvar addEvent = require(\"./add-event.js\")\nvar removeEvent = require(\"./remove-event.js\")\nvar ProxyEvent = require(\"./proxy-event.js\")\n\nvar HANDLER_STORE = createStore()\n\nmodule.exports = DOMDelegator\n\nfunction DOMDelegator(document) {\n    if (!(this instanceof DOMDelegator)) {\n        return new DOMDelegator(document);\n    }\n\n    document = document || globalDocument\n\n    this.target = document.documentElement\n    this.events = {}\n    this.rawEventListeners = {}\n    this.globalListeners = {}\n}\n\nDOMDelegator.prototype.addEventListener = addEvent\nDOMDelegator.prototype.removeEventListener = removeEvent\n\nDOMDelegator.allocateHandle =\n    function allocateHandle(func) {\n        var handle = new Handle()\n\n        HANDLER_STORE(handle).func = func;\n\n        return handle\n    }\n\nDOMDelegator.transformHandle =\n    function transformHandle(handle, broadcast) {\n        var func = HANDLER_STORE(handle).func\n\n        return this.allocateHandle(function (ev) {\n            broadcast(ev, func);\n        })\n    }\n\nDOMDelegator.prototype.addGlobalEventListener =\n    function addGlobalEventListener(eventName, fn) {\n        var listeners = this.globalListeners[eventName] || [];\n        if (listeners.indexOf(fn) === -1) {\n            listeners.push(fn)\n        }\n\n        this.globalListeners[eventName] = listeners;\n    }\n\nDOMDelegator.prototype.removeGlobalEventListener =\n    function removeGlobalEventListener(eventName, fn) {\n        var listeners = this.globalListeners[eventName] || [];\n\n        var index = listeners.indexOf(fn)\n        if (index !== -1) {\n            listeners.splice(index, 1)\n        }\n    }\n\nDOMDelegator.prototype.listenTo = function listenTo(eventName) {\n    if (!(eventName in this.events)) {\n        this.events[eventName] = 0;\n    }\n\n    this.events[eventName]++;\n\n    if (this.events[eventName] !== 1) {\n        return\n    }\n\n    var listener = this.rawEventListeners[eventName]\n    if (!listener) {\n        listener = this.rawEventListeners[eventName] =\n            createHandler(eventName, this)\n    }\n\n    this.target.addEventListener(eventName, listener, true)\n}\n\nDOMDelegator.prototype.unlistenTo = function unlistenTo(eventName) {\n    if (!(eventName in this.events)) {\n        this.events[eventName] = 0;\n    }\n\n    if (this.events[eventName] === 0) {\n        throw new Error(\"already unlistened to event.\");\n    }\n\n    this.events[eventName]--;\n\n    if (this.events[eventName] !== 0) {\n        return\n    }\n\n    var listener = this.rawEventListeners[eventName]\n\n    if (!listener) {\n        throw new Error(\"dom-delegator#unlistenTo: cannot \" +\n            \"unlisten to \" + eventName)\n    }\n\n    this.target.removeEventListener(eventName, listener, true)\n}\n\nfunction createHandler(eventName, delegator) {\n    var globalListeners = delegator.globalListeners;\n    var delegatorTarget = delegator.target;\n\n    return handler\n\n    function handler(ev) {\n        var globalHandlers = globalListeners[eventName] || []\n\n        if (globalHandlers.length > 0) {\n            var globalEvent = new ProxyEvent(ev);\n            globalEvent.currentTarget = delegatorTarget;\n            callListeners(globalHandlers, globalEvent)\n        }\n\n        findAndInvokeListeners(ev.target, ev, eventName)\n    }\n}\n\nfunction findAndInvokeListeners(elem, ev, eventName) {\n    var listener = getListener(elem, eventName)\n\n    if (listener && listener.handlers.length > 0) {\n        var listenerEvent = new ProxyEvent(ev);\n        listenerEvent.currentTarget = listener.currentTarget\n        callListeners(listener.handlers, listenerEvent)\n\n        if (listenerEvent._bubbles) {\n            var nextTarget = listener.currentTarget.parentNode\n            findAndInvokeListeners(nextTarget, ev, eventName)\n        }\n    }\n}\n\nfunction getListener(target, type) {\n    // terminate recursion if parent is `null`\n    if (target === null || typeof target === \"undefined\") {\n        return null\n    }\n\n    var events = EvStore(target)\n    // fetch list of handler fns for this event\n    var handler = events[type]\n    var allHandler = events.event\n\n    if (!handler && !allHandler) {\n        return getListener(target.parentNode, type)\n    }\n\n    var handlers = [].concat(handler || [], allHandler || [])\n    return new Listener(target, handlers)\n}\n\nfunction callListeners(handlers, ev) {\n    handlers.forEach(function (handler) {\n        if (typeof handler === \"function\") {\n            handler(ev)\n        } else if (typeof handler.handleEvent === \"function\") {\n            handler.handleEvent(ev)\n        } else if (handler.type === \"dom-delegator-handle\") {\n            HANDLER_STORE(handler).func(ev)\n        } else {\n            throw new Error(\"dom-delegator: unknown handler \" +\n                \"found: \" + JSON.stringify(handlers));\n        }\n    })\n}\n\nfunction Listener(target, handlers) {\n    this.currentTarget = target\n    this.handlers = handlers\n}\n\nfunction Handle() {\n    this.type = \"dom-delegator-handle\"\n}\n",
    "var Individual = require(\"individual\")\nvar cuid = require(\"cuid\")\nvar globalDocument = require(\"global/document\")\n\nvar DOMDelegator = require(\"./dom-delegator.js\")\n\nvar versionKey = \"13\"\nvar cacheKey = \"__DOM_DELEGATOR_CACHE@\" + versionKey\nvar cacheTokenKey = \"__DOM_DELEGATOR_CACHE_TOKEN@\" + versionKey\nvar delegatorCache = Individual(cacheKey, {\n    delegators: {}\n})\nvar commonEvents = [\n    \"blur\", \"change\", \"click\",  \"contextmenu\", \"dblclick\",\n    \"error\",\"focus\", \"focusin\", \"focusout\", \"input\", \"keydown\",\n    \"keypress\", \"keyup\", \"load\", \"mousedown\", \"mouseup\",\n    \"resize\", \"select\", \"submit\", \"touchcancel\",\n    \"touchend\", \"touchstart\", \"unload\"\n]\n\n/*  Delegator is a thin wrapper around a singleton `DOMDelegator`\n        instance.\n\n    Only one DOMDelegator should exist because we do not want\n        duplicate event listeners bound to the DOM.\n\n    `Delegator` will also `listenTo()` all events unless\n        every caller opts out of it\n*/\nmodule.exports = Delegator\n\nfunction Delegator(opts) {\n    opts = opts || {}\n    var document = opts.document || globalDocument\n\n    var cacheKey = document[cacheTokenKey]\n\n    if (!cacheKey) {\n        cacheKey =\n            document[cacheTokenKey] = cuid()\n    }\n\n    var delegator = delegatorCache.delegators[cacheKey]\n\n    if (!delegator) {\n        delegator = delegatorCache.delegators[cacheKey] =\n            new DOMDelegator(document)\n    }\n\n    if (opts.defaultEvents !== false) {\n        for (var i = 0; i < commonEvents.length; i++) {\n            delegator.listenTo(commonEvents[i])\n        }\n    }\n\n    return delegator\n}\n\nDelegator.allocateHandle = DOMDelegator.allocateHandle;\nDelegator.transformHandle = DOMDelegator.transformHandle;\n",
    "var inherits = require(\"inherits\")\n\nvar ALL_PROPS = [\n    \"altKey\", \"bubbles\", \"cancelable\", \"ctrlKey\",\n    \"eventPhase\", \"metaKey\", \"relatedTarget\", \"shiftKey\",\n    \"target\", \"timeStamp\", \"type\", \"view\", \"which\"\n]\nvar KEY_PROPS = [\"char\", \"charCode\", \"key\", \"keyCode\"]\nvar MOUSE_PROPS = [\n    \"button\", \"buttons\", \"clientX\", \"clientY\", \"layerX\",\n    \"layerY\", \"offsetX\", \"offsetY\", \"pageX\", \"pageY\",\n    \"screenX\", \"screenY\", \"toElement\"\n]\n\nvar rkeyEvent = /^key|input/\nvar rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/\n\nmodule.exports = ProxyEvent\n\nfunction ProxyEvent(ev) {\n    if (!(this instanceof ProxyEvent)) {\n        return new ProxyEvent(ev)\n    }\n\n    if (rkeyEvent.test(ev.type)) {\n        return new KeyEvent(ev)\n    } else if (rmouseEvent.test(ev.type)) {\n        return new MouseEvent(ev)\n    }\n\n    for (var i = 0; i < ALL_PROPS.length; i++) {\n        var propKey = ALL_PROPS[i]\n        this[propKey] = ev[propKey]\n    }\n\n    this._rawEvent = ev\n    this._bubbles = false;\n}\n\nProxyEvent.prototype.preventDefault = function () {\n    this._rawEvent.preventDefault()\n}\n\nProxyEvent.prototype.startPropagation = function () {\n    this._bubbles = true;\n}\n\nfunction MouseEvent(ev) {\n    for (var i = 0; i < ALL_PROPS.length; i++) {\n        var propKey = ALL_PROPS[i]\n        this[propKey] = ev[propKey]\n    }\n\n    for (var j = 0; j < MOUSE_PROPS.length; j++) {\n        var mousePropKey = MOUSE_PROPS[j]\n        this[mousePropKey] = ev[mousePropKey]\n    }\n\n    this._rawEvent = ev\n}\n\ninherits(MouseEvent, ProxyEvent)\n\nfunction KeyEvent(ev) {\n    for (var i = 0; i < ALL_PROPS.length; i++) {\n        var propKey = ALL_PROPS[i]\n        this[propKey] = ev[propKey]\n    }\n\n    for (var j = 0; j < KEY_PROPS.length; j++) {\n        var keyPropKey = KEY_PROPS[j]\n        this[keyPropKey] = ev[keyPropKey]\n    }\n\n    this._rawEvent = ev\n}\n\ninherits(KeyEvent, ProxyEvent)\n",
    "var EvStore = require(\"ev-store\")\n\nmodule.exports = removeEvent\n\nfunction removeEvent(target, type, handler) {\n    var events = EvStore(target)\n    var event = events[type]\n\n    if (!event) {\n        return\n    } else if (Array.isArray(event)) {\n        var index = event.indexOf(handler)\n        if (index !== -1) {\n            event.splice(index, 1)\n        }\n    } else if (event === handler) {\n        events[type] = null\n    }\n}\n",
    "'use strict';\n\nvar OneVersionConstraint = require('individual/one-version');\n\nvar MY_VERSION = '7';\nOneVersionConstraint('ev-store', MY_VERSION);\n\nvar hashKey = '__EV_STORE_KEY@' + MY_VERSION;\n\nmodule.exports = EvStore;\n\nfunction EvStore(elem) {\n    var hash = elem[hashKey];\n\n    if (!hash) {\n        hash = elem[hashKey] = {};\n    }\n\n    return hash;\n}\n",
    "'use strict';\n\n/*global window, global*/\n\nvar root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual;\n\nfunction Individual(key, value) {\n    if (key in root) {\n        return root[key];\n    }\n\n    root[key] = value;\n\n    return value;\n}\n",
    "'use strict';\n\nvar Individual = require('./index.js');\n\nmodule.exports = OneVersion;\n\nfunction OneVersion(moduleName, version, defaultValue) {\n    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;\n    var enforceKey = key + '_ENFORCE_SINGLETON';\n\n    var versionValue = Individual(enforceKey, version);\n\n    if (versionValue !== version) {\n        throw new Error('Can only have one copy of ' +\n            moduleName + '.\\n' +\n            'You already have version ' + versionValue +\n            ' installed.\\n' +\n            'This means you cannot install version ' + version);\n    }\n\n    return Individual(key, defaultValue);\n}\n",
    "var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = require('min-document');\n\nif (typeof document !== 'undefined') {\n    module.exports = document;\n} else {\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n\n    module.exports = doccy;\n}\n",
    "var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = require('min-documentx');\n\nif (typeof document !== 'undefined') {\n    module.exports = document;\n} else {\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n\n    module.exports = doccy;\n}\n",
    "var root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual\n\nfunction Individual(key, value) {\n    if (root[key]) {\n        return root[key]\n    }\n\n    Object.defineProperty(root, key, {\n        value: value\n        , configurable: true\n    })\n\n    return value\n}\n",
    "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n",
    "\"use strict\";\n\nmodule.exports = function isObject(x) {\n\treturn typeof x === \"object\" && x !== null;\n};\n",
    "module.exports = require('./lib/index');\n",
    "/**\n * @fileoverview parse jsx to ast\n * @author javey\n * @date 15-4-22\n */\n\nvar Utils = require('./utils'),\n    Type = Utils.Type,\n    TypeName = Utils.TypeName;\n\nvar elementNameRegexp = /^<\\w+:?\\s*[\\w\\/>]/;\n\nfunction isJSXIdentifierPart(ch) {\n    return (ch === 58) || (ch === 95) || (ch === 45) ||  // : and _ (underscore) and -\n        (ch >= 65 && ch <= 90) ||         // A..Z\n        (ch >= 97 && ch <= 122) ||        // a..z\n        (ch >= 48 && ch <= 57);         // 0..9\n}\n\nvar Parser = function() {\n    this.source = '';\n    this.index = 0;\n    this.length = 0;\n};\n\nParser.prototype = {\n    constructor: Parser,\n\n    parse: function(source, options) {\n        this.source = Utils.trimRight(source);\n        this.index = 0;\n        this.line = 1;\n        this.column = 1;\n        this.length = this.source.length;\n\n        this.options = Utils.extend({\n            delimiters: Utils.getDelimiters()\n        }, options);\n\n        return this._parseTemplate();\n    },\n\n    _parseTemplate: function() {\n        var elements = [],\n            braces = {count: 0};\n        while (this.index < this.length && braces.count >= 0) {\n            elements.push(this._advance(braces));\n        }\n\n        return elements;\n    },\n\n    _advance: function(braces) {\n        var ch = this._char();\n        if (ch !== '<') {\n            return this._scanJS(braces);\n        } else {\n            return this._scanJSX();\n        }\n    },\n\n    _scanJS: function(braces) {\n        var start = this.index,\n            Delimiters = this.options.delimiters;\n\n        while (this.index < this.length) {\n            var ch = this._char();\n            if (ch === '\\'' || ch === '\"') {\n                // skip element(<div>) in quotes\n                this._scanStringLiteral();\n            } else if (this._isElementStart()) {\n                break;\n            } else {\n                if (this._isExpect(Delimiters[0])) {\n                    braces.count++;\n                } else if (this._isExpect(Delimiters[1])) {\n                    braces.count--;\n                    if (braces.count < 0) {\n                        this._updateIndex();\n                        break;\n                    }\n                } else if (ch === '\\n') {\n                    this._updateLine();\n                }\n                this._updateIndex();\n            }\n        }\n\n        return this._type(Type.JS, {value: this.source.slice(start, braces.count < 0 ? this.index - 1 : this.index)});\n    },\n\n    _scanStringLiteral: function() {\n        var quote = this._char(),\n            start = this.index,\n            str = '';\n        this._updateIndex();\n        \n\n        while (this.index < this.length) {\n            var ch = this._char();\n            this._updateIndex();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                str += this._char(this._updateIndex());\n            } else {\n                str += ch;\n            }\n        }\n        if (quote !== '') {\n            this._error('Unclosed quote');\n        }\n\n        return this._type(Type.StringLiteral, {value: this.source.slice(start, this.index)});\n    },\n\n    _scanJSX: function() {\n        return this._parseJSXElement();\n    },\n\n    _scanJSXText: function(stopChars) {\n        var start = this.index,\n            l = stopChars.length,\n            i;\n        loop:\n        while (this.index < this.length) {\n            if (this._charCode() === 10) {\n                this._updateLine();\n            }\n            for (i = 0; i < l; i++) {\n                if (typeof stopChars[i] === 'function' && stopChars[i].call(this) || this._isExpect(stopChars[i])) {\n                    break loop;\n                }\n            }\n            this._updateIndex();\n        }\n\n        return this._type(Type.JSXText, {value: this.source.slice(start, this.index)});\n    },\n\n    _scanJSXStringLiteral: function() {\n        var quote = this._char();\n        if (quote !== '\\'' && quote !== '\"') {\n            this._error('String literal must starts with a qoute');\n        }\n        this._updateIndex();\n        var token = this._scanJSXText([quote]);\n        this._updateIndex();\n        return token;\n    },\n\n    _parseJSXElement: function() {\n        this._expect('<');\n        var start = this.index,\n            ret = {},\n            flag = this._charCode();\n        if (flag >= 65 && flag <= 90/* upper case */) {\n            // is a widget\n            this._type(Type.JSXWidget, ret);\n        } else if (this._isExpect('!--')) {\n            // is html comment\n            return this._parseJSXComment();\n        } else if (this._charCode(this.index + 1) === 58/* : */){\n            // is a directive\n            start += 2;\n            switch (flag) {\n                case 116: // t\n                    this._type(Type.JSXVdt, ret);\n                    break;\n                case 98: // b\n                    this._type(Type.JSXBlock, ret);\n                    break;\n                default:\n                    this._error('Unknown directive ' + String.fromCharCode(flag) + ':');\n            }\n            this._updateIndex(2);\n        } else {\n            // is an element\n            this._type(Type.JSXElement, ret);\n        }\n\n        while (this.index < this.length) {\n            if (!isJSXIdentifierPart(this._charCode())) {\n                break;\n            }\n            this._updateIndex();\n        }\n\n        ret.value = this.source.slice(start, this.index);\n\n        return this._parseAttributeAndChildren(ret);\n    },\n\n    _parseAttributeAndChildren: function(ret) {\n        Utils.extend(ret, {\n            attributes: this._parseJSXAttribute(),\n            children: []\n        });\n\n        if (ret.type === Type.JSXElement && Utils.isSelfClosingTag(ret.value)) {\n            // self closing tag\n            if (this._char() === '/') {\n                this._updateIndex();\n            }\n            this._expect('>');\n        } else if (this._char() === '/') {\n            // unknown self closing tag\n            this._updateIndex();\n            this._expect('>');\n        } else {\n            this._expect('>');\n            ret.children = this._parseJSXChildren();\n        }\n\n        return ret;\n    },\n\n    _parseJSXAttribute: function() {\n        var ret = [];\n        while (this.index < this.length) {\n            this._skipWhitespace();\n            if (this._char() === '/' || this._char() === '>') {\n                break;\n            } else {\n                var attr = this._parseJSXAttributeName();\n                if (this._char() === '=') {\n                    this._updateIndex();\n                    attr.value = this._parseJSXAttributeValue();\n                }\n                ret.push(attr);\n            }\n        }\n\n        return ret;\n    },\n\n    _parseJSXAttributeName: function() {\n        var start = this.index;\n        if (!isJSXIdentifierPart(this._charCode())) {\n            this._error('Unexpected identifier ' + this._char());\n        }\n        while (this.index < this.length) {\n            var ch = this._charCode();\n            if (!isJSXIdentifierPart(ch)) {\n                break;\n            }\n            this._updateIndex();\n        }\n\n        return this._type(Type.JSXAttribute, {name: this.source.slice(start, this.index)});\n    },\n\n    _parseJSXAttributeValue: function() {\n        var value,\n            Delimiters = this.options.delimiters;\n        if (this._isExpect(Delimiters[0])) {\n            value = this._parseJSXExpressionContainer();\n        } else {\n            value = this._scanJSXStringLiteral();\n        }\n        return value;\n    },\n\n    _parseJSXExpressionContainer: function() {\n        var expression,\n            Delimiters = this.options.delimiters;\n        this._expect(Delimiters[0]);\n        if (this._isExpect(Delimiters[1])) {\n            expression = this._parseJSXEmptyExpression();\n        } else {\n            expression = this._parseExpression();\n        }\n        this._expect(Delimiters[1]);\n\n        return this._type(Type.JSXExpressionContainer, {value: expression});\n    },\n\n    _parseJSXEmptyExpression: function() {\n        return this._type(Type.JSXEmptyExpression, {value: null});\n    },\n\n    _parseExpression: function() {\n        var ret = this._parseTemplate();\n        this._updateIndex(-1);\n        return ret;\n    },\n\n    _parseJSXChildren: function() {\n        var children = [];\n        while (this.index < this.length) {\n            if (this._char(this.index) === '<' && this._char(this.index + 1) === '/') {\n                break;\n            }\n            children.push(this._parseJSXChild());\n        }\n        this._parseJSXClosingElement();\n        return children;\n    },\n\n    _parseJSXChild: function() {\n        var token,\n            Delimiters = this.options.delimiters;\n        if (this._isExpect(Delimiters[0])) {\n            token = this._parseJSXExpressionContainer();\n        } else if (this._isElementStart()) {\n            token = this._parseJSXElement();\n        } else {\n            token = this._scanJSXText([function() {\n                return this._isExpect('</') || this._isElementStart();\n            }, Delimiters[0]]);\n        }\n\n        return token;\n    },\n\n    _parseJSXClosingElement: function() {\n        this._expect('</');\n\n        while (this.index < this.length) {\n            if (!isJSXIdentifierPart(this._charCode())) {\n                break;\n            }\n            this._updateIndex();;\n        }\n\n        this._skipWhitespace();\n        this._expect('>');\n    },\n\n    _parseJSXComment: function() {\n        this._expect('!--');\n        var start = this.index;\n        while (this.index < this.length) {\n            if (this._isExpect('-->')) {\n                break;\n            } else if (this._charCode() === 10) {\n                this._updateLine();\n            }\n            this._updateIndex();\n        }\n        var ret = this._type(Type.JSXComment, {value: this.source.slice(start, this.index)});\n        this._expect('-->');\n\n        return ret;\n    },\n\n    _char: function(index) {\n        arguments.length === 0 && (index = this.index);\n        return this.source.charAt(index);\n    },\n\n    _charCode: function(index) {\n         arguments.length === 0 && (index = this.index);\n         return this.source.charCodeAt(index);\n    },\n\n    _skipWhitespace: function() {\n        while (this.index < this.length) {\n            var code = this._charCode();\n            if (!Utils.isWhiteSpace(code)) {\n                break;\n            } else if (code === 10) {\n                // is \\n\n                this._updateLine();\n            }\n            this._updateIndex();\n        }\n    },\n\n    _expect: function(str) {\n        if (!this._isExpect(str)) {\n            this._error('expect string ' + str);\n        }\n        this.index += str.length;\n    },\n\n    _isExpect: function(str) {\n        return this.source.slice(this.index, this.index + str.length) === str;\n    },\n\n    _isElementStart: function() {\n        return this._char() === '<' && (this._isExpect('<!--') || elementNameRegexp.test(this.source.slice(this.index)));\n    },\n\n    _type: function(type, ret) {\n        ret || (ret = {});\n        ret.type = type;\n        ret.typeName = TypeName[type];\n        return ret;\n    },\n\n    _updateLine: function() {\n        this.line++;\n        this.column = 0;\n    },\n\n    _updateIndex: function(value) {\n        value === undefined && (value = 1);\n        var index = this.index;\n        this.index = this.index + value;\n        this.column = this.column + value;\n        return index;\n    },\n\n    _error: function(msg) {\n        throw new Error(\n            msg + ' At: {line: ' + this.line + ', column: ' + this.column +\n            '} Near: \"' + this.source.slice(this.index - 10, this.index + 20) + '\"'\n        );\n    }\n};\n\nmodule.exports = Parser;\n",
    "/**\n * @fileoverview stringify ast of jsx to js\n * @author javey\n * @date 15-4-22\n */\n\nvar Utils = require('./utils'),\n    Type = Utils.Type,\n    TypeName = Utils.TypeName,\n\n    attrMap = (function() {\n        var map = {\n            'class': 'className',\n            'for': 'htmlFor'\n        };\n        return function(name) {\n            return map[name] || name;\n        };\n    })();\n\nvar Stringifier = function() {};\n\nStringifier.prototype = {\n    constructor: Stringifier,\n\n    stringify: function(ast, autoReturn) {\n        if (arguments.length === 1) {\n            autoReturn = true;\n        }\n        this.autoReturn = !!autoReturn;\n        this.enterStringExpression = false;\n        return this._visitJSXExpressionContainer(ast, true);\n    },\n\n    _visitJSXExpressionContainer: function(ast, isRoot) {\n        var str = '', length = ast.length;\n        Utils.each(ast, function(element, i) {\n            // if is root, add `return` keyword\n            if (this.autoReturn && isRoot && i === length - 1) {\n                str += 'return ' + this._visit(element, isRoot);\n            } else {\n                str += this._visit(element, isRoot);\n            }\n        }, this);\n\n        return str;\n    },\n\n    _visit: function(element, isRoot) {\n        element = element || {};\n        switch (element.type) {\n            case Type.JS:\n                return this._visitJS(element);\n            case Type.JSXElement:\n                return this._visitJSX(element);\n            case Type.JSXText:\n                return this._visitJSXText(element);\n            case Type.JSXExpressionContainer:\n                return this._visitJSXExpressionContainer(element.value);\n            case Type.JSXWidget:\n                return this._visitJSXWidget(element);\n            case Type.JSXBlock:\n                return this._visitJSXBlock(element);\n            case Type.JSXVdt:\n                return this._visitJSXVdt(element, isRoot);\n            case Type.JSXComment:\n                return this._visitJSXComment(element);\n            default:\n                return 'null';\n        }\n    },\n\n    _visitJS: function(element) {\n        return this.enterStringExpression ? '(' + element.value + ')' : element.value;\n    },\n\n    _visitJSX: function(element) {\n        if (element.value === 'script' || element.value === 'style') {\n            if (element.children.length) {\n                element.attributes.push({\n                    type: Type.JSXAttribute,\n                    typeName: TypeName[Type.JSXAttribute],\n                    name: 'innerHTML',\n                    value: {\n                        type: Type.JS,\n                        typeName: TypeName[Type.JS],\n                        value: this._visitJSXChildrenAsString(element.children)\n                    }\n                });\n                element.children = [];\n            }\n        }\n        var str = \"h('\" + element.value + \"',\" + this._visitJSXAttribute(element.attributes) + \", \";\n\n        return str + this._visitJSXChildren(element.children) + ')';\n    },\n\n    _visitJSXChildren: function(children) {\n        var ret = [];\n        Utils.each(children, function(child) {\n            ret.push(this._visit(child));\n        }, this);\n\n        return '[' + ret.join(', ') + ']';\n    },\n\n    _visitJSXChildrenAsString: function(children) {\n        var ret = [];\n        this.enterStringExpression = true;\n        Utils.each(children, function(child) {\n            ret.push(this._visit(child));\n        }, this);\n        this.enterStringExpression = false;\n        return ret.join('+');\n    },\n\n    _visitJSXAttribute: function(attributes) {\n        var ret = [];\n        Utils.each(attributes, function(attr) {\n            ret.push(\"'\" + attrMap(attr.name) + \"': \" + (Utils.isArray(attr.value) ? this._visitJSXChildren(attr.value) : this._visit(attr.value)));\n        }, this);\n\n        return ret.length ? '{' + ret.join(', ') + '}' : 'null';\n    },\n\n    _visitJSXText: function(element) {\n        return \"'\" + element.value.replace(/[\\r\\n]/g, '\\\\n').replace(/([\\'\\\"])/g, '\\\\$1') + \"'\";\n    },\n\n    _visitJSXWidget: function(element) {\n        element.attributes.push({name: 'children', value: element.children});\n        return element.value + '(' + this._visitJSXAttribute(element.attributes) + ', widgets)';\n    },\n\n    _visitJSXBlock: function(element, isAncestor) {\n        arguments.length === 1 && (isAncestor = true);\n\n        return '(_blocks.' + element.value + ' = function(parent) {return ' + this._visitJSXChildren(element.children) + ';}) && (__blocks.' + element.value + ' = function(parent) {\\n' +\n            'var self = this;\\n' +\n            'return blocks.' + element.value + ' ? blocks.' + element.value + '.call(this, function() {\\n' +\n                'return _blocks.' + element.value + '.call(self, parent);\\n' +\n            '}) : _blocks.' + element.value + '.call(this, parent);\\n' +\n        '})' + (isAncestor ? ' && __blocks.' + element.value + '.call(this)' : '');\n    },\n\n    _visitJSXVdt: function(element, isRoot) {\n        var ret = ['(function(blocks) {',\n                'var _blocks = {}, __blocks = extend({}, blocks), _obj = ' + this._visitJSXAttribute(element.attributes) + ' || {};',\n                'if (_obj.hasOwnProperty(\"arguments\")) { _obj = extend({}, _obj.arguments === null ? obj : _obj.arguments, _obj); delete _obj.arguments; }',\n                'return ' + element.value + '.call(this, _obj, _Vdt, '\n            ].join('\\n'),\n            blocks = [];\n\n        Utils.each(element.children, function(child) {\n            if (child.type === Type.JSXBlock) {\n                blocks.push(this._visitJSXBlock(child, false))\n            }\n        }, this);\n\n        ret += (blocks.length ? blocks.join(' && ') + ' && __blocks)' : '__blocks)') + ('}).call(this, ') + (isRoot ? 'blocks)' : '{})');\n\n        return ret;\n    },\n\n    _visitJSXComment: function(element) {\n        return 'h.c(' + this._visitJSXText(element) + ')';\n    }\n};\n\nmodule.exports = Stringifier;\n",
    "/**\n * @fileoverview utility methods\n * @author javey\n * @date 15-4-22\n */\n\nvar i = 0,\n    Type = {\n        JS: i++,\n        JSXText: i++,\n        JSXElement: i++,\n        JSXExpressionContainer: i++,\n        JSXAttribute: i++,\n        JSXEmptyExpression: i++,\n\n        JSXWidget: i++,\n        JSXVdt: i++,\n        JSXBlock: i++,\n        JSXComment: i++\n    },\n    TypeName = [],\n\n    SelfClosingTags = {\n        'area': true,\n        'base': true,\n        'br': true,\n        'col': true,\n        'embed': true,\n        'hr': true,\n        'img': true,\n        'input': true,\n        'keygen': true,\n        'link': true,\n        'menuitem': true,\n        'meta': true,\n        'param': true,\n        'source': true,\n        'track': true,\n        'wbr': true\n    },\n\n    Delimiters = ['{', '}'];\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n(function() {\n    for (var type in Type) {\n        if (hasOwn.call(Type, type)) {\n            TypeName[Type[type]] = type;\n        }\n    }\n})();\n\nvar Utils = {\n    each: function(collection, iterate, thisArgs) {\n        for (var i = 0, l = collection.length; i < l; i++) {\n            var item = collection[i];\n            iterate.call(thisArgs, item, i);\n        }\n    },\n\n    isWhiteSpace: function(charCode) {\n        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n        (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n    },\n\n    trimRight: function(str) {\n        var index = str.length;\n\n        while (index-- && Utils.isWhiteSpace(str.charCodeAt(index))) {}\n\n        return str.slice(0, index + 1);\n    },\n\n    Type: Type,\n    TypeName: TypeName,\n\n    setDelimiters: function(delimiters) {\n        if (!Utils.isArray(delimiters)) {\n            throw new Error('The parameter must be an array like [\"{{\", \"}}\"]');\n        }\n        Delimiters = delimiters;\n    },\n\n    getDelimiters: function() {\n        return Delimiters;\n    },\n\n    isSelfClosingTag: function(tag) {\n        return SelfClosingTags[tag];\n    },\n\n    extend: function(dest, source) {\n        var length = arguments.length;\n        if (length > 1) {\n            for (var i = 1; i < length; i++) {\n                source = arguments[i];\n                if (source) {\n                    for (var key in source) {\n                        if (hasOwn.call(source, key)) {\n                            dest[key] = source[key];\n                        }\n                    }\n                }\n            }\n        }\n        return dest;\n    },\n\n    isArray: Array.isArray || function(arr) {\n        return Object.prototype.toString.call(arr) === '[object Array]';\n    },\n\n    noop: function() {},\n\n    require: (function() {\n        var isNode = new Function(\"try { return this === global; } catch (e) { return false; }\"); \n        if (isNode()) {\n            return require('./compile');\n        } else {\n            // use amd require\n        }\n    })(),\n\n    noRequire: function() {\n        throw new Error('Vdt depends RequireJs to require file over http.');\n    }\n};\n\nmodule.exports = Utils;\n",
    "var parser = new (require('./parser')),\n    stringifier = new (require('./stringifier')),\n    virtualDom = require('virtual-domx'),\n    utils = require('./utils');\n\nvar Vdt = function(source, options) {\n    var vdt = {\n        render: function(data) {\n            vdt.renderTree.apply(vdt, arguments); \n            vdt.node = virtualDom.create(vdt.tree);\n            return vdt.node;\n        },\n\n        renderTree: function(data) {\n            if (arguments.length) {\n                vdt.data = data;\n            }\n            vdt.data.vdt = vdt;\n            vdt.tree = vdt.template.call(vdt.data, vdt.data, Vdt);\n            return vdt.tree;\n        },\n\n        renderString: function(data) {\n            var node = vdt.render.apply(vdt, arguments);\n            return node.outerHTML || node.toString();\n        },\n\n        update: function(data) {\n            var oldTree = vdt.tree;\n            vdt.renderTree.apply(vdt, arguments);\n            vdt.patches = virtualDom.diff(oldTree, vdt.tree);\n            vdt.node = virtualDom.patch(vdt.node, vdt.patches);\n            return vdt.node;\n        },\n\n        /**\n         * Restore the data, so you can modify it directly.\n         */\n        data: {},\n        tree: {},\n        patches: {},\n        node: null,\n        template: compile(source, options),\n\n        getTree: function() {\n            return vdt.tree;\n        },\n\n        setTree: function(tree) {\n            vdt.tree = tree;\n        },\n\n        getNode: function() {\n            return vdt.node;\n        },\n\n        setNode: function(node) {\n            vdt.node = node;\n        }\n    };\n\n    // reference cycle vdt\n    vdt.data.vdt = vdt;\n\n    return vdt;\n};\n\nfunction compile(source, options) {\n    var templateFn;\n\n    // backward compatibility v0.2.2\n    if (options === true || options === false) {\n        options = {autoReturn: options};\n    }\n\n    options = utils.extend({\n        autoReturn: true,\n        onlySource: false,\n        delimiters: utils.getDelimiters()\n    }, options);\n\n    switch (typeof source) {\n        case 'string':\n            var ast = parser.parse(source, {delimiters: options.delimiters}),\n                hscript = stringifier.stringify(ast, options.autoReturn);\n\n            hscript = [\n                '_Vdt || (_Vdt = Vdt);',\n                'obj || (obj = {});',\n                'blocks || (blocks = {});',\n                'var h = _Vdt.virtualDom.h, widgets = this.widgets || (this.widgets = {}), _blocks = {}, __blocks = {},',\n                    'extend = _Vdt.utils.extend;',\n                'obj.require = _Vdt.utils.require || (typeof require === \"undefined\" ? _Vdt.utils.noRequire : require);',\n                'var self; if (obj.type === \"Widget\") { self = this; } else { obj.get = function(name) { return obj[name]; }; self = obj; }',\n                'with (obj) {',\n                    hscript,\n                '}'\n            ].join('\\n');\n            templateFn = options.onlySource ? utils.noop : new Function('obj', '_Vdt', 'blocks', hscript);\n            templateFn.source = 'function(obj, _Vdt, blocks) {\\n' + hscript + '\\n}';\n            break;\n        case 'function':\n            templateFn = source;\n            break;\n        default:\n            throw new Error('Expect a string or function');\n    }\n\n    return templateFn;\n}\n\nVdt.parser = parser;\nVdt.stringifier = stringifier;\nVdt.virtualDom = virtualDom;\nVdt.compile = compile;\nVdt.utils = utils;\nVdt.setDelimiters = utils.setDelimiters;\nVdt.getDelimiters = utils.getDelimiters;\n\nmodule.exports = Vdt;\n",
    "var createElement = require(\"./vdom/create-element.js\")\n\nmodule.exports = createElement\n",
    "var diff = require(\"./vtree/diff.js\")\n\nmodule.exports = diff\n",
    "var h = require(\"./virtual-hyperscript/index.js\")\n\nmodule.exports = h\n",
    "var diff = require(\"./diff.js\")\r\nvar patch = require(\"./patch.js\")\r\nvar h = require(\"./h.js\")\r\nvar create = require(\"./create-element.js\")\r\nvar VNode = require('./vnode/vnode.js')\r\nvar VText = require('./vnode/vtext.js')\r\n\r\nmodule.exports = {\r\n    diff: diff,\r\n    patch: patch,\r\n    h: h,\r\n    create: create,\r\n    VNode: VNode,\r\n    VText: VText\r\n}\r\n",
    "var patch = require(\"./vdom/patch.js\")\n\nmodule.exports = patch\n",
    "var isObject = require(\"is-object\")\nvar isHook = require(\"../vnode/is-vhook.js\")\n\nmodule.exports = applyProperties\n\nfunction applyProperties(node, props, previous) {\n    for (var propName in props) {\n        var propValue = props[propName]\n\n        if (propValue === undefined) {\n            removeProperty(node, propName, propValue, previous);\n        } else if (isHook(propValue)) {\n            removeProperty(node, propName, propValue, previous)\n            if (propValue.hook) {\n                propValue.hook(node,\n                    propName,\n                    previous ? previous[propName] : undefined)\n            }\n        } else {\n            if (isObject(propValue)) {\n                patchObject(node, props, previous, propName, propValue);\n            } else {\n                node[propName] = propValue\n            }\n        }\n    }\n}\n\nfunction removeProperty(node, propName, propValue, previous) {\n    if (previous) {\n        var previousValue = previous[propName]\n\n        if (!isHook(previousValue)) {\n            if (propName === \"attributes\") {\n                for (var attrName in previousValue) {\n                    node.removeAttribute(attrName)\n                }\n            } else if (propName === \"style\") {\n                for (var i in previousValue) {\n                    node.style[i] = \"\"\n                }\n            } else if (typeof previousValue === \"string\") {\n                node[propName] = \"\"\n            } else {\n                try {\n                    node[propName] = null\n                } catch (e) {\n                    node.removeAttribute(propName.toLowerCase());\n                }\n            }\n        } else if (previousValue.unhook) {\n            previousValue.unhook(node, propName, propValue)\n        }\n    }\n}\n\nfunction patchObject(node, props, previous, propName, propValue) {\n    var previousValue = previous ? previous[propName] : undefined\n\n    // Set attributes\n    if (propName === \"attributes\") {\n        for (var attrName in propValue) {\n            var attrValue = propValue[attrName]\n\n            if (attrValue === undefined) {\n                node.removeAttribute(attrName)\n            } else {\n                node.setAttribute(attrName, attrValue)\n            }\n        }\n\n        return\n    }\n\n    if(previousValue && isObject(previousValue) &&\n        getPrototype(previousValue) !== getPrototype(propValue)) {\n        node[propName] = propValue\n        return\n    }\n\n    if (!isObject(node[propName])) {\n        node[propName] = {}\n    }\n\n    var replacer = propName === \"style\" ? \"\" : undefined\n\n    for (var k in propValue) {\n        var value = propValue[k]\n        node[propName][k] = (value === undefined) ? replacer : value\n    }\n}\n\nfunction getPrototype(value) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(value)\n    } else if (value.__proto__) {\n        return value.__proto__\n    } else if (value.constructor) {\n        return value.constructor.prototype\n    }\n}\n",
    "var document = require(\"globalx/document\")\n\nvar applyProperties = require(\"./apply-properties\")\n\nvar isVNode = require(\"../vnode/is-vnode.js\")\nvar isVText = require(\"../vnode/is-vtext.js\")\nvar isWidget = require(\"../vnode/is-widget.js\")\nvar isVComment = require(\"../vnode/is-vcomment.js\")\nvar handleThunk = require(\"../vnode/handle-thunk.js\")\n\nmodule.exports = createElement\n\nfunction createElement(vnode, opts) {\n    var doc = opts ? opts.document || document : document\n    var warn = opts ? opts.warn : null\n\n    vnode = handleThunk(vnode).a\n\n    if (isWidget(vnode)) {\n        return vnode.init()\n    } else if (isVText(vnode)) {\n        return doc.createTextNode(vnode.text)\n    } else if (isVComment(vnode)) {\n        return doc.createComment(vnode.comment)\n    } else if (!isVNode(vnode)) {\n        if (warn) {\n            warn(\"Item is not a valid virtual dom node\", vnode)\n        }\n        return null\n    }\n\n    var node\n    if (vnode.tagName === 'FRAGMENT') {\n        node = doc.createDocumentFragment()\n    } else {\n        node = (vnode.namespace === null) ?\n            doc.createElement(vnode.tagName) :\n            doc.createElementNS(vnode.namespace, vnode.tagName)\n    }\n    \n    var props = vnode.properties\n    applyProperties(node, props)\n\n    var children = vnode.children\n\n    for (var i = 0; i < children.length; i++) {\n        var childNode = createElement(children[i], opts)\n        if (childNode) {\n            node.appendChild(childNode)\n        }\n    }\n\n    return node\n}\n",
    "// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.\n// We don't want to read all of the DOM nodes in the tree so we use\n// the in-order tree indexing to eliminate recursion down certain branches.\n// We only recurse into a DOM node if we know that it contains a child of\n// interest.\n\nvar noChild = {}\n\nmodule.exports = domIndex\n\nfunction domIndex(rootNode, tree, indices, nodes) {\n    if (!indices || indices.length === 0) {\n        return {}\n    } else {\n        indices.sort(ascending)\n        return recurse(rootNode, tree, indices, nodes, 0)\n    }\n}\n\nfunction recurse(rootNode, tree, indices, nodes, rootIndex) {\n    nodes = nodes || {}\n\n\n    if (rootNode) {\n        if (indexInRange(indices, rootIndex, rootIndex)) {\n            nodes[rootIndex] = rootNode\n        }\n\n        var vChildren = tree.children\n\n        if (vChildren) {\n\n            var childNodes = rootNode.childNodes\n\n            for (var i = 0; i < tree.children.length; i++) {\n                rootIndex += 1\n\n                var vChild = vChildren[i] || noChild\n                var nextIndex = rootIndex + (vChild.count || 0)\n\n                // skip recursion down the tree if there are no nodes down here\n                if (indexInRange(indices, rootIndex, nextIndex)) {\n                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)\n                }\n\n                rootIndex = nextIndex\n            }\n        }\n    }\n\n    return nodes\n}\n\n// Binary search for an index in the interval [left, right]\nfunction indexInRange(indices, left, right) {\n    if (indices.length === 0) {\n        return false\n    }\n\n    var minIndex = 0\n    var maxIndex = indices.length - 1\n    var currentIndex\n    var currentItem\n\n    while (minIndex <= maxIndex) {\n        currentIndex = ((maxIndex + minIndex) / 2) >> 0\n        currentItem = indices[currentIndex]\n\n        if (minIndex === maxIndex) {\n            return currentItem >= left && currentItem <= right\n        } else if (currentItem < left) {\n            minIndex = currentIndex + 1\n        } else  if (currentItem > right) {\n            maxIndex = currentIndex - 1\n        } else {\n            return true\n        }\n    }\n\n    return false;\n}\n\nfunction ascending(a, b) {\n    return a > b ? 1 : -1\n}\n",
    "var applyProperties = require(\"./apply-properties\")\n\nvar isWidget = require(\"../vnode/is-widget.js\")\nvar VPatch = require(\"../vnode/vpatch.js\")\n\nvar updateWidget = require(\"./update-widget\")\n\nmodule.exports = applyPatch\n\nfunction applyPatch(vpatch, domNode, renderOptions) {\n    var type = vpatch.type\n    var vNode = vpatch.vNode\n    var patch = vpatch.patch\n\n    switch (type) {\n        case VPatch.REMOVE:\n            return removeNode(domNode, vNode)\n        case VPatch.INSERT:\n            return insertNode(domNode, patch, renderOptions)\n        case VPatch.VTEXT:\n            return stringPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.VCOMMENT:\n            return commentPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.WIDGET:\n            return widgetPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.VNODE:\n            return vNodePatch(domNode, vNode, patch, renderOptions)\n        case VPatch.ORDER:\n            reorderChildren(domNode, patch)\n            return domNode\n        case VPatch.PROPS:\n            applyProperties(domNode, patch, vNode.properties)\n            return domNode\n        case VPatch.THUNK:\n            return replaceRoot(domNode,\n                renderOptions.patch(domNode, patch, renderOptions))\n        default:\n            return domNode\n    }\n}\n\nfunction removeNode(domNode, vNode) {\n    var parentNode = domNode.parentNode\n\n    if (parentNode) {\n        parentNode.removeChild(domNode)\n    }\n\n    destroyWidget(domNode, vNode);\n\n    return null\n}\n\nfunction insertNode(parentNode, vNode, renderOptions) {\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode) {\n        parentNode.appendChild(newNode)\n    }\n\n    return parentNode\n}\n\nfunction stringPatch(domNode, leftVNode, vText, renderOptions) {\n    var newNode\n\n    if (domNode.nodeType === 3) {\n        domNode.replaceData(0, domNode.length, vText.text)\n        newNode = domNode\n    } else {\n        var parentNode = domNode.parentNode\n        newNode = renderOptions.render(vText, renderOptions)\n\n        if (parentNode && newNode !== domNode) {\n            parentNode.replaceChild(newNode, domNode)\n        }\n    }\n\n    return newNode\n}\n\nfunction commentPatch(domNode, leftNode, vComment, renderOptions) {\n    var newNode\n\n    if (domNode.nodeType === 8) {\n        // todo: need min-document to support replaceData method to update nodeValue and length\n        domNode.data = vComment.comment\n        newNode = domNode\n    } else {\n        var parentNode = domNode.parentNode\n        newNode = renderOptions.render(vComment, renderOptions)\n\n        if (parentNode && newNode !== domNode) {\n            parentNode.replaceChild(newNode, domNode)\n        }\n    }\n\n    return newNode\n}\n\nfunction widgetPatch(domNode, leftVNode, widget, renderOptions) {\n    var updating = updateWidget(leftVNode, widget)\n    var newNode\n\n    if (updating) {\n        newNode = widget.update(leftVNode, domNode) || domNode\n    } else {\n        newNode = renderOptions.render(widget, renderOptions)\n    }\n\n    var parentNode = domNode.parentNode\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    if (!updating) {\n        destroyWidget(domNode, leftVNode)\n    }\n\n    return newNode\n}\n\nfunction vNodePatch(domNode, leftVNode, vNode, renderOptions) {\n    var parentNode = domNode.parentNode\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    return newNode\n}\n\nfunction destroyWidget(domNode, w) {\n    if (typeof w.destroy === \"function\" && isWidget(w)) {\n        w.destroy(domNode)\n    }\n}\n\nfunction reorderChildren(domNode, moves) {\n    var childNodes = domNode.childNodes\n    var keyMap = {}\n    var node\n    var remove\n    var insert\n\n    // remove child from back to front\n    for (var i = moves.removes.length - 1; i >= 0; i--) {\n        remove = moves.removes[i]\n        node = childNodes[remove.from]\n        if (remove.key) {\n            keyMap[remove.key] = node\n        }\n        domNode.removeChild(node)\n    }\n\n    var length = childNodes.length\n    for (var j = 0; j < moves.inserts.length; j++) {\n        insert = moves.inserts[j]\n        node = keyMap[insert.key]\n        // this is the weirdest bug i've ever seen in webkit\n        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])\n    }\n}\n\nfunction replaceRoot(oldRoot, newRoot) {\n    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {\n        oldRoot.parentNode.replaceChild(newRoot, oldRoot)\n    }\n\n    return newRoot;\n}\n",
    "var document = require(\"globalx/document\")\nvar isArray = require(\"x-is-array\")\n\nvar render = require(\"./create-element\")\nvar domIndex = require(\"./dom-index\")\nvar patchOp = require(\"./patch-op\")\nmodule.exports = patch\n\nfunction patch(rootNode, patches, renderOptions) {\n    renderOptions = renderOptions || {}\n    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch\n        ? renderOptions.patch\n        : patchRecursive\n    renderOptions.render = renderOptions.render || render\n\n    return renderOptions.patch(rootNode, patches, renderOptions)\n}\n\nfunction patchRecursive(rootNode, patches, renderOptions) {\n    var indices = patchIndices(patches)\n\n    if (indices.length === 0) {\n        return rootNode\n    }\n\n    var index = domIndex(rootNode, patches.a, indices)\n    var ownerDocument = rootNode.ownerDocument\n\n    if (!renderOptions.document && ownerDocument !== document) {\n        renderOptions.document = ownerDocument\n    }\n\n    for (var i = 0; i < indices.length; i++) {\n        var nodeIndex = indices[i]\n        rootNode = applyPatch(rootNode,\n            index[nodeIndex],\n            patches[nodeIndex],\n            renderOptions)\n    }\n\n    return rootNode\n}\n\nfunction applyPatch(rootNode, domNode, patchList, renderOptions) {\n    if (!domNode) {\n        return rootNode\n    }\n\n    var newNode\n\n    if (isArray(patchList)) {\n        for (var i = 0; i < patchList.length; i++) {\n            newNode = patchOp(patchList[i], domNode, renderOptions)\n\n            if (domNode === rootNode) {\n                rootNode = newNode\n            }\n        }\n    } else {\n        newNode = patchOp(patchList, domNode, renderOptions)\n\n        if (domNode === rootNode) {\n            rootNode = newNode\n        }\n    }\n\n    return rootNode\n}\n\nfunction patchIndices(patches) {\n    var indices = []\n\n    for (var key in patches) {\n        if (key !== \"a\") {\n            indices.push(Number(key))\n        }\n    }\n\n    return indices\n}\n",
    "var isWidget = require(\"../vnode/is-widget.js\")\n\nmodule.exports = updateWidget\n\nfunction updateWidget(a, b) {\n    if (isWidget(a) && isWidget(b)) {\n        if (\"name\" in a && \"name\" in b) {\n            return a.id === b.id\n        } else if (!(a.constructor instanceof a.constructor) || !(b.constructor instanceof b.constructor)) {\n            return a.constructor === b.constructor\n        } else {\n            return a.init === b.init\n        }\n    }\n\n    return false\n}\n",
    "'use strict';\n\nvar EvStore = require('ev-store');\nvar Delegator = require('dom-delegator');\n\nvar delegator = new Delegator({defaultEvents: false});\n\nmodule.exports = EvHook;\n\nfunction EvHook(value) {\n    if (!(this instanceof EvHook)) {\n        return new EvHook(value);\n    }\n\n    this.value = value;\n}\n\nEvHook.prototype.hook = function (node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    delegator.listenTo(propName);\n    es[propName] = this.value;\n};\n\nEvHook.prototype.unhook = function(node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    delegator.unlistenTo(propName);\n    es[propName] = undefined;\n};\n",
    "'use strict';\n\nmodule.exports = SoftSetHook;\n\nfunction SoftSetHook(value) {\n    if (!(this instanceof SoftSetHook)) {\n        return new SoftSetHook(value);\n    }\n\n    this.value = value;\n}\n\nSoftSetHook.prototype.hook = function (node, propertyName) {\n    if (node[propertyName] !== this.value) {\n        node[propertyName] = this.value;\n    }\n};\n",
    "'use strict';\n\nvar isArray = require('x-is-array');\n\nvar VNode = require('../vnode/vnode.js');\nvar VText = require('../vnode/vtext.js');\nvar VComment = require('../vnode/vcomment.js');\nvar isVNode = require('../vnode/is-vnode');\nvar isVText = require('../vnode/is-vtext');\nvar isVComment = require('../vnode/is-vcomment');\nvar isWidget = require('../vnode/is-widget');\nvar isHook = require('../vnode/is-vhook');\nvar isVThunk = require('../vnode/is-thunk');\n\nvar parseTag = require('./parse-tag.js');\nvar softSetHook = require('./hooks/soft-set-hook.js');\nvar evHook = require('./hooks/ev-hook.js');\n\nmodule.exports = h;\n\nfunction h(tagName, properties, children) {\n    var childNodes = [];\n    var tag, props, key, namespace;\n\n    if (!children && isChildren(properties)) {\n        children = properties;\n        props = {};\n    }\n\n    props = props || properties || {};\n    tag = parseTag(tagName, props);\n\n    // support keys\n    if (props.hasOwnProperty('key')) {\n        key = props.key;\n        props.key = undefined;\n    }\n\n    // support namespace\n    if (props.hasOwnProperty('namespace')) {\n        namespace = props.namespace;\n        props.namespace = undefined;\n    }\n\n    // fix cursor bug\n    if (tag === 'INPUT' &&\n        !namespace &&\n        props.hasOwnProperty('value') &&\n        props.value !== undefined &&\n        !isHook(props.value)\n    ) {\n        props.value = softSetHook(props.value);\n    }\n\n    transformProperties(props);\n\n    if (children !== undefined && children !== null) {\n        addChild(children, childNodes, tag, props);\n    }\n\n\n    return new VNode(tag, props, childNodes, key, namespace);\n}\n\nh.c = function(comment) {\n    return new VComment(comment) \n}\n\nfunction addChild(c, childNodes, tag, props) {\n    if (typeof c === 'string') {\n        childNodes.push(new VText(c));\n    } else if (typeof c === 'number') {\n        childNodes.push(new VText(String(c)));\n    } else if (isChild(c)) {\n        childNodes.push(c);\n    } else if (isArray(c)) {\n        for (var i = 0; i < c.length; i++) {\n            addChild(c[i], childNodes, tag, props);\n        }\n    } else if (c === null || c === undefined) {\n        return;\n    } else {\n        throw UnexpectedVirtualElement({\n            foreignObject: c,\n            parentVnode: {\n                tagName: tag,\n                properties: props\n            }\n        });\n    }\n}\n\nfunction transformProperties(props) {\n    for (var propName in props) {\n        if (props.hasOwnProperty(propName)) {\n            var value = props[propName];\n\n            if (isHook(value)) {\n                continue;\n            }\n\n            if (propName.substr(0, 3) === 'ev-') {\n                // add ev-foo support\n                props[propName] = evHook(value);\n            }\n        }\n    }\n}\n\nfunction isChild(x) {\n    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x) || isVComment(x);\n}\n\nfunction isChildren(x) {\n    return typeof x === 'string' || isArray(x) || isChild(x);\n}\n\nfunction UnexpectedVirtualElement(data) {\n    var err = new Error();\n\n    err.type = 'virtual-hyperscript.unexpected.virtual-element';\n    err.message = 'Unexpected virtual child passed to h().\\n' +\n        'Expected a VNode / Vthunk / VWidget / string but:\\n' +\n        'got:\\n' +\n        errorString(data.foreignObject) +\n        '.\\n' +\n        'The parent vnode is:\\n' +\n        errorString(data.parentVnode)\n        '\\n' +\n        'Suggested fix: change your `h(..., [ ... ])` callsite.';\n    err.foreignObject = data.foreignObject;\n    err.parentVnode = data.parentVnode;\n\n    return err;\n}\n\nfunction errorString(obj) {\n    try {\n        return JSON.stringify(obj, null, '    ');\n    } catch (e) {\n        return String(obj);\n    }\n}\n",
    "'use strict';\n\nvar split = require('browser-split');\n\nvar classIdSplit = /([\\.#]?[a-zA-Z0-9\\u007F-\\uFFFF_:-]+)/;\nvar notClassId = /^\\.|#/;\n\nmodule.exports = parseTag;\n\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'DIV';\n    }\n\n    var noId = !(props.hasOwnProperty('id'));\n\n    var tagParts = split(tag, classIdSplit);\n    var tagName = null;\n\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'DIV';\n    }\n\n    var classes, part, type, i;\n\n    for (i = 0; i < tagParts.length; i++) {\n        part = tagParts[i];\n\n        if (!part) {\n            continue;\n        }\n\n        type = part.charAt(0);\n\n        if (!tagName) {\n            tagName = part;\n        } else if (type === '.') {\n            classes = classes || [];\n            classes.push(part.substring(1, part.length));\n        } else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n\n        props.className = classes.join(' ');\n    }\n\n    return props.namespace ? tagName : tagName.toUpperCase();\n}\n",
    "var isVNode = require(\"./is-vnode\")\nvar isVText = require(\"./is-vtext\")\nvar isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\")\n\nmodule.exports = handleThunk\n\nfunction handleThunk(a, b) {\n    var renderedA = a\n    var renderedB = b\n\n    if (isThunk(b)) {\n        renderedB = renderThunk(b, a)\n    }\n\n    if (isThunk(a)) {\n        renderedA = renderThunk(a, null)\n    }\n\n    return {\n        a: renderedA,\n        b: renderedB\n    }\n}\n\nfunction renderThunk(thunk, previous) {\n    var renderedThunk = thunk.vnode\n\n    if (!renderedThunk) {\n        renderedThunk = thunk.vnode = thunk.render(previous)\n    }\n\n    if (!(isVNode(renderedThunk) ||\n            isVText(renderedThunk) ||\n            isWidget(renderedThunk))) {\n        throw new Error(\"thunk did not return a valid node\");\n    }\n\n    return renderedThunk\n}\n",
    "module.exports = isThunk\r\n\r\nfunction isThunk(t) {\r\n    return t && t.type === \"Thunk\"\r\n}\r\n",
    "var version = require(\"./version\")\n\nmodule.exports = isVirtualComment\n\nfunction isVirtualComment(x) {\n    return x && x.type === \"VirtualComment\" && x.version === version \n}\n",
    "module.exports = isHook\n\nfunction isHook(hook) {\n    return hook &&\n      (typeof hook.hook === \"function\" && !hook.hasOwnProperty(\"hook\") ||\n       typeof hook.unhook === \"function\" && !hook.hasOwnProperty(\"unhook\"))\n}\n",
    "var version = require(\"./version\")\n\nmodule.exports = isVirtualNode\n\nfunction isVirtualNode(x) {\n    return x && x.type === \"VirtualNode\" && x.version === version\n}\n",
    "var version = require(\"./version\")\n\nmodule.exports = isVirtualText\n\nfunction isVirtualText(x) {\n    return x && x.type === \"VirtualText\" && x.version === version\n}\n",
    "module.exports = isWidget\n\nfunction isWidget(w) {\n    return w && w.type === \"Widget\"\n}\n",
    "var version = require(\"./version\")\n\nmodule.exports = VirtualComment\n\nfunction VirtualComment(comment) {\n    this.comment = String(comment)\n}\n\nVirtualComment.prototype.version = version\nVirtualComment.prototype.type = \"VirtualComment\"\n",
    "module.exports = \"2\"\n",
    "var version = require(\"./version\")\nvar isVNode = require(\"./is-vnode\")\nvar isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\")\nvar isVHook = require(\"./is-vhook\")\n\nmodule.exports = VirtualNode\n\nvar noProperties = {}\nvar noChildren = []\n\nfunction VirtualNode(tagName, properties, children, key, namespace) {\n    this.tagName = tagName\n    this.properties = properties || noProperties\n    this.children = children || noChildren\n    this.key = key != null ? String(key) : undefined\n    this.namespace = (typeof namespace === \"string\") ? namespace : null\n\n    var count = (children && children.length) || 0\n    var descendants = 0\n    var hasWidgets = false\n    var hasThunks = false\n    var descendantHooks = false\n    var hooks\n\n    for (var propName in properties) {\n        if (properties.hasOwnProperty(propName)) {\n            var property = properties[propName]\n            if (isVHook(property) && property.unhook) {\n                if (!hooks) {\n                    hooks = {}\n                }\n\n                hooks[propName] = property\n            }\n        }\n    }\n\n    for (var i = 0; i < count; i++) {\n        var child = children[i]\n        if (isVNode(child)) {\n            descendants += child.count || 0\n\n            if (!hasWidgets && child.hasWidgets) {\n                hasWidgets = true\n            }\n\n            if (!hasThunks && child.hasThunks) {\n                hasThunks = true\n            }\n\n            if (!descendantHooks && (child.hooks || child.descendantHooks)) {\n                descendantHooks = true\n            }\n        } else if (!hasWidgets && isWidget(child)) {\n            if (typeof child.destroy === \"function\") {\n                hasWidgets = true\n            }\n        } else if (!hasThunks && isThunk(child)) {\n            hasThunks = true;\n        }\n    }\n\n    this.count = count + descendants\n    this.hasWidgets = hasWidgets\n    this.hasThunks = hasThunks\n    this.hooks = hooks\n    this.descendantHooks = descendantHooks\n}\n\nVirtualNode.prototype.version = version\nVirtualNode.prototype.type = \"VirtualNode\"\n",
    "var version = require(\"./version\")\n\nVirtualPatch.NONE = 0\nVirtualPatch.VTEXT = 1\nVirtualPatch.VNODE = 2\nVirtualPatch.WIDGET = 3\nVirtualPatch.PROPS = 4\nVirtualPatch.ORDER = 5\nVirtualPatch.INSERT = 6\nVirtualPatch.REMOVE = 7\nVirtualPatch.THUNK = 8\nVirtualPatch.VCOMMENT = 9\n\nmodule.exports = VirtualPatch\n\nfunction VirtualPatch(type, vNode, patch) {\n    this.type = Number(type)\n    this.vNode = vNode\n    this.patch = patch\n}\n\nVirtualPatch.prototype.version = version\nVirtualPatch.prototype.type = \"VirtualPatch\"\n",
    "var version = require(\"./version\")\n\nmodule.exports = VirtualText\n\nfunction VirtualText(text) {\n    this.text = String(text)\n}\n\nVirtualText.prototype.version = version\nVirtualText.prototype.type = \"VirtualText\"\n",
    "var isObject = require(\"is-object\")\nvar isHook = require(\"../vnode/is-vhook\")\n\nmodule.exports = diffProps\n\nfunction diffProps(a, b) {\n    var diff\n\n    for (var aKey in a) {\n        if (!(aKey in b)) {\n            diff = diff || {}\n            diff[aKey] = undefined\n        }\n\n        var aValue = a[aKey]\n        var bValue = b[aKey]\n\n        if (aValue === bValue) {\n            continue\n        } else if (isObject(aValue) && isObject(bValue)) {\n            if (getPrototype(bValue) !== getPrototype(aValue)) {\n                diff = diff || {}\n                diff[aKey] = bValue\n            } else if (isHook(bValue)) {\n                 diff = diff || {}\n                 diff[aKey] = bValue\n            } else {\n                var objectDiff = diffProps(aValue, bValue)\n                if (objectDiff) {\n                    diff = diff || {}\n                    diff[aKey] = objectDiff\n                }\n            }\n        } else {\n            diff = diff || {}\n            diff[aKey] = bValue\n        }\n    }\n\n    for (var bKey in b) {\n        if (!(bKey in a)) {\n            diff = diff || {}\n            diff[bKey] = b[bKey]\n        }\n    }\n\n    return diff\n}\n\nfunction getPrototype(value) {\n  if (Object.getPrototypeOf) {\n    return Object.getPrototypeOf(value)\n  } else if (value.__proto__) {\n    return value.__proto__\n  } else if (value.constructor) {\n    return value.constructor.prototype\n  }\n}\n",
    "var isArray = require(\"x-is-array\")\n\nvar VPatch = require(\"../vnode/vpatch\")\nvar isVNode = require(\"../vnode/is-vnode\")\nvar isVText = require(\"../vnode/is-vtext\")\nvar isVComment = require(\"../vnode/is-vcomment\")\nvar isWidget = require(\"../vnode/is-widget\")\nvar isThunk = require(\"../vnode/is-thunk\")\nvar handleThunk = require(\"../vnode/handle-thunk\")\n\nvar diffProps = require(\"./diff-props\")\n\nmodule.exports = diff\n\nfunction diff(a, b) {\n    var patch = { a: a }\n    walk(a, b, patch, 0)\n    return patch\n}\n\nfunction walk(a, b, patch, index) {\n    if (a === b && !isWidget(a)) {\n        return\n    }\n\n    var apply = patch[index]\n    var applyClear = false\n\n    if (isThunk(a) || isThunk(b)) {\n        thunks(a, b, patch, index)\n    } else if (b == null) {\n\n        // If a is a widget we will add a remove patch for it\n        // Otherwise any child widgets/hooks must be destroyed.\n        // This prevents adding two remove patches for a widget.\n        if (!isWidget(a)) {\n            clearState(a, patch, index)\n            apply = patch[index]\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))\n    } else if (isVNode(b)) {\n        if (isVNode(a)) {\n            if (a.tagName === b.tagName &&\n                a.namespace === b.namespace &&\n                a.key === b.key) {\n                var propsPatch = diffProps(a.properties, b.properties)\n                if (propsPatch) {\n                    apply = appendPatch(apply,\n                        new VPatch(VPatch.PROPS, a, propsPatch))\n                }\n                apply = diffChildren(a, b, patch, apply, index)\n            } else {\n                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n                applyClear = true\n            }\n        } else {\n            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n            applyClear = true\n        }\n    } else if (isVText(b)) {\n        if (!isVText(a)) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n            applyClear = true\n        } else if (a.text !== b.text) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n        }\n    } else if (isVComment(b)) {\n        if (!isVComment(a)) {\n            apply = appendPatch(apply, new VPatch(VPatch.VCOMMENT, a, b))\n            applyClear = true\n        } else if (a.comment !== b.comment) {\n            apply = appendPatch(apply, new VPatch(VPatch.VCOMMENT, a, b))\n        }\n    } else if (isWidget(b)) {\n        if (!isWidget(a)) {\n            applyClear = true\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))\n    }\n\n    if (apply) {\n        patch[index] = apply\n    }\n\n    if (applyClear) {\n        clearState(a, patch, index)\n    }\n}\n\nfunction diffChildren(a, b, patch, apply, index) {\n    var aChildren = a.children\n    var orderedSet = reorder(aChildren, b.children)\n    var bChildren = orderedSet.children\n\n    var aLen = aChildren.length\n    var bLen = bChildren.length\n    var len = aLen > bLen ? aLen : bLen\n\n    for (var i = 0; i < len; i++) {\n        var leftNode = aChildren[i]\n        var rightNode = bChildren[i]\n        index += 1\n\n        if (!leftNode) {\n            if (rightNode) {\n                // Excess nodes in b need to be added\n                apply = appendPatch(apply,\n                    new VPatch(VPatch.INSERT, null, rightNode))\n            }\n        } else {\n            walk(leftNode, rightNode, patch, index)\n        }\n\n        if (isVNode(leftNode) && leftNode.count) {\n            index += leftNode.count\n        }\n    }\n\n    if (orderedSet.moves) {\n        // Reorder nodes last\n        apply = appendPatch(apply, new VPatch(\n            VPatch.ORDER,\n            a,\n            orderedSet.moves\n        ))\n    }\n\n    return apply\n}\n\nfunction clearState(vNode, patch, index) {\n    // TODO: Make this a single walk, not two\n    unhook(vNode, patch, index)\n    destroyWidgets(vNode, patch, index)\n}\n\n// Patch records for all destroyed widgets must be added because we need\n// a DOM node reference for the destroy function\nfunction destroyWidgets(vNode, patch, index) {\n    if (isWidget(vNode)) {\n        if (typeof vNode.destroy === \"function\") {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(VPatch.REMOVE, vNode, null)\n            )\n        }\n    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {\n        var children = vNode.children\n        var len = children.length\n        for (var i = 0; i < len; i++) {\n            var child = children[i]\n            index += 1\n\n            destroyWidgets(child, patch, index)\n\n            if (isVNode(child) && child.count) {\n                index += child.count\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\n// Create a sub-patch for thunks\nfunction thunks(a, b, patch, index) {\n    var nodes = handleThunk(a, b)\n    var thunkPatch = diff(nodes.a, nodes.b)\n    if (hasPatches(thunkPatch)) {\n        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)\n    }\n}\n\nfunction hasPatches(patch) {\n    for (var index in patch) {\n        if (index !== \"a\") {\n            return true\n        }\n    }\n\n    return false\n}\n\n// Execute hooks when two nodes are identical\nfunction unhook(vNode, patch, index) {\n    if (isVNode(vNode)) {\n        if (vNode.hooks) {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(\n                    VPatch.PROPS,\n                    vNode,\n                    undefinedKeys(vNode.hooks)\n                )\n            )\n        }\n\n        if (vNode.descendantHooks || vNode.hasThunks) {\n            var children = vNode.children\n            var len = children.length\n            for (var i = 0; i < len; i++) {\n                var child = children[i]\n                index += 1\n\n                unhook(child, patch, index)\n\n                if (isVNode(child) && child.count) {\n                    index += child.count\n                }\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\nfunction undefinedKeys(obj) {\n    var result = {}\n\n    for (var key in obj) {\n        result[key] = undefined\n    }\n\n    return result\n}\n\n// List diff, naive left to right reordering\nfunction reorder(aChildren, bChildren) {\n    // O(M) time, O(M) memory\n    var bChildIndex = keyIndex(bChildren)\n    var bKeys = bChildIndex.keys\n    var bFree = bChildIndex.free\n\n    if (bFree.length === bChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(N) time, O(N) memory\n    var aChildIndex = keyIndex(aChildren)\n    var aKeys = aChildIndex.keys\n    var aFree = aChildIndex.free\n\n    if (aFree.length === aChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(MAX(N, M)) memory\n    var newChildren = []\n\n    var freeIndex = 0\n    var freeCount = bFree.length\n    var deletedItems = 0\n\n    // Iterate through a and match a node in b\n    // O(N) time,\n    for (var i = 0 ; i < aChildren.length; i++) {\n        var aItem = aChildren[i]\n        var itemIndex\n\n        if (aItem.key) {\n            if (bKeys.hasOwnProperty(aItem.key)) {\n                // Match up the old keys\n                itemIndex = bKeys[aItem.key]\n                newChildren.push(bChildren[itemIndex])\n\n            } else {\n                // Remove old keyed items\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        } else {\n            // Match the item in a with the next free item in b\n            if (freeIndex < freeCount) {\n                itemIndex = bFree[freeIndex++]\n                newChildren.push(bChildren[itemIndex])\n            } else {\n                // There are no free items in b to match with\n                // the free items in a, so the extra free nodes\n                // are deleted.\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        }\n    }\n\n    var lastFreeIndex = freeIndex >= bFree.length ?\n        bChildren.length :\n        bFree[freeIndex]\n\n    // Iterate through b and append any new keys\n    // O(M) time\n    for (var j = 0; j < bChildren.length; j++) {\n        var newItem = bChildren[j]\n\n        if (newItem.key) {\n            if (!aKeys.hasOwnProperty(newItem.key)) {\n                // Add any new keyed items\n                // We are adding new items to the end and then sorting them\n                // in place. In future we should insert new items in place.\n                newChildren.push(newItem)\n            }\n        } else if (j >= lastFreeIndex) {\n            // Add any leftover non-keyed items\n            newChildren.push(newItem)\n        }\n    }\n\n    var simulateIndex = 0\n    var removes = []\n    var inserts = []\n    var simulateItem\n\n    for (var k = 0; k < bChildren.length;) {\n        var wantedItem = bChildren[k]\n        simulateItem = newChildren[simulateIndex]\n\n        // remove items\n        while (simulateItem === null && simulateIndex < newChildren.length) {\n            removes.push({from: simulateIndex++, key: null})\n            simulateItem = newChildren[simulateIndex]\n        }\n\n        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n            // if we need a key in this position...\n            if (wantedItem.key) {\n                if (simulateItem && simulateItem.key) {\n                    // if an insert doesn't put this key in place, it needs to move\n                    if (bKeys[simulateItem.key] !== k + 1) {\n                        removes.push({from: simulateIndex++, key: simulateItem.key})\n                        simulateItem = newChildren[simulateIndex]\n                        // if the remove didn't put the wanted item in place, we need to insert it\n                        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n                            inserts.push({key: wantedItem.key, to: k})\n                        }\n                        // items are matching, so skip ahead\n                        else {\n                            simulateIndex++\n                        }\n                    }\n                    else {\n                        inserts.push({key: wantedItem.key, to: k})\n                    }\n                }\n                else {\n                    inserts.push({key: wantedItem.key, to: k})\n                }\n                k++\n            }\n            // a key in simulate has no matching wanted key, remove it\n            else if (simulateItem && simulateItem.key) {\n                removes.push({from: simulateIndex++, key: simulateItem.key})\n            }\n        }\n        else {\n            simulateIndex++\n            k++\n        }\n    }\n\n    // remove all the remaining nodes from simulate\n    while(simulateIndex < newChildren.length) {\n        simulateItem = newChildren[simulateIndex]\n        removes.push({from: simulateIndex++, key: simulateItem && simulateItem.key})\n    }\n\n    // If the only moves we have are deletes then we can just\n    // let the delete patch remove these items.\n    if (removes.length === deletedItems && !inserts.length) {\n        return {\n            children: newChildren,\n            moves: null\n        }\n    }\n\n    return {\n        children: newChildren,\n        moves: {\n            removes: removes,\n            inserts: inserts\n        }\n    }\n}\n\nfunction remove(arr, index, key) {\n    arr.splice(index, 1)\n\n    return {\n        from: index,\n        key: key\n    }\n}\n\nfunction keyIndex(children) {\n    var keys = {}\n    var free = []\n    var length = children.length\n\n    for (var i = 0; i < length; i++) {\n        var child = children[i]\n\n        if (child.key) {\n            keys[child.key] = i\n        } else {\n            free.push(i)\n        }\n    }\n\n    return {\n        keys: keys,     // A hash of key name to index\n        free: free      // An array of unkeyed item indices\n    }\n}\n\nfunction appendPatch(apply, patch) {\n    if (apply) {\n        if (isArray(apply)) {\n            apply.push(patch)\n        } else {\n            apply = [apply, patch]\n        }\n\n        return apply\n    } else {\n        return patch\n    }\n}\n",
    "var hiddenStore = require('./hidden-store.js');\n\nmodule.exports = createStore;\n\nfunction createStore() {\n    var key = {};\n\n    return function (obj) {\n        if ((typeof obj !== 'object' || obj === null) &&\n            typeof obj !== 'function'\n        ) {\n            throw new Error('Weakmap-shim: Key must be object')\n        }\n\n        var store = obj.valueOf(key);\n        return store && store.identity === key ?\n            store : hiddenStore(obj, key);\n    };\n}\n",
    "module.exports = hiddenStore;\n\nfunction hiddenStore(obj, key) {\n    var store = { identity: key };\n    var valueOf = obj.valueOf;\n\n    Object.defineProperty(obj, \"valueOf\", {\n        value: function (value) {\n            return value !== key ?\n                valueOf.apply(this, arguments) : store;\n        },\n        writable: true\n    });\n\n    return store;\n}\n",
    "var nativeIsArray = Array.isArray\nvar toString = Object.prototype.toString\n\nmodule.exports = nativeIsArray || isArray\n\nfunction isArray(obj) {\n    return toString.call(obj) === \"[object Array]\"\n}\n",
    "import {inherit, extend, result, each, isFunction, isEqual} from './utils';\nimport Thunk from './thunk';\nimport Vdt from 'vdt';\n\nexport default class Intact {\n    constructor(attrs = {}, contextWidgets = {}) {\n        if (!(this instanceof Intact)) {\n            return new Thunk(this, attributes, contextWidgets);\n        }\n\n        if (!this.template) {\n            throw new Error('Can not instantiate when this.template does not exist.');\n        }\n\n        attrs = extend({\n            children: undefined \n        }, result(this, 'defaults'), attrs);\n\n        this._events = {};\n        this.attributes = {};\n\n        this.vdt = Vdt(this.template);\n        this.set(attrs, {silent: true});\n        this.key = attrs.key;\n\n        this.widgets = {};\n\n        this.inited = false;\n        this.rendered = false;\n        this._hasCalledInit = false;\n\n        this._contextWidgets = contextWidgets;\n        this._widget = this.attributes.widget || _.uniqueId('widget');\n\n        // for debug\n        this.displayName = this.displayName;\n\n        this.addEvents(); \n\n        this.children = this.get('children');\n        delete this.attributes.children;\n        // widgetwidgets\n        this._contextWidgets[this._widget] = this;\n\n        // argumentsattributes\n        if (this.attributes.arguments) {\n            extend(this.attributes, result(this.attributes, 'arguments'));\n            delete this.attributes.arguments;\n        }\n\n        // \n        this.Animate = Animate;\n\n        // change\n        this._updateCount = 0;\n        let handleUpdate = () => {\n            if (this._updateCount > 0) {\n                this.update();\n                this._updateCount--;\n                handleUpdate.call(this);\n            }\n        };\n        this.on('change', function() { \n            if (++this._updateCount === 1) {\n                handleUpdate();\n            } else if (this._updateCount > 10) {\n                throw new Error('Too many recursive update.');\n            }\n        });\n\n        let ret = this._init();\n        // support promise\n        let inited = () => {\n            this.inited = true;\n            this.trigger('inited', self);\n        };\n        if (ret && ret.then) {\n            ret.then(inited);\n        } else {\n            inited();\n        }\n    }\n\n    _init() {}\n\n    _create() {}\n\n    _beforeUpdate(prevWidget, domNode) {}\n\n    _update(prevWidget, domNode) {}\n\n    _destroy(domNode) {}\n\n    removeEvents() {\n        // \n        each(this.attributes, (value, key) => {\n            if (key.substring(0, 3) === 'ev-' && isFunction(value)) {\n                this.off(key.substring(3), value);\n                delete this.attributes[key];\n            }\n        });\n    }\n\n    addEvents(attrs) {\n        // 'ev-'\n        attrs || (attrs = this.attributes);\n        each(attrs, (value, key) => {\n            if (key.substring(0, 3) === 'ev-' && isFunction(value)) {\n                this.on(key.substring(3), value);\n            }\n        });\n    }\n\n    init(isUpdate/* for private */) {\n        !isUpdate && (this.element = this.vdt.render(this));\n        this.rendered = true;\n        this._hasCalledInit = true;\n        this.trigger('rendered', this);\n        this._create();\n        return this.element;\n    }\n\n    update(prevWidget, domNode) {\n        if (!this.vdt.node && (!prevWidget || !prevWidget.vdt.node)) return;\n        this._beforeUpdate(prevWidget, domNode);\n        if (prevWidget && domNode) {\n            this.vdt.node = domNode;\n            this.vdt.tree = prevWidget.vdt.tree;\n        }\n        this.prevWidget = prevWidget;\n        this.element = this.vdt.update(this);\n        if (!this._hasCalledInit) {\n            this.init(true);\n        }\n        this._update(prevWidget, domNode);\n        return this.element;\n    }\n\n    destroy(domNode) {\n        // \n        if (this._contextWidgets[this._widget] === this) {\n            delete this._contextWidgets[this._widget];\n        }\n        this.off();\n        function destroy(children) {\n            each(children, function(child) {\n                if (child.hasThunks) {\n                    destroy(child.children);\n                } else if (child.type === 'Thunk') {\n                    child.widget.destroy();\n                }\n            });\n        }\n        destroy([this.vdt.tree]);\n        this._destroy(domNode);\n    }\n\n    get(attr) {\n        // @deprecated for v0.0.1 compatibility, use this.children instead of\n        if (attr === 'children') {\n            return this.attributes.children || this.children;\n        }\n        return arguments.length === 0 ? this.attributes : this.attributes[attr];\n    }\n\n    set(key, val, options) {\n        if (key == null) return this;\n\n        let attrs;\n        if (typeof key === 'object') {\n            attrs = key;\n            options = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        options = extend({\n            silent: false,\n            global: true,\n            async: false\n        }, options);\n\n        let current = this.attributes,\n            changes = [];\n\n        for (let attr in attrs) {\n            val = attrs[attr];\n            if (!isEqual(current[attr], val)) {\n                changes.push(attr);\n            }\n            current[attr] = val;\n        }\n\n        if (changes.length) {\n            let eventName;\n            for (let attr of changes) {\n                eventName = `change:${attr}`;\n                options[eventName] && options[eventName].call(this, current[attr]);\n                !options.silent && this.trigger(eventName, this, current[attr]);\n            }\n\n            options.change && options.change.call(this);\n            if (!options.silent) {\n                this.trigger('beforeChange', this);\n                if (options.global) {\n                    clearTimeout(this._asyncUpdate);\n                    if (options.async) {\n                        this._asyncUpdate = setTimeout(() => {\n                            this.trigger('change', this);\n                        });\n                    } else {\n                        this.trigger('change', this);\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    on(name, callback) {\n        (this._events[name] || (this._events[name] = [])).push(callback);\n\n        return this;\n    }\n\n    off(name, callback) {\n        if (!arguments.length) {\n            this._events = {};\n            return this;\n        }\n\n        let callbacks = this._events[name];\n        if (!callbacks) return this;\n\n        if (arguments.length === 1) {\n            delete this._events[name];\n            return this;\n        }\n\n        for (let cb, i = 0; i < callbacks.length; i++) {\n            cb = callbacks[i];\n            if (cb === callback) {\n                callbacks.splice(i, 1);\n                i--;\n            }\n        }\n\n        return this;\n    }\n\n    trigger(name, ...args) {\n        let callbacks = this._events[name];\n\n        if (callbacks) {\n            for (let callback of callbacks) {\n                callback.apply(this, args);\n            }\n        }\n\n        return this;\n    }\n}\n",
    "import {result, extend} from './utils';\n\nexport default class Thunk {\n    constructor(Widget, attributes, contextWidget) {\n        this.Widget = Widget;\n        this.attributes = attributes || {};\n        this.key = this.attributes.key;\n        this.contextWidget = contextWidget;\n    }\n\n    get type() {\n        return 'Thunk';\n    }\n\n    render(previous) {\n        if (!previous || previous.Widget !== this.Widget || previous.key !== this.key) {\n            this.widget = new this.Widget(this.attributes, this.contextWidget);\n        } else if (previous.Widget === this.Widget) {\n            if (!previous.widget) throw new Error('Don\\'t update when updating.');\n\n            var widget = this.widget = previous.widget;\n            widget.children = this.attributes.children;\n            delete this.attributes.children;\n\n            // argumentsattributes\n            if (this.attributes.arguments) {\n                extend(this.attributes, result(this.attributes, 'arguments'));\n                delete this.attributes.arguments;\n            }\n\n            widget.removeEvents();\n            widget.addEvents(this.attributes);\n            widget.set(this.attributes, {global: false});\n\n            // \n            // widgets\n            this.contextWidget[this.widget._widget] = this.widget;\n        }\n\n        return this.widget;\n    }\n}\n",
    "import Vdt from 'vdt';\n\nexport let extend = Vdt.utils.extend; \nexport let isArray = Vdt.utils.isArray;\n\n/**\n * inherit\n * @param Parent\n * @param prototype\n * @returns {Function}\n */\nexport function inherit(Parent, prototype) {\n    let Child = (...args) => {\n        if (!(this instanceof Child || this.prototype instanceof Child)) {\n            return Parent.apply(Child, args);\n        }\n        return Parent.apply(this, args);\n    };\n\n    Child.prototype = create(Parent.prototype);\n    each(prototype, function(proto, name) {\n        if (name === 'displayName') {\n            Child.displayName = proto;\n        }\n        if (isFunction(proto) || name === 'template') {\n            return Child.prototype[name] = proto;\n        }\n        Child.prototype[name] = (() => {\n            let _super = (...args) => Parent.prototype[name].apply(this, args),\n                _superApply = (args) => Parent.prototype[name].apply(this, args);\n            return (...args) => {\n                let __super = this._super,\n                    __superApply = this._superApply,\n                    returnValue;\n\n                this._super = _super;\n                this._superApply = _superApply;\n\n                returnValue = proto.apply(this, args);\n\n                this._super = __super;\n                this._superApply = __superApply;\n\n                return returnValue;\n            };\n        })();\n    });\n    Child.__super = Parent.prototype;\n    Child.prototype.constructor = Child;\n\n    extend(Child, Parent);\n\n    return Child;\n}\n\nlet nativeCreate = Object.create;\nexport function create(object) {\n    if (nativeCreate) {\n        return nativeCreate(object);\n    } else {\n        let fn = () => {};\n        fn.prototype = object;\n        return new fn();\n    }\n}\n\nlet hasOwn = Object.prototype.hasOwnProperty;\nexport function each(obj, iter) {\n    if (isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            iter(obj[i], i, obj);\n        } \n    } else if (isObject(obj)) {\n        for (let key in obj) {\n            if (hasOwn.call(obj, key)) {\n                iter(obj[key], key, obj);\n            }\n        }\n    }\n}\n\nexport function isFunction(obj) {\n    return typeof obj === 'function';\n}\n\nexport function isObject(obj) {\n    let type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj; \n}\n\nexport function result(obj, property, fallback) {\n    let value = obj == null ? undefined : obj[property];\n    if (value === undefined) {\n        value = fallback;\n    }\n    return isFunction(value) ? value.call(obj) : value;\n}\n",
    null
  ]
}