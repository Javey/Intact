/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		3: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "static/chunk/" + {"0":"c4b20e4b5d972f1122b1","1":"78b656a363f3775a300a","2":"e85436da49506bf2d15e"}[chunkId] + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.isObject = isObject;
exports.isStringOrNumber = isStringOrNumber;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isComponentInstance = isComponentInstance;
exports.isEventProp = isEventProp;
exports.isInvalid = isInvalid;
exports.isSkipProp = isSkipProp;
exports.MountedQueue = MountedQueue;
var toString = Object.prototype.toString;

var doc = exports.doc = typeof document === 'undefined' ? {} : document;

var isArray = exports.isArray = Array.isArray || function (arr) {
    return toString.call(arr) === '[object Array]';
};

function isObject(o) {
    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && o !== null;
}

function isStringOrNumber(o) {
    var type = typeof o === 'undefined' ? 'undefined' : _typeof(o);
    return type === 'string' || type === 'number';
}

function isNullOrUndefined(o) {
    return o === null || o === undefined;
}

function isComponentInstance(o) {
    return o && typeof o.init === 'function';
}

function isEventProp(propName) {
    return propName.substr(0, 3) === 'ev-';
}

function isInvalid(o) {
    return isNullOrUndefined(o) || o === false || o === true;
}

var indexOf = exports.indexOf = function () {
    if (Array.prototype.indexOf) {
        return function (arr, value) {
            return arr.indexOf(value);
        };
    } else {
        return function (arr, value) {
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] === value) {
                    return i;
                }
            }
            return -1;
        };
    }
}();

var nativeObject = Object.create;
var createObject = exports.createObject = function () {
    if (nativeObject) {
        return function (obj) {
            return nativeObject(obj);
        };
    } else {
        return function (obj) {
            function Fn() {}
            Fn.prototype = obj;
            return new Fn();
        };
    }
}();

var SimpleMap = exports.SimpleMap = typeof Map === 'function' ? Map : function () {
    function SimpleMap() {
        this._keys = [];
        this._values = [];
        this.size = 0;
    }

    SimpleMap.prototype.set = function (key, value) {
        var index = indexOf(this._keys, key);
        if (!~index) {
            index = this._keys.push(key) - 1;
            this.size++;
        }
        this._values[index] = value;
        return this;
    };
    SimpleMap.prototype.get = function (key) {
        var index = indexOf(this._keys, key);
        if (!~index) return;
        return this._values[index];
    };
    SimpleMap.prototype['delete'] = function (key) {
        var index = indexOf(this._keys, key);
        if (!~index) return false;
        this._keys.splice(index, 1);
        this._values.splice(index, 1);
        this.size--;
        return true;
    };

    return SimpleMap;
}();

var skipProps = exports.skipProps = {
    key: true,
    ref: true,
    children: true,
    className: true,
    checked: true,
    multiple: true,
    defaultValue: true,
    'v-model': true
};

function isSkipProp(prop) {
    // treat prop which start with '_' as private prop, so skip it
    return skipProps[prop] || prop[0] === '_';
}

var booleanProps = exports.booleanProps = {
    muted: true,
    scoped: true,
    loop: true,
    open: true,
    checked: true,
    'default': true,
    capture: true,
    disabled: true,
    readOnly: true,
    required: true,
    autoplay: true,
    controls: true,
    seamless: true,
    reversed: true,
    allowfullscreen: true,
    noValidate: true,
    hidden: true,
    autofocus: true,
    selected: true,
    indeterminate: true
};

var strictProps = exports.strictProps = {
    volume: true,
    defaultChecked: true,
    value: true,
    htmlFor: true
};

var selfClosingTags = exports.selfClosingTags = {
    'area': true,
    'base': true,
    'br': true,
    'col': true,
    'command': true,
    'embed': true,
    'hr': true,
    'img': true,
    'input': true,
    'keygen': true,
    'link': true,
    'menuitem': true,
    'meta': true,
    'param': true,
    'source': true,
    'track': true,
    'wbr': true
};

function MountedQueue() {
    this.queue = [];
}
MountedQueue.prototype.push = function (fn) {
    this.queue.push(fn);
};
MountedQueue.prototype.unshift = function (fn) {
    this.queue.unshift(fn);
};
MountedQueue.prototype.trigger = function () {
    var queue = this.queue;
    var callback = void 0;
    while (callback = queue.shift()) {
        callback();
    }
};

var browser = exports.browser = {};
if (typeof navigator !== 'undefined') {
    var ua = navigator.userAgent.toLowerCase();
    var index = ua.indexOf('msie ');
    if (~index) {
        browser.isIE = true;
        var version = parseInt(ua.substring(index + 5, ua.indexOf('.', index)), 10);
        browser.version = version;
        browser.isIE8 = version === 8;
    } else if (~ua.indexOf('edge')) {
        browser.isEdge = true;
    } else if (~ua.indexOf('safari')) {
        if (~ua.indexOf('chrome')) {
            browser.isChrome = true;
        } else {
            browser.isSafari = true;
        }
    }
}

var setTextContent = exports.setTextContent = browser.isIE8 ? function (dom, text) {
    dom.innerText = text;
} : function (dom, text) {
    dom.textContent = text;
};

var svgNS = exports.svgNS = "http://www.w3.org/2000/svg";
var xlinkNS = exports.xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = exports.xmlNS = "http://www.w3.org/XML/1998/namespace";

var namespaces = exports.namespaces = {
    'xlink:href': xlinkNS,
    'xlink:arcrole': xlinkNS,
    'xlink:actuate': xlinkNS,
    'xlink:show': xlinkNS,
    'xlink:role': xlinkNS,
    'xlink:title': xlinkNS,
    'xlink:type': xlinkNS,
    'xml:base': xmlNS,
    'xml:lang': xmlNS,
    'xml:space': xmlNS
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports.__esModule = true;
exports.EMPTY_OBJ = exports.Types = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.VNode = VNode;
exports.createVNode = createVNode;
exports.createCommentVNode = createCommentVNode;
exports.createUnescapeTextVNode = createUnescapeTextVNode;
exports.createTextVNode = createTextVNode;
exports.createVoidVNode = createVoidVNode;
exports.createComponentInstanceVNode = createComponentInstanceVNode;

var _utils = __webpack_require__(0);

var Types = exports.Types = {
    Text: 1,
    HtmlElement: 1 << 1,

    ComponentClass: 1 << 2,
    ComponentFunction: 1 << 3,
    ComponentInstance: 1 << 4,

    HtmlComment: 1 << 5,

    InputElement: 1 << 6,
    SelectElement: 1 << 7,
    TextareaElement: 1 << 8,
    SvgElement: 1 << 9,

    UnescapeText: 1 << 10 // for server side render unescape text
};
Types.FormElement = Types.InputElement | Types.SelectElement | Types.TextareaElement;
Types.Element = Types.HtmlElement | Types.FormElement | Types.SvgElement;
Types.ComponentClassOrInstance = Types.ComponentClass | Types.ComponentInstance;
Types.TextElement = Types.Text | Types.HtmlComment;

var EMPTY_OBJ = exports.EMPTY_OBJ = {};
if (process.env.NODE_ENV !== 'production' && !_utils.browser.isIE) {
    Object.freeze(EMPTY_OBJ);
}

function VNode(type, tag, props, children, className, key, ref) {
    this.type = type;
    this.tag = tag;
    this.props = props;
    this.children = children;
    this.key = key;
    this.ref = ref;
    this.className = className;
}

function createVNode(tag, props, children, className, key, ref) {
    var type = void 0;
    props || (props = EMPTY_OBJ);
    switch (typeof tag === 'undefined' ? 'undefined' : _typeof(tag)) {
        case 'string':
            if (tag === 'input') {
                type = Types.InputElement;
            } else if (tag === 'select') {
                type = Types.SelectElement;
            } else if (tag === 'textarea') {
                type = Types.TextareaElement;
            } else if (tag === 'svg') {
                type = Types.SvgElement;
            } else {
                type = Types.HtmlElement;
            }
            break;
        case 'function':
            if (tag.prototype.init) {
                type = Types.ComponentClass;
            } else {
                // return tag(props);
                type = Types.ComponentFunction;
            }
            break;
        case 'object':
            if (tag.init) {
                return createComponentInstanceVNode(tag);
            }
        default:
            throw new Error('unknown vNode type: ' + tag);
    }

    if (type & (Types.ComponentClass | Types.ComponentFunction)) {
        if (!(0, _utils.isNullOrUndefined)(children)) {
            if (props === EMPTY_OBJ) props = {};
            props.children = normalizeChildren(children, false);
            // props.children = children;
        } else if (!(0, _utils.isNullOrUndefined)(props.children)) {
            props.children = normalizeChildren(props.children, false);
        }
        if (type & Types.ComponentFunction) {
            if (key || ref) {
                if (props === EMPTY_OBJ) props = {};
                if (key) props.key = key;
                if (ref) props.ref = ref;
            }
            return tag(props);
        }
    } else if (!(0, _utils.isNullOrUndefined)(children)) {
        children = normalizeChildren(children, true);
    }

    return new VNode(type, tag, props, children, className || props.className, key || props.key, ref || props.ref);
}

function createCommentVNode(children) {
    return new VNode(Types.HtmlComment, null, EMPTY_OBJ, children);
}

function createUnescapeTextVNode(children) {
    return new VNode(Types.UnescapeText, null, EMPTY_OBJ, children);
}

function createTextVNode(text) {
    return new VNode(Types.Text, null, EMPTY_OBJ, text);
}

function createVoidVNode() {
    return new VNode(Types.VoidElement, null, EMPTY_OBJ);
}

function createComponentInstanceVNode(instance) {
    var props = instance.props || EMPTY_OBJ;
    return new VNode(Types.ComponentInstance, instance.constructor, props, instance, null, props.key, props.ref);
}

function normalizeChildren(vNodes, isAddKey) {
    if ((0, _utils.isArray)(vNodes)) {
        var childNodes = addChild(vNodes, { index: 0 }, isAddKey);
        return childNodes.length ? childNodes : null;
    } else if ((0, _utils.isComponentInstance)(vNodes)) {
        return createComponentInstanceVNode(vNodes);
    } else if (vNodes.type && !(0, _utils.isNullOrUndefined)(vNodes.dom)) {
        return directClone(vNodes);
    }
    return vNodes;
}

function applyKey(vNode, reference, isAddKey) {
    if (!isAddKey) return vNode;
    // start with '.' means the vNode has been set key by index
    // we will reset the key when it comes back again
    if ((0, _utils.isNullOrUndefined)(vNode.key) || vNode.key[0] === '.') {
        vNode.key = '.$' + reference.index++;
    }
    return vNode;
}

function addChild(vNodes, reference, isAddKey) {
    var newVNodes = void 0;
    for (var i = 0; i < vNodes.length; i++) {
        var n = vNodes[i];
        if ((0, _utils.isNullOrUndefined)(n)) {
            if (!newVNodes) {
                newVNodes = vNodes.slice(0, i);
            }
        } else if ((0, _utils.isArray)(n)) {
            if (!newVNodes) {
                newVNodes = vNodes.slice(0, i);
            }
            newVNodes = newVNodes.concat(addChild(n, reference, isAddKey));
        } else if ((0, _utils.isStringOrNumber)(n)) {
            if (!newVNodes) {
                newVNodes = vNodes.slice(0, i);
            }
            newVNodes.push(applyKey(createTextVNode(n), reference, isAddKey));
        } else if ((0, _utils.isComponentInstance)(n)) {
            if (!newVNodes) {
                newVNodes = vNodes.slice(0, i);
            }
            newVNodes.push(applyKey(createComponentInstanceVNode(n), reference, isAddKey));
        } else if (n.type) {
            if (!newVNodes) {
                newVNodes = vNodes.slice(0, i);
            }
            if (n.dom || n.key && n.key[0] === '.') {
                newVNodes.push(applyKey(directClone(n), reference, isAddKey));
            } else {
                newVNodes.push(applyKey(n, reference, isAddKey));
            }
        }
    }
    return newVNodes || vNodes;
}

function directClone(vNode) {
    var newVNode = void 0;
    var type = vNode.type;

    if (type & Types.ComponentClassOrInstance) {
        var props = void 0;
        var propsToClone = vNode.props;

        if (propsToClone === EMPTY_OBJ || (0, _utils.isNullOrUndefined)(propsToClone)) {
            props = EMPTY_OBJ;
        } else {
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }

        newVNode = new VNode(type, vNode.tag, props, vNode.children, null, vNode.key, vNode.ref);

        var newProps = newVNode.props;
        var newChildren = newProps.children;

        if (newChildren) {
            if ((0, _utils.isArray)(newChildren)) {
                var len = newChildren.length;
                if (len > 0) {
                    var tmpArray = [];

                    for (var i = 0; i < len; i++) {
                        var child = newChildren[i];
                        if ((0, _utils.isStringOrNumber)(child)) {
                            tmpArray.push(child);
                        } else if (!(0, _utils.isInvalid)(child) && child.type) {
                            tmpArray.push(directClone(child));
                        }
                    }
                    newProps.children = tmpArray;
                }
            } else if (newChildren.type) {
                newProps.children = directClone(newChildren);
            }
        }
    } else if (type & Types.Element) {
        var children = vNode.children;
        var _props = void 0;
        var _propsToClone = vNode.props;

        if (_propsToClone === EMPTY_OBJ || (0, _utils.isNullOrUndefined)(_propsToClone)) {
            _props = EMPTY_OBJ;
        } else {
            _props = {};
            for (var _key in _propsToClone) {
                _props[_key] = _propsToClone[_key];
            }
        }

        newVNode = new VNode(type, vNode.tag, vNode.props, children, vNode.className, vNode.key, vNode.ref);
    } else if (type & Types.TextElement) {
        newVNode = createTextVNode(vNode.children);
    }

    return newVNode;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.error = exports.noop = exports.hasOwn = exports.Options = exports.Directives = exports.TextTags = exports.TypeName = exports.Type = exports.SelfClosingTags = exports.indexOf = exports.isArray = exports.isNullOrUndefined = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /** 
                                                                                                                                                                                                                                                                               * @fileoverview utility methods
                                                                                                                                                                                                                                                                               * @author javey
                                                                                                                                                                                                                                                                               * @date 15-4-22
                                                                                                                                                                                                                                                                               */

exports.each = each;
exports.isObject = isObject;
exports.map = map;
exports.className = className;
exports.isWhiteSpace = isWhiteSpace;
exports.trimRight = trimRight;
exports.trimLeft = trimLeft;
exports.setDelimiters = setDelimiters;
exports.getDelimiters = getDelimiters;
exports.configure = configure;
exports.isSelfClosingTag = isSelfClosingTag;
exports.isTextTag = isTextTag;
exports.isDirective = isDirective;
exports.extend = extend;
exports.setCheckboxModel = setCheckboxModel;
exports.detectCheckboxChecked = detectCheckboxChecked;
exports.setSelectModel = setSelectModel;

var _utils = __webpack_require__(0);

exports.isNullOrUndefined = _utils.isNullOrUndefined;
exports.isArray = _utils.isArray;
exports.indexOf = _utils.indexOf;
exports.SelfClosingTags = _utils.selfClosingTags;


var i = 0;
var Type = exports.Type = {
    JS: i++,
    JSImport: i++,

    JSXText: i++,
    JSXUnescapeText: i++,
    JSXElement: i++,
    JSXExpressionContainer: i++,
    JSXAttribute: i++,
    JSXEmptyExpression: i++,

    JSXWidget: i++,
    JSXVdt: i++,
    JSXBlock: i++,
    JSXComment: i++,

    JSXDirective: i++
};
var TypeName = exports.TypeName = [];
for (var type in Type) {
    TypeName[Type[type]] = type;
}

// which children must be text
var TextTags = exports.TextTags = {
    style: true,
    script: true,
    textarea: true
};

var Directives = exports.Directives = {
    'v-if': true,
    'v-else-if': true,
    'v-else': true,
    'v-for': true,
    'v-for-value': true,
    'v-for-key': true,
    'v-raw': true
};

var Options = exports.Options = {
    autoReturn: true,
    onlySource: false,
    delimiters: ['{', '}'],
    // remove `with` statement
    noWith: false,
    // whether rendering on server or not
    server: false,
    // skip all whitespaces in template
    skipWhitespace: true,
    setModel: function setModel(data, key, value, self) {
        data[key] = value;
        self.update();
    },
    getModel: function getModel(data, key) {
        return data[key];
    },
    disableSplitText: false // split text with <!---->
};

var hasOwn = exports.hasOwn = Object.prototype.hasOwnProperty;
var noop = exports.noop = function noop() {};

function isArrayLike(value) {
    if ((0, _utils.isNullOrUndefined)(value)) return false;
    var length = value.length;
    return typeof length === 'number' && length > -1 && length % 1 === 0 && length <= 9007199254740991 && typeof value !== 'function';
}

function each(obj, iter, thisArg) {
    if (isArrayLike(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
            iter.call(thisArg, obj[i], i, obj);
        }
    } else if (isObject(obj)) {
        for (var key in obj) {
            if (hasOwn.call(obj, key)) {
                iter.call(thisArg, obj[key], key, obj);
            }
        }
    }
}

function isObject(obj) {
    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
    return type === 'function' || type === 'object' && !!obj;
}

function map(obj, iter, thisArgs) {
    var ret = [];
    each(obj, function (value, key, obj) {
        ret.push(iter.call(thisArgs, value, key, obj));
    });
    return ret;
}

function className(obj) {
    if ((0, _utils.isNullOrUndefined)(obj)) return;
    if (typeof obj === 'string') return obj;
    var ret = [];
    for (var key in obj) {
        if (hasOwn.call(obj, key) && obj[key]) {
            ret.push(key);
        }
    }
    return ret.join(' ');
}

function isWhiteSpace(charCode) {
    return charCode <= 160 && charCode >= 9 && charCode <= 13 || charCode == 32 || charCode == 160 || charCode == 5760 || charCode == 6158 || charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279);
}

function trimRight(str) {
    var index = str.length;

    while (index-- && isWhiteSpace(str.charCodeAt(index))) {}

    return str.slice(0, index + 1);
}

function trimLeft(str) {
    var length = str.length,
        index = -1;

    while (index++ < length && isWhiteSpace(str.charCodeAt(index))) {}

    return str.slice(index);
}

function setDelimiters(delimiters) {
    if (!(0, _utils.isArray)(delimiters)) {
        throw new Error('The parameter must be an array like ["{{", "}}"]');
    }
    Options.delimiters = delimiters;
}

function getDelimiters() {
    return Options.delimiters;
}

function configure(key, value) {
    if (typeof key === 'string') {
        if (value === undefined) {
            return Options[key];
        } else {
            Options[key] = value;
        }
    } else if (isObject(key)) {
        extend(Options, key);
    }
    return Options;
}

function isSelfClosingTag(tag) {
    return _utils.selfClosingTags[tag];
}

function isTextTag(tag) {
    return TextTags[tag];
}

function isDirective(name) {
    return hasOwn.call(Directives, name);
}

function extend() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    var dest = args[0];
    var length = args.length;
    if (length > 1) {
        for (var i = 1; i < length; i++) {
            var source = args[i];
            if (source) {
                for (var key in source) {
                    if (hasOwn.call(source, key)) {
                        dest[key] = source[key];
                    }
                }
            }
        }
    }
    return dest;
}

function setCheckboxModel(data, key, trueValue, falseValue, e, self) {
    var value = Options.getModel(data, key),
        checked = e.target.checked;
    if ((0, _utils.isArray)(value)) {
        value = value.slice(0);
        var index = (0, _utils.indexOf)(value, trueValue);
        if (checked) {
            if (!~index) {
                value.push(trueValue);
            }
        } else {
            if (~index) {
                value.splice(index, 1);
            }
        }
    } else {
        value = checked ? trueValue : falseValue;
    }
    Options.setModel(data, key, value, self);
}

function detectCheckboxChecked(data, key, trueValue) {
    var value = Options.getModel(data, key);
    if ((0, _utils.isArray)(value)) {
        return (0, _utils.indexOf)(value, trueValue) > -1;
    } else {
        return value === trueValue;
    }
}

function setSelectModel(data, key, e, self) {
    var target = e.target,
        multiple = target.multiple,
        value,
        i,
        opt,
        options = target.options;

    if (multiple) {
        value = [];
        for (i = 0; i < options.length; i++) {
            opt = options[i];
            if (opt.selected) {
                value.push((0, _utils.isNullOrUndefined)(opt._value) ? opt.value : opt._value);
            }
        }
    } else {
        for (i = 0; i < options.length; i++) {
            opt = options[i];
            if (opt.selected) {
                value = (0, _utils.isNullOrUndefined)(opt._value) ? opt.value : opt._value;
                break;
            }
        }
    }
    Options.setModel(data, key, value, self);
}

var error = exports.error = function () {
    var hasConsole = typeof console !== 'undefined';
    return hasConsole ? function (e) {
        console.error(e.stack);
    } : noop;
}();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;

var _vdt = __webpack_require__(18);

var _vdt2 = _interopRequireDefault(_vdt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = _vdt2['default'];
module.exports = exports['default'];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.patch = patch;
exports.patchVNode = patchVNode;
exports.patchProps = patchProps;
exports.patchProp = patchProp;
exports.kebabCase = kebabCase;

var _vnode = __webpack_require__(1);

var _vdom = __webpack_require__(5);

var _utils = __webpack_require__(0);

var _event = __webpack_require__(14);

var _process = __webpack_require__(7);

function patch(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG) {
    var isTrigger = true;
    if (mountedQueue) {
        isTrigger = false;
    } else {
        mountedQueue = new _utils.MountedQueue();
    }
    var dom = patchVNode(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
    if (isTrigger) {
        mountedQueue.trigger();
    }
    return dom;
}

function patchVNode(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG) {
    if (lastVNode !== nextVNode) {
        var nextType = nextVNode.type;
        var lastType = lastVNode.type;

        if (nextType & _vnode.Types.Element) {
            if (lastType & _vnode.Types.Element) {
                patchElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
            } else {
                replaceElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
            }
        } else if (nextType & _vnode.Types.TextElement) {
            if (lastType & _vnode.Types.TextElement) {
                patchText(lastVNode, nextVNode);
            } else {
                replaceElement(lastVNode, nextVNode, parentDom, mountedQueue, isSVG);
            }
        } else if (nextType & _vnode.Types.ComponentClass) {
            if (lastType & _vnode.Types.ComponentClass) {
                patchComponentClass(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
            } else {
                replaceElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
            }
            // } else if (nextType & Types.ComponentFunction) {
            // if (lastType & Types.ComponentFunction) {
            // patchComponentFunction(lastVNode, nextVNode, parentDom, mountedQueue);
            // } else {
            // replaceElement(lastVNode, nextVNode, parentDom, mountedQueue);
            // }
        } else if (nextType & _vnode.Types.ComponentInstance) {
            if (lastType & _vnode.Types.ComponentInstance) {
                patchComponentIntance(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
            } else {
                replaceElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
            }
        }
    }
    return nextVNode.dom;
}

function patchElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG) {
    var dom = lastVNode.dom;
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var lastChildren = lastVNode.children;
    var nextChildren = nextVNode.children;
    var lastClassName = lastVNode.className;
    var nextClassName = nextVNode.className;
    var nextType = nextVNode.type;

    nextVNode.dom = dom;
    nextVNode.parentVNode = parentVNode;

    isSVG = isSVG || (nextType & _vnode.Types.SvgElement) > 0;

    if (lastVNode.tag !== nextVNode.tag || lastVNode.key !== nextVNode.key) {
        replaceElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG);
    } else {
        if (lastChildren !== nextChildren) {
            patchChildren(lastChildren, nextChildren, dom, mountedQueue, nextVNode, isSVG === true && nextVNode.tag !== 'foreignObject');
        }

        if (lastProps !== nextProps) {
            patchProps(lastVNode, nextVNode, isSVG);
        }

        if (lastClassName !== nextClassName) {
            if ((0, _utils.isNullOrUndefined)(nextClassName)) {
                dom.removeAttribute('class');
            } else {
                if (isSVG) {
                    dom.setAttribute('class', nextClassName);
                } else {
                    dom.className = nextClassName;
                }
            }
        }

        var nextRef = nextVNode.ref;
        if (!(0, _utils.isNullOrUndefined)(nextRef) && lastVNode.ref !== nextRef) {
            (0, _vdom.createRef)(dom, nextRef, mountedQueue);
        }
    }
}

function patchComponentClass(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG) {
    var lastTag = lastVNode.tag;
    var nextTag = nextVNode.tag;
    var dom = lastVNode.dom;

    var instance = void 0;
    var newDom = void 0;

    if (lastTag !== nextTag || lastVNode.key !== nextVNode.key) {
        // we should call this remove function in component's init method
        // because it should be destroyed until async component has rendered
        // removeComponentClassOrInstance(lastVNode, null, nextVNode);
        newDom = (0, _vdom.createComponentClassOrInstance)(nextVNode, parentDom, mountedQueue, lastVNode, false, parentVNode, isSVG);
    } else {
        instance = lastVNode.children;
        instance.mountedQueue = mountedQueue;
        instance.isRender = false;
        instance.parentVNode = parentVNode;
        instance.vNode = nextVNode;
        instance.isSVG = isSVG;
        newDom = instance.update(lastVNode, nextVNode);
        nextVNode.dom = newDom;
        nextVNode.children = instance;
        nextVNode.parentVNode = parentVNode;

        // for intact.js, the dom will not be removed and
        // the component will not be destoryed, so the ref
        // function need be called in update method.
        var ref = nextVNode.ref;
        if (typeof ref === 'function') {
            ref(instance);
        }
    }

    // perhaps the dom has be replaced
    if (dom !== newDom && dom.parentNode &&
    // when dom has be replaced, its parentNode maybe be fragment in IE8
    dom.parentNode.nodeName !== '#document-fragment') {
        (0, _vdom.replaceChild)(parentDom, lastVNode, nextVNode);
    }
}

function patchComponentIntance(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG) {
    var lastInstance = lastVNode.children;
    var nextInstance = nextVNode.children;
    var dom = lastVNode.dom;

    var newDom = void 0;

    if (lastInstance !== nextInstance) {
        // removeComponentClassOrInstance(lastVNode, null, nextVNode);
        newDom = (0, _vdom.createComponentClassOrInstance)(nextVNode, parentDom, mountedQueue, lastVNode, false, parentVNode, isSVG);
    } else {
        lastInstance.mountedQueue = mountedQueue;
        lastInstance.isRender = false;
        lastInstance.parentVNode = parentVNode;
        newDom = lastInstance.update(lastVNode, nextVNode);
        nextVNode.dom = newDom;
        nextVNode.parentVNode = parentVNode;

        var ref = nextVNode.ref;
        if (typeof ref === 'function') {
            ref(instance);
        }
    }

    if (dom !== newDom && dom.parentNode &&
    // when dom has be replaced, its parentNode maybe be fragment in IE8
    dom.parentNode.nodeName !== '#document-fragment') {
        (0, _vdom.replaceChild)(parentDom, lastVNode, nextVNode);
    }
}

// function patchComponentFunction(lastVNode, nextVNode, parentDom, mountedQueue) {
// const lastTag = lastVNode.tag;
// const nextTag = nextVNode.tag;

// if (lastVNode.key !== nextVNode.key) {
// removeElements(lastVNode.children, parentDom);
// createComponentFunction(nextVNode, parentDom, mountedQueue);
// } else {
// nextVNode.dom = lastVNode.dom;
// createComponentFunctionVNode(nextVNode);
// patchChildren(lastVNode.children, nextVNode.children, parentDom, mountedQueue);
// }
// }

function patchChildren(lastChildren, nextChildren, parentDom, mountedQueue, parentVNode, isSVG) {
    if ((0, _utils.isNullOrUndefined)(lastChildren)) {
        if (!(0, _utils.isNullOrUndefined)(nextChildren)) {
            (0, _vdom.createElements)(nextChildren, parentDom, mountedQueue, false, parentVNode, isSVG);
        }
    } else if ((0, _utils.isNullOrUndefined)(nextChildren)) {
        if ((0, _utils.isStringOrNumber)(lastChildren)) {
            (0, _utils.setTextContent)(parentDom, '');
        } else {
            (0, _vdom.removeElements)(lastChildren, parentDom);
        }
    } else if ((0, _utils.isStringOrNumber)(nextChildren)) {
        if ((0, _utils.isStringOrNumber)(lastChildren)) {
            (0, _utils.setTextContent)(parentDom, nextChildren);
        } else {
            (0, _vdom.removeElements)(lastChildren, parentDom);
            (0, _utils.setTextContent)(parentDom, nextChildren);
        }
    } else if ((0, _utils.isArray)(lastChildren)) {
        if ((0, _utils.isArray)(nextChildren)) {
            patchChildrenByKey(lastChildren, nextChildren, parentDom, mountedQueue, parentVNode, isSVG);
        } else {
            (0, _vdom.removeElements)(lastChildren, parentDom);
            (0, _vdom.createElement)(nextChildren, parentDom, mountedQueue, false, parentVNode, isSVG);
        }
    } else if ((0, _utils.isArray)(nextChildren)) {
        if ((0, _utils.isStringOrNumber)(lastChildren)) {
            (0, _utils.setTextContent)(parentDom, '');
        } else {
            (0, _vdom.removeElement)(lastChildren, parentDom);
        }
        (0, _vdom.createElements)(nextChildren, parentDom, mountedQueue, false, parentVNode, isSVG);
    } else if ((0, _utils.isStringOrNumber)(lastChildren)) {
        (0, _utils.setTextContent)(parentDom, '');
        (0, _vdom.createElement)(nextChildren, parentDom, mountedQueue, false, parentVNode, isSVG);
    } else {
        patchVNode(lastChildren, nextChildren, parentDom, mountedQueue, parentVNode, isSVG);
    }
}

function patchChildrenByKey(a, b, dom, mountedQueue, parentVNode, isSVG) {
    var aLength = a.length;
    var bLength = b.length;
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var aStart = 0;
    var bStart = 0;
    var i = void 0;
    var j = void 0;
    var aNode = void 0;
    var bNode = void 0;
    var nextNode = void 0;
    var nextPos = void 0;
    var node = void 0;
    var aStartNode = a[aStart];
    var bStartNode = b[bStart];
    var aEndNode = a[aEnd];
    var bEndNode = b[bEnd];

    outer: while (true) {
        while (aStartNode.key === bStartNode.key) {
            patchVNode(aStartNode, bStartNode, dom, mountedQueue, parentVNode, isSVG);
            ++aStart;
            ++bStart;
            if (aStart > aEnd || bStart > bEnd) {
                break outer;
            }
            aStartNode = a[aStart];
            bStartNode = b[bStart];
        }
        while (aEndNode.key === bEndNode.key) {
            patchVNode(aEndNode, bEndNode, dom, mountedQueue, parentVNode, isSVG);
            --aEnd;
            --bEnd;
            if (aEnd < aStart || bEnd < bStart) {
                break outer;
            }
            aEndNode = a[aEnd];
            bEndNode = b[bEnd];
        }

        if (aEndNode.key === bStartNode.key) {
            patchVNode(aEndNode, bStartNode, dom, mountedQueue, parentVNode, isSVG);
            dom.insertBefore(bStartNode.dom, aStartNode.dom);
            --aEnd;
            ++bStart;
            aEndNode = a[aEnd];
            bStartNode = b[bStart];
            continue;
        }

        if (aStartNode.key === bEndNode.key) {
            patchVNode(aStartNode, bEndNode, dom, mountedQueue, parentVNode, isSVG);
            insertOrAppend(bEnd, bLength, bEndNode.dom, b, dom);
            ++aStart;
            --bEnd;
            aStartNode = a[aStart];
            bEndNode = b[bEnd];
            continue;
        }
        break;
    }

    if (aStart > aEnd) {
        while (bStart <= bEnd) {
            insertOrAppend(bEnd, bLength, (0, _vdom.createElement)(b[bStart], null, mountedQueue, false, parentVNode, isSVG), b, dom, true /* detectParent: for animate, if the parentNode exists, then do nothing*/
            );
            ++bStart;
        }
    } else if (bStart > bEnd) {
        while (aStart <= aEnd) {
            (0, _vdom.removeElement)(a[aStart], dom);
            ++aStart;
        }
    } else {
        aLength = aEnd - aStart + 1;
        bLength = bEnd - bStart + 1;
        var sources = new Array(bLength);
        for (i = 0; i < bLength; i++) {
            sources[i] = -1;
        }
        var moved = false;
        var pos = 0;
        var patched = 0;

        if (bLength <= 4 || aLength * bLength <= 16) {
            for (i = aStart; i <= aEnd; i++) {
                aNode = a[i];
                if (patched < bLength) {
                    for (j = bStart; j <= bEnd; j++) {
                        bNode = b[j];
                        if (aNode.key === bNode.key) {
                            sources[j - bStart] = i;
                            if (pos > j) {
                                moved = true;
                            } else {
                                pos = j;
                            }
                            patchVNode(aNode, bNode, dom, mountedQueue, parentVNode, isSVG);
                            ++patched;
                            a[i] = null;
                            break;
                        }
                    }
                }
            }
        } else {
            var keyIndex = {};
            for (i = bStart; i <= bEnd; i++) {
                keyIndex[b[i].key] = i;
            }
            for (i = aStart; i <= aEnd; i++) {
                aNode = a[i];
                if (patched < bLength) {
                    j = keyIndex[aNode.key];
                    if (j !== undefined) {
                        bNode = b[j];
                        sources[j - bStart] = i;
                        if (pos > j) {
                            moved = true;
                        } else {
                            pos = j;
                        }
                        patchVNode(aNode, bNode, dom, mountedQueue, parentVNode, isSVG);
                        ++patched;
                        a[i] = null;
                    }
                }
            }
        }
        if (aLength === a.length && patched === 0) {
            // removeAllChildren(dom, a);
            // children maybe have animation
            (0, _vdom.removeElements)(a, dom);
            while (bStart < bLength) {
                (0, _vdom.createElement)(b[bStart], dom, mountedQueue, false, parentVNode, isSVG);
                ++bStart;
            }
        } else {
            // some browsers, e.g. ie, must insert before remove for some element,
            // e.g. select/option, otherwise the selected property will be weird
            if (moved) {
                var seq = lisAlgorithm(sources);
                j = seq.length - 1;
                for (i = bLength - 1; i >= 0; i--) {
                    if (sources[i] === -1) {
                        pos = i + bStart;
                        insertOrAppend(pos, b.length, (0, _vdom.createElement)(b[pos], null, mountedQueue, false, parentVNode, isSVG), b, dom);
                    } else {
                        if (j < 0 || i !== seq[j]) {
                            pos = i + bStart;
                            insertOrAppend(pos, b.length, b[pos].dom, b, dom);
                        } else {
                            --j;
                        }
                    }
                }
            } else if (patched !== bLength) {
                for (i = bLength - 1; i >= 0; i--) {
                    if (sources[i] === -1) {
                        pos = i + bStart;
                        insertOrAppend(pos, b.length, (0, _vdom.createElement)(b[pos], null, mountedQueue, false, parentVNode, isSVG), b, dom, true);
                    }
                }
            }
            i = aLength - patched;
            while (i > 0) {
                aNode = a[aStart++];
                if (aNode !== null) {
                    (0, _vdom.removeElement)(aNode, dom);
                    --i;
                }
            }
        }
    }
}

function lisAlgorithm(arr) {
    var p = arr.slice(0);
    var result = [0];
    var i = void 0;
    var j = void 0;
    var u = void 0;
    var v = void 0;
    var c = void 0;
    var len = arr.length;
    for (i = 0; i < len; i++) {
        var arrI = arr[i];
        if (arrI === -1) {
            continue;
        }
        j = result[result.length - 1];
        if (arr[j] < arrI) {
            p[i] = j;
            result.push(i);
            continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
            c = (u + v) / 2 | 0;
            if (arr[result[c]] < arrI) {
                u = c + 1;
            } else {
                v = c;
            }
        }
        if (arrI < arr[result[u]]) {
            if (u > 0) {
                p[i] = result[u - 1];
            }
            result[u] = i;
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

function insertOrAppend(pos, length, newDom, nodes, dom, detectParent) {
    var nextPos = pos + 1;
    // if (detectParent && newDom.parentNode) {
    // return;
    // } else
    if (nextPos < length) {
        dom.insertBefore(newDom, nodes[nextPos].dom);
    } else {
        dom.appendChild(newDom);
        // appendChild(dom, newDom);
    }
}

function replaceElement(lastVNode, nextVNode, parentDom, mountedQueue, parentVNode, isSVG) {
    (0, _vdom.removeElement)(lastVNode, null, nextVNode);
    (0, _vdom.createElement)(nextVNode, null, mountedQueue, false, parentVNode, isSVG);
    (0, _vdom.replaceChild)(parentDom, lastVNode, nextVNode);
}

function patchText(lastVNode, nextVNode, parentDom) {
    var nextText = nextVNode.children;
    var dom = lastVNode.dom;
    nextVNode.dom = dom;
    if (lastVNode.children !== nextText) {
        dom.nodeValue = nextText;
    }
}

function patchProps(lastVNode, nextVNode, isSVG) {
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var dom = nextVNode.dom;
    var prop = void 0;
    if (nextProps !== _vnode.EMPTY_OBJ) {
        var isFormElement = (nextVNode.type & _vnode.Types.FormElement) > 0;
        for (prop in nextProps) {
            patchProp(prop, lastProps[prop], nextProps[prop], dom, isFormElement, isSVG);
        }
        if (isFormElement) {
            (0, _process.processForm)(nextVNode, dom, nextProps, false);
        }
    }
    if (lastProps !== _vnode.EMPTY_OBJ) {
        for (prop in lastProps) {
            if (!(0, _utils.isSkipProp)(prop) && (0, _utils.isNullOrUndefined)(nextProps[prop]) && !(0, _utils.isNullOrUndefined)(lastProps[prop])) {
                removeProp(prop, lastProps[prop], dom);
            }
        }
    }
}

function patchProp(prop, lastValue, nextValue, dom, isFormElement, isSVG) {
    if (lastValue !== nextValue) {
        if ((0, _utils.isSkipProp)(prop) || isFormElement && prop === 'value') {
            return;
        } else if (_utils.booleanProps[prop]) {
            dom[prop] = !!nextValue;
        } else if (_utils.strictProps[prop]) {
            var value = (0, _utils.isNullOrUndefined)(nextValue) ? '' : nextValue;
            // IE8 the value of option is equal to its text as default
            // so set it forcely
            if (dom[prop] !== value || _utils.browser.isIE8) {
                dom[prop] = value;
            }
            // add a private property _value for selecting an non-string value 
            if (prop === 'value') {
                dom._value = value;
            }
        } else if ((0, _utils.isNullOrUndefined)(nextValue)) {
            removeProp(prop, lastValue, dom);
        } else if ((0, _utils.isEventProp)(prop)) {
            (0, _event.handleEvent)(prop.substr(3), lastValue, nextValue, dom);
        } else if ((0, _utils.isObject)(nextValue)) {
            patchPropByObject(prop, lastValue, nextValue, dom);
        } else if (prop === 'innerHTML') {
            dom.innerHTML = nextValue;
        } else {
            if (isSVG && _utils.namespaces[prop]) {
                dom.setAttributeNS(_utils.namespaces[prop], prop, nextValue);
            } else {
                dom.setAttribute(prop, nextValue);
            }
        }
    }
}

function removeProp(prop, lastValue, dom) {
    if (!(0, _utils.isNullOrUndefined)(lastValue)) {
        switch (prop) {
            case 'value':
                dom.value = '';
                return;
            case 'style':
                dom.removeAttribute('style');
                return;
            case 'attributes':
                for (var key in lastValue) {
                    dom.removeAttribute(key);
                }
                return;
            case 'dataset':
                removeDataset(lastValue, dom);
                return;
            case 'innerHTML':
                dom.innerHTML = '';
                return;
            default:
                break;
        }

        if (_utils.booleanProps[prop]) {
            dom[prop] = false;
        } else if ((0, _utils.isEventProp)(prop)) {
            (0, _event.handleEvent)(prop.substr(3), lastValue, null, dom);
        } else if ((0, _utils.isObject)(lastValue)) {
            var domProp = dom[prop];
            try {
                dom[prop] = undefined;
                delete dom[prop];
            } catch (e) {
                for (var _key in lastValue) {
                    delete domProp[_key];
                }
            }
        } else {
            dom.removeAttribute(prop);
        }
    }
}

var removeDataset = _utils.browser.isIE || _utils.browser.isSafari ? function (lastValue, dom) {
    for (var key in lastValue) {
        dom.removeAttribute('data-' + kebabCase(key));
    }
} : function (lastValue, dom) {
    var domProp = dom.dataset;
    for (var key in lastValue) {
        delete domProp[key];
    }
};

function patchPropByObject(prop, lastValue, nextValue, dom) {
    if (lastValue && !(0, _utils.isObject)(lastValue) && !(0, _utils.isNullOrUndefined)(lastValue)) {
        removeProp(prop, lastValue, dom);
        lastValue = null;
    }
    switch (prop) {
        case 'attributes':
            return patchAttributes(lastValue, nextValue, dom);
        case 'style':
            return patchStyle(lastValue, nextValue, dom);
        case 'dataset':
            return patchDataset(prop, lastValue, nextValue, dom);
        default:
            return patchObject(prop, lastValue, nextValue, dom);
    }
}

var patchDataset = _utils.browser.isIE ? function patchDataset(prop, lastValue, nextValue, dom) {
    var hasRemoved = {};
    var key = void 0;
    var value = void 0;

    for (key in nextValue) {
        var dataKey = 'data-' + kebabCase(key);
        value = nextValue[key];
        if ((0, _utils.isNullOrUndefined)(value)) {
            dom.removeAttribute(dataKey);
            hasRemoved[key] = true;
        } else {
            dom.setAttribute(dataKey, value);
        }
    }

    if (!(0, _utils.isNullOrUndefined)(lastValue)) {
        for (key in lastValue) {
            if ((0, _utils.isNullOrUndefined)(nextValue[key]) && !hasRemoved[key]) {
                dom.removeAttribute('data-' + kebabCase(key));
            }
        }
    }
} : patchObject;

var _cache = {};
var uppercasePattern = /[A-Z]/g;
function kebabCase(word) {
    if (!_cache[word]) {
        _cache[word] = word.replace(uppercasePattern, function (item) {
            return '-' + item.toLowerCase();
        });
    }
    return _cache[word];
}

function patchObject(prop, lastValue, nextValue, dom) {
    var domProps = dom[prop];
    if ((0, _utils.isNullOrUndefined)(domProps)) {
        domProps = dom[prop] = {};
    }
    var key = void 0;
    var value = void 0;
    for (key in nextValue) {
        domProps[key] = nextValue[key];
    }
    if (!(0, _utils.isNullOrUndefined)(lastValue)) {
        for (key in lastValue) {
            if ((0, _utils.isNullOrUndefined)(nextValue[key])) {
                delete domProps[key];
            }
        }
    }
}

function patchAttributes(lastValue, nextValue, dom) {
    var hasRemoved = {};
    var key = void 0;
    var value = void 0;
    for (key in nextValue) {
        value = nextValue[key];
        if ((0, _utils.isNullOrUndefined)(value)) {
            dom.removeAttribute(key);
            hasRemoved[key] = true;
        } else {
            dom.setAttribute(key, value);
        }
    }
    if (!(0, _utils.isNullOrUndefined)(lastValue)) {
        for (key in lastValue) {
            if ((0, _utils.isNullOrUndefined)(nextValue[key]) && !hasRemoved[key]) {
                dom.removeAttribute(key);
            }
        }
    }
}

function patchStyle(lastValue, nextValue, dom) {
    var domStyle = dom.style;
    var hasRemoved = {};
    var key = void 0;
    var value = void 0;
    for (key in nextValue) {
        value = nextValue[key];
        if ((0, _utils.isNullOrUndefined)(value)) {
            domStyle[key] = '';
            hasRemoved[key] = true;
        } else {
            domStyle[key] = value;
        }
    }
    if (!(0, _utils.isNullOrUndefined)(lastValue)) {
        for (key in lastValue) {
            if ((0, _utils.isNullOrUndefined)(nextValue[key]) && !hasRemoved[key]) {
                domStyle[key] = '';
            }
        }
    }
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports.__esModule = true;
exports.render = render;
exports.createElement = createElement;
exports.createHtmlElement = createHtmlElement;
exports.createTextElement = createTextElement;
exports.createComponentClassOrInstance = createComponentClassOrInstance;
exports.createComponentFunction = createComponentFunction;
exports.createCommentElement = createCommentElement;
exports.createComponentFunctionVNode = createComponentFunctionVNode;
exports.createElements = createElements;
exports.removeElements = removeElements;
exports.removeElement = removeElement;
exports.removeHtmlElement = removeHtmlElement;
exports.removeText = removeText;
exports.removeComponentFunction = removeComponentFunction;
exports.removeComponentClassOrInstance = removeComponentClassOrInstance;
exports.removeAllChildren = removeAllChildren;
exports.replaceChild = replaceChild;
exports.removeChild = removeChild;
exports.appendChild = appendChild;
exports.createRef = createRef;
exports.documentCreateElement = documentCreateElement;

var _vnode = __webpack_require__(1);

var _vpatch = __webpack_require__(4);

var _event = __webpack_require__(14);

var _utils = __webpack_require__(0);

var _process = __webpack_require__(7);

function render(vNode, parentDom, mountedQueue, parentVNode, isSVG) {
    if ((0, _utils.isNullOrUndefined)(vNode)) return;
    var isTrigger = true;
    if (mountedQueue) {
        isTrigger = false;
    } else {
        mountedQueue = new _utils.MountedQueue();
    }
    var dom = createElement(vNode, parentDom, mountedQueue, true /* isRender */, parentVNode, isSVG);
    if (isTrigger) {
        mountedQueue.trigger();
    }
    return dom;
}

function createElement(vNode, parentDom, mountedQueue, isRender, parentVNode, isSVG) {
    var type = vNode.type;
    if (type & _vnode.Types.Element) {
        return createHtmlElement(vNode, parentDom, mountedQueue, isRender, parentVNode, isSVG);
    } else if (type & _vnode.Types.Text) {
        return createTextElement(vNode, parentDom);
    } else if (type & _vnode.Types.ComponentClassOrInstance) {
        return createComponentClassOrInstance(vNode, parentDom, mountedQueue, null, isRender, parentVNode, isSVG);
        // } else if (type & Types.ComponentFunction) {
        // return createComponentFunction(vNode, parentDom, mountedQueue, isNotAppendChild, isRender);
        // } else if (type & Types.ComponentInstance) {
        // return createComponentInstance(vNode, parentDom, mountedQueue);
    } else if (type & _vnode.Types.HtmlComment) {
        return createCommentElement(vNode, parentDom);
    } else {
        throw new Error('unknown vnode type ' + type);
    }
}

function createHtmlElement(vNode, parentDom, mountedQueue, isRender, parentVNode, isSVG) {
    var type = vNode.type;

    isSVG = isSVG || (type & _vnode.Types.SvgElement) > 0;

    var dom = documentCreateElement(vNode.tag, isSVG);
    var children = vNode.children;
    var props = vNode.props;
    var className = vNode.className;

    vNode.dom = dom;
    vNode.parentVNode = parentVNode;

    if (!(0, _utils.isNullOrUndefined)(children)) {
        createElements(children, dom, mountedQueue, isRender, vNode, isSVG === true && vNode.tag !== 'foreignObject');
    }

    if (!(0, _utils.isNullOrUndefined)(className)) {
        if (isSVG) {
            dom.setAttribute('class', className);
        } else {
            dom.className = className;
        }
    }

    // in IE8, the select value will be set to the first option's value forcely
    // when it is appended to parent dom. We change its value in processForm does not
    // work. So processForm after it has be appended to parent dom.
    var isFormElement = void 0;
    if (props !== _vnode.EMPTY_OBJ) {
        isFormElement = (vNode.type & _vnode.Types.FormElement) > 0;
        for (var prop in props) {
            (0, _vpatch.patchProp)(prop, null, props[prop], dom, isFormElement, isSVG);
        }
    }

    var ref = vNode.ref;
    if (!(0, _utils.isNullOrUndefined)(ref)) {
        createRef(dom, ref, mountedQueue);
    }

    if (parentDom) {
        appendChild(parentDom, dom);
    }

    if (isFormElement) {
        (0, _process.processForm)(vNode, dom, props, true);
    }

    return dom;
}

function createTextElement(vNode, parentDom) {
    var dom = _utils.doc.createTextNode(vNode.children);
    vNode.dom = dom;

    if (parentDom) {
        parentDom.appendChild(dom);
    }

    return dom;
}

function createComponentClassOrInstance(vNode, parentDom, mountedQueue, lastVNode, isRender, parentVNode, isSVG) {
    var props = vNode.props;
    var instance = vNode.type & _vnode.Types.ComponentClass ? new vNode.tag(props) : vNode.children;
    instance.parentDom = parentDom;
    instance.mountedQueue = mountedQueue;
    instance.isRender = isRender;
    instance.parentVNode = parentVNode;
    instance.isSVG = isSVG;
    instance.vNode = vNode;
    var dom = instance.init(lastVNode, vNode);
    var ref = vNode.ref;

    vNode.dom = dom;
    vNode.children = instance;
    vNode.parentVNode = parentVNode;

    if (parentDom) {
        appendChild(parentDom, dom);
        // parentDom.appendChild(dom);
    }

    if (typeof instance.mount === 'function') {
        mountedQueue.push(function () {
            return instance.mount(lastVNode, vNode);
        });
    }

    if (typeof ref === 'function') {
        ref(instance);
    }

    return dom;
}

function createComponentFunction(vNode, parentDom, mountedQueue) {
    var props = vNode.props;
    var ref = vNode.ref;

    createComponentFunctionVNode(vNode);

    var children = vNode.children;
    var dom = void 0;
    // support ComponentFunction return an array for macro usage
    if ((0, _utils.isArray)(children)) {
        dom = [];
        for (var i = 0; i < children.length; i++) {
            dom.push(createElement(children[i], parentDom, mountedQueue));
        }
    } else {
        dom = createElement(vNode.children, parentDom, mountedQueue);
    }
    vNode.dom = dom;

    // if (parentDom) {
    // parentDom.appendChild(dom);
    // }

    if (ref) {
        createRef(dom, ref, mountedQueue);
    }

    return dom;
}

function createCommentElement(vNode, parentDom) {
    var dom = _utils.doc.createComment(vNode.children);
    vNode.dom = dom;

    if (parentDom) {
        parentDom.appendChild(dom);
    }

    return dom;
}

function createComponentFunctionVNode(vNode) {
    var result = vNode.tag(vNode.props);
    if ((0, _utils.isStringOrNumber)(result)) {
        result = (0, _vnode.createTextVNode)(result);
    } else if (process.env.NODE_ENV !== 'production') {
        if ((0, _utils.isArray)(result)) {
            throw new Error('ComponentFunction ' + vNode.tag.name + ' returned a invalid vNode');
        }
    }

    vNode.children = result;

    return vNode;
}

function createElements(vNodes, parentDom, mountedQueue, isRender, parentVNode, isSVG) {
    if ((0, _utils.isStringOrNumber)(vNodes)) {
        (0, _utils.setTextContent)(parentDom, vNodes);
    } else if ((0, _utils.isArray)(vNodes)) {
        for (var i = 0; i < vNodes.length; i++) {
            createElement(vNodes[i], parentDom, mountedQueue, isRender, parentVNode, isSVG);
        }
    } else {
        createElement(vNodes, parentDom, mountedQueue, isRender, parentVNode, isSVG);
    }
}

function removeElements(vNodes, parentDom) {
    if ((0, _utils.isNullOrUndefined)(vNodes)) {
        return;
    } else if ((0, _utils.isArray)(vNodes)) {
        for (var i = 0; i < vNodes.length; i++) {
            removeElement(vNodes[i], parentDom);
        }
    } else {
        removeElement(vNodes, parentDom);
    }
}

function removeElement(vNode, parentDom, nextVNode) {
    var type = vNode.type;
    if (type & _vnode.Types.Element) {
        return removeHtmlElement(vNode, parentDom);
    } else if (type & _vnode.Types.TextElement) {
        return removeText(vNode, parentDom);
    } else if (type & _vnode.Types.ComponentClassOrInstance) {
        return removeComponentClassOrInstance(vNode, parentDom, nextVNode);
    } else if (type & _vnode.Types.ComponentFunction) {
        return removeComponentFunction(vNode, parentDom);
    }
}

function removeHtmlElement(vNode, parentDom) {
    var ref = vNode.ref;
    var props = vNode.props;
    var dom = vNode.dom;

    if (ref) {
        ref(null);
    }

    removeElements(vNode.children, null);

    // remove event
    for (var name in props) {
        var prop = props[name];
        if (!(0, _utils.isNullOrUndefined)(prop) && (0, _utils.isEventProp)(name)) {
            (0, _event.handleEvent)(name.substr(0, 3), prop, null, dom);
        }
    }

    if (parentDom) {
        parentDom.removeChild(dom);
    }
}

function removeText(vNode, parentDom) {
    if (parentDom) {
        parentDom.removeChild(vNode.dom);
    }
}

function removeComponentFunction(vNode, parentDom) {
    var ref = vNode.ref;
    if (ref) {
        ref(null);
    }
    removeElement(vNode.children, parentDom);
}

function removeComponentClassOrInstance(vNode, parentDom, nextVNode) {
    var instance = vNode.children;
    var ref = vNode.ref;

    if (typeof instance.destroy === 'function') {
        instance.destroy(vNode, nextVNode, parentDom);
    }

    if (ref) {
        ref(null);
    }

    // instance destroy method will remove everything
    // removeElements(vNode.props.children, null);

    if (parentDom) {
        removeChild(parentDom, vNode);
    }
}

function removeAllChildren(dom, vNodes) {
    // setTextContent(dom, '');
    // removeElements(vNodes);
}

function replaceChild(parentDom, lastVNode, nextVNode) {
    var lastDom = lastVNode.dom;
    var nextDom = nextVNode.dom;
    var parentNode = lastDom.parentNode;
    // maybe the lastDom has be moved
    if (!parentDom || parentNode !== parentDom) parentDom = parentNode;
    if (lastDom._unmount) {
        lastDom._unmount(lastVNode, parentDom);
        if (!nextDom.parentNode) {
            parentDom.appendChild(nextDom);
        }
    } else {
        parentDom.replaceChild(nextDom, lastDom);
    }
}

function removeChild(parentDom, vNode) {
    var dom = vNode.dom;
    if (dom._unmount) {
        dom._unmount(vNode, parentDom);
    } else {
        parentDom.removeChild(dom);
    }
}

function appendChild(parentDom, dom) {
    // in IE8, when a element has appendChild,
    // then its parentNode will be HTMLDocument object,
    // so check the tagName for this case
    if (!dom.parentNode || !dom.parentNode.tagName) {
        parentDom.appendChild(dom);
    }
}

function createRef(dom, ref, mountedQueue) {
    if (typeof ref === 'function') {
        mountedQueue.push(function () {
            return ref(dom);
        });
    } else {
        throw new Error('ref must be a function, but got "' + JSON.stringify(ref) + '"');
    }
}

function documentCreateElement(tag, isSVG) {
    if (isSVG === true) {
        return _utils.doc.createElementNS(_utils.svgNS, tag);
    } else {
        return _utils.doc.createElement(tag);
    }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.error = exports.warn = exports.keys = exports.create = exports.isIOS = exports.UA = exports.inBrowser = exports.noop = exports.isNullOrUndefined = exports.hasOwn = exports.isObject = exports.each = exports.isArray = exports.extend = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.inherit = inherit;
exports.templateDecorator = templateDecorator;
exports.isFunction = isFunction;
exports.isString = isString;
exports.result = result;
exports.bind = bind;
exports.isEqual = isEqual;
exports.uniqueId = uniqueId;
exports.values = values;
exports.castPath = castPath;
exports.get = get;
exports.set = set;
exports.NextTick = NextTick;
exports.autobind = autobind;

var _utils = __webpack_require__(2);

var _utils2 = __webpack_require__(0);

var _vdt = __webpack_require__(3);

var _vdt2 = _interopRequireDefault(_vdt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports.extend = _utils.extend;
exports.isArray = _utils.isArray;
exports.each = _utils.each;
exports.isObject = _utils.isObject;
exports.hasOwn = _utils.hasOwn;
exports.isNullOrUndefined = _utils2.isNullOrUndefined;
exports.noop = _utils.noop;
var inBrowser = exports.inBrowser = typeof window !== 'undefined';
var UA = exports.UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIOS = exports.isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

/**
 * inherit
 * @param Parent
 * @param prototype
 * @returns {Function}
 */
var isSupportGetDescriptor = function () {
    var a = {};
    try {
        Object.getOwnPropertyDescriptor(a, 'a');
    } catch (e) {
        return false;
    }
    return true;
}();
function setPrototype(Parent, Child, name, value) {
    var prototype = Child.prototype;
    var tmp = void 0;
    if (isSupportGetDescriptor && (tmp = Object.getOwnPropertyDescriptor(Parent.prototype, name)) && tmp.get) {
        Object.defineProperty(prototype, name, {
            get: function get() {
                return value;
            },

            enumerable: true,
            configurable: true
        });
    } else {
        prototype[name] = value;
    }
}
function inherit(Parent, prototype) {
    var Child = function Child() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return Parent.apply(this, args);
    };

    Child.prototype = create(Parent.prototype);
    (0, _utils.each)(prototype, function (proto, name) {
        if (name === 'displayName') {
            Child.displayName = proto;
        }
        if (name === 'template') {
            if (isString(proto)) {
                proto = _vdt2['default'].compile(proto);
                prototype.template = proto;
            }
            var _super = Parent.template;
            if (!_super || _super === templateDecorator) {
                _super = Parent.prototype.template;
            }
            proto._super = _super;
            Child.template = undefined;
            return setPrototype(Parent, Child, 'template', proto);
        } else if (!isFunction(proto)) {
            Child.prototype[name] = proto;
            return;
        }
        var fn = function () {
            var _super = function _super() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                return Parent.prototype[name].apply(this, args);
            },
                _superApply = function _superApply(args) {
                return Parent.prototype[name].apply(this, args);
            };
            return function () {
                var self = this || {},
                    __super = self._super,
                    __superApply = self._superApply,
                    returnValue = void 0;

                self._super = _super;
                self._superApply = _superApply;

                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3];
                }

                returnValue = proto.apply(this, args);

                self._super = __super;
                self._superApply = __superApply;

                return returnValue;
            };
        }();
        setPrototype(Parent, Child, name, fn);
    });
    Child.prototype.constructor = Child;

    for (var key in Parent) {
        if (!_utils.hasOwn.call(Child, key)) {
            Child[key] = Parent[key];
        }
    }

    Child.__super = Parent.prototype;

    return Child;
}

function templateDecorator(options) {
    return function (target, name, descriptor) {
        var template = target.template;
        if (isString(template)) {
            template = _vdt2['default'].compile(template, options);
        }
        var Parent = Object.getPrototypeOf(target);
        var _super = void 0;
        if (typeof Parent === 'function') {
            // is define by static
            _super = Parent.template;
            if (!_super || _super === templateDecorator) {
                _super = Parent.prototype.template;
            }
        } else {
            // is define by prototype
            _super = Parent.constructor.template;
            if (!_super || _super === templateDecorator) {
                _super = Parent.template;
            }
        }
        template._super = _super;

        if (typeof target === 'function') {
            // for: static template = ''
            target.template = template;
            return template;
        } else {
            // for: get template() { }
            descriptor.get = function () {
                return template;
            };
            // remove static template. Maybe it inherited from parent
            target.constructor.template = undefined;
        }
    };
}

var nativeCreate = Object.create;
var create = exports.create = nativeCreate ? nativeCreate : function (object) {
    var fn = function fn() {};
    fn.prototype = object;
    return new fn();
};

function isFunction(obj) {
    return typeof obj === 'function';
}

function isString(s) {
    return typeof s === 'string';
}

function result(obj, property, fallback) {
    var value = (0, _utils2.isNullOrUndefined)(obj) ? undefined : obj[property];
    if (value === undefined) {
        value = fallback;
    }
    return isFunction(value) ? value.call(obj) : value;
}

var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = create(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if ((0, _utils.isObject)(result)) return result;
    return self;
};
var nativeBind = Function.prototype.bind;
function bind(func, context) {
    for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
    }

    if (nativeBind && func.bind === nativeBind) {
        return nativeBind.call.apply(nativeBind, [func, context].concat(args));
    }
    if (!isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = function bound() {
        for (var _len5 = arguments.length, args1 = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args1[_key5] = arguments[_key5];
        }

        return executeBound(func, bound, context, this, [].concat(args, args1));
    };
    return bound;
}

var toString = Object.prototype.toString;
// Internal recursive comparison function for `isEqual`.
var eq = function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if ((0, _utils2.isNullOrUndefined)(a) || (0, _utils2.isNullOrUndefined)(b)) return a === b;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor,
            bCtor = b.constructor;
        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
            return false;
        }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
            if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
    } else {
        // Deep compare objects.
        var aKeys = keys(a),
            key;
        length = aKeys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (keys(b).length !== length) return false;
        while (length--) {
            // Deep compare each member
            key = aKeys[length];
            if (!(_utils.hasOwn.call(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
};

function isEqual(a, b) {
    return eq(a, b);
}

var idCounter = 0;
function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
}

var keys = exports.keys = Object.keys || function (obj) {
    var ret = [];
    (0, _utils.each)(obj, function (value, key) {
        return ret.push(key);
    });
    return ret;
};

function values(obj) {
    var ret = [];
    (0, _utils.each)(obj, function (value) {
        return ret.push(value);
    });
    return ret;
}

var pathMap = {},
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    reEscapeChar = /\\(\\)?/g,
    reIsUint = /^(?:0|[1-9]\d*)$/;
function castPath(path) {
    if (typeof path !== 'string') return path;
    if (pathMap[path]) return pathMap[path];

    var ret = [];
    if (reLeadingDot.test(path)) {
        result.push('');
    }
    path.replace(rePropName, function (match, number, quote, string) {
        ret.push(quote ? path.replace(reEscapeChar, '$1') : number || match);
    });
    pathMap[path] = ret;

    return ret;
}
function isIndex(value) {
    return (typeof value === 'number' || reIsUint.test(value)) && value > -1 && value % 1 === 0;
}
function get(object, path, defaultValue) {
    if (_utils.hasOwn.call(object, path)) return object[path];
    path = castPath(path);

    var index = 0,
        length = path.length;

    while (!(0, _utils2.isNullOrUndefined)(object) && index < length) {
        object = object[path[index++]];
    }

    return index && index === length && object !== undefined ? object : defaultValue;
}
function set(object, path, value) {
    if (_utils.hasOwn.call(object, path)) {
        object[path] = value;
        return object;
    }

    path = castPath(path);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;
    while (!(0, _utils2.isNullOrUndefined)(nested) && ++index < length) {
        var key = path[index],
            newValue = value;
        if (index !== lastIndex) {
            var objValue = nested[key];
            newValue = (0, _utils.isObject)(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
        nested[key] = newValue;
        nested = nested[key];
    }

    return object;
}

var hasConsole = typeof console !== 'undefined';
var warn = exports.warn = hasConsole ? function () {
    console.warn.apply(console, arguments);
} : _utils.noop;
var error = exports.error = hasConsole ? function () {
    console.error.apply(console, arguments);
} : _utils.noop;

function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}
var nextTick = function () {
    if (typeof Promise !== 'undefined' && isNative(Promise)) {
        var p = Promise.resolve();
        return function (callback) {
            p.then(callback)['catch'](function (err) {
                return error(err);
            });
            // description in vue
            if (isIOS) setTimeout(_utils.noop);
        };
    } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]')) {
        var callbacks = [];
        var nextTickHandler = function nextTickHandler() {
            var _callbacks = callbacks.slice(0);
            callbacks.length = 0;
            for (var _i = 0; _i < _callbacks.length; _i++) {
                _callbacks[_i]();
            }
        };
        var node = document.createTextNode('');
        new MutationObserver(nextTickHandler).observe(node, {
            characterData: true
        });
        var i = 1;
        return function (callback) {
            callbacks.push(callback);
            i = (i + 1) % 2;
            node.data = String(i);
        };
    } else {
        return function (callback) {
            setTimeout(callback, 0);
        };
    }
}();
function NextTick(eachCallback) {
    var _this = this;

    this.callback = null;
    this.eachCallback = eachCallback;
    nextTick(function () {
        return _this.callback();
    });
}
NextTick.prototype.fire = function (callback, data) {
    this.callback = callback;
    if (this.eachCallback) {
        this.eachCallback(data);
    }
};

var wontBind = ['constructor', 'template', 'defaults'];
if (typeof Object.getPrototypeOf !== "function") {
    if (_typeof("".__proto__) === "object") {
        Object.getPrototypeOf = function (object) {
            return object.__proto__;
        };
    } else {
        Object.getPrototypeOf = function (object) {
            // May break if the constructor has been tampered with
            return object.constructor.prototype;
        };
    }
}

if (typeof Object.getOwnPropertyNames !== 'function') {
    Object.getOwnPropertyNames = keys;
}

function autobind(prototype, context, Intact, bound) {
    if (!prototype) return;
    if (prototype === Intact.prototype) return;

    var toBind = Object.getOwnPropertyNames(prototype);
    (0, _utils.each)(toBind, function (method) {
        var fn = prototype[method];
        if (fn === undefined) {
            // warn(`Autobind: '${method}' method not found in class.`);
            return;
        }

        if (~(0, _utils2.indexOf)(wontBind, method) || bound[method] || typeof fn !== 'function') {
            return;
        }

        context[method] = bind(fn, context);
        bound[method] = true;
    });

    // bind super method
    autobind(Object.getPrototypeOf(prototype), context, Intact, bound);
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.processForm = processForm;

var _select = __webpack_require__(21);

var _input = __webpack_require__(22);

var _textarea = __webpack_require__(23);

var _vnode = __webpack_require__(1);

function processForm(vNode, dom, nextProps, isRender) {
    var type = vNode.type;
    if (type & _vnode.Types.InputElement) {
        (0, _input.processInput)(vNode, dom, nextProps, isRender);
    } else if (type & _vnode.Types.TextareaElement) {
        (0, _textarea.processTextarea)(vNode, dom, nextProps, isRender);
    } else if (type & _vnode.Types.SelectElement) {
        (0, _select.processSelect)(vNode, dom, nextProps, isRender);
    }
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;

var _intact = __webpack_require__(11);

var _intact2 = _interopRequireDefault(_intact);

var _vdt = __webpack_require__(3);

var _vdt2 = _interopRequireDefault(_vdt);

var _animate = __webpack_require__(26);

var _animate2 = _interopRequireDefault(_animate);

var _utils = __webpack_require__(6);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_intact2['default'].prototype.Animate = _animate2['default'];
_intact2['default'].Animate = _animate2['default'];
_intact2['default'].Vdt = _vdt2['default'];
_intact2['default'].utils = utils;
_vdt2['default'].configure({
    getModel: function getModel(self, key) {
        return self.get(key);
    },
    setModel: function setModel(self, key, value) {
        // self.set(key, value, {async: true});
        self.set(key, value);
    }
});

exports['default'] = _intact2['default'];
module.exports = exports['default'];

/***/ }),
/* 9 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(31);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = Intact;

var _utils = __webpack_require__(6);

var _vdt = __webpack_require__(3);

var _vdt2 = _interopRequireDefault(_vdt);

var _misstime = __webpack_require__(12);

var _vdom = __webpack_require__(5);

var _vnode = __webpack_require__(1);

var _utils2 = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function Intact(props) {
    var _this = this;

    var template = this.constructor.template;
    // Intact.template is a decorator
    if (!template || template === _utils.templateDecorator) {
        template = this.template;
    }
    if (!template) {
        throw new Error('Can not instantiate when template does not exist.');
    }

    (0, _utils.autobind)(Object.getPrototypeOf(this), this, Intact, {});

    props = (0, _utils.extend)({}, (0, _utils.result)(this, 'defaults'), props);

    this._events = {};
    this.props = {};
    this.vdt = (0, _vdt2['default'])(template);
    this.set(props, { silent: true });
    // this._patchProps(null, props, {silent: true});

    // for compatibility v1.0
    this.widgets = this.vdt.widgets || {};
    this._widget = this.props.widget || (0, _utils.uniqueId)('widget');
    this.attributes = this.props;

    // for string ref
    this.refs = this.widgets;

    this.uniqueId = this._widget;

    this.inited = false;
    this.rendered = false;
    this.mounted = false;
    this.destroyed = false;

    // if the flag is false, every set operation will not lead to update 
    this._startRender = false;

    // for debug
    this.displayName = this.displayName;

    // bind events
    (0, _utils.each)(this.props, function (value, key) {
        if ((0, _utils2.isEventProp)(key) && (0, _utils.isFunction)(value)) {
            _this.on(key.substr(3), value);
        }
    });

    this._updateCount = 0;

    var inited = function inited() {
        _this.inited = true;
        _this.trigger('$inited', _this);
    };
    var ret = this._init();
    if (ret && ret.then) {
        ret.then(inited, function (err) {
            (0, _utils.error)('Unhandled promise rejection in _init: ', err);
            inited();
        });
    } else {
        inited();
    }
}

Intact.prototype = {
    constructor: Intact,

    defaults: function defaults() {},
    _init: function _init(props) {},
    _create: function _create(lastVNode, nextVNode) {},
    _mount: function _mount(lastVNode, nextVNode) {},
    _beforeUpdate: function _beforeUpdate(lastVNode, nextVNode) {},
    _update: function _update(lastVNode, nextVNode) {},
    _destroy: function _destroy(lastVNode, nextVNode, parentDom) {},
    hydrate: function hydrate(vNode, dom) {
        var _this2 = this;

        var vdt = this.vdt;
        if (!this.inited) {
            this.one('$inited', function () {
                var element = _this2.hydrate(vNode, dom);
                if (dom !== element) {
                    vNode.dom = element;
                }
                _this2._triggerMountedQueue();
                _this2.mount(null, vNode);
            });

            return dom;
        }

        this._startRender = true;
        this.element = vdt.hydrate(this, dom, this.mountedQueue, this.parentDom, vNode, this.isSVG, this.get('_blocks'));
        this.rendered = true;
        this.trigger('$rendered', this);
        this._create(null, vNode);

        return this.element;
    },
    init: function init(lastVNode, nextVNode) {
        var _this3 = this;

        var vdt = this.vdt;
        this._lastVNode = lastVNode;
        if (!this.inited) {
            // 支持异步组件
            var placeholder = void 0;
            if (lastVNode) {
                placeholder = lastVNode.dom;
                var lastInstance = lastVNode.children;
                vdt.vNode = lastInstance.vdt.vNode;
                // 如果上一个组件是异步组件，并且也还没渲染完成，则直接destroy掉
                // 让它不再渲染了
                if (!lastInstance.inited) {
                    (0, _vdom.removeComponentClassOrInstance)(lastVNode, null, nextVNode);
                }
            } else {
                var vNode = (0, _misstime.hc)('!');
                placeholder = (0, _misstime.render)(vNode);
                vdt.vNode = vNode;
            }
            // 组件销毁事件也会解绑，所以这里无需判断组件是否销毁了
            this.one('$inited', function () {
                var element = _this3.init(lastVNode, nextVNode);
                var dom = nextVNode.dom;
                // 存在一种情况，组件的第一个元素是一个组件，他们管理的是同一个dom
                // 但是当第一个元素的dom变更时，父组件的vNode却没有变
                // 所以这里强制保持一致
                nextVNode.dom = element;
                if (!lastVNode || lastVNode.key !== nextVNode.key) {
                    dom.parentNode.replaceChild(element, dom);
                }
                _this3._triggerMountedQueue();
                _this3.mount(lastVNode, nextVNode);
            });
            vdt.node = placeholder;
            return placeholder;
        }

        this._startRender = true;
        // 如果key不相同，则不复用dom，直接返回新dom来替换
        if (lastVNode && lastVNode.key === nextVNode.key) {
            // destroy the last component
            if (!lastVNode.children.destroyed) {
                (0, _vdom.removeComponentClassOrInstance)(lastVNode, null, nextVNode);
            }

            // make the dom not be replaced, but update the last one
            vdt.vNode = lastVNode.children.vdt.vNode;
            this.element = vdt.update(this, this.parentDom, this.mountedQueue, nextVNode, this.isSVG, this.get('_blocks'));
        } else {
            if (lastVNode) {
                (0, _vdom.removeComponentClassOrInstance)(lastVNode, null, nextVNode);
            }
            this.element = vdt.render(this, this.parentDom, this.mountedQueue, nextVNode, this.isSVG, this.get('_blocks'));
        }
        this.rendered = true;
        if (this._pendingUpdate) {
            this._pendingUpdate(lastVNode, nextVNode);
            this._pendingUpdate = null;
        }
        this.trigger('$rendered', this);
        this._create(lastVNode, nextVNode);

        return this.element;
    },
    toString: function toString() {
        return this.vdt.renderString(this, this.get('_blocks'));
    },
    mount: function mount(lastVNode, nextVNode) {
        // 异步组件，直接返回
        if (!this.inited) return;
        this.mounted = true;
        this.trigger('$mounted', this);
        this._mount(lastVNode, nextVNode);
    },
    update: function update(lastVNode, nextVNode, fromPending) {
        // 如果该组件已被销毁，则不更新
        // 组件的销毁顺序是从自下而上逐步销毁的，对于子组件，即使将要销毁也要更新
        // 只有父组件被销毁了才不去更新，父组件的更新是没有vNode参数
        if (!lastVNode && !nextVNode && this.destroyed) {
            return lastVNode ? lastVNode.dom : undefined;
        }
        // 如果还没有渲染，则等待结束再去更新
        if (!this.rendered) {
            this._pendingUpdate = function (lastVNode, nextVNode) {
                this.update(lastVNode, nextVNode, true);
            };
            return lastVNode ? lastVNode.dom : undefined;
        }

        if (!nextVNode && !fromPending && this._updateCount === 0) {
            // 如果直接调用update方法，则要清除mountedQueue
            // 如果在render的过程中，又触发了update，则此时
            // 不能清空
            this.mountedQueue = null;
        }

        // 如果不存在nextVNode，则为直接调用update方法更新自己
        // 否则则是父组件触发的子组件更新，此时需要更新一些状态
        // 有一种情况，在父组件初次渲染时，子组件渲染过程中，
        // 又触发了父组件的数据变更，此时父组件渲染完成执行_pendingUpdate
        // 是没有lastVNode的
        if (nextVNode && lastVNode) {
            this._patchProps(lastVNode.props, nextVNode.props);
        }

        ++this._updateCount;
        if (this._updateCount > 1) return this.element;
        if (this._updateCount === 1) return this.__update(lastVNode, nextVNode);
    },
    __update: function __update(lastVNode, nextVNode) {
        var _this4 = this;

        this._beforeUpdate(lastVNode, nextVNode);
        // 直接调用update方法，保持parentVNode不变
        this.element = this.vdt.update(this, this.parentDom, this.mountedQueue, nextVNode || this.vNode, this.isSVG, this.get('_blocks'));
        // 让整个更新完成，才去触发_update生命周期函数
        if (this.mountedQueue) {
            this.mountedQueue.push(function () {
                _this4._update(lastVNode, nextVNode);
            });
        } else {
            this._update(lastVNode, nextVNode);
        }
        if (--this._updateCount > 0) {
            // 如果更新完成，发现还有更新，则是在更新过程中又触发了更新
            // 此时直接将_updateCount置为1，因为所有数据都已更新，只做最后一次模板更新即可
            // --this._updateCount会将该值设为0，所以这里设为1
            this._updateCount = 1;
            return this.__update();
        }

        return this.element;
    },
    _patchProps: function _patchProps(lastProps, nextProps) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { update: false, _fromPatchProps: true };

        lastProps = lastProps || _vnode.EMPTY_OBJ;
        nextProps = nextProps || _vnode.EMPTY_OBJ;
        var lastValue = void 0;
        var nextValue = void 0;
        if (lastProps !== nextProps) {
            // 需要先处理事件，因为prop变更可能触发相应的事件
            var lastPropsWithoutEvents = void 0;
            var nextPropsWithoutEvents = void 0;
            if (nextProps !== _vnode.EMPTY_OBJ) {
                for (var prop in nextProps) {
                    nextValue = nextProps[prop];
                    if ((0, _utils2.isEventProp)(prop)) {
                        this.set(prop, nextValue, { silent: true });
                        lastValue = lastProps[prop];
                        if ((0, _utils.isFunction)(nextValue)) {
                            // 更换事件监听函数
                            var eventName = prop.substr(3);
                            if ((0, _utils.isFunction)(lastValue)) {
                                this.off(eventName, lastValue);
                            }
                            this.on(eventName, nextValue);
                        } else if ((0, _utils.isFunction)(lastValue)) {
                            // 解绑事件监听函数
                            this.off(prop.substr(3), lastValue);
                        }
                    } else {
                        if (!nextPropsWithoutEvents) {
                            nextPropsWithoutEvents = {};
                        }
                        nextPropsWithoutEvents[prop] = nextValue;
                    }
                }
                if (lastProps !== _vnode.EMPTY_OBJ) {
                    for (var _prop in lastProps) {
                        if (!_utils.hasOwn.call(nextProps, _prop)) {
                            lastValue = lastProps[_prop];
                            if ((0, _utils2.isEventProp)(_prop) && (0, _utils.isFunction)(lastValue)) {
                                this.set(_prop, undefined, { silent: true });
                                // 如果是事件，则要解绑事件
                                this.off(_prop.substr(3), lastValue);
                            } else {
                                if (!lastPropsWithoutEvents) {
                                    lastPropsWithoutEvents = {};
                                }
                                lastPropsWithoutEvents[_prop] = lastValue;
                            }
                        }
                    }
                }

                if (nextPropsWithoutEvents) {
                    this.set(nextPropsWithoutEvents, options);
                }
            } else {
                for (var _prop2 in lastProps) {
                    lastValue = lastProps[_prop2];
                    if ((0, _utils2.isEventProp)(_prop2) && (0, _utils.isFunction)(lastValue)) {
                        this.set(_prop2, undefined, { silent: true });
                        // 如果是事件，则要解绑事件
                        this.off(_prop2.substr(3), lastValue);
                    } else {
                        if (!lastPropsWithoutEvents) {
                            lastPropsWithoutEvents = {};
                        }
                        lastPropsWithoutEvents[_prop2] = lastValue;
                    }
                }
            }

            // 将不存在nextProps中，但存在lastProps中的属性，统统置为默认值
            var defaults = (0, _utils.result)(this, 'defaults') || _vnode.EMPTY_OBJ;
            if (lastPropsWithoutEvents) {
                for (var _prop3 in lastPropsWithoutEvents) {
                    this.set(_prop3, defaults[_prop3], options);
                }
            }
        }
    },
    destroy: function destroy(lastVNode, nextVNode, parentDom) {
        if (this.destroyed) {
            return (0, _utils.warn)('destroyed multiple times');
        }
        var vdt = this.vdt;
        // 异步组件，可能还没有渲染
        if (!this.rendered) {
            // 异步组件，只有开始渲染时才销毁上一个组件
            // 如果没有渲染当前异步组件就被销毁了，则要
            // 在这里销毁上一个组件
            var _lastVNode = this._lastVNode;
            if (_lastVNode && !_lastVNode.children.destroyed) {
                (0, _vdom.removeComponentClassOrInstance)(_lastVNode, null, lastVNode);
            }
        } else if (!nextVNode || !(nextVNode.type & _vnode.Types.ComponentClassOrInstance) || nextVNode.key !== lastVNode.key) {
            vdt.destroy();
        }
        // 如果存在nextVNode，并且nextVNode也是一个组件类型，
        // 并且，它俩的key相等，则不去destroy，而是在下一个组件init时
        // 复用上一个dom，然后destroy上一个元素
        this._destroy(lastVNode, nextVNode);
        this.destroyed = true;
        this.trigger('$destroyed', this);
        this.off();
    },


    // function name conflict with utils.get
    get: function _get(key, defaultValue) {
        if (key === undefined) return this.props;

        return (0, _utils.get)(this.props, key, defaultValue);
    },

    set: function _set(key, val, options) {
        var _this5 = this;

        if ((0, _utils2.isNullOrUndefined)(key)) return this;

        var isSetByObject = false;
        if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
            options = val;
            isSetByObject = true;
        }
        options = (0, _utils.extend)({
            silent: false,
            update: true,
            async: false,
            _fromPatchProps: false
        }, options);
        // 兼容老版本
        if (_utils.hasOwn.call(options, 'global')) {
            options.update = options.global;
        }

        var props = this.props;
        var changes = {};

        var hasChanged = false;

        // 前面做了undefined的判断，这里不可能为undefined了
        if (isSetByObject) {
            if (!options.silent) {
                for (var prop in key) {
                    var nextValue = key[prop];
                    var lastValue = props[prop];
                    if (!(0, _utils.isEqual)(lastValue, nextValue)) {
                        changes[prop] = [lastValue, nextValue];
                        hasChanged = true;
                    }
                    // 即使相等，也要重新复制，因为有可能引用地址变更
                    props[prop] = nextValue;
                }
            } else {
                // 如果静默更新，则直接赋值
                (0, _utils.extend)(props, key);
            }
        } else {
            if (!options.silent) {
                var _lastValue2 = (0, _utils.get)(props, key);
                if (!(0, _utils.isEqual)(_lastValue2, val)) {
                    if (!_utils.hasOwn.call(props, key)) {
                        changes[key] = [_lastValue2, val];
                        var path = (0, _utils.castPath)(key);
                        // 如果是像'a.b.c'这样设置属性，而该属性不存在
                        // 依次触发change:a.b.c、change:a.b、change:a这样的事件
                        // 先不设置props，去取老值
                        var _props = [];
                        for (var i = path.length - 1; i > 0; i--) {
                            var _prop4 = path.slice(0, i).join('.');
                            var _lastValue = (0, _utils.get)(props, _prop4);
                            changes[_prop4] = [_lastValue];
                            _props.push(_prop4);
                        }
                        // 设置props后，去取新值
                        // 对于引用数据类型，新老值可能一样
                        (0, _utils.set)(props, key, val);
                        for (var _i = 0; _i < _props.length; _i++) {
                            var _prop5 = _props[_i];
                            changes[_prop5].push((0, _utils.get)(props, _prop5));
                        }
                    } else {
                        // 否则，只触发change:a.b.c
                        changes[key] = [_lastValue2, val];
                        (0, _utils.set)(props, key, val);
                    }

                    hasChanged = true;
                } else {
                    (0, _utils.set)(props, key, val);
                }
            } else {
                (0, _utils.set)(props, key, val);
            }
        }

        if (hasChanged) {
            for (var _prop6 in changes) {
                var values = changes[_prop6];
                if (options._fromPatchProps) {
                    // trigger a $receive event to show that we received a different prop
                    this.trigger('$receive:' + _prop6, this, values[1], values[0]);
                }
                // trigger `change*` events
                this.trigger('$change:' + _prop6, this, values[1], values[0]);
            }
            var changeKeys = (0, _utils.keys)(changes);

            this.trigger('$change', this, changeKeys);

            if (options.update && this._startRender) {
                var triggerChange = function triggerChange(changes, changeKeys) {
                    _this5.update();
                    _this5._triggerChangedEvent(changes, changeKeys);
                };
                if (options.async) {
                    if (!this._$nextTick) {
                        this._$nextTick = new _utils.NextTick(function (data) {
                            // 将每次改变的属性放入数组
                            this.args.push(data);
                        });
                        this._$nextTick.args = [];
                    }
                    var self = this;
                    this._$nextTick.fire(function () {
                        // 合并执行更新后，触发所有$changed事件
                        var args = this.args;
                        var changes = {};
                        for (var _i2 = 0; _i2 < args.length; _i2++) {
                            (0, _utils.extend)(changes, args[_i2]);
                        }
                        self._$nextTick = null;
                        triggerChange(changes, (0, _utils.keys)(changes));
                    }, changes);
                } else {
                    triggerChange(changes, changeKeys);
                }
            } else if (this.mountedQueue && this._startRender) {
                // 如果是父组件导致子组件更新，此时存在mountedQueue
                // 则在组件数更新完毕，触发$changed事件
                this.mountedQueue.push(function () {
                    _this5._triggerChangedEvent(changes, changeKeys);
                });
            }
        }

        return this;
    },

    on: function on(name, callback) {
        (this._events[name] || (this._events[name] = [])).push(callback);

        return this;
    },
    one: function one(name, callback) {
        var _this6 = this;

        var fn = function fn() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            callback.apply(_this6, args);
            _this6.off(name, fn);
        };
        this.on(name, fn);

        return this;
    },
    off: function off(name, callback) {
        if (name === undefined) {
            this._events = {};
            return this;
        }

        var callbacks = this._events[name];
        if (!callbacks) return this;

        if (callback === undefined) {
            delete this._events[name];
            return this;
        }

        for (var cb, i = 0; i < callbacks.length; i++) {
            cb = callbacks[i];
            if (cb === callback) {
                callbacks.splice(i, 1);
                i--;
            }
        }

        return this;
    },
    trigger: function trigger(name) {
        var callbacks = this._events[name];

        if (callbacks) {
            callbacks = callbacks.slice();

            for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
            }

            for (var i = 0, l = callbacks.length; i < l; i++) {
                callbacks[i].apply(this, args);
            }
        }

        return this;
    },
    _initMountedQueue: function _initMountedQueue() {
        this.mountedQueue = new _utils2.MountedQueue();
    },
    _triggerMountedQueue: function _triggerMountedQueue() {
        this.mountedQueue.trigger();
    },
    _triggerChangedEvent: function _triggerChangedEvent(changes, changeKeys) {
        for (var prop in changes) {
            var values = changes[prop];
            this.trigger('$changed:' + prop, this, values[1], values[0]);
        }
        this.trigger('$changed', this, changeKeys);
    }
};

/**
 * @brief 继承某个组件
 *
 * @param prototype
 */
Intact.extend = function () {
    var prototype = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (_typeof(this.prototype.defaults) === 'object' && _typeof(prototype.defaults) === 'object') {
        prototype.defaults = (0, _utils.extend)({}, this.prototype.defaults, prototype.defaults);
    }
    return (0, _utils.inherit)(this, prototype);
};

/**
 * 挂载组件到dom中
 * @param Component {Intact} Intact类或子类
 * @param node {Node} html节点
 */
Intact.mount = function (Component, node) {
    if (!node) throw new Error('expect a parent dom to mount Component, but got ' + node);
    var vNode = (0, _misstime.h)(Component);
    var mountedQueue = new _utils2.MountedQueue();
    (0, _misstime.render)(vNode, node, mountedQueue);
    var instance = vNode.children;
    // 如果不是异步组件，则触发mount事件，否则
    // 交给组件的init方法，等异步处理完成后触发
    if (instance.inited) {
        mountedQueue.trigger();
    }
    return instance;
};

Intact.hydrate = function (Component, node) {
    if (!node) throw new Error('expect a parent dom to hydrate Component, but got ' + node);
    var vNode = (0, _misstime.h)(Component);
    (0, _misstime.hydrateRoot)(vNode, node);
    return vNode.children;
};

// ES7 Decorator for template
if (Object.defineProperty) {
    Object.defineProperty(Intact, 'template', {
        configurable: false,
        enumerable: false,
        value: _utils.templateDecorator,
        writable: true
    });
}
module.exports = exports['default'];

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.Types = exports.hydrate = exports.hydrateRoot = exports.renderString = exports.MountedQueue = exports.remove = exports.hu = exports.hc = exports.render = exports.patch = exports.h = undefined;

var _vnode = __webpack_require__(1);

var _vpatch = __webpack_require__(4);

var _vdom = __webpack_require__(5);

var _utils = __webpack_require__(0);

var _tostring = __webpack_require__(24);

var _hydration = __webpack_require__(25);

exports.h = _vnode.createVNode;
exports.patch = _vpatch.patch;
exports.render = _vdom.render;
exports.hc = _vnode.createCommentVNode;
exports.hu = _vnode.createUnescapeTextVNode;
exports.remove = _vdom.removeElement;
exports.MountedQueue = _utils.MountedQueue;
exports.renderString = _tostring.toString;
exports.hydrateRoot = _hydration.hydrateRoot;
exports.hydrate = _hydration.hydrate;
exports.Types = _vnode.Types;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.handleEvent = handleEvent;

var _utils = __webpack_require__(0);

var ALL_PROPS = ["altKey", "bubbles", "cancelable", "ctrlKey", "eventPhase", "metaKey", "relatedTarget", "shiftKey", "target", "timeStamp", "type", "view", "which"];
var KEY_PROPS = ["char", "charCode", "key", "keyCode"];
var MOUSE_PROPS = ["button", "buttons", "clientX", "clientY", "layerX", "layerY", "offsetX", "offsetY", "pageX", "pageY", "screenX", "screenY", "toElement"];

var rkeyEvent = /^key|input/;
var rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/;

function Event(e) {
    for (var i = 0; i < ALL_PROPS.length; i++) {
        var propKey = ALL_PROPS[i];
        this[propKey] = e[propKey];
    }

    if (!e.target) {
        this.target = e.srcElement;
    }

    this._rawEvent = e;
}
Event.prototype.preventDefault = function () {
    var e = this._rawEvent;
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
};
Event.prototype.stopPropagation = function () {
    var e = this._rawEvent;
    e.cancelBubble = true;
    e.stopImmediatePropagation && e.stopImmediatePropagation();
};

function MouseEvent(e) {
    Event.call(this, e);
    for (var j = 0; j < MOUSE_PROPS.length; j++) {
        var mousePropKey = MOUSE_PROPS[j];
        this[mousePropKey] = e[mousePropKey];
    }
}
MouseEvent.prototype = (0, _utils.createObject)(Event.prototype);
MouseEvent.prototype.constructor = MouseEvent;

function KeyEvent(e) {
    Event.call(this, e);
    for (var j = 0; j < KEY_PROPS.length; j++) {
        var keyPropKey = KEY_PROPS[j];
        this[keyPropKey] = e[keyPropKey];
    }
}
KeyEvent.prototype = (0, _utils.createObject)(Event.prototype);
KeyEvent.prototype.constructor = KeyEvent;

function proxyEvent(e) {
    if (rkeyEvent.test(e.type)) {
        return new KeyEvent(e);
    } else if (rmouseEvent.test(e.type)) {
        return new MouseEvent(e);
    } else {
        return new Event(e);
    }
}

var addEventListener = void 0;
var removeEventListener = void 0;
if ('addEventListener' in _utils.doc) {
    addEventListener = function addEventListener(dom, name, fn) {
        dom.addEventListener(name, fn, false);
    };

    removeEventListener = function removeEventListener(dom, name, fn) {
        dom.removeEventListener(name, fn);
    };
} else {
    addEventListener = function addEventListener(dom, name, fn) {
        fn.cb = function (e) {
            e = proxyEvent(e);
            fn(e);
        };
        dom.attachEvent("on" + name, fn.cb);
    };

    removeEventListener = function removeEventListener(dom, name, fn) {
        dom.detachEvent("on" + name, fn.cb || fn);
    };
}

var delegatedEvents = {};
var unDelegatesEvents = {
    'mouseenter': true,
    'mouseleave': true,
    'propertychange': true,
    'scroll': true
};

// change event can not be deletegated in IE8 
if (_utils.browser.isIE8) {
    unDelegatesEvents.change = true;
}

function handleEvent(name, lastEvent, nextEvent, dom) {
    if (name === 'blur') {
        name = 'focusout';
    } else if (name === 'focus') {
        name = 'focusin';
    } else if (_utils.browser.isIE8 && name === 'input') {
        name = 'propertychange';
    }

    if (!unDelegatesEvents[name]) {
        var delegatedRoots = delegatedEvents[name];

        if (nextEvent) {
            if (!delegatedRoots) {
                delegatedRoots = { items: new _utils.SimpleMap(), docEvent: null };
                delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);
                delegatedEvents[name] = delegatedRoots;
            }
            delegatedRoots.items.set(dom, nextEvent);
        } else if (delegatedRoots) {
            var items = delegatedRoots.items;
            if (items["delete"](dom)) {
                if (items.size === 0) {
                    removeEventListener(_utils.doc, name, delegatedRoots.docEvent);
                    delete delegatedRoots[name];
                }
            }
        }
    } else {
        if (lastEvent) {
            removeEventListener(dom, name, lastEvent);
        }
        if (nextEvent) {
            addEventListener(dom, name, nextEvent);
        }
    }
}

function dispatchEvent(event, target, items, count, isClick) {
    var eventToTrigger = items.get(target);
    if (eventToTrigger) {
        count--;
        event.currentTarget = target;
        eventToTrigger(event);
        if (event._rawEvent.cancelBubble) {
            return;
        }
    }
    if (count > 0) {
        var parentDom = target.parentNode;
        if ((0, _utils.isNullOrUndefined)(parentDom) || isClick && parentDom.nodeType === 1 && parentDom.disabled) {
            return;
        }
        dispatchEvent(event, parentDom, items, count, isClick);
    }
}

function attachEventToDocument(name, delegatedRoots) {
    var docEvent = function docEvent(event) {
        var count = delegatedRoots.items.size;
        event || (event = window.event);
        if (count > 0) {
            event = proxyEvent(event);
            dispatchEvent(event, event.target, delegatedRoots.items, count, event.type === 'click');
        }
    };
    addEventListener(_utils.doc, name, docEvent);
    return docEvent;
}

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
(function (global, factory) {

	"use strict";

	if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : undefined, function (window, noGlobal) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var _slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call(Object);

	var support = {};

	function DOMEval(code, doc) {
		doc = doc || document;

		var script = doc.createElement("script");

		script.text = code;
		doc.head.appendChild(script).parentNode.removeChild(script);
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module


	var version = "3.2.1",


	// Define a local copy of jQuery
	jQuery = function jQuery(selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([a-z])/g,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function fcamelCase(all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function toArray() {
			return _slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function get(num) {

			// Return all the elements in a clean array
			if (num == null) {
				return _slice.call(this);
			}

			// Return just the one element from the set
			return num < 0 ? this[num + this.length] : this[num];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function pushStack(elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function each(callback) {
			return jQuery.each(this, callback);
		},

		map: function map(callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function slice() {
			return this.pushStack(_slice.apply(this, arguments));
		},

		first: function first() {
			return this.eq(0);
		},

		last: function last() {
			return this.eq(-1);
		},

		eq: function eq(i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function end() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function error(msg) {
			throw new Error(msg);
		},

		noop: function noop() {},

		isFunction: function isFunction(obj) {
			return jQuery.type(obj) === "function";
		},

		isWindow: function isWindow(obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function isNumeric(obj) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type(obj);
			return (type === "number" || type === "string") &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN(obj - parseFloat(obj));
		},

		isPlainObject: function isPlainObject(obj) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if (!obj || toString.call(obj) !== "[object Object]") {
				return false;
			}

			proto = getProto(obj);

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if (!proto) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
			return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
		},

		isEmptyObject: function isEmptyObject(obj) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function type(obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
		},

		// Evaluates a script in a global context
		globalEval: function globalEval(code) {
			DOMEval(code);
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function camelCase(string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		each: function each(obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function trim(text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function makeArray(arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function inArray(elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function merge(first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function grep(elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function map(elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function proxy(fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = _slice.call(arguments, 2);
			proxy = function proxy() {
				return fn.apply(context || this, args.concat(_slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.3.3
  * https://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2016-08-08
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function sortOrder(a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function indexOf(list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,


		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function funescape(_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		    fcssescape = function fcssescape(ch, asCodePoint) {
			if (asCodePoint) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if (ch === "\0") {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function unloadHandler() {
			setDocument();
		},
		    disabledAncestor = addCombinator(function (elem) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		}, { dir: "parentNode", next: "legend" });

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rcssescape, fcssescape);
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							while (i--) {
								groups[i] = "#" + nid + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
		function assert(fn) {
			var el = document.createElement("fieldset");

			try {
				return !!fn(el);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (el.parentNode) {
					el.parentNode.removeChild(el);
				}
				// release memory in IE
				el = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
		function createDisabledPseudo(disabled) {

			// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
			return function (elem) {

				// Only certain elements can match :enabled or :disabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
				if ("form" in elem) {

					// Check for inherited disabledness on relevant non-disabled elements:
					// * listed form-associated elements in a disabled fieldset
					//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
					// * option elements in a disabled optgroup
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
					// All such elements have a "form" property.
					if (elem.parentNode && elem.disabled === false) {

						// Option elements defer to a parent optgroup if present
						if ("label" in elem) {
							if ("label" in elem.parentNode) {
								return elem.parentNode.disabled === disabled;
							} else {
								return elem.disabled === disabled;
							}
						}

						// Support: IE 6 - 11
						// Use the isDisabled shortcut property to check for disabled fieldset ancestors
						return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
					}

					return elem.disabled === disabled;

					// Try to winnow out elements that can't be disabled before trusting the disabled property.
					// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
					// even exist on them, let alone have a boolean value.
				} else if ("label" in elem) {
					return elem.disabled === disabled;
				}

				// Remaining elements are neither :enabled nor :disabled
				return false;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    subWindow,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {

				// Support: IE 11, Edge
				if (subWindow.addEventListener) {
					subWindow.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (subWindow.attachEvent) {
					subWindow.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (el) {
				el.className = "i";
				return !el.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (el) {
				el.appendChild(document.createComment(""));
				return !el.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programmatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (el) {
				docElem.appendChild(el).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID filter and find
			if (support.getById) {
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var elem = context.getElementById(id);
						return elem ? [elem] : [];
					}
				};
			} else {
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};

				// Support: IE 6 - 7 only
				// getElementById is not reliable as a find shortcut
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var node,
						    i,
						    elems,
						    elem = context.getElementById(id);

						if (elem) {

							// Verify the id attribute
							node = elem.getAttributeNode("id");
							if (node && node.value === id) {
								return [elem];
							}

							// Fall back on getElementsByName
							elems = context.getElementsByName(id);
							i = 0;
							while (elem = elems[i++]) {
								node = elem.getAttributeNode("id");
								if (node && node.value === id) {
									return [elem];
								}
							}
						}

						return [];
					}
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See https://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (el) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// https://bugs.jquery.com/ticket/12359
					docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (el.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!el.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!el.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibling-combinator selector` fails
					if (!el.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (el) {
					el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";

					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					el.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (el.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (el.querySelectorAll(":enabled").length !== 2) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Support: IE9-11+
					// IE's :disabled selector does not pick up the children of disabled fieldsets
					docElem.appendChild(el).disabled = true;
					if (el.querySelectorAll(":disabled").length !== 2) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					el.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (el) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(el, "*");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(el, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.escape = function (sel) {
			return (sel + "").replace(rcssescape, fcssescape);
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function ATTR(match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function CHILD(match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function PSEUDO(match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function TAG(nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function CLASS(className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function ATTR(name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function CHILD(type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function PSEUDO(pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function target(elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function root(elem) {
					return elem === docElem;
				},

				"focus": function focus(elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": createDisabledPseudo(false),
				"disabled": createDisabledPseudo(true),

				"checked": function checked(elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function selected(elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function empty(elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function parent(elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function header(elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function input(elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function button(elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function text(elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    skip = combinator.next,
			    key = skip || dir,
			    checkNonElements = base && key === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if (skip && skip === elem.nodeName.toLowerCase()) {
								elem = elem[dir] || elem;
							} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[key] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function superMatcher(seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (el) {
			// Should return 1, but returns 4 (following)
			return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (el) {
			el.innerHTML = "<a href='#'></a>";
			return el.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (el) {
			el.innerHTML = "<input/>";
			el.firstChild.setAttribute("value", "");
			return el.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (el) {
			return el.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;

	var dir = function dir(elem, _dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[_dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var _siblings = function _siblings(n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	function nodeName(elem, name) {

		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	};
	var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		// Single element
		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if (typeof qualifier !== "string") {
			return jQuery.grep(elements, function (elem) {
				return indexOf.call(qualifier, elem) > -1 !== not;
			});
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if (risSimple.test(qualifier)) {
			return jQuery.filter(qualifier, elements, not);
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter(qualifier, elements);
		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		if (elems.length === 1 && elem.nodeType === 1) {
			return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
		}

		return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function find(selector) {
			var i,
			    ret,
			    len = this.length,
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			ret = this.pushStack([]);

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			return len > 1 ? jQuery.uniqueSort(ret) : ret;
		},
		filter: function filter(selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function not(selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function is(selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					if (elem) {

						// Inject the element directly into the jQuery object
						this[0] = elem;
						this.length = 1;
					}
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function has(target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function closest(selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    targets = typeof selectors !== "string" && jQuery(selectors);

			// Positional selectors never match, since there's no _selection_ context
			if (!rneedsContext.test(selectors)) {
				for (; i < l; i++) {
					for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

						// Always skip document fragments
						if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

							matched.push(cur);
							break;
						}
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function index(elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function add(selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function addBack(selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function parent(elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function parents(elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function parentsUntil(elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function next(elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function prev(elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function nextAll(elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function prevAll(elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function nextUntil(elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function prevUntil(elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function siblings(elem) {
			return _siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function children(elem) {
			return _siblings(elem.firstChild);
		},
		contents: function contents(elem) {
			if (nodeName(elem, "iframe")) {
				return elem.contentDocument;
			}

			// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
			// Treat the template element as a regular one in browsers that
			// don't support it.
			if (nodeName(elem, "template")) {
				elem = elem.content || elem;
			}

			return jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		_fired,


		// Flag to prevent firing
		_locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function fire() {

			// Enforce single-firing
			_locked = _locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			_fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (_locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function add() {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function remove() {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function has(fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function empty() {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function disable() {
				_locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function disabled() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function lock() {
				_locked = queue = [];
				if (!memory && !firing) {
					list = memory = "";
				}
				return this;
			},
			locked: function locked() {
				return !!_locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function fireWith(context, args) {
				if (!_locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function fire() {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function fired() {
				return !!_fired;
			}
		};

		return self;
	};

	function Identity(v) {
		return v;
	}
	function Thrower(ex) {
		throw ex;
	}

	function adoptValue(value, resolve, reject, noValue) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if (value && jQuery.isFunction(method = value.promise)) {
				method.call(value).done(resolve).fail(reject);

				// Other thenables
			} else if (value && jQuery.isFunction(method = value.then)) {
				method.call(value, resolve, reject);

				// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply(undefined, [value].slice(noValue));
			}

			// For Promises/A+, convert exceptions into rejections
			// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
			// Deferred#then to conditionally suppress rejection.
		} catch (value) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply(undefined, [value]);
		}
	}

	jQuery.extend({

		Deferred: function Deferred(func) {
			var tuples = [

			// action, add listener, callbacks,
			// ... .then handlers, argument index, [final state]
			["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
			    _state = "pending",
			    _promise = {
				state: function state() {
					return _state;
				},
				always: function always() {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				"catch": function _catch(fn) {
					return _promise.then(null, fn);
				},

				// Keep pipe for back-compat
				pipe: function pipe() /* fnDone, fnFail, fnProgress */{
					var fns = arguments;

					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},
				then: function then(onFulfilled, onRejected, onProgress) {
					var maxDepth = 0;
					function resolve(depth, deferred, handler, special) {
						return function () {
							var that = this,
							    args = arguments,
							    mightThrow = function mightThrow() {
								var returned, then;

								// Support: Promises/A+ section 2.3.3.3.3
								// https://promisesaplus.com/#point-59
								// Ignore double-resolution attempts
								if (depth < maxDepth) {
									return;
								}

								returned = handler.apply(that, args);

								// Support: Promises/A+ section 2.3.1
								// https://promisesaplus.com/#point-48
								if (returned === deferred.promise()) {
									throw new TypeError("Thenable self-resolution");
								}

								// Support: Promises/A+ sections 2.3.3.1, 3.5
								// https://promisesaplus.com/#point-54
								// https://promisesaplus.com/#point-75
								// Retrieve `then` only once
								then = returned && (

								// Support: Promises/A+ section 2.3.4
								// https://promisesaplus.com/#point-64
								// Only check objects and functions for thenability
								(typeof returned === "undefined" ? "undefined" : _typeof(returned)) === "object" || typeof returned === "function") && returned.then;

								// Handle a returned thenable
								if (jQuery.isFunction(then)) {

									// Special processors (notify) just wait for resolution
									if (special) {
										then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));

										// Normal processors (resolve) also hook into progress
									} else {

										// ...and disregard older resolution values
										maxDepth++;

										then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
									}

									// Handle all other returned values
								} else {

									// Only substitute handlers pass on context
									// and multiple values (non-spec behavior)
									if (handler !== Identity) {
										that = undefined;
										args = [returned];
									}

									// Process the value(s)
									// Default process is resolve
									(special || deferred.resolveWith)(that, args);
								}
							},


							// Only normal processors (resolve) catch and reject exceptions
							process = special ? mightThrow : function () {
								try {
									mightThrow();
								} catch (e) {

									if (jQuery.Deferred.exceptionHook) {
										jQuery.Deferred.exceptionHook(e, process.stackTrace);
									}

									// Support: Promises/A+ section 2.3.3.3.4.1
									// https://promisesaplus.com/#point-61
									// Ignore post-resolution exceptions
									if (depth + 1 >= maxDepth) {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if (handler !== Thrower) {
											that = undefined;
											args = [e];
										}

										deferred.rejectWith(that, args);
									}
								}
							};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if (depth) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if (jQuery.Deferred.getStackHook) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout(process);
							}
						};
					}

					return jQuery.Deferred(function (newDefer) {

						// progress_handlers.add( ... )
						tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));

						// fulfilled_handlers.add( ... )
						tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));

						// rejected_handlers.add( ... )
						tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function promise(obj) {
					return obj != null ? jQuery.extend(obj, _promise) : _promise;
				}
			},
			    deferred = {};

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[5];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				_promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						_state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[3 - i][2].disable,

					// progress_callbacks.lock
					tuples[0][2].lock);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add(tuple[3].fire);

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			_promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function when(singleValue) {
			var

			// count of uncompleted subordinates
			remaining = arguments.length,


			// count of unprocessed arguments
			i = remaining,


			// subordinate fulfillment data
			resolveContexts = Array(i),
			    resolveValues = _slice.call(arguments),


			// the master Deferred
			master = jQuery.Deferred(),


			// subordinate callback factory
			updateFunc = function updateFunc(i) {
				return function (value) {
					resolveContexts[i] = this;
					resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;
					if (! --remaining) {
						master.resolveWith(resolveContexts, resolveValues);
					}
				};
			};

			// Single- and empty arguments are adopted like Promise.resolve
			if (remaining <= 1) {
				adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while (i--) {
				adoptValue(resolveValues[i], updateFunc(i), master.reject);
			}

			return master.promise();
		}
	});

	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function (error, stack) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
			window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
		}
	};

	jQuery.readyException = function (error) {
		window.setTimeout(function () {
			throw error;
		});
	};

	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function (fn) {

		readyList.then(fn)

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		["catch"](function (error) {
			jQuery.readyException(error);
		});

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function ready(wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);
		}
	});

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout(jQuery.ready);
	} else {

		// Use the handy event callback
		document.addEventListener("DOMContentLoaded", completed);

		// A fallback to window.onload, that will always work
		window.addEventListener("load", completed);
	}

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function fn(elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		if (chainable) {
			return elems;
		}

		// Gets
		if (bulk) {
			return fn.call(elems);
		}

		return len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function acceptData(owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function cache(owner) {

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function set(owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if (typeof data === "string") {
				cache[jQuery.camelCase(data)] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[jQuery.camelCase(prop)] = data[prop];
				}
			}
			return cache;
		},
		get: function get(owner, key) {
			return key === undefined ? this.cache(owner) :

			// Always use camelCase key (gh-2257)
			owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
		},
		access: function access(owner, key, value) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				return this.get(owner, key);
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function remove(owner, key) {
			var i,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key !== undefined) {

				// Support array or space separated string of keys
				if (Array.isArray(key)) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map(jQuery.camelCase);
				} else {
					key = jQuery.camelCase(key);

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
				}

				i = key.length;

				while (i--) {
					delete cache[key[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function hasData(owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function getData(data) {
		if (data === "true") {
			return true;
		}

		if (data === "false") {
			return false;
		}

		if (data === "null") {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if (data === +data + "") {
			return +data;
		}

		if (rbrace.test(data)) {
			return JSON.parse(data);
		}

		return data;
	}

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = getData(data);
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function hasData(elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function data(elem, name, _data) {
			return dataUser.access(elem, name, _data);
		},

		removeData: function removeData(elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function _data(elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function _removeData(elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function data(key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get(elem, key);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, key);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function () {

					// We always store the camelCased key
					dataUser.set(this, key, value);
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function removeData(key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function queue(elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || Array.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function dequeue(elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function next() {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function _queueHooks(elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function queue(type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function dequeue(type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function clearQueue(type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function promise(type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function resolve() {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" || elem.style.display === "" &&

		// Otherwise, check computed style
		// Support: Firefox <=43 - 45
		// Disconnected elements can have computed display: none, so first confirm that elem is
		// in the document.
		jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
	};

	var swap = function swap(elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}

	var defaultDisplayMap = {};

	function getDefaultDisplay(elem) {
		var temp,
		    doc = elem.ownerDocument,
		    nodeName = elem.nodeName,
		    display = defaultDisplayMap[nodeName];

		if (display) {
			return display;
		}

		temp = doc.body.appendChild(doc.createElement(nodeName));
		display = jQuery.css(temp, "display");

		temp.parentNode.removeChild(temp);

		if (display === "none") {
			display = "block";
		}
		defaultDisplayMap[nodeName] = display;

		return display;
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    values = [],
		    index = 0,
		    length = elements.length;

		// Determine new display value for elements that need to change
		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			display = elem.style.display;
			if (show) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if (display === "none") {
					values[index] = dataPriv.get(elem, "display") || null;
					if (!values[index]) {
						elem.style.display = "";
					}
				}
				if (elem.style.display === "" && isHiddenWithinTree(elem)) {
					values[index] = getDefaultDisplay(elem);
				}
			} else {
				if (display !== "none") {
					values[index] = "none";

					// Remember what we're overwriting
					dataPriv.set(elem, "display", display);
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for (index = 0; index < length; index++) {
			if (values[index] != null) {
				elements[index].style.display = values[index];
			}
		}

		return elements;
	}

	jQuery.fn.extend({
		show: function show() {
			return showHide(this, true);
		},
		hide: function hide() {
			return showHide(this);
		},
		toggle: function toggle(state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHiddenWithinTree(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if (typeof context.getElementsByTagName !== "undefined") {
			ret = context.getElementsByTagName(tag || "*");
		} else if (typeof context.querySelectorAll !== "undefined") {
			ret = context.querySelectorAll(tag || "*");
		} else {
			ret = [];
		}

		if (tag === undefined || tag && nodeName(context, tag)) {
			return jQuery.merge([context], ret);
		}

		return ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();
	var documentElement = document.documentElement;

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function _on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				_on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function fn(event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function add(elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if (selector) {
				jQuery.find.matchesSelector(documentElement, selector);
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnothtmlwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function remove(elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnothtmlwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function dispatch(nativeEvent) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix(nativeEvent);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue,
			    args = new Array(arguments.length),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;

			for (i = 1; i < arguments.length; i++) {
				args[i] = arguments[i];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function handlers(event, _handlers) {
			var i,
			    handleObj,
			    sel,
			    matchedHandlers,
			    matchedSelectors,
			    handlerQueue = [],
			    delegateCount = _handlers.delegateCount,
			    cur = event.target;

			// Find delegate handlers
			if (delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!(event.type === "click" && event.button >= 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
						matchedHandlers = [];
						matchedSelectors = {};
						for (i = 0; i < delegateCount; i++) {
							handleObj = _handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matchedSelectors[sel] === undefined) {
								matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matchedSelectors[sel]) {
								matchedHandlers.push(handleObj);
							}
						}
						if (matchedHandlers.length) {
							handlerQueue.push({ elem: cur, handlers: matchedHandlers });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if (delegateCount < _handlers.length) {
				handlerQueue.push({ elem: cur, handlers: _handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		addProp: function addProp(name, hook) {
			Object.defineProperty(jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction(hook) ? function () {
					if (this.originalEvent) {
						return hook(this.originalEvent);
					}
				} : function () {
					if (this.originalEvent) {
						return this.originalEvent[name];
					}
				},

				set: function set(value) {
					Object.defineProperty(this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					});
				}
			});
		},

		fix: function fix(originalEvent) {
			return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function trigger() {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function trigger() {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function trigger() {
					if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function _default(event) {
					return nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function postDispatch(event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android <=2.3 only
			src.returnValue === false ? returnTrue : returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function preventDefault() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e && !this.isSimulated) {
				e.preventDefault();
			}
		},
		stopPropagation: function stopPropagation() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function stopImmediatePropagation() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each({
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function which(event) {
			var button = event.button;

			// Add which for key events
			if (event.which == null && rkeyEvent.test(event.type)) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
				if (button & 1) {
					return 1;
				}

				if (button & 2) {
					return 3;
				}

				if (button & 4) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp);

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function handle(event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({

		on: function on(types, selector, data, fn) {
			return _on(this, types, selector, data, fn);
		},
		one: function one(types, selector, data, fn) {
			return _on(this, types, selector, data, fn, 1);
		},
		off: function off(types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,


	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget(elem, content) {
		if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

			return jQuery(">tbody", elem)[0] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								DOMEval(node.textContent.replace(rcleanScript, ""), doc);
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function _remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function htmlPrefilter(html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function cleanData(elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({
		detach: function detach(selector) {
			return _remove(this, selector, true);
		},

		remove: function remove(selector) {
			return _remove(this, selector);
		},

		text: function text(value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function append() {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function prepend() {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function before() {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function after() {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function empty() {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function clone(dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function html(value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function replaceWith() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function getStyles(elem) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	(function () {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if (!div) {
				return;
			}

			div.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		jQuery.extend(support, {
			pixelPosition: function pixelPosition() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function boxSizingReliable() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function pixelMarginRight() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function reliableMarginLeft() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,


		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

		computed = computed || getStyles(elem);

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if (computed) {
			ret = computed.getPropertyValue(name) || computed[name];

			if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
				ret = jQuery.style(elem, name);
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function get() {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    rcustomProp = /^--/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName(name) {
		var ret = jQuery.cssProps[name];
		if (!ret) {
			ret = jQuery.cssProps[name] = vendorPropName(name) || name;
		}
		return ret;
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i,
		    val = 0;

		// If we already have the right measurement, avoid augmentation
		if (extra === (isBorderBox ? "border" : "content")) {
			i = 4;

			// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with computed style
		var valueIsBorderBox,
		    styles = getStyles(elem),
		    val = curCSS(elem, name, styles),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Computed unit is not pixels. Stop here and return.
		if (rnumnonpx.test(val)) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

		// Fall back to offsetWidth/Height when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		if (val === "auto") {
			val = elem["offset" + name[0].toUpperCase() + name.slice(1)];
		}

		// Normalize "", auto, and prepare for extra
		val = parseFloat(val) || 0;

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function get(elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function style(elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    isCustomProp = rcustomProp.test(name),
			    style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if (!isCustomProp) {
				name = finalPropName(origName);
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value === "undefined" ? "undefined" : _typeof(value);

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					if (isCustomProp) {
						style.setProperty(name, value);
					} else {
						style[name] = value;
					}
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function css(elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name),
			    isCustomProp = rcustomProp.test(name);

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if (!isCustomProp) {
				name = finalPropName(origName);
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}

			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function get(elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && (

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function set(elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function expand(value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function css(name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (Array.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function init(elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function cur() {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function run(percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function get(tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function set(tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function set(tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function linear(p) {
			return p;
		},
		swing: function swing(p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    inProgress,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	function schedule() {
		if (inProgress) {
			if (document.hidden === false && window.requestAnimationFrame) {
				window.requestAnimationFrame(schedule);
			} else {
				window.setTimeout(schedule, jQuery.fx.interval);
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		var prop,
		    value,
		    toggle,
		    hooks,
		    oldfire,
		    propTween,
		    restoreDisplay,
		    display,
		    isBox = "width" in props || "height" in props,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHiddenWithinTree(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Queue-skipping animations hijack the fx hooks
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Detect show/hide animations
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.test(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;

						// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject(props);
		if (!propTween && jQuery.isEmptyObject(orig)) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if (isBox && elem.nodeType === 1) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if (restoreDisplay == null) {
				restoreDisplay = dataPriv.get(elem, "display");
			}
			display = jQuery.css(elem, "display");
			if (display === "none") {
				if (restoreDisplay) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide([elem], true);
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css(elem, "display");
					showHide([elem]);
				}
			}

			// Animate inline elements as inline-block
			if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
				if (jQuery.css(elem, "float") === "none") {

					// Restore the original display value at the end of pure show/hide animations
					if (!propTween) {
						anim.done(function () {
							style.display = restoreDisplay;
						});
						if (restoreDisplay == null) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// Implement show/hide animations
		propTween = false;
		for (prop in orig) {

			// General show/hide setup for this element animation
			if (!propTween) {
				if (dataShow) {
					if ("hidden" in dataShow) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if (toggle) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if (hidden) {
					showHide([elem], true);
				}

				/* eslint-disable no-loop-func */

				anim.done(function () {

					/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if (!hidden) {
						showHide([elem]);
					}
					dataPriv.remove(elem, "fxshow");
					for (prop in orig) {
						jQuery.style(elem, prop, orig[prop]);
					}
				});
			}

			// Per-property setup
			propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
			if (!(prop in dataShow)) {
				dataShow[prop] = propTween.start;
				if (hidden) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (Array.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function tick() {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3 only
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			// If there's more to do, yield
			if (percent < 1 && length) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if (!length) {
				deferred.notifyWith(elem, [animation, 1, 0]);
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith(elem, [animation]);
			return false;
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function createTween(prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function stop(gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		// Attach callbacks from options
		animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		return animation;
	}

	jQuery.Animation = jQuery.extend(Animation, {

		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function tweener(props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnothtmlwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function prefilter(callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		// Go to the end state if fx are off
		if (jQuery.fx.off) {
			opt.duration = 0;
		} else {
			if (typeof opt.duration !== "number") {
				if (opt.duration in jQuery.fx.speeds) {
					opt.duration = jQuery.fx.speeds[opt.duration];
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function fadeTo(speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHiddenWithinTree).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function animate(prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function doAnimation() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function stop(type, clearQueue, gotoEnd) {
			var stopQueue = function stopQueue(hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function finish(type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Run the timer and safely remove it when done (allowing for external removal)
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (inProgress) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function () {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function attr(name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function removeAttr(name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function attr(elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function set(elem, value) {
					if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function removeAttr(elem, value) {
			var name,
			    i = 0,


			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match(rnothtmlwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function set(elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};

	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret,
			    handle,
			    lowercaseName = name.toLowerCase();

			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[lowercaseName];
				attrHandle[lowercaseName] = ret;
				ret = getter(elem, name, isXML) != null ? lowercaseName : null;
				attrHandle[lowercaseName] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function prop(name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function removeProp(name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function prop(elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function get(elem) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					if (tabindex) {
						return parseInt(tabindex, 10);
					}

					if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function get(elem) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function set(elem) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse(value) {
		var tokens = value.match(rnothtmlwhite) || [];
		return tokens.join(" ");
	}

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function addClass(value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnothtmlwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function removeClass(value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnothtmlwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function toggleClass(value, stateVal) {
			var type = typeof value === "undefined" ? "undefined" : _typeof(value);

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnothtmlwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function hasClass(selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function val(value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if (typeof ret === "string") {
						return ret.replace(rreturn, "");
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (Array.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function get(elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse(jQuery.text(elem));
				}
			},
			select: {
				get: function get(elem) {
					var value,
					    option,
					    i,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one",
					    values = one ? null : [],
					    max = one ? index + 1 : options.length;

					if (index < 0) {
						i = max;
					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) &&

						// Don't return options that are disabled or in a disabled optgroup
						!option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function set(elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];

						/* eslint-disable no-cond-assign */

						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function set(elem, value) {
				if (Array.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function trigger(event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function simulate(type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true
			});

			jQuery.event.trigger(e, null, elem);
		}

	});

	jQuery.fn.extend({

		trigger: function trigger(type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function triggerHandler(type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function hover(fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function handler(event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function setup() {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function teardown() {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (Array.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function add(key, valueOrFunction) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;

			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
		};

		// If an array was passed in, assume that it is an array of form elements.
		if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&");
	};

	jQuery.fn.extend({
		serialize: function serialize() {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function serializeArray() {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				if (val == null) {
					return null;
				}

				if (Array.isArray(val)) {
					return jQuery.map(val, function (val) {
						return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					});
				}

				return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	var r20 = /%20/g,
	    rhash = /#.*$/,
	    rantiCache = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function ajaxSetup(target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function ajax(url, options) {

			// If url is an object, simulate pre-1.5 signature
			if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// Request state (becomes false upon send and true upon completion)
			completed,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// uncached part of the url
			uncached,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			_statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function getResponseHeader(key) {
					var match;
					if (completed) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function getAllResponseHeaders() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function setRequestHeader(name, value) {
					if (completed == null) {
						name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function overrideMimeType(type) {
					if (completed == null) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function statusCode(map) {
					var code;
					if (map) {
						if (completed) {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for (code in map) {
								_statusCode[code] = [_statusCode[code], map[code]];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function abort(statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR);

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (completed) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace(rhash, "");

			// More options handling for requests with no content
			if (!s.hasContent) {

				// Remember the hash so we can put it back
				uncached = s.url.slice(cacheURL.length);

				// If data is available, append data to url
				if (s.data) {
					cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if (s.cache === false) {
					cacheURL = cacheURL.replace(rantiCache, "$1");
					uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

				// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
				s.data = s.data.replace(r20, "+");
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add(s.complete);
			jqXHR.done(s.success);
			jqXHR.fail(s.error);

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (completed) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					completed = false;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Rethrow post-completion exceptions
					if (completed) {
						throw e;
					}

					// Propagate others as results
					done(-1, e);
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Ignore repeat invocations
				if (completed) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(_statusCode);
				_statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function getJSON(url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function getScript(url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function wrapAll(html) {
			var wrap;

			if (this[0]) {
				if (jQuery.isFunction(html)) {
					html = html.call(this[0]);
				}

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function wrapInner(html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function wrap(html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function unwrap(selector) {
			this.parent(selector).not("body").each(function () {
				jQuery(this).replaceWith(this.childNodes);
			});
			return this;
		}
	});

	jQuery.expr.pseudos.hidden = function (elem) {
		return !jQuery.expr.pseudos.visible(elem);
	};
	jQuery.expr.pseudos.visible = function (elem) {
		return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	};

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var _callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function send(headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					_callback = function callback(type) {
						return function () {
							if (_callback) {
								_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = _callback();
					errorCallback = xhr.onerror = _callback("error");

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (_callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					_callback = _callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (_callback) {
							throw e;
						}
					}
				},

				abort: function abort() {
					if (_callback) {
						_callback();
					}
				}
			};
		}
	});

	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter(function (s) {
		if (s.crossDomain) {
			s.contents.script = false;
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function textScript(text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, _callback2;
			return {
				send: function send(_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", _callback2 = function callback(evt) {
						script.remove();
						_callback2 = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function abort() {
					if (_callback2) {
						_callback2();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function jsonpCallback() {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = function () {
		var body = document.implementation.createHTMLDocument("").body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	}();

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (typeof data !== "string") {
			return [];
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if (!context) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if (support.createHTMLDocument) {
				context = document.implementation.createHTMLDocument("");

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement("base");
				base.href = document.location.href;
				context.head.appendChild(base);
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec(data);
		scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = stripAndCollapse(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.pseudos.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	jQuery.offset = {
		setOffset: function setOffset(elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function offset(options) {

			// Preserve chaining for setter
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var doc,
			    docElem,
			    rect,
			    win,
			    elem = this[0];

			if (!elem) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if (!elem.getClientRects().length) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			doc = elem.ownerDocument;
			docElem = doc.documentElement;
			win = doc.defaultView;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function position() {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
					left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function offsetParent() {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {

				// Coalesce documents and windows
				var win;
				if (jQuery.isWindow(elem)) {
					win = elem;
				} else if (elem.nodeType === 9) {
					win = elem.defaultView;
				}

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable);
			};
		});
	});

	jQuery.fn.extend({

		bind: function bind(types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function unbind(types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function delegate(selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function undelegate(selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		}
	});

	jQuery.holdReady = function (hold) {
		if (hold) {
			jQuery.readyWait++;
		} else {
			jQuery.ready(true);
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact) {var _app = __webpack_require__(27);

var _app2 = _interopRequireDefault(_app);

var _director = __webpack_require__(32);

var _layout = __webpack_require__(33);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_director.Router.prototype.replaceRoute = function (i, v, val) {
    var url = this.explode();

    if (typeof i === 'number' && typeof v === 'string') {
        url[i] = v;
    } else if (typeof val === 'string') {
        url.splice(i, v, s);
    } else {
        url = [i];
    }

    var s = url;

    document.location.replace(s[0] === '#' ? s : '#' + s);
    return url;
};

var app = Intact.mount(_app2['default'], document.getElementById('page'));

var router = (0, _director.Router)({
    '/': function _() {
        __webpack_require__.e/* require */(2).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(36)]; (app.run().apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this)).catch(__webpack_require__.oe);
    },
    '/document': {
        '/:title': {
            on: function on(title) {
                __webpack_require__.e/* require */(1).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(35)]; (app.run({
                    title: title
                }).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this)).catch(__webpack_require__.oe);
            }
        },
        on: function on() {
            router.replaceRoute('/document/start');
        }
    },
    '/api': function api() {
        __webpack_require__.e/* require */(0).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(37)]; (app.run({
            title: 'api'
        }).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this)).catch(__webpack_require__.oe);
    }
}).configure({
    notfound: function notfound() {
        router.replaceRoute('/');
    }
});

router.init('/');
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = Vdt;

var _parser = __webpack_require__(19);

var _parser2 = _interopRequireDefault(_parser);

var _stringifier = __webpack_require__(20);

var _stringifier2 = _interopRequireDefault(_stringifier);

var _utils = __webpack_require__(2);

var utils = _interopRequireWildcard(_utils);

var _misstime = __webpack_require__(12);

var miss = _interopRequireWildcard(_misstime);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var parser = new _parser2['default']();
var stringifier = new _stringifier2['default']();

function Vdt(source, options) {
    if (!(this instanceof Vdt)) return new Vdt(source, options);

    this.template = compile(source, options);
    this.data = null;
    this.vNode = null;
    this.node = null;
    this.widgets = {};
    this.blocks = {};
}
Vdt.prototype = {
    constructor: Vdt,

    render: function render(data, parentDom, queue, parentVNode, isSVG, blocks) {
        this.renderVNode(data, blocks);
        this.node = miss.render(this.vNode, parentDom, queue, parentVNode, isSVG);

        return this.node;
    },
    renderVNode: function renderVNode(data, blocks) {
        if (data !== undefined) {
            this.data = data;
        }
        // if (blocks !== undefined) {
        this.blocks = blocks;
        // }
        this.vNode = this.template(this.data, Vdt, this.blocks, this.template) || miss.hc('empty');

        return this.vNode;
    },
    renderString: function renderString(data, blocks) {
        this.renderVNode(data, blocks);

        return miss.renderString(this.vNode, null, Vdt.configure().disableSplitText);
    },
    update: function update(data, parentDom, queue, parentVNode, isSVG, blocks) {
        var oldVNode = this.vNode;
        this.renderVNode(data, blocks);
        this.node = miss.patch(oldVNode, this.vNode, parentDom, queue, parentVNode, isSVG);

        return this.node;
    },
    hydrate: function hydrate(data, dom, queue, parentDom, parentVNode, isSVG, blocks) {
        this.renderVNode(data, blocks);
        miss.hydrate(this.vNode, dom, queue, parentDom, parentVNode, isSVG);
        this.node = this.vNode.dom;

        return this.node;
    },
    destroy: function destroy() {
        miss.remove(this.vNode);
    }
};

function compile(source, options) {
    var templateFn;

    // backward compatibility v0.2.2
    if (options === true || options === false) {
        options = { autoReturn: options };
    }

    options = utils.extend({}, utils.configure(), options);

    switch (typeof source === 'undefined' ? 'undefined' : _typeof(source)) {
        case 'string':
            var ast = parser.parse(source, options),
                hscript = stringifier.stringify(ast, options.autoReturn);

            hscript = ['_Vdt || (_Vdt = Vdt);', 'obj || (obj = {});', 'blocks || (blocks = {});', 'var h = _Vdt.miss.h, hc = _Vdt.miss.hc, hu = _Vdt.miss.hu, widgets = this && this.widgets || {}, _blocks = {}, __blocks = {},', '__u = _Vdt.utils, extend = __u.extend, _e = __u.error, _className = __u.className,', '__o = __u.Options, _getModel = __o.getModel, _setModel = __o.setModel,', '_setCheckboxModel = __u.setCheckboxModel, _detectCheckboxChecked = __u.detectCheckboxChecked,', '_setSelectModel = __u.setSelectModel,', (options.server ? 'require = function(file) { return _Vdt.require(file, "' + options.filename.replace(/\\/g, '\\\\') + '") }, ' : '') + 'self = this.data, $this = this, scope = obj, Animate = self && self.Animate, parent = ($callee || {})._super', options.noWith ? hscript : ['with (obj) {', hscript, '}'].join('\n')].join('\n');
            templateFn = options.onlySource ? function () {} : new Function('obj', '_Vdt', 'blocks', '$callee', hscript);
            templateFn.source = 'function(obj, _Vdt, blocks, $callee) {\n' + hscript + '\n}';
            templateFn.head = stringifier.head;
            break;
        case 'function':
            templateFn = source;
            break;
        default:
            throw new Error('Expect a string or function');
    }

    return templateFn;
}

Vdt.parser = parser;
Vdt.stringifier = stringifier;
Vdt.miss = miss;
Vdt.compile = compile;
Vdt.utils = utils;
Vdt.setDelimiters = utils.setDelimiters;
Vdt.getDelimiters = utils.getDelimiters;
Vdt.configure = utils.configure;

// for compatibility v1.0
Vdt.virtualDom = miss;
module.exports = exports['default'];

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports['default'] = Parser;

var _utils = __webpack_require__(2);

var Utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var Type = Utils.Type,
    TypeName = Utils.TypeName; /**
                                * @fileoverview parse jsx to ast
                                * @author javey
                                * @date 15-4-22
                                */

var elementNameRegexp = /^<\w+:?\s*[\{\w\/>]/;
// const importRegexp = /^\s*\bimport\b/;

function isJSXIdentifierPart(ch) {
    return ch === 58 || ch === 95 || ch === 45 || ch === 36 || ch === 46 || // : _ (underscore) - $ .
    ch >= 65 && ch <= 90 || // A..Z
    ch >= 97 && ch <= 122 || // a..z
    ch >= 48 && ch <= 57; // 0..9
}

function Parser() {
    this.source = '';
    this.index = 0;
    this.length = 0;
}

Parser.prototype = {
    constructor: Parser,

    parse: function parse(source, options) {
        this.source = Utils.trimRight(source);
        this.index = 0;
        this.line = 1;
        this.column = 1;
        this.length = this.source.length;

        this.options = Utils.extend({}, Utils.configure(), options);

        return this._parseTemplate(true);
    },

    _parseTemplate: function _parseTemplate(isRoot) {
        var elements = [],
            braces = { count: 0 };
        while (this.index < this.length && braces.count >= 0) {
            elements.push(this._advance(braces, isRoot));
        }

        return elements;
    },

    _advance: function _advance(braces, isRoot) {
        var ch = this._char();
        if (isRoot && this._isJSImport()) {
            return this._scanJSImport();
        } else if (ch !== '<') {
            return this._scanJS(braces, isRoot);
        } else {
            return this._scanJSX();
        }
    },

    _scanJS: function _scanJS(braces, isRoot) {
        var start = this.index,
            tmp,
            Delimiters = this.options.delimiters;

        while (this.index < this.length) {
            this._skipJSComment();
            var ch = this._char();
            if (ch === '\'' || ch === '"' || ch === '`') {
                // skip element(<div>) in quotes
                this._scanStringLiteral();
            } else if (this._isElementStart()) {
                break;
            } else if (isRoot && this._isJSImport()) {
                break;
            } else {
                if (ch === '{') {
                    braces.count++;
                } else if (braces.count > 0 && ch === '}') {
                    braces.count--;
                } else if (this._isExpect(Delimiters[1])) {
                    // for parseTemplate break
                    braces.count--;
                    break;
                } else if (ch === '\n') {
                    this._updateLine();
                }
                this._updateIndex();
            }
        }

        return this._type(Type.JS, {
            value: this.source.slice(start, this.index)
        });
    },

    _scanJSImport: function _scanJSImport() {
        var start = this.index;
        this._updateIndex(7); // 'import '.length
        while (this.index < this.length) {
            var ch = this._char();
            this._updateIndex();
            if ((ch === '\'' || ch === '"') && ((ch = this._char()) === ';' || ch === '\n')) {
                if (ch === '\n') {
                    this._updateLine();
                }
                this._updateIndex();
                break;
            }
        }

        return this._type(Type.JSImport, {
            value: this.source.slice(start, this.index)
        });
    },


    _scanStringLiteral: function _scanStringLiteral() {
        var quote = this._char(),
            start = this.index,
            str = '';
        this._updateIndex();

        while (this.index < this.length) {
            var ch = this._char();
            if (ch.charCodeAt(0) === 10) {
                this._updateLine();
            }
            this._updateIndex();

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                str += this._char(this._updateIndex());
            } else {
                str += ch;
            }
        }
        if (quote !== '') {
            this._error('Unclosed quote');
        }

        return this._type(Type.StringLiteral, {
            value: this.source.slice(start, this.index)
        });
    },

    _scanJSX: function _scanJSX() {
        return this._parseJSXElement();
    },

    _scanJSXText: function _scanJSXText(stopChars) {
        var start = this.index,
            l = stopChars.length,
            i,
            charCode;

        loop: while (this.index < this.length) {
            charCode = this._charCode();
            if (Utils.isWhiteSpace(charCode)) {
                if (charCode === 10) {
                    this._updateLine();
                }
            } else {
                for (i = 0; i < l; i++) {
                    if (typeof stopChars[i] === 'function' && stopChars[i].call(this) || this._isExpect(stopChars[i])) {
                        break loop;
                    }
                }
            }
            this._updateIndex();
        }

        return this._type(Type.JSXText, {
            value: this.source.slice(start, this.index)
        });
    },

    _scanJSXStringLiteral: function _scanJSXStringLiteral() {
        var quote = this._char();
        if (quote !== '\'' && quote !== '"' && quote !== '`') {
            this._error('String literal must starts with a qoute');
        }
        this._updateIndex();
        var token = this._scanJSXText([quote]);
        this._updateIndex();
        return token;
    },

    _parseJSXElement: function _parseJSXElement() {
        this._expect('<');
        var start = this.index,
            ret = {},
            flag = this._charCode();
        if (flag >= 65 && flag <= 90 /* upper case */) {
                // is a widget
                this._type(Type.JSXWidget, ret);
            } else if (this._isExpect('!--')) {
            // is html comment
            return this._parseJSXComment();
        } else if (this._charCode(this.index + 1) === 58 /* : */) {
                // is a directive
                start += 2;
                switch (flag) {
                    case 116:
                        // t
                        this._type(Type.JSXVdt, ret);
                        break;
                    case 98:
                        // b
                        this._type(Type.JSXBlock, ret);
                        break;
                    default:
                        this._error('Unknown directive ' + String.fromCharCode(flag) + ':');
                }
                this._updateIndex(2);
            } else {
            // is an element
            this._type(Type.JSXElement, ret);
        }

        while (this.index < this.length) {
            if (!isJSXIdentifierPart(this._charCode())) {
                break;
            }
            this._updateIndex();
        }

        ret.value = this.source.slice(start, this.index);

        return this._parseAttributeAndChildren(ret);
    },

    _parseAttributeAndChildren: function _parseAttributeAndChildren(ret) {
        var attrs = this._parseJSXAttribute();
        Utils.extend(ret, {
            attributes: attrs.attributes,
            directives: attrs.directives,
            children: []
        });
        if (!ret.directives.length) delete ret.directives;

        if (ret.type === Type.JSXElement && Utils.isSelfClosingTag(ret.value)) {
            // self closing tag
            if (this._char() === '/') {
                this._updateIndex();
            }
            this._expect('>');
        } else if (this._char() === '/') {
            // unknown self closing tag
            this._updateIndex();
            this._expect('>');
        } else {
            this._expect('>');
            ret.children = this._parseJSXChildren(ret, attrs.hasVRaw);
        }

        return ret;
    },

    _parseJSXAttribute: function _parseJSXAttribute() {
        var ret = {
            attributes: [],
            directives: [],
            hasVRaw: false
        };
        while (this.index < this.length) {
            this._skipWhitespace();
            if (this._char() === '/' || this._char() === '>') {
                break;
            } else {
                var Delimiters = this.options.delimiters;
                if (this._isExpect(Delimiters[0])) {
                    // support dynamic attributes
                    ret.attributes.push(this._parseJSXExpressionContainer());
                    continue;
                }
                var attr = this._parseJSXAttributeName();
                if (attr.name === 'v-raw') {
                    ret.hasVRaw = true;
                    continue;
                }
                if (this._char() === '=') {
                    this._updateIndex();
                    attr.value = this._parseJSXAttributeValue();
                } else {
                    // treat no-value attribute as true
                    attr.value = this._type(Type.JSXExpressionContainer, { value: [this._type(Type.JS, { value: 'true' })] });
                }
                ret[attr.type === Type.JSXAttribute ? 'attributes' : 'directives'].push(attr);
            }
        }

        return ret;
    },

    _parseJSXAttributeName: function _parseJSXAttributeName() {
        var start = this.index;
        if (!isJSXIdentifierPart(this._charCode())) {
            this._error('Unexpected identifier ' + this._char());
        }
        while (this.index < this.length) {
            var ch = this._charCode();
            if (!isJSXIdentifierPart(ch)) {
                break;
            }
            this._updateIndex();
        }

        var name = this.source.slice(start, this.index);
        if (Utils.isDirective(name)) {
            return this._type(Type.JSXDirective, { name: name });
        }

        return this._type(Type.JSXAttribute, { name: name });
    },

    _parseJSXAttributeValue: function _parseJSXAttributeValue() {
        var value,
            Delimiters = this.options.delimiters;
        if (this._isExpect(Delimiters[0])) {
            value = this._parseJSXExpressionContainer();
        } else {
            value = this._scanJSXStringLiteral();
        }
        return value;
    },

    _parseJSXExpressionContainer: function _parseJSXExpressionContainer() {
        var expression,
            Delimiters = this.options.delimiters;
        this._expect(Delimiters[0]);
        if (this._isExpect(Delimiters[1])) {
            expression = this._parseJSXEmptyExpression();
        } else if (this._isExpect('=')) {
            // if the lead char is '=', then treat it as unescape string
            expression = this._parseJSXUnescapeText();
            this._expect(Delimiters[1]);
            return expression;
        } else {
            expression = this._parseExpression();
        }
        this._expect(Delimiters[1]);

        return this._type(Type.JSXExpressionContainer, { value: expression });
    },

    _parseJSXEmptyExpression: function _parseJSXEmptyExpression() {
        return this._type(Type.JSXEmptyExpression, { value: null });
    },

    _parseExpression: function _parseExpression() {
        return this._parseTemplate();
    },

    _parseJSXUnescapeText: function _parseJSXUnescapeText() {
        this._expect('=');
        return this._type(Type.JSXUnescapeText, {
            value: this._parseTemplate()
        });
    },

    _parseJSXChildren: function _parseJSXChildren(element, hasVRaw) {
        var children = [],
            endTag = element.value + '>',
            current = null;

        switch (element.type) {
            case Type.JSXBlock:
                endTag = '</b:' + endTag;
                break;
            case Type.JSXVdt:
                endTag = '</t:' + endTag;
                break;
            case Type.JSXElement:
            default:
                endTag = '</' + endTag;
                break;
        }

        if (hasVRaw) {
            while (this.index < this.length) {
                if (this._isExpect(endTag)) {
                    break;
                }
                children.push(this._scanJSXText([endTag]));
            }
        } else {
            this._skipWhitespaceBetweenElements(endTag);
            while (this.index < this.length) {
                if (this._isExpect(endTag)) {
                    break;
                }
                current = this._parseJSXChild(element, endTag, current);
                children.push(current);
            }
        }
        this._parseJSXClosingElement();
        return children;
    },

    _parseJSXChild: function _parseJSXChild(element, endTag, prev) {
        var ret,
            Delimiters = this.options.delimiters;

        if (this._isExpect(Delimiters[0])) {
            ret = this._parseJSXExpressionContainer();
        } else if (Utils.isTextTag(element.value)) {
            ret = this._scanJSXText([endTag, Delimiters[0]]);
        } else if (this._isElementStart()) {
            ret = this._parseJSXElement();
            this._skipWhitespaceBetweenElements(endTag);
        } else {
            ret = this._scanJSXText([function () {
                return this._isExpect(endTag) || this._isElementStart();
            }, Delimiters[0]]);
        }

        ret.prev = undefined;
        ret.next = undefined;
        if (prev) {
            prev.next = ret;
            ret.prev = prev;
        }

        return ret;
    },

    _parseJSXClosingElement: function _parseJSXClosingElement() {
        this._expect('</');

        while (this.index < this.length) {
            if (!isJSXIdentifierPart(this._charCode())) {
                break;
            }
            this._updateIndex();
        }

        this._skipWhitespace();
        this._expect('>');
    },

    _parseJSXComment: function _parseJSXComment() {
        this._expect('!--');
        var start = this.index;
        while (this.index < this.length) {
            if (this._isExpect('-->')) {
                break;
            } else if (this._charCode() === 10) {
                this._updateLine();
            }
            this._updateIndex();
        }
        var ret = this._type(Type.JSXComment, {
            value: this.source.slice(start, this.index)
        });
        this._expect('-->');

        return ret;
    },

    _char: function _char() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.index;

        return this.source.charAt(index);
    },

    _charCode: function _charCode() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.index;

        return this.source.charCodeAt(index);
    },

    _skipWhitespaceBetweenElements: function _skipWhitespaceBetweenElements(endTag) {
        if (!this.options.skipWhitespace) return;

        var start = this.index;
        while (start < this.length) {
            var code = this._charCode(start);
            if (Utils.isWhiteSpace(code)) {
                start++;
            } else if (this._isExpect(endTag, start) || this._isElementStart(start)) {
                this._skipWhitespace();
                break;
            } else {
                break;
            }
        }
    },

    _skipWhitespace: function _skipWhitespace() {
        while (this.index < this.length) {
            var code = this._charCode();
            if (!Utils.isWhiteSpace(code)) {
                break;
            } else if (code === 10) {
                // is \n
                this._updateLine();
            }
            this._updateIndex();
        }
    },

    _skipJSComment: function _skipJSComment() {
        if (this._char() === '/') {
            var ch = this._char(this.index + 1);
            if (ch === '/') {
                this._updateIndex(2);
                while (this.index < this.length) {
                    if (this._charCode() === 10) {
                        // is \n
                        this._updateLine();
                        break;
                    }
                    this._updateIndex();
                }
            } else if (ch === '*') {
                this._updateIndex(2);
                while (this.index < this.length) {
                    if (this._isExpect('*/')) {
                        this._updateIndex(2);
                        break;
                    } else if (this._charCode() === 10) {
                        this._updateLine();
                    }
                    this._updateIndex();
                }
            }
        }
    },

    _expect: function _expect(str) {
        if (!this._isExpect(str)) {
            this._error('expect string ' + str);
        }
        this._updateIndex(str.length);
    },

    _isExpect: function _isExpect(str) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.index;

        return this.source.slice(index, index + str.length) === str;
    },

    _isElementStart: function _isElementStart() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.index;

        return this._char(index) === '<' && (this._isExpect('<!--') || elementNameRegexp.test(this.source.slice(index)));
    },

    _isJSImport: function _isJSImport() {
        return this._isExpect('import ');
    },

    _type: function _type(type, ret) {
        ret || (ret = {});
        ret.type = type;
        ret.typeName = TypeName[type];
        ret.line = this.line;
        ret.column = this.column;
        return ret;
    },

    _updateLine: function _updateLine() {
        this.line++;
        this.column = 0;
    },

    _updateIndex: function _updateIndex(value) {
        value === undefined && (value = 1);
        var index = this.index;
        this.index = this.index + value;
        this.column = this.column + value;
        return index;
    },

    _error: function _error(msg) {
        throw new Error(msg + ' At: {line: ' + this.line + ', column: ' + this.column + '} Near: "' + this.source.slice(this.index - 10, this.index + 20) + '"');
    }
};
module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports['default'] = Stringifier;

var _utils = __webpack_require__(2);

var Utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var Type = Utils.Type,
    TypeName = Utils.TypeName; /**
                                * @fileoverview stringify ast of jsx to js
                                * @author javey
                                * @date 15-4-22
                                */

var attrMap = function () {
    var map = {
        'class': 'className',
        'for': 'htmlFor'
    };
    return function (name) {
        return map[name] || name;
    };
}();

var normalizeArgs = function normalizeArgs(args) {
    var l = args.length - 1;
    for (var i = l; i >= 0; i--) {
        if (args[i] !== 'null') {
            break;
        }
    }
    return (i === l ? args : args.slice(0, i + 1)).join(', ');
};

function Stringifier() {}

Stringifier.prototype = {
    constructor: Stringifier,

    stringify: function stringify(ast, autoReturn) {
        if (arguments.length === 1) {
            autoReturn = true;
        }
        this.autoReturn = !!autoReturn;
        this.enterStringExpression = false;
        this.head = ''; // save import syntax
        return this._visitJSXExpressionContainer(ast, true);
    },

    _visitJSXExpressionContainer: function _visitJSXExpressionContainer(ast, isRoot) {
        var str = '',
            length = ast.length,
            hasDestructuring = false;
        Utils.each(ast, function (element, i) {
            // if is root, add `return` keyword
            if (this.autoReturn && isRoot && i === length - 1) {
                str += 'return ';
            }
            var tmp = this._visit(element, isRoot);
            if (isRoot && element.type === Type.JSImport) {
                this.head += tmp;
            } else {
                str += tmp;
            }
        }, this);

        if (!isRoot && !this.enterStringExpression) {
            // special for ... syntaxt
            str = Utils.trimLeft(str);
            if (str[0] === '.' && str[1] === '.' && str[2] === '.') {
                hasDestructuring = true;
                str = str.substr(3);
            }
            // add [][0] for return /* comment */
            str = 'function() {try {return [' + str + '][0]} catch(e) {_e(e)}}.call(this)';
            // str = 'function() {try {return (' + str + ')} catch(e) {_e(e)}}.call(this)';
            if (hasDestructuring) {
                str = '...' + str;
            }
        }

        return str;
    },

    _visit: function _visit(element, isRoot) {
        element = element || {};
        switch (element.type) {
            case Type.JS:
            case Type.JSImport:
                return this._visitJS(element);
            case Type.JSXElement:
                return this._visitJSXElement(element);
            case Type.JSXText:
                return this._visitJSXText(element);
            case Type.JSXUnescapeText:
                return this._visitJSXUnescapeText(element);
            case Type.JSXExpressionContainer:
                return this._visitJSXExpressionContainer(element.value);
            case Type.JSXWidget:
                return this._visitJSXWidget(element);
            case Type.JSXBlock:
                return this._visitJSXBlock(element, true);
            case Type.JSXVdt:
                return this._visitJSXVdt(element, isRoot);
            case Type.JSXComment:
                return this._visitJSXComment(element);
            default:
                return 'null';
        }
    },

    _visitJS: function _visitJS(element) {
        return this.enterStringExpression ? '(' + element.value + ')' : element.value;
    },

    _visitJSXElement: function _visitJSXElement(element) {
        if (element.value === 'script' || element.value === 'style') {
            if (element.children.length) {
                element.attributes.push({
                    type: Type.JSXAttribute,
                    typeName: TypeName[Type.JSXAttribute],
                    name: 'innerHTML',
                    value: {
                        type: Type.JS,
                        typeName: TypeName[Type.JS],
                        value: this._visitJSXChildrenAsString(element.children)
                    }
                });
                element.children = [];
            }
        }

        var attributes = this._visitJSXAttribute(element, true, true);
        var ret = "h(" + normalizeArgs(["'" + element.value + "'", attributes.props, this._visitJSXChildren(element.children), attributes.className, attributes.key, attributes.ref]) + ')';

        return this._visitJSXDirective(element, ret);
    },

    _visitJSXChildren: function _visitJSXChildren(children) {
        var ret = [];
        Utils.each(children, function (child) {
            // if this.element has be handled return directly
            if (child._skip) return;
            ret.push(this._visit(child));
        }, this);

        return ret.length > 1 ? '[' + ret.join(', ') + ']' : ret[0] || 'null';
    },

    _visitJSXDirective: function _visitJSXDirective(element, ret) {
        var directiveFor = {
            data: null,
            value: 'value',
            key: 'key'
        };
        Utils.each(element.directives, function (directive) {
            switch (directive.name) {
                case 'v-if':
                    ret = this._visitJSXDirectiveIf(directive, ret, element);
                    break;
                case 'v-else-if':
                case 'v-else':
                    if (element._skip) break;
                    throw new Error(directive.name + ' must be led with v-if. At: {line: ' + element.line + ', column: ' + element.column + '}');
                case 'v-for':
                    directiveFor.data = this._visitJSXAttributeValue(directive.value);
                    break;
                case 'v-for-value':
                    directiveFor.value = this._visitJSXText(directive.value, true);
                    break;
                case 'v-for-key':
                    directiveFor.key = this._visitJSXText(directive.value, true);
                    break;
                default:
                    break;
            }
        }, this);
        // if exists v-for
        if (directiveFor.data) {
            ret = this._visitJSXDirectiveFor(directiveFor, ret);
        }

        return ret;
    },

    _visitJSXDirectiveIf: function _visitJSXDirectiveIf(directive, ret, element) {
        var result = this._visitJSXAttributeValue(directive.value) + ' ? ' + ret + ' : ',
            hasElse = false,
            next = element,
            emptyTextNodes = [],
            // persist empty text node, skip them if find v-else-if or v-else
        skipNodes = function skipNodes() {
            Utils.each(emptyTextNodes, function (item) {
                item._skip = true;
            });
            emptyTextNodes = [];
        };
        while (next = next.next) {
            if (next.type === Utils.Type.JSXText) {
                if (!/^\s*$/.test(next.value)) break;
                // is not the last text node, mark as handled
                else emptyTextNodes.push(next);
            } else if (next.type === Utils.Type.JSXElement || next.type === Utils.Type.JSXWidget || next.type === Utils.Type.JSXVdt || next.type === Utils.Type.JSXBlock) {
                if (!next.directives || !next.directives.length) break;
                var isContinue = false;
                for (var i = 0, l = next.directives.length; i < l; i++) {
                    var dire = next.directives[i],
                        name = dire.name;
                    if (name === 'v-else-if') {
                        // mark this element as handled
                        next._skip = true;
                        result += this._visitJSXAttributeValue(dire.value) + ' ? ' + this._visit(next) + ' : ';
                        isContinue = true;
                        // mark text node before as handled
                        skipNodes();
                        break;
                    } else if (name === 'v-else') {
                        // mark this element as handled
                        next._skip = true;
                        result += this._visit(next);
                        hasElse = true;
                        // mark text node before as handled
                        skipNodes();
                        break;
                    }
                }
                if (!isContinue) break;
            }
        }
        if (!hasElse) result += 'undefined';
        return result;
    },

    _visitJSXDirectiveFor: function _visitJSXDirectiveFor(directive, ret) {
        return '_Vdt.utils.map(' + directive.data + ', function(' + directive.value + ', ' + directive.key + ') {\n' + 'return ' + ret + ';\n' + '}, this)';
    },

    _visitJSXChildrenAsString: function _visitJSXChildrenAsString(children) {
        var ret = [];
        this.enterStringExpression = true;
        Utils.each(children, function (child) {
            ret.push(this._visit(child));
        }, this);
        this.enterStringExpression = false;
        return ret.join('+');
    },

    _visitJSXAttribute: function _visitJSXAttribute(element, individualClassName, individualKeyAndRef) {
        var ret = [],
            attributes = element.attributes,
            className,
            key,
            ref,
            type = 'text',
            hasModel = false,
            addition = { trueValue: true, falseValue: false };
        Utils.each(attributes, function (attr) {
            if (attr.type === Type.JSXExpressionContainer) {
                return ret.push(this._visitJSXAttributeValue(attr));
            }
            var name = attrMap(attr.name),
                value = this._visitJSXAttributeValue(attr.value);
            if ((name === 'widget' || name === 'ref') && attr.value.type === Type.JSXText) {
                // for compatility v1.0
                // convert widget="a" to ref=(i) => widgets.a = i
                // convert ref="a" to ref=(i) => widgets.a = i. For Intact
                ref = 'function(i) {widgets[' + value + '] = i}';
                return;
            } else if (name === 'className') {
                // process className individually
                if (attr.value.type === Type.JSXExpressionContainer) {
                    // for class={ {active: true} }
                    value = '_className(' + value + ')';
                }
                if (individualClassName) {
                    className = value;
                    return;
                }
            } else if (name === 'key' && individualKeyAndRef) {
                key = value;
                return;
            } else if (name === 'ref' && individualKeyAndRef) {
                ref = value;
                return;
            } else if (name === 'v-model') {
                hasModel = value;
                // pass v-model to element, sometimes it is useful
                // return;
            } else if (name === 'v-model-true') {
                addition.trueValue = value;
                return;
            } else if (name === 'v-model-false') {
                addition.falseValue = value;
                return;
            } else if (name === 'type') {
                // save the type value for v-model of input element
                type = value;
            } else if (name === 'value') {
                addition.value = value;
            }
            ret.push("'" + name + "': " + value);
        }, this);

        if (hasModel) {
            this._visitJSXAttributeModel(element, hasModel, ret, type, addition);
        }

        return {
            props: ret.length ? '{' + ret.join(', ') + '}' : 'null',
            className: className || 'null',
            ref: ref || 'null',
            key: key || 'null'
        };
    },

    _visitJSXAttributeModel: function _visitJSXAttributeModel(element, value, ret, type, addition) {
        var valueName = 'value',
            eventName = 'change';
        if (element.type === Type.JSXElement) {
            switch (element.value) {
                case 'input':
                    valueName = 'value';
                    switch (type) {
                        case "'file'":
                            eventName = 'change';
                            break;
                        case "'radio'":
                        case "'checkbox'":
                            var trueValue = addition.trueValue,
                                falseValue = addition.falseValue,
                                inputValue = addition.value;
                            if (Utils.isNullOrUndefined(inputValue)) {
                                ret.push('checked: _getModel(self, ' + value + ') === ' + trueValue);
                                ret.push('\'ev-change\': function(__e) {\n                                    _setModel(self, ' + value + ', __e.target.checked ? ' + trueValue + ' : ' + falseValue + ', $this);\n                                }');
                            } else {
                                if (type === "'radio'") {
                                    ret.push('checked: _getModel(self, ' + value + ') === ' + inputValue);
                                    ret.push('\'ev-change\': function(__e) { \n                                        _setModel(self, ' + value + ', __e.target.checked ? ' + inputValue + ' : ' + falseValue + ', $this);\n                                    }');
                                } else {
                                    ret.push('checked: _detectCheckboxChecked(self, ' + value + ', ' + inputValue + ')');
                                    ret.push('\'ev-change\': function(__e) { \n                                        _setCheckboxModel(self, ' + value + ', ' + inputValue + ', ' + falseValue + ', __e, $this);\n                                    }');
                                }
                            }
                            return;
                        default:
                            eventName = 'input';
                            break;
                    }
                    break;
                case 'select':
                    ret.push('value: _getModel(self, ' + value + ')');
                    ret.push('\'ev-change\': function(__e) {\n                        _setSelectModel(self, ' + value + ', __e, $this);\n                    }');
                    return;
                case 'textarea':
                    eventName = 'input';
                    break;
                default:
                    break;
            }
            ret.push(valueName + ': _getModel(self, ' + value + ')');
            ret.push('\'ev-' + eventName + '\': function(__e) { _setModel(self, ' + value + ', __e.target.value, $this) }');
        } else if (element.type === Type.JSXWidget) {
            ret.push('value: _getModel(self, ' + value + ')');
            ret.push('\'ev-$change:value\': function(__c, __n) { _setModel(self, ' + value + ', __n, $this) }');
        }
    },

    _visitJSXAttributeValue: function _visitJSXAttributeValue(value) {
        return Utils.isArray(value) ? this._visitJSXChildren(value) : this._visit(value);
    },

    _visitJSXText: function _visitJSXText(element, noQuotes) {
        var ret = element.value.replace(/([\'\"\\])/g, '\\$1').replace(/[\r\n]/g, '\\n');
        if (!noQuotes) {
            ret = "'" + ret + "'";
        }
        return ret;
    },

    _visitJSXUnescapeText: function _visitJSXUnescapeText(element) {
        return 'hu(' + this._visitJSXExpressionContainer(element.value) + ')';
    },

    _visitJSXWidget: function _visitJSXWidget(element) {
        var _visitJSXBlocks = this._visitJSXBlocks(element, false),
            blocks = _visitJSXBlocks.blocks,
            children = _visitJSXBlocks.children,
            hasBlock = _visitJSXBlocks.hasBlock;

        element.attributes.push({ name: 'children', value: children });
        element.attributes.push({ name: '_context', value: {
                type: Type.JS,
                value: '$this'
            } });
        if (hasBlock) {
            element.attributes.push({ name: '_blocks', value: blocks });
        }

        var attributes = this._visitJSXAttribute(element, false, false);
        return this._visitJSXDirective(element, 'h(' + normalizeArgs([element.value, attributes.props, 'null', 'null', attributes.key, attributes.ref]) + ')');
    },

    _visitJSXBlock: function _visitJSXBlock(element, isAncestor) {
        return this._visitJSXDirective(element, '(_blocks["' + element.value + '"] = function(parent) {return ' + this._visitJSXChildren(element.children) + ';}) && (__blocks["' + element.value + '"] = function(parent) {\n' + 'var self = this;\n' + 'return blocks["' + element.value + '"] ? blocks["' + element.value + '"].call(this, function() {\n' + 'return _blocks["' + element.value + '"].call(self, parent);\n' + '}) : _blocks["' + element.value + '"].call(this, parent);\n' + '})' + (isAncestor ? ' && __blocks["' + element.value + '"].call(this)' : ''));
    },

    _visitJSXBlocks: function _visitJSXBlocks(element, isRoot) {
        var blocks = [];
        var children = [];
        Utils.each(element.children, function (child) {
            if (child.type === Type.JSXBlock) {
                blocks.push(this._visitJSXBlock(child, false));
            } else {
                children.push(child);
            }
        }, this);

        var _blocks = {
            type: Type.JS,
            value: blocks.length ? ['function(blocks) {', '    var _blocks = {}, __blocks = extend({}, blocks);', '    return (' + blocks.join(' && ') + ', __blocks);', '}.call(this, ' + (isRoot ? 'blocks' : '{}') + ')'].join('\n') : isRoot ? 'blocks' : 'null'
        };

        return { blocks: _blocks, children: children.length ? children : null, hasBlock: blocks.length };
    },

    _visitJSXVdt: function _visitJSXVdt(element, isRoot) {
        var _visitJSXBlocks2 = this._visitJSXBlocks(element, isRoot),
            blocks = _visitJSXBlocks2.blocks,
            children = _visitJSXBlocks2.children;

        element.attributes.push({ name: 'children', value: children });
        var ret = ['(function() {', '    var _obj = ' + this._visitJSXAttribute(element, false, false).props + ';', '    if (_obj.hasOwnProperty("arguments")) {', '        extend(_obj, _obj.arguments === true ? obj : _obj.arguments);', '        delete _obj.arguments;', '    }', '    return ' + element.value + '.call(this, _obj, _Vdt, ' + this._visitJS(blocks) + ', ' + element.value + ')', '}).call(this)'].join('\n');

        return this._visitJSXDirective(element, ret);
    },

    _visitJSXComment: function _visitJSXComment(element) {
        return 'hc(' + this._visitJSXText(element) + ')';
    }
};
module.exports = exports['default'];

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.processSelect = processSelect;

var _utils = __webpack_require__(0);

var _vnode = __webpack_require__(1);

function processSelect(vNode, dom, nextProps, isRender) {
    var multiple = nextProps.multiple;
    if (multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    var children = vNode.children;

    if (!(0, _utils.isNullOrUndefined)(children)) {
        var value = nextProps.value;
        if (isRender && (0, _utils.isNullOrUndefined)(value)) {
            value = nextProps.defaultValue;
        }

        var flag = { hasSelected: false };
        if ((0, _utils.isArray)(children)) {
            for (var i = 0; i < children.length; i++) {
                updateChildOptionGroup(children[i], value, flag);
            }
        } else {
            updateChildOptionGroup(children, value, flag);
        }
        if (!flag.hasSelected) {
            dom.value = '';
        }
    }
}

function updateChildOptionGroup(vNode, value, flag) {
    var tag = vNode.tag;

    if (tag === 'optgroup') {
        var children = vNode.children;

        if ((0, _utils.isArray)(children)) {
            for (var i = 0; i < children.length; i++) {
                updateChildOption(children[i], value, flag);
            }
        } else {
            updateChildOption(children, value, flag);
        }
    } else {
        updateChildOption(vNode, value, flag);
    }
}

function updateChildOption(vNode, value, flag) {
    // skip text and comment node
    if (vNode.type & _vnode.Types.HtmlElement) {
        var props = vNode.props;
        var dom = vNode.dom;

        if ((0, _utils.isArray)(value) && (0, _utils.indexOf)(value, props.value) !== -1 || props.value === value) {
            dom.selected = true;
            if (!flag.hasSelected) flag.hasSelected = true;
        } else if (!(0, _utils.isNullOrUndefined)(value) || !(0, _utils.isNullOrUndefined)(props.selected)) {
            var selected = !!props.selected;
            if (!flag.hasSelected && selected) flag.hasSelected = true;
            dom.selected = selected;
        }
    }
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.processInput = processInput;

var _utils = __webpack_require__(0);

function processInput(vNode, dom, nextProps) {
    var type = nextProps.type;
    var value = nextProps.value;
    var checked = nextProps.checked;
    var defaultValue = nextProps.defaultValue;
    var multiple = nextProps.multiple;
    var hasValue = !(0, _utils.isNullOrUndefined)(value);

    if (multiple && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!(0, _utils.isNullOrUndefined)(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!(0, _utils.isNullOrUndefined)(checked)) {
            dom.checked = checked;
        }
    } else {
        if (hasValue && dom.value !== value) {
            dom.value = value;
        } else if (!(0, _utils.isNullOrUndefined)(checked)) {
            dom.checked = checked;
        }
    }
}

function isCheckedType(type) {
    return type === 'checkbox' || type === 'radio';
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.processTextarea = processTextarea;

var _utils = __webpack_require__(0);

function processTextarea(vNode, dom, nextProps, isRender) {
    var value = nextProps.value;
    var domValue = dom.value;

    if ((0, _utils.isNullOrUndefined)(value)) {
        if (isRender) {
            var defaultValue = nextProps.defaultValue;
            if (!(0, _utils.isNullOrUndefined)(defaultValue)) {
                if (defaultValue !== domValue) {
                    dom.value = defaultValue;
                }
            } else if (domValue !== '') {
                dom.value = '';
            }
        }
    } else {
        if (domValue !== value) {
            dom.value = value;
        }
    }
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.toString = toString;
exports.escapeText = escapeText;
exports.isString = isString;
exports.isNumber = isNumber;
exports.renderStylesToString = renderStylesToString;
exports.renderDatasetToString = renderDatasetToString;
exports.renderAttributesToString = renderAttributesToString;

var _vnode = __webpack_require__(1);

var _utils = __webpack_require__(0);

var _vpatch = __webpack_require__(4);

function toString(vNode, parent, disableSplitText, firstChild) {
    var type = vNode.type;
    var tag = vNode.tag;
    var props = vNode.props;
    var children = vNode.children;

    var html = void 0;
    if (type & _vnode.Types.ComponentClass) {
        var instance = new tag(props);
        html = instance.toString();
    } else if (type & _vnode.Types.ComponentInstance) {
        html = vNode.children.toString();
    } else if (type & _vnode.Types.Element) {
        var innerHTML = void 0;
        html = '<' + tag;

        if (!(0, _utils.isNullOrUndefined)(vNode.className)) {
            html += ' class="' + escapeText(vNode.className) + '"';
        }

        if (props !== _vnode.EMPTY_OBJ) {
            for (var prop in props) {
                var value = props[prop];

                if (prop === 'innerHTML') {
                    innerHTML = value;
                } else if (prop === 'style') {
                    html += ' style="' + renderStylesToString(value) + '"';
                } else if (prop === 'children' || prop === 'className' || prop === 'key' || prop === 'ref') {
                    // ignore
                } else if (prop === 'defaultValue') {
                    if ((0, _utils.isNullOrUndefined)(props.value) && !(0, _utils.isNullOrUndefined)(value)) {
                        html += ' value="' + (isString(value) ? escapeText(value) : value) + '"';
                    }
                } else if (prop === 'defaultChecked') {
                    if ((0, _utils.isNullOrUndefined)(props.checked) && value === true) {
                        html += ' checked';
                    }
                } else if (prop === 'attributes') {
                    html += renderAttributesToString(value);
                } else if (prop === 'dataset') {
                    html += renderDatasetToString(value);
                } else if (tag === 'option' && prop === 'value') {
                    html += renderAttributeToString(prop, value);
                    if (parent && value === parent.props.value) {
                        html += ' selected';
                    }
                } else {
                    html += renderAttributeToString(prop, value);
                }
            }
        }

        if (_utils.selfClosingTags[tag]) {
            html += ' />';
        } else {
            html += '>';
            if (innerHTML) {
                html += innerHTML;
            } else if (!(0, _utils.isNullOrUndefined)(children)) {
                if (isString(children)) {
                    html += children === '' ? ' ' : escapeText(children);
                } else if (isNumber(children)) {
                    html += children;
                } else if ((0, _utils.isArray)(children)) {
                    var index = -1;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (isString(child)) {
                            html += child === '' ? ' ' : escapeText(child);
                        } else if (isNumber(child)) {
                            html += child;
                        } else if (!(0, _utils.isNullOrUndefined)(child)) {
                            if (!(child.type & _vnode.Types.Text)) {
                                index = -1;
                            } else {
                                index++;
                            }
                            html += toString(child, vNode, disableSplitText, index === 0);
                        }
                    }
                } else {
                    html += toString(children, vNode, disableSplitText, true);
                }
            }

            html += '</' + tag + '>';
        }
    } else if (type & _vnode.Types.Text) {
        html = (firstChild || disableSplitText ? '' : '<!---->') + (children === '' ? ' ' : escapeText(children));
    } else if (type & _vnode.Types.HtmlComment) {
        html = '<!--' + children + '-->';
    } else if (type & _vnode.Types.UnescapeText) {
        html = (0, _utils.isNullOrUndefined)(children) ? '' : children;
    } else {
        throw new Error('Unknown vNode: ' + vNode);
    }

    return html;
}

function escapeText(text) {
    var result = text;
    var escapeString = "";
    var start = 0;
    var i = void 0;
    for (i = 0; i < text.length; i++) {
        switch (text.charCodeAt(i)) {
            case 34:
                // "
                escapeString = "&quot;";
                break;
            case 39:
                // \
                escapeString = "&#039;";
                break;
            case 38:
                // &
                escapeString = "&amp;";
                break;
            case 60:
                // <
                escapeString = "&lt;";
                break;
            case 62:
                // >
                escapeString = "&gt;";
                break;
            default:
                continue;
        }
        if (start) {
            result += text.slice(start, i);
        } else {
            result = text.slice(start, i);
        }
        result += escapeString;
        start = i + 1;
    }
    if (start && i !== start) {
        return result + text.slice(start, i);
    }
    return result;
}

function isString(o) {
    return typeof o === 'string';
}

function isNumber(o) {
    return typeof o === 'number';
}

function renderStylesToString(styles) {
    if ((0, _utils.isStringOrNumber)(styles)) {
        return styles;
    } else {
        var renderedString = "";
        for (var styleName in styles) {
            var value = styles[styleName];

            if ((0, _utils.isStringOrNumber)(value)) {
                renderedString += (0, _vpatch.kebabCase)(styleName) + ':' + value + ';';
            }
        }
        return renderedString;
    }
}

function renderDatasetToString(dataset) {
    var renderedString = '';
    for (var key in dataset) {
        var dataKey = 'data-' + (0, _vpatch.kebabCase)(key);
        var value = dataset[key];
        if (isString(value)) {
            renderedString += ' ' + dataKey + '="' + escapeText(value) + '"';
        } else if (isNumber(value)) {
            renderedString += ' ' + dataKey + '="' + value + '"';
        } else if (value === true) {
            renderedString += ' ' + dataKey + '="true"';
        }
    }
    return renderedString;
}

function renderAttributesToString(attributes) {
    var renderedString = '';
    for (var key in attributes) {
        renderedString += renderAttributeToString(key, attributes[key]);
    }
    return renderedString;
}

function renderAttributeToString(key, value) {
    if (isString(value)) {
        return ' ' + key + '="' + escapeText(value) + '"';
    } else if (isNumber(value)) {
        return ' ' + key + '="' + value + '"';
    } else if (value === true) {
        return ' ' + key;
    } else {
        return '';
    }
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.hydrateRoot = hydrateRoot;
exports.hydrate = hydrate;
exports.hydrateElement = hydrateElement;

var _vnode = __webpack_require__(1);

var _vdom = __webpack_require__(5);

var _utils = __webpack_require__(0);

var _vpatch = __webpack_require__(4);

var _process = __webpack_require__(7);

function hydrateRoot(vNode, parentDom, mountedQueue) {
    if (!(0, _utils.isNullOrUndefined)(parentDom)) {
        var dom = parentDom.firstChild;
        if ((0, _utils.isNullOrUndefined)(dom)) {
            return (0, _vdom.render)(vNode, parentDom, mountedQueue, null, false);
        }
        var newDom = hydrate(vNode, dom, mountedQueue, parentDom, null, false);
        dom = dom.nextSibling;
        // should only one entry
        while (dom) {
            var next = dom.nextSibling;
            parentDom.removeChild(dom);
            dom = next;
        }
        return newDom;
    }
    return null;
}

function hydrate(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG) {
    if (dom !== null) {
        var isTrigger = true;
        if (mountedQueue) {
            isTrigger = false;
        } else {
            mountedQueue = new _utils.MountedQueue();
        }
        dom = hydrateElement(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG);
        if (isTrigger) {
            mountedQueue.trigger();
        }
    }
    return dom;
}

function hydrateElement(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG) {
    var type = vNode.type;

    if (type & _vnode.Types.Element) {
        return hydrateHtmlElement(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG);
    } else if (type & _vnode.Types.Text) {
        return hydrateText(vNode, dom);
    } else if (type & _vnode.Types.HtmlComment) {
        return hydrateComment(vNode, dom);
    } else if (type & _vnode.Types.ComponentClassOrInstance) {
        return hydrateComponentClassOrInstance(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG);
    }
}

function hydrateComponentClassOrInstance(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG) {
    var props = vNode.props;
    var instance = vNode.type & _vnode.Types.ComponentClass ? new vNode.tag(props) : vNode.children;
    instance.parentDom = parentDom;
    instance.mountedQueue = mountedQueue;
    instance.isRender = true;
    instance.parentVNode = parentVNode;
    instance.isSVG = isSVG;
    instance.vNode = vNode;
    var newDom = instance.hydrate(vNode, dom);

    vNode.dom = newDom;
    vNode.children = instance;
    vNode.parentVNode = parentVNode;

    if (typeof instance.mount === 'function') {
        mountedQueue.push(function () {
            return instance.mount(null, vNode);
        });
    }

    var ref = vNode.ref;
    if (typeof ref === 'function') {
        ref(instance);
    }

    if (dom !== newDom && dom.parentNode) {
        dom.parentNode.replaceChild(newDom, dom);
    }

    return dom;
}

function hydrateComment(vNode, dom) {
    if (dom.nodeType !== 8) {
        var newDom = (0, _vdom.createCommentElement)(vNode, null);
        dom.parentNode.replaceChild(newDom, dom);
        return newDom;
    }
    var comment = vNode.children;
    if (dom.data !== comment) {
        dom.data = comment;
    }
    vNode.dom = dom;
    return dom;
}

function hydrateText(vNode, dom) {
    if (dom.nodeType !== 3) {
        var newDom = (0, _vdom.createTextElement)(vNode, null);
        dom.parentNode.replaceChild(newDom, dom);

        return newDom;
    }

    var text = vNode.children;
    if (dom.nodeValue !== text) {
        dom.nodeValue = text;
    }
    vNode.dom = dom;

    return dom;
}

function hydrateHtmlElement(vNode, dom, mountedQueue, parentDom, parentVNode, isSVG) {
    var children = vNode.children;
    var props = vNode.props;
    var className = vNode.className;
    var type = vNode.type;
    var ref = vNode.ref;

    vNode.parentVNode = parentVNode;
    isSVG = isSVG || (type & _vnode.Types.SvgElement) > 0;

    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.tag) {
        warning('Server-side markup doesn\'t match client-side markup');
        var newDom = (0, _vdom.createElement)(vNode, null, mountedQueue, parentDom, parentVNode, isSVG);
        dom.parentNode.replaceChild(newDom, dom);

        return newDom;
    }

    vNode.dom = dom;
    if (!(0, _utils.isNullOrUndefined)(children)) {
        hydrateChildren(children, dom, mountedQueue, vNode, isSVG);
    } else if (dom.firstChild !== null) {
        (0, _utils.setTextContent)(dom, '');
    }

    if (props !== _vnode.EMPTY_OBJ) {
        var isFormElement = (type & _vnode.Types.FormElement) > 0;
        for (var prop in props) {
            (0, _vpatch.patchProp)(prop, null, props[prop], dom, isFormElement, isSVG);
        }
        if (isFormElement) {
            (0, _process.processForm)(vNode, dom, props, true);
        }
    }

    if (!(0, _utils.isNullOrUndefined)(className)) {
        if (isSVG) {
            dom.setAttribute('class', className);
        } else {
            dom.className = className;
        }
    } else if (dom.className !== '') {
        dom.removeAttribute('class');
    }

    if (ref) {
        (0, _vdom.createRef)(dom, ref, mountedQueue);
    }

    return dom;
}

function hydrateChildren(children, parentDom, mountedQueue, parentVNode, isSVG) {
    normalizeChildren(parentDom);
    var dom = parentDom.firstChild;

    if ((0, _utils.isStringOrNumber)(children)) {
        if (dom !== null && dom.nodeType === 3) {
            if (dom.nodeValue !== children) {
                dom.nodeValue = children;
            }
        } else if (children === '') {
            parentDom.appendChild(document.createTextNode(''));
        } else {
            (0, _utils.setTextContent)(parentDom, children);
        }
        if (dom !== null) {
            dom = dom.nextSibling;
        }
    } else if ((0, _utils.isArray)(children)) {
        for (var i = 0; i < children.length; i++) {
            var child = children[i];

            if (!(0, _utils.isNullOrUndefined)(child)) {
                if (dom !== null) {
                    var nextSibling = dom.nextSibling;
                    hydrateElement(child, dom, mountedQueue, parentDom, parentVNode, isSVG);
                    dom = nextSibling;
                } else {
                    (0, _vdom.createElement)(child, parentDom, mountedQueue, true, parentVNode, isSVG);
                }
            }
        }
    } else {
        if (dom !== null) {
            hydrateElement(children, dom, mountedQueue, parentDom, parentVNode, isSVG);
            dom = dom.nextSibling;
        } else {
            (0, _vdom.createElement)(children, parentDom, mountedQueue, true, parentVNode, isSVG);
        }
    }

    // clear any other DOM nodes, there should be on a single entry for the root
    while (dom) {
        var _nextSibling = dom.nextSibling;
        parentDom.removeChild(dom);
        dom = _nextSibling;
    }
}

function normalizeChildren(parentDom) {
    var dom = parentDom.firstChild;

    while (dom) {
        if (dom.nodeType === 8 && dom.data === '') {
            var lastDom = dom.previousSibling;
            parentDom.removeChild(dom);
            dom = lastDom || parentDom.firstChild;
        } else {
            dom = dom.nextSibling;
        }
    }
}

var warning = (typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object' ? function (message) {
    console.warn(message);
} : function () {};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.nextFrame = nextFrame;

var _intact = __webpack_require__(11);

var _intact2 = _interopRequireDefault(_intact);

var _vnode = __webpack_require__(1);

var _utils = __webpack_require__(6);

var _vdt = __webpack_require__(3);

var _vdt2 = _interopRequireDefault(_vdt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var Animate = void 0;
exports['default'] = Animate = _intact2['default'].extend({
    defaults: {
        'a:tag': 'div',
        'a:transition': 'animate',
        'a:appear': false,
        'a:mode': 'both', // out-in | in-out | both
        'a:disabled': false, // 只做动画管理者，自己不进行动画
        'a:move': true, // 是否执行move动画
        'a:css': true, // 是否使用css动画，如果自定义动画函数，可以将它置为false
        'a:delayDestroy': true // 是否动画完成才destroy子元素
    },

    template: function template() {
        var h = _vdt2['default'].miss.h;
        var self = this.data;
        var tagName = self.get('a:tag');
        var props = {};
        var _props = self.get();
        for (var key in _props) {
            if (key !== 'ref' && key !== 'key' && (key[0] !== 'a' || key[1] !== ':') && key.substr(0, 5) !== 'ev-a:') {
                props[key] = _props[key];
            }
        }
        return h(tagName, props, self.get('children'));
    },
    _init: function _init() {
        this.isSupportCssTransition = endEvents.length;
        if (!this.isSupportCssTransition) {
            // 如果不支持css动画，则关闭css
            this.set({
                'a:css': false,
                'a:move': false
            }, { silent: true });
        }

        this.mountChildren = [];
        this.unmountChildren = [];
        this.updateChildren = [];
        this.children = [];
        this._enteringAmount = 0;
        this._leavingAmount = 0;
    },
    _hasJsTransition: function _hasJsTransition() {
        var events = this._events;
        for (var key in events) {
            if (key[0] === 'a' && key[1] === ':') {
                if (events[key].length) {
                    return true;
                }
            }
        }
        return false;
    },


    init: _utils.inBrowser ? function (lastVNode, nextVNode) {
        // if (this.get('a:disabled')) {
        // return this._super(lastVNode, nextVNode);
        // }

        var parentDom = this.parentVNode && this.parentVNode.dom || this.parentDom;
        if (parentDom && parentDom._reserve) {
            lastVNode = parentDom._reserve[nextVNode.key];
        }
        return this._super(lastVNode, nextVNode);
    } : function () {
        return this._superApply(arguments);
    },

    _mount: function _mount(lastVNode, vNode) {
        var _this = this;

        var isAppear = false;
        if (this.isRender) {
            var parent = void 0;
            if (this.get('a:appear') && (this.parentDom || (parent = this.parentVNode) && parent.type & _vnode.Types.ComponentClassOrInstance && !parent.children.isRender)) {
                isAppear = true;
            }
        }

        var element = this.element;

        var initClassName = function initClassName(c, newValue, oldValue) {
            var transition = _this.get('a:transition');
            var enterClass = void 0;
            var enterActiveClass = void 0;
            if (isAppear) {
                enterClass = transition + '-appear';
                enterActiveClass = transition + '-appear-active';
            } else {
                enterClass = transition + '-enter';
                enterActiveClass = transition + '-enter-active';
            }

            _this.isAppear = isAppear;
            _this.enterClass = enterClass;
            _this.enterActiveClass = enterActiveClass;
            _this.leaveClass = transition + '-leave';
            _this.leaveActiveClass = transition + '-leave-active';
            _this.moveClass = transition + '-move';
            _this.enterEventName = isAppear ? 'a:appear' : 'a:enter';

            if (oldValue) {
                element.className = element.className.replace(new RegExp('\\b(' + oldValue + '(?=\\-(appear|enter|leave|move)))', 'g'), newValue);
            }
        };
        this.on('$change:a:transition', initClassName);
        initClassName();

        // 一个动画元素被删除后，会被保存
        // 如果在删除的过程中，又添加了，则要清除上一个动画状态
        // 将这种情况记录下来
        if (this._lastVNode && this._lastVNode !== lastVNode) {
            var lastInstance = this._lastVNode.children;
            if (lastInstance._leaving) {
                this.lastInstance = lastInstance;
            }
        }

        var parentInstance = this.parentInstance = this._getParentAnimate();

        this._enterEnd = function (e) {
            if (e && e.target !== element) return;

            if (_this.get('a:css') && !_this.get('a:disabled')) {
                e && e.stopPropagation && e.stopPropagation();
                removeClass(element, _this.enterClass);
                removeClass(element, _this.enterActiveClass);
            }
            TransitionEvents.off(element, _this._enterEnd);
            _this._entering = false;
            if (parentInstance) {
                if (--parentInstance._enteringAmount === 0 && parentInstance.get('a:mode') === 'in-out') {
                    nextFrame(function () {
                        parentInstance._checkMode();
                    });
                }
            }
            _this.trigger(_this.enterEventName + 'End', element);
        };

        element._unmount = function (nouse, parentDom) {
            // 如果该元素是延迟mount的元素，则直接删除
            if (_this._delayEnter) {
                parentDom.removeChild(element);
                _this.destroy(vNode);
                parentInstance._enteringAmount--;
                return;
            }
            var isNotAnimate = !_this.get('a:css') && !_this._hasJsTransition() || _this.get('a:disabled');
            _this.vNode = vNode;
            _this.parentDom = parentDom;
            if (parentInstance && !isNotAnimate) {
                parentInstance._leavingAmount++;
                if (parentInstance.get('a:mode') === 'in-out') {
                    parentInstance.updateChildren.push(_this);
                    _this._delayLeave = true;
                } else {
                    parentInstance.unmountChildren.push(_this);
                }
                parentInstance.children.push(_this);
            } else if (isNotAnimate) {
                parentDom.removeChild(element);
                _this.destroy(vNode);
            } else {
                _this._unmount();
            }
        };

        if (parentInstance) {
            // 如果存在父动画组件，则使用父级进行管理
            // 统一做动画
            if (isAppear || !this.isRender) {
                if (this.lastInstance && this.lastInstance._delayLeave) {
                    parentInstance.updateChildren.push(this);
                } else {
                    parentInstance._enteringAmount++;
                    // 如果没有unmount的元素，则直接enter
                    if (parentInstance._leavingAmount > 0 && parentInstance.get('a:mode') === 'out-in') {
                        this._delayEnter = true;
                        element.style.display = 'none';
                    } else {
                        parentInstance.mountChildren.push(this);
                    }
                }
            }
            parentInstance.children.push(this);
        } else if (isAppear || !this.isRender) {
            // 否则单个元素自己动画
            this._enter();
        }
    },
    _getParentAnimate: function _getParentAnimate() {
        // 根节点为Animate，不存在parentVNode
        if (!this.parentVNode) return;
        // this.parentVNode是animate的tag，所以要拿this.parentVNode.parentVNode
        var parentVNode = this.parentVNode.parentVNode;
        if (parentVNode) {
            var parentInstance = parentVNode.children;
            if (parentInstance instanceof Animate) {
                return parentInstance;
            }
        }
    },
    _unmount: function _unmount() {
        var _this2 = this;

        if (this.get('a:disabled')) return;
        var element = this.element;
        var vNode = this.vNode;
        var parentDom = this.parentDom;
        // vNode都会被添加key，当只有一个子元素时，vNode.key === undefined
        // 这种情况，我们也当成有key处理，此时key为undefined
        if (!parentDom._reserve) {
            parentDom._reserve = {};
        }
        parentDom._reserve[vNode.key] = vNode;

        this._leaving = true;

        if (this._entering) {
            TransitionEvents.off(element, this._enterEnd);
            this._enterEnd();
        }

        this._leaveEnd = function (e) {
            if (e && e.target !== element) return;

            if (_this2.get('a:css') && !_this2.get('a:disabled')) {
                e && e.stopPropagation && e.stopPropagation();
                removeClass(element, _this2.leaveClass);
                removeClass(element, _this2.leaveActiveClass);
            }
            if (_this2._triggeredLeave) {
                var s = element.style;
                s.position = s.top = s.left = s.transform = s.WebkitTransform = '';
            }
            _this2._leaving = false;
            delete parentDom._reserve[vNode.key];
            TransitionEvents.off(element, _this2._leaveEnd);
            var parentInstance = _this2.parentInstance;
            if (parentInstance) {
                if (--parentInstance._leavingAmount === 0 && parentInstance.get('a:mode') === 'out-in') {
                    parentInstance._checkMode();
                }
            }
            _this2.trigger('a:leaveEnd', element);
            if (!_this2._unmountCancelled) {
                parentDom.removeChild(element);
                if (_this2.get('a:delayDestroy')) {
                    _this2.destroy(vNode, null, parentDom);
                }
            }
        };

        this._leave();
        // 存在一种情况，相同的dom，同时被子组件和父组件管理的情况
        // 所以unmount后，将其置为空函数，以免再次unmount
        element._unmount = _utils.noop;

        this.trigger('a:leaveStart', element);
    },
    _beforeUpdate: function _beforeUpdate(lastVNode, vNode) {
        // 更新之前，这里的children不包含本次更新mount进来的元素
        var children = this.children;
        var reservedChildren = [];
        var isMove = this.get('a:move');
        for (var i = 0; i < children.length; i++) {
            var instance = children[i];
            if (!instance._leaving && isMove) {
                instance.position = instance._getPosition();
            }
            if (instance._delayLeave) {
                reservedChildren.push(instance);
                this.updateChildren.push(instance);
            }
        }
        this.children = reservedChildren;
    },
    _getPosition: function _getPosition() {
        var element = this.element;
        var style = getComputedStyle(element);
        var transform = style.transform || style.WebkitTransform;
        if (transform === 'none') {
            return {
                top: element.offsetTop,
                left: element.offsetLeft
            };
        }
        // const transform = element.style.transform;
        var matrix = new CSSMatrix(transform);
        return {
            top: element.offsetTop + matrix.m42,
            left: element.offsetLeft + matrix.m41
        };
    },


    /**
     * 尽量保持动画的连贯性
     */
    _update: function _update(lastVNode, vNode, isFromCheckMode) {
        var parentInstance = void 0;
        if (!this.get('a:disabled')) {
            parentInstance = this.parentInstance;
            if (parentInstance) {
                parentInstance.updateChildren.push(this);
                parentInstance.children.push(this);
            }
        }

        // 更新之后，这里的children包括当前mount/update/unmount的元素
        var children = this.children;
        // 不存在children，则表示没有子动画元素要管理，直接返回
        if (!children.length) return;

        var mountChildren = this.mountChildren;
        var unmountChildren = this.unmountChildren;
        var updateChildren = this.updateChildren;
        var isMove = this.get('a:move');

        // 如果是in-out模式，但是没有元素enter，则直接leave
        if (!isFromCheckMode && this._enteringAmount === 0 && parentInstance && parentInstance.get('a:mode') === 'in-out') {
            for (var i = 0; i < updateChildren.length; i++) {
                var instance = updateChildren[i];
                if (instance._delayLeave) {
                    unmountChildren.push(instance);
                    updateChildren.splice(i, 1);
                    instance._delayLeave = false;
                    i--;
                }
            }
        }

        // 进行mount元素的进入动画
        // 因为存在moving元素被unmount又被mount的情况
        // 所以最先处理
        if (isMove) {
            mountChildren.forEach(function (instance) {
                // 如果当前元素是从上一个unmount的元素来的，
                // 则要初始化最新位置，因为beforeUpdate中
                // 不包括当前mount元素的位置初始化
                // 这样才能保持位置的连贯性
                if (instance.lastInstance) {
                    instance.position = instance._getPosition();
                }
            });
        }
        mountChildren.forEach(function (instance) {
            return instance._enter();
        });

        // 先将之前的动画清空
        // 只有既在move又在enter的unmount元素才清空动画
        // 这种情况保持不了连贯性
        if (isMove) {
            unmountChildren.forEach(function (instance) {
                if (instance._moving) {
                    instance._moveEnd();
                    if (instance._entering) {
                        instance._enterEnd();
                    }
                }
            });

            // 对于更新的元素，如果正在move，则将位置清空，以便确定最终位置
            updateChildren.forEach(function (instance) {
                if (instance._moving) {
                    var s = instance.element.style;
                    s.left = s.top = '';
                }
            });

            // 将要删除的元素，设为absolute，以便确定其它元素最终位置
            unmountChildren.forEach(function (instance) {
                instance.element.style.position = 'absolute';
            });

            // 获取所有元素的新位置
            children.forEach(function (instance) {
                instance.newPosition = instance._getPosition();
            });

            // 分别判断元素是否需要移动，并保持当前位置不变
            // unmount的元素，从当前位置直接leave，不要move了
            unmountChildren.forEach(function (instance) {
                return instance._initMove(true);
            });
            updateChildren.forEach(function (instance) {
                return instance._initMove();
            });
            mountChildren.forEach(function (instance) {
                return instance._initMove();
            });

            // 对于animation动画，enterEnd了entering元素
            // 需要re-layout，来触发move动画
            document.body.offsetWidth;

            // 如果元素需要移动，则进行move动画
            children.forEach(function (instance) {
                if (instance._needMove) {
                    if (!instance._moving) {
                        instance._move();
                    } else {
                        // 如果已经在移动了，那直接改变translate，保持动画连贯
                        instance._triggerMove();
                    }
                }
            });
        }

        // unmount元素做leave动画
        unmountChildren.forEach(function (instance) {
            return instance._unmount();
        });

        this.mountChildren = [];
        this.updateChildren = [];
        this.unmountChildren = [];
    },
    _checkMode: function _checkMode() {
        var mountChildren = [];
        var updateChildren = [];
        var unmountChildren = [];
        var children = this.children = this.children.filter(function (instance) {
            if (instance._delayEnter) {
                instance._delayEnter = false;
                mountChildren.push(instance);
                return false;
            } else if (instance._delayLeave) {
                instance._delayLeave = false;
                unmountChildren.push(instance);
                return true;
            } else if (instance._leaving !== false) {
                updateChildren.push(instance);
                return true;
            }
            return false;
        });
        this._beforeUpdate();
        mountChildren.forEach(function (instance) {
            instance.element.style.display = '';
            instance.position = null;
        });
        this.mountChildren = mountChildren;
        this.updateChildren = updateChildren;
        this.unmountChildren = unmountChildren;
        this.children = children.concat(mountChildren);
        this._update(null, null, true);
    },
    _initMove: function _initMove(isUnmount) {
        var element = this.element;
        var oldPosition = this.position;
        var newPosition = this.newPosition;

        this.position = newPosition;

        // 对于新mount的元素，不进行move判断
        if (!oldPosition) return;

        var dx = oldPosition.left - newPosition.left;
        var dy = oldPosition.top - newPosition.top;
        var oDx = this.dx;
        var oDy = this.dy;

        this.dx = dx;
        this.dy = dy;

        if (dx || dy || oDx || oDy) {
            // 对于move中的元素，需要将它重新回到0
            var s = element.style;
            if (isUnmount) {
                s.left = oldPosition.left + 'px';
                s.top = oldPosition.top + 'px';
                this._needMove = false;
            } else {
                // 如果当前元素正在enter，而且是animation动画，则要enterEnd
                // 否则无法move
                if (this._entering && getAnimateType(element) !== 'transition') {
                    this._enterEnd();
                }
                this._needMove = true;
                s.position = 'relative';
                s.left = dx + 'px';
                s.top = dy + 'px';
            }
        } else {
            this._needMove = false;
        }
    },
    _move: function _move() {
        var _this3 = this;

        if (this.get('a:disabled')) return;
        this._moving = true;
        var element = this.element;
        var s = element.style;
        addClass(element, this.moveClass);
        this._moveEnd = function (e) {
            e && e.stopPropagation();
            if (!e || /transform$/.test(e.propertyName)) {
                TransitionEvents.off(element, _this3._moveEnd);
                removeClass(element, _this3.moveClass);
                s.position = s.left = s.top = s.transform = s.WebkitTransform = '';
                _this3.dx = _this3.dy = 0;
                _this3._moving = false;
            }
        };
        TransitionEvents.on(element, this._moveEnd);
        this._triggerMove();
        // nextFrame(() => this._triggerMove());
    },
    _triggerMove: function _triggerMove() {
        var s = this.element.style;
        s.transform = s.WebkitTransform = 'translate(' + (0 - this.dx) + 'px, ' + (0 - this.dy) + 'px)';
    },
    _enter: function _enter() {
        var _this4 = this;

        if (this.get('a:disabled')) return;
        this._entering = true;
        var element = this.element;
        var enterClass = this.enterClass;
        var enterActiveClass = this.enterActiveClass;
        var isCss = this.get('a:css');

        // getAnimateType将添加enter-active className，在firefox下将导致动画提前执行
        // 我们应该先于添加`enter` className去调用该函数
        var isTransition = false;
        if (isCss && getAnimateType(element, enterActiveClass) !== 'animation') {
            isTransition = true;
        }

        // 如果这个元素是上一个删除的元素，则从当前状态回到原始状态
        if (this.lastInstance) {
            this.lastInstance._unmountCancelled = true;
            this.lastInstance._leaveEnd();

            if (isCss) {
                if (this.lastInstance._triggeredLeave) {
                    // addClass(element, enterActiveClass);
                    // 保持连贯，添加leaveActiveClass
                    addClass(element, this.leaveActiveClass);
                } else {
                    // 如果上一个元素还没来得及做动画，则当做新元素处理
                    addClass(element, enterClass);
                }
            }
        } else if (isCss) {
            addClass(element, enterClass);
        }
        TransitionEvents.on(element, this._enterEnd);

        this.trigger(this.enterEventName + 'Start', element);

        if (isTransition) {
            nextFrame(function () {
                return _this4._triggerEnter();
            });
        } else {
            // 对于animation动画，同步添加enterActiveClass，避免闪动
            this._triggerEnter();
        }
    },
    _triggerEnter: function _triggerEnter() {
        var element = this.element;
        this._triggeredEnter = true;
        if (this.get('a:css')) {
            if (this._entering === false) {
                return removeClass(element, this.enterActiveClass);
            }
            addClass(element, this.enterActiveClass);
            removeClass(element, this.enterClass);
            removeClass(element, this.leaveActiveClass);
        }
        this.trigger(this.enterEventName, element, this._enterEnd);
    },
    _leave: function _leave() {
        var _this5 = this;

        var element = this.element;
        // 为了保持动画连贯，我们立即添加leaveActiveClass
        // 但如果当前元素还没有来得及做enter动画，就被删除
        // 则leaveActiveClass和leaveClass都放到下一帧添加
        // 否则leaveClass和enterClass一样就不会有动画效果
        if (this._triggeredEnter && this.get('a:css')) {
            addClass(element, this.leaveActiveClass);
        }
        // TransitionEvents.on(element, this._leaveEnd);
        nextFrame(function () {
            // 1. 如果leave动画还没得及执行，就enter了，此时啥也不做
            if (_this5._unmountCancelled) return;
            // 存在一种情况，当一个enter动画在完成的瞬间，
            // 这个元素被删除了，由于前面保持动画的连贯性
            // 添加了leaveActiveClass，则会导致绑定的leaveEnd
            // 立即执行，所以这里放到下一帧来绑定
            TransitionEvents.on(element, _this5._leaveEnd);
            _this5._triggerLeave();
        });
    },
    _triggerLeave: function _triggerLeave() {
        this._triggeredLeave = true;
        if (this._leaving === false) {
            return;
        }
        var element = this.element;
        if (this.get('a:css')) {
            addClass(element, this.leaveActiveClass);
            addClass(element, this.leaveClass);
        }
        this.trigger('a:leave', element, this._leaveEnd);
    },
    destroy: function destroy(lastVNode, nextVNode, parentDom) {
        // 1: 不存在parentDom，有两种情况：
        //      1): 父元素也要被销毁，此时: !parentDom && lastVNode && !nextVNode
        //      2): 该元素将被替换，此时：!parentDom && lastVNode && nextVNode
        //      对于1)，既然父元素要销毁，那本身也要直接销毁
        //      对于2)，本身必须待动画结束方能销毁
        // 2: 如果该元素已经动画完成，直接销毁
        // 3: 如果直接调用destroy方法，则直接销毁，此时：!lastVNode && !nextVNode && !parentDom
        // 4: 如果不是延迟destroy子元素，则立即销毁
        if (!this.get('a:delayDestroy') || !parentDom && !nextVNode && this.parentVNode.dom !== this.element ||
        // this.get('a:disabled') || 
        this._leaving === false) {
            this._super(lastVNode, nextVNode, parentDom);
        }
    }
});


function addClass(element, className) {
    if (className) {
        if (element.classList) {
            element.classList.add(className);
        } else if (!hasClass(element, className)) {
            element.className += ' ' + className;
        }
    }
    return element;
}

function hasClass(element, className) {
    if (element.classList) {
        return !!className && element.className.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
}

function removeClass(element, className) {
    if (className) {
        if (element.classList) {
            element.classList.remove(className);
        } else if (hasClass(element, className)) {
            element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
            .replace(/^\s*|\s*$/g, ''); // trim the ends
        }
    }
}

var EVENT_NAME_MAP = {
    transitionend: {
        'transition': 'transitionend',
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'mozTransitionEnd',
        'OTransition': 'oTransitionEnd',
        'msTransition': 'MSTransitionEnd'
    },

    animationend: {
        'animation': 'animationend',
        'WebkitAnimation': 'webkitAnimationEnd',
        'MozAnimation': 'mozAnimationEnd',
        'OAnimation': 'oAnimationEnd',
        'msAnimation': 'MSAnimationEnd'
    }
};

var endEvents = [];
var transitionProp = 'transition';
var animationProp = 'animation';

function detectEvents() {
    var testEl = document.createElement('div');
    var style = testEl.style;

    // On some platforms, in particular some releases of Android 4.x,
    // the un-prefixed "animation" and "transition" properties are defined on the
    // style object but the events that fire will still be prefixed, so we need
    // to check if the un-prefixed events are useable, and if not remove them
    // from the map
    if (!('AnimationEvent' in window)) {
        delete EVENT_NAME_MAP.animationend.animation;
    }

    if (!('TransitionEvent' in window)) {
        delete EVENT_NAME_MAP.transitionend.transition;
    }

    for (var baseEventName in EVENT_NAME_MAP) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];
        for (var styleName in baseEvents) {
            if (styleName in style) {
                endEvents.push(baseEvents[styleName]);
                if (baseEventName === 'transitionend') {
                    transitionProp = styleName;
                } else {
                    animationProp = styleName;
                }
                break;
            }
        }
    }
}

function getAnimateType(element, className) {
    if (className) addClass(element, className);
    var style = window.getComputedStyle(element);
    var transitionDurations = style[transitionProp + 'Duration'].split(', ');
    var animationDurations = style[animationProp + 'Duration'].split(', ');
    var transitionDuration = getDuration(transitionDurations);
    var animationDuration = getDuration(animationDurations);
    if (className) removeClass(element, className);
    return transitionDuration > animationDuration ? 'transition' : 'animation';
}

function getDuration(durations) {
    return Math.max.apply(null, durations.map(function (d) {
        return d.slice(0, -1) * 1000;
    }));
}

function addEventListener(node, eventName, eventListener) {
    node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
    node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
    on: function on(node, eventListener) {
        if (endEvents.length === 0) {
            // If CSS transitions are not supported, trigger an "end animation"
            // event immediately.
            window.setTimeout(eventListener, 0);
            return;
        }
        endEvents.forEach(function (endEvent) {
            addEventListener(node, endEvent, eventListener);
        });
    },

    off: function off(node, eventListener) {
        if (endEvents.length === 0) {
            return;
        }
        endEvents.forEach(function (endEvent) {
            removeEventListener(node, endEvent, eventListener);
        });
    },

    one: function one(node, eventListener) {
        var listener = function listener() {
            eventListener.apply(this, arguments);
            TransitionEvents.off(node, listener);
        };
        TransitionEvents.on(node, listener);
    }
};

var raf = void 0;
function nextFrame(fn) {
    raf(function () {
        return raf(fn);
    });
}

if (_utils.inBrowser) {
    raf = window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

    detectEvents();
}

var CSSMatrix = typeof WebKitCSSMatrix !== 'undefined' ? WebKitCSSMatrix : function (transform) {
    this.m42 = 0;
    this.m41 = 0;
    var type = transform.slice(0, transform.indexOf('('));
    var parts = void 0;
    if (type === 'matrix3d') {
        parts = transform.slice(9, -1).split(',');
        this.m41 = parseFloat(parts[12]);
        this.m42 = parseFloat(parts[13]);
    } else if (type === 'matrix') {
        parts = transform.slice(7, -1).split(',');
        this.m41 = parseFloat(parts[4]);
        this.m42 = parseFloat(parts[5]);
    }
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _app = __webpack_require__(28);

var _app2 = _interopRequireDefault(_app);

var _loading = __webpack_require__(29);

var _loading2 = _interopRequireDefault(_loading);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _default = function (_Intact) {
    _inherits(_default, _Intact);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _default.prototype.defaults = function defaults() {
        return {
            view: undefined,
            loading: false
        };
    };

    _default.prototype.run = function run(data) {
        var _this2 = this;

        return function (Page) {
            _this2.set('loading', true);
            var page = new Page(data);
            _this2.set('view', page);
            // for debug
            window.__page__ = page;
            if (page.inited) {
                _this2.set('loading', false);
                $(window).scrollTop(0);
            } else {
                page.one('$inited', function () {
                    _this2.set('loading', false);
                    $(window).scrollTop(0);
                });
            }
        };
    };

    _createClass(_default, [{
        key: 'template',
        get: function get() {
            return _app2['default'];
        }
    }]);

    return _default;
}(Intact);

exports['default'] = _default;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(16)))

/***/ }),
/* 28 */
/***/ (function(module, exports) {

exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
  _Vdt || (_Vdt = Vdt);
  obj || (obj = {});
  blocks || (blocks = {});
  var h = _Vdt.miss.h,
      hc = _Vdt.miss.hc,
      hu = _Vdt.miss.hu,
      widgets = this && this.widgets || {},
      _blocks = {},
      __blocks = {},
      __u = _Vdt.utils,
      extend = __u.extend,
      _e = __u.error,
      _className = __u.className,
      __o = __u.Options,
      _getModel = __o.getModel,
      _setModel = __o.setModel,
      _setCheckboxModel = __u.setCheckboxModel,
      _detectCheckboxChecked = __u.detectCheckboxChecked,
      _setSelectModel = __u.setSelectModel,
      self = this.data,
      $this = this,
      scope = obj,
      Animate = self && self.Animate,
      parent = ($callee || {})._super;
  return h('div', null, ['\n    ', function () {
    try {
      return [self.get('view')][0];
    } catch (e) {
      _e(e);
    }
  }.call(this), '\n    ', function () {
    try {
      return [self.get('loading')][0];
    } catch (e) {
      _e(e);
    }
  }.call(this) ? h(Animate, { 'key': 'loading', 'className': 'spinner', 'a:transition': 'loading', 'children': [h('div', null, null, 'double-bounce1'), h('div', null, null, 'double-bounce2')], '_context': $this }) : undefined], 'app-wrapper');
};

module.exports = exports['default'];

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(30);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(10)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./loading.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./loading.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(9)(undefined);
// imports


// module
exports.push([module.i, ".spinner {\n  width: 40px;\n  height: 40px;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  margin-top: -20px;\n  margin-left: -20px;\n}\n.double-bounce1,\n.double-bounce2 {\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  background-color: #fe4444;\n  opacity: 0.6;\n  position: absolute;\n  top: 0;\n  left: 0;\n  -webkit-animation: sk-bounce 2s infinite ease-in-out;\n  animation: sk-bounce 2s infinite ease-in-out;\n}\n.double-bounce2 {\n  -webkit-animation-delay: -1s;\n  animation-delay: -1s;\n}\n@-webkit-keyframes sk-bounce {\n  0%, 100% {\n    -webkit-transform: scale(0);\n  }\n  50% {\n    -webkit-transform: scale(1);\n  }\n}\n.loading-enter,\n.loading-leave {\n  opacity: 0;\n}\n.loading-enter-active,\n.loading-leave-active {\n  transition: opacity 0.3s;\n}\n@-moz-keyframes sk-bounce {\n  0%, 100% {\n    transform: scale(0);\n    -webkit-transform: scale(0);\n  }\n  50% {\n    transform: scale(1);\n    -webkit-transform: scale(1);\n  }\n}\n@-webkit-keyframes sk-bounce {\n  0%, 100% {\n    transform: scale(0);\n    -webkit-transform: scale(0);\n  }\n  50% {\n    transform: scale(1);\n    -webkit-transform: scale(1);\n  }\n}\n@-o-keyframes sk-bounce {\n  0%, 100% {\n    transform: scale(0);\n    -webkit-transform: scale(0);\n  }\n  50% {\n    transform: scale(1);\n    -webkit-transform: scale(1);\n  }\n}\n@keyframes sk-bounce {\n  0%, 100% {\n    transform: scale(0);\n    -webkit-transform: scale(0);\n  }\n  50% {\n    transform: scale(1);\n    -webkit-transform: scale(1);\n  }\n}\n", ""]);

// exports


/***/ }),
/* 31 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//
// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).
// Version 1.2.6
//

(function (exports) {

  /*
   * browser.js: Browser specific functionality for director.
   *
   * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.
   * MIT LICENSE
   *
   */

  var dloc = document.location;

  function dlocHashEmpty() {
    // Non-IE browsers return '' when the address bar shows '#'; Director's logic
    // assumes both mean empty.
    return dloc.hash === '' || dloc.hash === '#';
  }

  var listener = {
    mode: 'modern',
    hash: dloc.hash,
    history: false,

    check: function check() {
      var h = dloc.hash;
      if (h != this.hash) {
        this.hash = h;
        this.onHashChanged();
      }
    },

    fire: function fire() {
      if (this.mode === 'modern') {
        this.history === true ? window.onpopstate() : window.onhashchange();
      } else {
        this.onHashChanged();
      }
    },

    init: function init(fn, history) {
      var self = this;
      this.history = history;

      if (!Router.listeners) {
        Router.listeners = [];
      }

      function onchange(onChangeEvent) {
        for (var i = 0, l = Router.listeners.length; i < l; i++) {
          Router.listeners[i](onChangeEvent);
        }
      }

      //note IE8 is being counted as 'modern' because it has the hashchange event
      if ('onhashchange' in window && (document.documentMode === undefined || document.documentMode > 7)) {
        // At least for now HTML5 history is available for 'modern' browsers only
        if (this.history === true) {
          // There is an old bug in Chrome that causes onpopstate to fire even
          // upon initial page load. Since the handler is run manually in init(),
          // this would cause Chrome to run it twise. Currently the only
          // workaround seems to be to set the handler after the initial page load
          // http://code.google.com/p/chromium/issues/detail?id=63040
          setTimeout(function () {
            window.onpopstate = onchange;
          }, 500);
        } else {
          window.onhashchange = onchange;
        }
        this.mode = 'modern';
      } else {
        //
        // IE support, based on a concept by Erik Arvidson ...
        //
        var frame = document.createElement('iframe');
        frame.id = 'state-frame';
        frame.style.display = 'none';
        document.body.appendChild(frame);
        this.writeFrame('');

        if ('onpropertychange' in document && 'attachEvent' in document) {
          document.attachEvent('onpropertychange', function () {
            if (event.propertyName === 'location') {
              self.check();
            }
          });
        }

        window.setInterval(function () {
          self.check();
        }, 50);

        this.onHashChanged = onchange;
        this.mode = 'legacy';
      }

      Router.listeners.push(fn);

      return this.mode;
    },

    destroy: function destroy(fn) {
      if (!Router || !Router.listeners) {
        return;
      }

      var listeners = Router.listeners;

      for (var i = listeners.length - 1; i >= 0; i--) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
        }
      }
    },

    setHash: function setHash(s) {
      // Mozilla always adds an entry to the history
      if (this.mode === 'legacy') {
        this.writeFrame(s);
      }

      if (this.history === true) {
        window.history.pushState({}, document.title, s);
        // Fire an onpopstate event manually since pushing does not obviously
        // trigger the pop event.
        this.fire();
      } else {
        dloc.hash = s[0] === '/' ? s : '/' + s;
      }
      return this;
    },

    writeFrame: function writeFrame(s) {
      // IE support...
      var f = document.getElementById('state-frame');
      var d = f.contentDocument || f.contentWindow.document;
      d.open();
      d.write("<script>_hash = '" + s + "'; onload = parent.listener.syncHash;<script>");
      d.close();
    },

    syncHash: function syncHash() {
      // IE support...
      var s = this._hash;
      if (s != dloc.hash) {
        dloc.hash = s;
      }
      return this;
    },

    onHashChanged: function onHashChanged() {}
  };

  var Router = exports.Router = function (routes) {
    if (!(this instanceof Router)) return new Router(routes);

    this.params = {};
    this.routes = {};
    this.methods = ['on', 'once', 'after', 'before'];
    this.scope = [];
    this._methods = {};

    this._insert = this.insert;
    this.insert = this.insertEx;

    this.historySupport = (window.history != null ? window.history.pushState : null) != null;

    this.configure();
    this.mount(routes || {});
  };

  Router.prototype.init = function (r) {
    var self = this,
        routeTo;
    this.handler = function (onChangeEvent) {
      var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;
      var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');
      self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);
    };

    listener.init(this.handler, this.history);

    if (this.history === false) {
      if (dlocHashEmpty() && r) {
        dloc.hash = r;
      } else if (!dlocHashEmpty()) {
        self.dispatch('on', '/' + dloc.hash.replace(/^(#\/|#|\/)/, ''));
      }
    } else {
      if (this.convert_hash_in_init) {
        // Use hash as route
        routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;
        if (routeTo) {
          window.history.replaceState({}, document.title, routeTo);
        }
      } else {
        // Use canonical url
        routeTo = this.getPath();
      }

      // Router has been initialized, but due to the chrome bug it will not
      // yet actually route HTML5 history state changes. Thus, decide if should route.
      if (routeTo || this.run_in_init === true) {
        this.handler();
      }
    }

    return this;
  };

  Router.prototype.explode = function () {
    var v = this.history === true ? this.getPath() : dloc.hash;
    if (v.charAt(1) === '/') {
      v = v.slice(1);
    }
    return v.slice(1, v.length).split("/");
  };

  Router.prototype.setRoute = function (i, v, val) {
    var url = this.explode();

    if (typeof i === 'number' && typeof v === 'string') {
      url[i] = v;
    } else if (typeof val === 'string') {
      url.splice(i, v, s);
    } else {
      url = [i];
    }

    listener.setHash(url.join('/'));
    return url;
  };

  //
  // ### function insertEx(method, path, route, parent)
  // #### @method {string} Method to insert the specific `route`.
  // #### @path {Array} Parsed path to insert the `route` at.
  // #### @route {Array|function} Route handlers to insert.
  // #### @parent {Object} **Optional** Parent "routes" to insert into.
  // insert a callback that will only occur once per the matched route.
  //
  Router.prototype.insertEx = function (method, path, route, parent) {
    if (method === "once") {
      method = "on";
      route = function (route) {
        var once = false;
        return function () {
          if (once) return;
          once = true;
          return route.apply(this, arguments);
        };
      }(route);
    }
    return this._insert(method, path, route, parent);
  };

  Router.prototype.getRoute = function (v) {
    var ret = v;

    if (typeof v === "number") {
      ret = this.explode()[v];
    } else if (typeof v === "string") {
      var h = this.explode();
      ret = h.indexOf(v);
    } else {
      ret = this.explode();
    }

    return ret;
  };

  Router.prototype.destroy = function () {
    listener.destroy(this.handler);
    return this;
  };

  Router.prototype.getPath = function () {
    var path = window.location.pathname;
    if (path.substr(0, 1) !== '/') {
      path = '/' + path;
    }
    return path;
  };
  function _every(arr, iterator) {
    for (var i = 0; i < arr.length; i += 1) {
      if (iterator(arr[i], i, arr) === false) {
        return;
      }
    }
  }

  function _flatten(arr) {
    var flat = [];
    for (var i = 0, n = arr.length; i < n; i++) {
      flat = flat.concat(arr[i]);
    }
    return flat;
  }

  function _asyncEverySeries(arr, iterator, callback) {
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    (function iterate() {
      iterator(arr[completed], function (err) {
        if (err || err === false) {
          callback(err);
          callback = function callback() {};
        } else {
          completed += 1;
          if (completed === arr.length) {
            callback();
          } else {
            iterate();
          }
        }
      });
    })();
  }

  function paramifyString(str, params, mod) {
    mod = str;
    for (var param in params) {
      if (params.hasOwnProperty(param)) {
        mod = params[param](str);
        if (mod !== str) {
          break;
        }
      }
    }
    return mod === str ? "([._a-zA-Z0-9-%()]+)" : mod;
  }

  function regifyString(str, params) {
    var matches,
        last = 0,
        out = "";
    while (matches = str.substr(last).match(/[^\w\d\- %@&]*\*[^\w\d\- %@&]*/)) {
      last = matches.index + matches[0].length;
      matches[0] = matches[0].replace(/^\*/, "([_.()!\\ %@&a-zA-Z0-9-]+)");
      out += str.substr(0, matches.index) + matches[0];
    }
    str = out += str.substr(last);
    var captures = str.match(/:([^\/]+)/ig),
        capture,
        length;
    if (captures) {
      length = captures.length;
      for (var i = 0; i < length; i++) {
        capture = captures[i];
        if (capture.slice(0, 2) === "::") {
          str = capture.slice(1);
        } else {
          str = str.replace(capture, paramifyString(capture, params));
        }
      }
    }
    return str;
  }

  function terminator(routes, delimiter, start, stop) {
    var last = 0,
        left = 0,
        right = 0,
        start = (start || "(").toString(),
        stop = (stop || ")").toString(),
        i;
    for (i = 0; i < routes.length; i++) {
      var chunk = routes[i];
      if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {
        left = chunk.indexOf(start, last);
        right = chunk.indexOf(stop, last);
        if (~left && !~right || !~left && ~right) {
          var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);
          routes = [tmp].concat(routes.slice((i || 1) + 1));
        }
        last = (right > left ? right : left) + 1;
        i = 0;
      } else {
        last = 0;
      }
    }
    return routes;
  }

  var QUERY_SEPARATOR = /\?.*/;

  Router.prototype.configure = function (options) {
    options = options || {};
    for (var i = 0; i < this.methods.length; i++) {
      this._methods[this.methods[i]] = true;
    }
    this.recurse = options.recurse || this.recurse || false;
    this.async = options.async || false;
    this.delimiter = options.delimiter || "/";
    this.strict = typeof options.strict === "undefined" ? true : options.strict;
    this.notfound = options.notfound;
    this.resource = options.resource;
    this.history = options.html5history && this.historySupport || false;
    this.run_in_init = this.history === true && options.run_handler_in_init !== false;
    this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;
    this.every = {
      after: options.after || null,
      before: options.before || null,
      on: options.on || null
    };
    return this;
  };

  Router.prototype.param = function (token, matcher) {
    if (token[0] !== ":") {
      token = ":" + token;
    }
    var compiled = new RegExp(token, "g");
    this.params[token] = function (str) {
      return str.replace(compiled, matcher.source || matcher);
    };
    return this;
  };

  Router.prototype.on = Router.prototype.route = function (method, path, route) {
    var self = this;
    if (!route && typeof path == "function") {
      route = path;
      path = method;
      method = "on";
    }
    if (Array.isArray(path)) {
      return path.forEach(function (p) {
        self.on(method, p, route);
      });
    }
    if (path.source) {
      path = path.source.replace(/\\\//ig, "/");
    }
    if (Array.isArray(method)) {
      return method.forEach(function (m) {
        self.on(m.toLowerCase(), path, route);
      });
    }
    path = path.split(new RegExp(this.delimiter));
    path = terminator(path, this.delimiter);
    this.insert(method, this.scope.concat(path), route);
  };

  Router.prototype.path = function (path, routesFn) {
    var self = this,
        length = this.scope.length;
    if (path.source) {
      path = path.source.replace(/\\\//ig, "/");
    }
    path = path.split(new RegExp(this.delimiter));
    path = terminator(path, this.delimiter);
    this.scope = this.scope.concat(path);
    routesFn.call(this, this);
    this.scope.splice(length, path.length);
  };

  Router.prototype.dispatch = function (method, path, callback) {
    var self = this,
        fns = this.traverse(method, path.replace(QUERY_SEPARATOR, ""), this.routes, ""),
        invoked = this._invoked,
        after;
    this._invoked = true;
    if (!fns || fns.length === 0) {
      this.last = [];
      if (typeof this.notfound === "function") {
        this.invoke([this.notfound], {
          method: method,
          path: path
        }, callback);
      }
      return false;
    }
    if (this.recurse === "forward") {
      fns = fns.reverse();
    }
    function updateAndInvoke() {
      self.last = fns.after;
      self.invoke(self.runlist(fns), self, callback);
    }
    after = this.every && this.every.after ? [this.every.after].concat(this.last) : [this.last];
    if (after && after.length > 0 && invoked) {
      if (this.async) {
        this.invoke(after, this, updateAndInvoke);
      } else {
        this.invoke(after, this);
        updateAndInvoke();
      }
      return true;
    }
    updateAndInvoke();
    return true;
  };

  Router.prototype.invoke = function (fns, thisArg, callback) {
    var self = this;
    var _apply2;
    if (this.async) {
      _apply2 = function apply(fn, next) {
        if (Array.isArray(fn)) {
          return _asyncEverySeries(fn, _apply2, next);
        } else if (typeof fn == "function") {
          fn.apply(thisArg, (fns.captures || []).concat(next));
        }
      };
      _asyncEverySeries(fns, _apply2, function () {
        if (callback) {
          callback.apply(thisArg, arguments);
        }
      });
    } else {
      _apply2 = function _apply(fn) {
        if (Array.isArray(fn)) {
          return _every(fn, _apply2);
        } else if (typeof fn === "function") {
          return fn.apply(thisArg, fns.captures || []);
        } else if (typeof fn === "string" && self.resource) {
          self.resource[fn].apply(thisArg, fns.captures || []);
        }
      };
      _every(fns, _apply2);
    }
  };

  Router.prototype.traverse = function (method, path, routes, regexp, filter) {
    var fns = [],
        current,
        exact,
        match,
        next,
        that;
    function filterRoutes(routes) {
      if (!filter) {
        return routes;
      }
      function deepCopy(source) {
        var result = [];
        for (var i = 0; i < source.length; i++) {
          result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];
        }
        return result;
      }
      function applyFilter(fns) {
        for (var i = fns.length - 1; i >= 0; i--) {
          if (Array.isArray(fns[i])) {
            applyFilter(fns[i]);
            if (fns[i].length === 0) {
              fns.splice(i, 1);
            }
          } else {
            if (!filter(fns[i])) {
              fns.splice(i, 1);
            }
          }
        }
      }
      var newRoutes = deepCopy(routes);
      newRoutes.matched = routes.matched;
      newRoutes.captures = routes.captures;
      newRoutes.after = routes.after.filter(filter);
      applyFilter(newRoutes);
      return newRoutes;
    }
    if (path === this.delimiter && routes[method]) {
      next = [[routes.before, routes[method]].filter(Boolean)];
      next.after = [routes.after].filter(Boolean);
      next.matched = true;
      next.captures = [];
      return filterRoutes(next);
    }
    for (var r in routes) {
      if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && _typeof(routes[r]) === "object" && !Array.isArray(routes[r]))) {
        current = exact = regexp + this.delimiter + r;
        if (!this.strict) {
          exact += "[" + this.delimiter + "]?";
        }
        match = path.match(new RegExp("^" + exact));
        if (!match) {
          continue;
        }
        if (match[0] && match[0] == path && routes[r][method]) {
          next = [[routes[r].before, routes[r][method]].filter(Boolean)];
          next.after = [routes[r].after].filter(Boolean);
          next.matched = true;
          next.captures = match.slice(1);
          if (this.recurse && routes === this.routes) {
            next.push([routes.before, routes.on].filter(Boolean));
            next.after = next.after.concat([routes.after].filter(Boolean));
          }
          return filterRoutes(next);
        }
        next = this.traverse(method, path, routes[r], current);
        if (next.matched) {
          if (next.length > 0) {
            fns = fns.concat(next);
          }
          if (this.recurse) {
            fns.push([routes[r].before, routes[r].on].filter(Boolean));
            next.after = next.after.concat([routes[r].after].filter(Boolean));
            if (routes === this.routes) {
              fns.push([routes["before"], routes["on"]].filter(Boolean));
              next.after = next.after.concat([routes["after"]].filter(Boolean));
            }
          }
          fns.matched = true;
          fns.captures = next.captures;
          fns.after = next.after;
          return filterRoutes(fns);
        }
      }
    }
    return false;
  };

  Router.prototype.insert = function (method, path, route, parent) {
    var methodType, parentType, isArray, nested, part;
    path = path.filter(function (p) {
      return p && p.length > 0;
    });
    parent = parent || this.routes;
    part = path.shift();
    if (/\:|\*/.test(part) && !/\\d|\\w/.test(part)) {
      part = regifyString(part, this.params);
    }
    if (path.length > 0) {
      parent[part] = parent[part] || {};
      return this.insert(method, path, route, parent[part]);
    }
    if (!part && !path.length && parent === this.routes) {
      methodType = _typeof(parent[method]);
      switch (methodType) {
        case "function":
          parent[method] = [parent[method], route];
          return;
        case "object":
          parent[method].push(route);
          return;
        case "undefined":
          parent[method] = route;
          return;
      }
      return;
    }
    parentType = _typeof(parent[part]);
    isArray = Array.isArray(parent[part]);
    if (parent[part] && !isArray && parentType == "object") {
      methodType = _typeof(parent[part][method]);
      switch (methodType) {
        case "function":
          parent[part][method] = [parent[part][method], route];
          return;
        case "object":
          parent[part][method].push(route);
          return;
        case "undefined":
          parent[part][method] = route;
          return;
      }
    } else if (parentType == "undefined") {
      nested = {};
      nested[method] = route;
      parent[part] = nested;
      return;
    }
    throw new Error("Invalid route context: " + parentType);
  };

  Router.prototype.extend = function (methods) {
    var self = this,
        len = methods.length,
        i;
    function extend(method) {
      self._methods[method] = true;
      self[method] = function () {
        var extra = arguments.length === 1 ? [method, ""] : [method];
        self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));
      };
    }
    for (i = 0; i < len; i++) {
      extend(methods[i]);
    }
  };

  Router.prototype.runlist = function (fns) {
    var runlist = this.every && this.every.before ? [this.every.before].concat(_flatten(fns)) : _flatten(fns);
    if (this.every && this.every.on) {
      runlist.push(this.every.on);
    }
    runlist.captures = fns.captures;
    runlist.source = fns.source;
    return runlist;
  };

  Router.prototype.mount = function (routes, path) {
    if (!routes || (typeof routes === 'undefined' ? 'undefined' : _typeof(routes)) !== "object" || Array.isArray(routes)) {
      return;
    }
    var self = this;
    path = path || [];
    if (!Array.isArray(path)) {
      path = path.split(self.delimiter);
    }
    function insertOrMount(route, local) {
      var rename = route,
          parts = route.split(self.delimiter),
          routeType = _typeof(routes[route]),
          isRoute = parts[0] === "" || !self._methods[parts[0]],
          event = isRoute ? "on" : rename;
      if (isRoute) {
        rename = rename.slice((rename.match(new RegExp("^" + self.delimiter)) || [""])[0].length);
        parts.shift();
      }
      if (isRoute && routeType === "object" && !Array.isArray(routes[route])) {
        local = local.concat(parts);
        self.mount(routes[route], local);
        return;
      }
      if (isRoute) {
        local = local.concat(rename.split(self.delimiter));
        local = terminator(local, self.delimiter);
      }
      self.insert(event, local, routes[route]);
    }
    for (var route in routes) {
      if (routes.hasOwnProperty(route)) {
        insertOrMount(route, path.slice(0));
      }
    }
  };
})(( false ? 'undefined' : _typeof(exports)) === "object" ? exports : window);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(34);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(10)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/stylus-loader/index.js??ref--2-2!./layout.styl", function() {
			var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/stylus-loader/index.js??ref--2-2!./layout.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(9)(undefined);
// imports


// module
exports.push([module.i, "html,\nbody {\n  margin: 0;\n  font-size: 14px;\n  color: #333;\n  background: #efefef;\n  height: 100%;\n}\na {\n  color: #2d8cf0;\n  text-decoration: none;\n  cursor: pointer;\n}\nh1,\nh2,\nh3,\nh4,\nh5 {\n  margin: 0;\n  font-weight: normal;\n  color: #000;\n}\nh1 {\n  font-size: 2em;\n}\nh2 {\n  font-size: 1.8em;\n}\nh3 {\n  font-size: 1.5em;\n}\ncode {\n  color: #c7254e;\n  background-color: #f9f2f4;\n  border-radius: 4px;\n  padding: 0 5px;\n}\nblockquote {\n  margin: 1em 0;\n  padding: 1px 2em;\n  background: #f8f8f8;\n  border-radius: 0 3px 3px 0;\n  border-left: 2px solid #fe4444;\n  position: relative;\n}\nblockquote:before {\n  content: '!';\n  display: block;\n  position: absolute;\n  top: 50%;\n  margin-top: -10px;\n  width: 20px;\n  height: 20px;\n  border-radius: 100%;\n  text-align: center;\n  background: #fe4444;\n  color: #fff;\n  line-height: 20px;\n  left: -11px;\n}\n#page,\n.app-wrapper,\n.main-wrapper {\n  height: 100%;\n}\n.header-wrapper {\n  height: 80px;\n  line-height: 80px;\n  box-shadow: 0 2px 5px rgba(0,0,0,0.08);\n  background: #fff;\n  position: fixed;\n  width: 100%;\n  top: 0;\n  z-index: 999;\n}\n.header-wrapper header {\n  width: 1080px;\n  margin: 0 auto;\n}\n.header-wrapper .logo {\n  font-size: 24px;\n  color: #333;\n  margin-left: 20px;\n}\n.header-wrapper nav {\n  float: right;\n  position: relative;\n}\n.header-wrapper nav a {\n  display: inline-block;\n  padding: 0 20px;\n  color: #333;\n}\n.header-wrapper nav a.active {\n  color: #fe4444;\n}\n.header-wrapper .border {\n  position: absolute;\n  bottom: 0;\n  border-bottom: 2px solid #fe4444;\n}\n.transition {\n  transition: all 350ms cubic-bezier(0.55, 0, 0.1, 1);\n}\n.blue {\n  color: #09d;\n}\n.red {\n  color: #d04;\n}\n.yellow {\n  color: #ffc400;\n}\n", ""]);

// exports


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzdjMTk1Mjk2Y2VjMTRjMWM2YzEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL3Zub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZHQvc3JjL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmR0L3NyYy9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy92cGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy92ZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbnRhY3Qvc3JjL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvd3JhcHBlcnMvcHJvY2Vzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50YWN0L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbnRhY3Qvc3JjL2ludGFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy9ldmVudC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmR0L3NyYy9saWIvdmR0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZHQvc3JjL2xpYi9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZkdC9zcmMvbGliL3N0cmluZ2lmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvd3JhcHBlcnMvc2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvd3JhcHBlcnMvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy93cmFwcGVycy90ZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL3Rvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvaHlkcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbnRhY3Qvc3JjL2FuaW1hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hcHAvYXBwLnZkdCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FwcC9sb2FkaW5nLmNzcz83NDIyIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYXBwL2xvYWRpbmcuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpcmVjdG9yL2J1aWxkL2RpcmVjdG9yLmpzIiwid2VicGFjazovLy8uL2Nzcy9sYXlvdXQuc3R5bD9jMzVlIiwid2VicGFjazovLy8uL2Nzcy9sYXlvdXQuc3R5bCJdLCJuYW1lcyI6WyJpc09iamVjdCIsImlzU3RyaW5nT3JOdW1iZXIiLCJpc051bGxPclVuZGVmaW5lZCIsImlzQ29tcG9uZW50SW5zdGFuY2UiLCJpc0V2ZW50UHJvcCIsImlzSW52YWxpZCIsImlzU2tpcFByb3AiLCJNb3VudGVkUXVldWUiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImRvYyIsImRvY3VtZW50IiwiaXNBcnJheSIsIkFycmF5IiwiYXJyIiwiY2FsbCIsIm8iLCJ0eXBlIiwidW5kZWZpbmVkIiwiaW5pdCIsInByb3BOYW1lIiwic3Vic3RyIiwiaW5kZXhPZiIsInZhbHVlIiwiaSIsImxlbmd0aCIsIm5hdGl2ZU9iamVjdCIsImNyZWF0ZSIsImNyZWF0ZU9iamVjdCIsIm9iaiIsIkZuIiwiU2ltcGxlTWFwIiwiTWFwIiwiX2tleXMiLCJfdmFsdWVzIiwic2l6ZSIsInNldCIsImtleSIsImluZGV4IiwicHVzaCIsImdldCIsInNwbGljZSIsInNraXBQcm9wcyIsInJlZiIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiY2hlY2tlZCIsIm11bHRpcGxlIiwiZGVmYXVsdFZhbHVlIiwicHJvcCIsImJvb2xlYW5Qcm9wcyIsIm11dGVkIiwic2NvcGVkIiwibG9vcCIsIm9wZW4iLCJjYXB0dXJlIiwiZGlzYWJsZWQiLCJyZWFkT25seSIsInJlcXVpcmVkIiwiYXV0b3BsYXkiLCJjb250cm9scyIsInNlYW1sZXNzIiwicmV2ZXJzZWQiLCJhbGxvd2Z1bGxzY3JlZW4iLCJub1ZhbGlkYXRlIiwiaGlkZGVuIiwiYXV0b2ZvY3VzIiwic2VsZWN0ZWQiLCJpbmRldGVybWluYXRlIiwic3RyaWN0UHJvcHMiLCJ2b2x1bWUiLCJkZWZhdWx0Q2hlY2tlZCIsImh0bWxGb3IiLCJzZWxmQ2xvc2luZ1RhZ3MiLCJxdWV1ZSIsImZuIiwidW5zaGlmdCIsInRyaWdnZXIiLCJjYWxsYmFjayIsInNoaWZ0IiwiYnJvd3NlciIsIm5hdmlnYXRvciIsInVhIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJpc0lFIiwidmVyc2lvbiIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiaXNJRTgiLCJpc0VkZ2UiLCJpc0Nocm9tZSIsImlzU2FmYXJpIiwic2V0VGV4dENvbnRlbnQiLCJkb20iLCJ0ZXh0IiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJzdmdOUyIsInhsaW5rTlMiLCJ4bWxOUyIsIm5hbWVzcGFjZXMiLCJWTm9kZSIsImNyZWF0ZVZOb2RlIiwiY3JlYXRlQ29tbWVudFZOb2RlIiwiY3JlYXRlVW5lc2NhcGVUZXh0Vk5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjcmVhdGVWb2lkVk5vZGUiLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZVZOb2RlIiwiVHlwZXMiLCJUZXh0IiwiSHRtbEVsZW1lbnQiLCJDb21wb25lbnRDbGFzcyIsIkNvbXBvbmVudEZ1bmN0aW9uIiwiQ29tcG9uZW50SW5zdGFuY2UiLCJIdG1sQ29tbWVudCIsIklucHV0RWxlbWVudCIsIlNlbGVjdEVsZW1lbnQiLCJUZXh0YXJlYUVsZW1lbnQiLCJTdmdFbGVtZW50IiwiVW5lc2NhcGVUZXh0IiwiRm9ybUVsZW1lbnQiLCJFbGVtZW50IiwiQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlIiwiVGV4dEVsZW1lbnQiLCJFTVBUWV9PQkoiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJmcmVlemUiLCJ0YWciLCJwcm9wcyIsIkVycm9yIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJWb2lkRWxlbWVudCIsImluc3RhbmNlIiwiY29uc3RydWN0b3IiLCJ2Tm9kZXMiLCJpc0FkZEtleSIsImNoaWxkTm9kZXMiLCJhZGRDaGlsZCIsImRpcmVjdENsb25lIiwiYXBwbHlLZXkiLCJ2Tm9kZSIsInJlZmVyZW5jZSIsIm5ld1ZOb2RlcyIsIm4iLCJzbGljZSIsImNvbmNhdCIsIm5ld1ZOb2RlIiwicHJvcHNUb0Nsb25lIiwibmV3UHJvcHMiLCJuZXdDaGlsZHJlbiIsImxlbiIsInRtcEFycmF5IiwiY2hpbGQiLCJlYWNoIiwibWFwIiwiaXNXaGl0ZVNwYWNlIiwidHJpbVJpZ2h0IiwidHJpbUxlZnQiLCJzZXREZWxpbWl0ZXJzIiwiZ2V0RGVsaW1pdGVycyIsImNvbmZpZ3VyZSIsImlzU2VsZkNsb3NpbmdUYWciLCJpc1RleHRUYWciLCJpc0RpcmVjdGl2ZSIsImV4dGVuZCIsInNldENoZWNrYm94TW9kZWwiLCJkZXRlY3RDaGVja2JveENoZWNrZWQiLCJzZXRTZWxlY3RNb2RlbCIsIlNlbGZDbG9zaW5nVGFncyIsIlR5cGUiLCJKUyIsIkpTSW1wb3J0IiwiSlNYVGV4dCIsIkpTWFVuZXNjYXBlVGV4dCIsIkpTWEVsZW1lbnQiLCJKU1hFeHByZXNzaW9uQ29udGFpbmVyIiwiSlNYQXR0cmlidXRlIiwiSlNYRW1wdHlFeHByZXNzaW9uIiwiSlNYV2lkZ2V0IiwiSlNYVmR0IiwiSlNYQmxvY2siLCJKU1hDb21tZW50IiwiSlNYRGlyZWN0aXZlIiwiVHlwZU5hbWUiLCJUZXh0VGFncyIsInN0eWxlIiwic2NyaXB0IiwidGV4dGFyZWEiLCJEaXJlY3RpdmVzIiwiT3B0aW9ucyIsImF1dG9SZXR1cm4iLCJvbmx5U291cmNlIiwiZGVsaW1pdGVycyIsIm5vV2l0aCIsInNlcnZlciIsInNraXBXaGl0ZXNwYWNlIiwic2V0TW9kZWwiLCJkYXRhIiwic2VsZiIsInVwZGF0ZSIsImdldE1vZGVsIiwiZGlzYWJsZVNwbGl0VGV4dCIsImhhc093biIsImhhc093blByb3BlcnR5Iiwibm9vcCIsImlzQXJyYXlMaWtlIiwiaXRlciIsInRoaXNBcmciLCJsIiwidGhpc0FyZ3MiLCJyZXQiLCJqb2luIiwiY2hhckNvZGUiLCJzdHIiLCJjaGFyQ29kZUF0IiwibmFtZSIsImFyZ3MiLCJkZXN0Iiwic291cmNlIiwidHJ1ZVZhbHVlIiwiZmFsc2VWYWx1ZSIsImUiLCJ0YXJnZXQiLCJvcHQiLCJvcHRpb25zIiwiX3ZhbHVlIiwiZXJyb3IiLCJoYXNDb25zb2xlIiwiY29uc29sZSIsInN0YWNrIiwicGF0Y2giLCJwYXRjaFZOb2RlIiwicGF0Y2hQcm9wcyIsInBhdGNoUHJvcCIsImtlYmFiQ2FzZSIsImxhc3RWTm9kZSIsIm5leHRWTm9kZSIsInBhcmVudERvbSIsIm1vdW50ZWRRdWV1ZSIsInBhcmVudFZOb2RlIiwiaXNTVkciLCJpc1RyaWdnZXIiLCJuZXh0VHlwZSIsImxhc3RUeXBlIiwicGF0Y2hFbGVtZW50IiwicmVwbGFjZUVsZW1lbnQiLCJwYXRjaFRleHQiLCJwYXRjaENvbXBvbmVudENsYXNzIiwicGF0Y2hDb21wb25lbnRJbnRhbmNlIiwibGFzdFByb3BzIiwibmV4dFByb3BzIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibGFzdENsYXNzTmFtZSIsIm5leHRDbGFzc05hbWUiLCJwYXRjaENoaWxkcmVuIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwibmV4dFJlZiIsImxhc3RUYWciLCJuZXh0VGFnIiwibmV3RG9tIiwiaXNSZW5kZXIiLCJwYXJlbnROb2RlIiwibm9kZU5hbWUiLCJsYXN0SW5zdGFuY2UiLCJuZXh0SW5zdGFuY2UiLCJwYXRjaENoaWxkcmVuQnlLZXkiLCJhIiwiYiIsImFMZW5ndGgiLCJiTGVuZ3RoIiwiYUVuZCIsImJFbmQiLCJhU3RhcnQiLCJiU3RhcnQiLCJqIiwiYU5vZGUiLCJiTm9kZSIsIm5leHROb2RlIiwibmV4dFBvcyIsIm5vZGUiLCJhU3RhcnROb2RlIiwiYlN0YXJ0Tm9kZSIsImFFbmROb2RlIiwiYkVuZE5vZGUiLCJvdXRlciIsImluc2VydEJlZm9yZSIsImluc2VydE9yQXBwZW5kIiwic291cmNlcyIsIm1vdmVkIiwicG9zIiwicGF0Y2hlZCIsImtleUluZGV4Iiwic2VxIiwibGlzQWxnb3JpdGhtIiwicCIsInJlc3VsdCIsInUiLCJ2IiwiYyIsImFyckkiLCJub2RlcyIsImRldGVjdFBhcmVudCIsImFwcGVuZENoaWxkIiwibmV4dFRleHQiLCJub2RlVmFsdWUiLCJpc0Zvcm1FbGVtZW50IiwicmVtb3ZlUHJvcCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsInBhdGNoUHJvcEJ5T2JqZWN0IiwiaW5uZXJIVE1MIiwic2V0QXR0cmlidXRlTlMiLCJyZW1vdmVEYXRhc2V0IiwiZG9tUHJvcCIsImRhdGFzZXQiLCJwYXRjaEF0dHJpYnV0ZXMiLCJwYXRjaFN0eWxlIiwicGF0Y2hEYXRhc2V0IiwicGF0Y2hPYmplY3QiLCJoYXNSZW1vdmVkIiwiZGF0YUtleSIsIl9jYWNoZSIsInVwcGVyY2FzZVBhdHRlcm4iLCJ3b3JkIiwicmVwbGFjZSIsIml0ZW0iLCJkb21Qcm9wcyIsImRvbVN0eWxlIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUh0bWxFbGVtZW50IiwiY3JlYXRlVGV4dEVsZW1lbnQiLCJjcmVhdGVDb21wb25lbnRDbGFzc09ySW5zdGFuY2UiLCJjcmVhdGVDb21wb25lbnRGdW5jdGlvbiIsImNyZWF0ZUNvbW1lbnRFbGVtZW50IiwiY3JlYXRlQ29tcG9uZW50RnVuY3Rpb25WTm9kZSIsImNyZWF0ZUVsZW1lbnRzIiwicmVtb3ZlRWxlbWVudHMiLCJyZW1vdmVFbGVtZW50IiwicmVtb3ZlSHRtbEVsZW1lbnQiLCJyZW1vdmVUZXh0IiwicmVtb3ZlQ29tcG9uZW50RnVuY3Rpb24iLCJyZW1vdmVDb21wb25lbnRDbGFzc09ySW5zdGFuY2UiLCJyZW1vdmVBbGxDaGlsZHJlbiIsInJlcGxhY2VDaGlsZCIsInJlbW92ZUNoaWxkIiwiY3JlYXRlUmVmIiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJtb3VudCIsImNyZWF0ZUNvbW1lbnQiLCJkZXN0cm95IiwibGFzdERvbSIsIm5leHREb20iLCJfdW5tb3VudCIsInRhZ05hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlYXRlRWxlbWVudE5TIiwiaW5oZXJpdCIsInRlbXBsYXRlRGVjb3JhdG9yIiwiaXNGdW5jdGlvbiIsImlzU3RyaW5nIiwiYmluZCIsImlzRXF1YWwiLCJ1bmlxdWVJZCIsInZhbHVlcyIsImNhc3RQYXRoIiwiTmV4dFRpY2siLCJhdXRvYmluZCIsImluQnJvd3NlciIsIndpbmRvdyIsIlVBIiwiaXNJT1MiLCJ0ZXN0IiwiaXNTdXBwb3J0R2V0RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInNldFByb3RvdHlwZSIsIlBhcmVudCIsIkNoaWxkIiwidG1wIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiYXBwbHkiLCJwcm90byIsImRpc3BsYXlOYW1lIiwiY29tcGlsZSIsInRlbXBsYXRlIiwiX3N1cGVyIiwiX3N1cGVyQXBwbHkiLCJfX3N1cGVyIiwiX19zdXBlckFwcGx5IiwicmV0dXJuVmFsdWUiLCJkZXNjcmlwdG9yIiwiZ2V0UHJvdG90eXBlT2YiLCJuYXRpdmVDcmVhdGUiLCJvYmplY3QiLCJzIiwicHJvcGVydHkiLCJmYWxsYmFjayIsImV4ZWN1dGVCb3VuZCIsInNvdXJjZUZ1bmMiLCJib3VuZEZ1bmMiLCJjb250ZXh0IiwiY2FsbGluZ0NvbnRleHQiLCJuYXRpdmVCaW5kIiwiRnVuY3Rpb24iLCJmdW5jIiwiVHlwZUVycm9yIiwiYm91bmQiLCJhcmdzMSIsImVxIiwiYVN0YWNrIiwiYlN0YWNrIiwiYXJlQXJyYXlzIiwiYUN0b3IiLCJiQ3RvciIsImFLZXlzIiwia2V5cyIsInBvcCIsImlkQ291bnRlciIsInByZWZpeCIsImlkIiwicGF0aE1hcCIsInJlTGVhZGluZ0RvdCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJyZUlzVWludCIsInBhdGgiLCJtYXRjaCIsIm51bWJlciIsInF1b3RlIiwic3RyaW5nIiwiaXNJbmRleCIsImxhc3RJbmRleCIsIm5lc3RlZCIsIm5ld1ZhbHVlIiwib2JqVmFsdWUiLCJ3YXJuIiwiYXJndW1lbnRzIiwiaXNOYXRpdmUiLCJDdG9yIiwibmV4dFRpY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJlcnIiLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNhbGxiYWNrcyIsIm5leHRUaWNrSGFuZGxlciIsIl9jYWxsYmFja3MiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsIlN0cmluZyIsImVhY2hDYWxsYmFjayIsImZpcmUiLCJ3b250QmluZCIsIl9fcHJvdG9fXyIsImdldE93blByb3BlcnR5TmFtZXMiLCJJbnRhY3QiLCJ0b0JpbmQiLCJtZXRob2QiLCJwcm9jZXNzRm9ybSIsInV0aWxzIiwiQW5pbWF0ZSIsIlZkdCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlUm9vdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiX2V2ZW50cyIsInZkdCIsInNpbGVudCIsIndpZGdldHMiLCJfd2lkZ2V0Iiwid2lkZ2V0IiwiYXR0cmlidXRlcyIsInJlZnMiLCJpbml0ZWQiLCJyZW5kZXJlZCIsIm1vdW50ZWQiLCJkZXN0cm95ZWQiLCJfc3RhcnRSZW5kZXIiLCJvbiIsIl91cGRhdGVDb3VudCIsIl9pbml0IiwiZGVmYXVsdHMiLCJfY3JlYXRlIiwiX21vdW50IiwiX2JlZm9yZVVwZGF0ZSIsIl91cGRhdGUiLCJfZGVzdHJveSIsImh5ZHJhdGUiLCJvbmUiLCJlbGVtZW50IiwiX3RyaWdnZXJNb3VudGVkUXVldWUiLCJfbGFzdFZOb2RlIiwicGxhY2Vob2xkZXIiLCJfcGVuZGluZ1VwZGF0ZSIsInJlbmRlclN0cmluZyIsImZyb21QZW5kaW5nIiwiX3BhdGNoUHJvcHMiLCJfX3VwZGF0ZSIsIl9mcm9tUGF0Y2hQcm9wcyIsImxhc3RQcm9wc1dpdGhvdXRFdmVudHMiLCJuZXh0UHJvcHNXaXRob3V0RXZlbnRzIiwiZXZlbnROYW1lIiwib2ZmIiwiX2dldCIsIl9zZXQiLCJ2YWwiLCJpc1NldEJ5T2JqZWN0IiwiYXN5bmMiLCJnbG9iYWwiLCJjaGFuZ2VzIiwiaGFzQ2hhbmdlZCIsIl9wcm9wcyIsIl9sYXN0VmFsdWUiLCJjaGFuZ2VLZXlzIiwidHJpZ2dlckNoYW5nZSIsIl90cmlnZ2VyQ2hhbmdlZEV2ZW50IiwiXyRuZXh0VGljayIsImNiIiwiX2luaXRNb3VudGVkUXVldWUiLCJDb21wb25lbnQiLCJ3cml0YWJsZSIsImgiLCJoYyIsImh1IiwicmVtb3ZlIiwiaHlkcmF0ZVJvb3QiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJJdGVtIiwiYXJyYXkiLCJ0aXRsZSIsImFyZ3YiLCJ2ZXJzaW9ucyIsImFkZExpc3RlbmVyIiwib25jZSIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImhhbmRsZUV2ZW50IiwiQUxMX1BST1BTIiwiS0VZX1BST1BTIiwiTU9VU0VfUFJPUFMiLCJya2V5RXZlbnQiLCJybW91c2VFdmVudCIsIkV2ZW50IiwicHJvcEtleSIsInNyY0VsZW1lbnQiLCJfcmF3RXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIk1vdXNlRXZlbnQiLCJtb3VzZVByb3BLZXkiLCJLZXlFdmVudCIsImtleVByb3BLZXkiLCJwcm94eUV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImRldGFjaEV2ZW50IiwiZGVsZWdhdGVkRXZlbnRzIiwidW5EZWxlZ2F0ZXNFdmVudHMiLCJjaGFuZ2UiLCJsYXN0RXZlbnQiLCJuZXh0RXZlbnQiLCJkZWxlZ2F0ZWRSb290cyIsIml0ZW1zIiwiZG9jRXZlbnQiLCJhdHRhY2hFdmVudFRvRG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnQiLCJjb3VudCIsImlzQ2xpY2siLCJldmVudFRvVHJpZ2dlciIsImN1cnJlbnRUYXJnZXQiLCJub2RlVHlwZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiZmFjdG9yeSIsInciLCJub0dsb2JhbCIsImdldFByb3RvIiwiY2xhc3MydHlwZSIsImZuVG9TdHJpbmciLCJPYmplY3RGdW5jdGlvblN0cmluZyIsInN1cHBvcnQiLCJET01FdmFsIiwiY29kZSIsImhlYWQiLCJqUXVlcnkiLCJzZWxlY3RvciIsInJ0cmltIiwicm1zUHJlZml4IiwicmRhc2hBbHBoYSIsImZjYW1lbENhc2UiLCJhbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImpxdWVyeSIsInRvQXJyYXkiLCJudW0iLCJwdXNoU3RhY2siLCJlbGVtcyIsIm1lcmdlIiwicHJldk9iamVjdCIsImVsZW0iLCJmaXJzdCIsImxhc3QiLCJlbmQiLCJzb3J0Iiwic3JjIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJkZWVwIiwiaXNQbGFpbk9iamVjdCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwiaXNSZWFkeSIsIm1zZyIsImlzV2luZG93IiwiaXNOdW1lcmljIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiaXNFbXB0eU9iamVjdCIsImdsb2JhbEV2YWwiLCJjYW1lbENhc2UiLCJ0cmltIiwibWFrZUFycmF5IiwicmVzdWx0cyIsImluQXJyYXkiLCJzZWNvbmQiLCJncmVwIiwiaW52ZXJ0IiwiY2FsbGJhY2tJbnZlcnNlIiwibWF0Y2hlcyIsImNhbGxiYWNrRXhwZWN0IiwiYXJnIiwiZ3VpZCIsInByb3h5Iiwibm93IiwiRGF0ZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic3BsaXQiLCJTaXp6bGUiLCJFeHByIiwiZ2V0VGV4dCIsImlzWE1MIiwidG9rZW5pemUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwic29ydE9yZGVyIiwicHVzaF9uYXRpdmUiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwicHNldWRvcyIsInJ3aGl0ZXNwYWNlIiwiUmVnRXhwIiwicmNvbW1hIiwicmNvbWJpbmF0b3JzIiwicmF0dHJpYnV0ZVF1b3RlcyIsInJwc2V1ZG8iLCJyaWRlbnRpZmllciIsIm1hdGNoRXhwciIsInJpbnB1dHMiLCJyaGVhZGVyIiwicm5hdGl2ZSIsInJxdWlja0V4cHIiLCJyc2libGluZyIsInJ1bmVzY2FwZSIsImZ1bmVzY2FwZSIsIl8iLCJlc2NhcGVkIiwiZXNjYXBlZFdoaXRlc3BhY2UiLCJoaWdoIiwiZnJvbUNoYXJDb2RlIiwicmNzc2VzY2FwZSIsImZjc3Nlc2NhcGUiLCJjaCIsImFzQ29kZVBvaW50IiwidW5sb2FkSGFuZGxlciIsImRpc2FibGVkQW5jZXN0b3IiLCJhZGRDb21iaW5hdG9yIiwibmV4dCIsImVscyIsInNlZWQiLCJtIiwibmlkIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInFzYSIsImdldEF0dHJpYnV0ZSIsInRvU2VsZWN0b3IiLCJ0ZXN0Q29udGV4dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxc2FFcnJvciIsImNhY2hlIiwiY2FjaGVMZW5ndGgiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJlbCIsImFkZEhhbmRsZSIsImF0dHJzIiwiaGFuZGxlciIsImF0dHJIYW5kbGUiLCJzaWJsaW5nQ2hlY2siLCJjdXIiLCJkaWZmIiwic291cmNlSW5kZXgiLCJuZXh0U2libGluZyIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlRGlzYWJsZWRQc2V1ZG8iLCJpc0Rpc2FibGVkIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwiZG9jdW1lbnRFbGVtZW50IiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwidG9wIiwiZ2V0QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiZmlsdGVyIiwiYXR0cklkIiwiZmluZCIsImdldEF0dHJpYnV0ZU5vZGUiLCJpbnB1dCIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImRpc2Nvbm5lY3RlZE1hdGNoIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJhZG93biIsImJ1cCIsImNvbXBhcmUiLCJzb3J0RGV0YWNoZWQiLCJhdXAiLCJhcCIsImJwIiwiZXhwciIsImVsZW1lbnRzIiwiYXR0ciIsInNwZWNpZmllZCIsImVzY2FwZSIsInNlbCIsInVuaXF1ZVNvcnQiLCJkdXBsaWNhdGVzIiwiZGV0ZWN0RHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJmaXJzdENoaWxkIiwic2VsZWN0b3JzIiwiY3JlYXRlUHNldWRvIiwicmVsYXRpdmUiLCJwcmVGaWx0ZXIiLCJleGNlc3MiLCJ1bnF1b3RlZCIsIm5vZGVOYW1lU2VsZWN0b3IiLCJwYXR0ZXJuIiwib3BlcmF0b3IiLCJjaGVjayIsIndoYXQiLCJzaW1wbGUiLCJmb3J3YXJkIiwib2ZUeXBlIiwieG1sIiwidW5pcXVlQ2FjaGUiLCJvdXRlckNhY2hlIiwibm9kZUluZGV4Iiwic3RhcnQiLCJwYXJlbnQiLCJ1c2VDYWNoZSIsImxhc3RDaGlsZCIsInVuaXF1ZUlEIiwicHNldWRvIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZWQiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4Iiwic2VsZWN0ZWRJbmRleCIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImNvbWJpbmF0b3IiLCJiYXNlIiwic2tpcCIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwidW5pcXVlIiwiaXNYTUxEb2MiLCJlc2NhcGVTZWxlY3RvciIsInVudGlsIiwidHJ1bmNhdGUiLCJpcyIsInNpYmxpbmdzIiwicm5lZWRzQ29udGV4dCIsIm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJyaXNTaW1wbGUiLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJub3QiLCJyb290alF1ZXJ5Iiwicm9vdCIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNvbnRlbnRzIiwicHJldiIsImhhcyIsInRhcmdldHMiLCJjbG9zZXN0IiwicHJldkFsbCIsImFkZCIsImFkZEJhY2siLCJzaWJsaW5nIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsIm5leHRBbGwiLCJuZXh0VW50aWwiLCJwcmV2VW50aWwiLCJjb250ZW50RG9jdW1lbnQiLCJyZXZlcnNlIiwicm5vdGh0bWx3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJmaXJpbmdJbmRleCIsInN0b3BPbkZhbHNlIiwiZW1wdHkiLCJkaXNhYmxlIiwibG9jayIsImZpcmVXaXRoIiwiSWRlbnRpdHkiLCJUaHJvd2VyIiwiZXgiLCJhZG9wdFZhbHVlIiwicmVqZWN0Iiwibm9WYWx1ZSIsInByb21pc2UiLCJmYWlsIiwiRGVmZXJyZWQiLCJ0dXBsZXMiLCJzdGF0ZSIsImFsd2F5cyIsImRlZmVycmVkIiwicGlwZSIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJyZXR1cm5lZCIsInByb2dyZXNzIiwibm90aWZ5Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsIm1heERlcHRoIiwiZGVwdGgiLCJzcGVjaWFsIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJleGNlcHRpb25Ib29rIiwic3RhY2tUcmFjZSIsInJlamVjdFdpdGgiLCJnZXRTdGFja0hvb2siLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzaW5nbGVWYWx1ZSIsInJlbWFpbmluZyIsInJlc29sdmVDb250ZXh0cyIsInJlc29sdmVWYWx1ZXMiLCJtYXN0ZXIiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJtZXNzYWdlIiwicmVhZHlFeGNlcHRpb24iLCJyZWFkeUxpc3QiLCJyZWFkeVdhaXQiLCJ3YWl0IiwiY29tcGxldGVkIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwiYWNjZXNzIiwiY2hhaW5hYmxlIiwiZW1wdHlHZXQiLCJyYXciLCJidWxrIiwiYWNjZXB0RGF0YSIsIm93bmVyIiwiRGF0YSIsInVpZCIsImhhc0RhdGEiLCJkYXRhUHJpdiIsImRhdGFVc2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImdldERhdGEiLCJwYXJzZSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJkZWZlciIsInBudW0iLCJyY3NzTnVtIiwiY3NzRXhwYW5kIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwiZGlzcGxheSIsImNzcyIsInN3YXAiLCJvbGQiLCJhZGp1c3RDU1MiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsImluaXRpYWwiLCJ1bml0IiwiY3NzTnVtYmVyIiwiaW5pdGlhbEluVW5pdCIsImRlZmF1bHREaXNwbGF5TWFwIiwiZ2V0RGVmYXVsdERpc3BsYXkiLCJib2R5Iiwic2hvd0hpZGUiLCJzaG93IiwiaGlkZSIsInRvZ2dsZSIsInJjaGVja2FibGVUeXBlIiwicnRhZ05hbWUiLCJyc2NyaXB0VHlwZSIsIndyYXBNYXAiLCJvcHRpb24iLCJ0aGVhZCIsImNvbCIsInRyIiwidGQiLCJfZGVmYXVsdCIsIm9wdGdyb3VwIiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwiZ2V0QWxsIiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwicmh0bWwiLCJidWlsZEZyYWdtZW50Iiwic2NyaXB0cyIsInNlbGVjdGlvbiIsImlnbm9yZWQiLCJ3cmFwIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiaHRtbFByZWZpbHRlciIsImRpdiIsImNoZWNrQ2xvbmUiLCJjbG9uZU5vZGUiLCJub0Nsb25lQ2hlY2tlZCIsInJ0eXBlbmFtZXNwYWNlIiwicmV0dXJuVHJ1ZSIsInJldHVybkZhbHNlIiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJ0eXBlcyIsIm9yaWdGbiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJldmVudHMiLCJ0IiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJvcmlnVHlwZSIsImVsZW1EYXRhIiwiaGFuZGxlIiwidHJpZ2dlcmVkIiwiZGlzcGF0Y2giLCJkZWxlZ2F0ZVR5cGUiLCJiaW5kVHlwZSIsIm5hbWVzcGFjZSIsImRlbGVnYXRlQ291bnQiLCJzZXR1cCIsIm1hcHBlZFR5cGVzIiwib3JpZ0NvdW50IiwidGVhcmRvd24iLCJyZW1vdmVFdmVudCIsIm5hdGl2ZUV2ZW50IiwiZml4IiwiaGFuZGxlclF1ZXVlIiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicG9zdERpc3BhdGNoIiwibWF0Y2hlZEhhbmRsZXJzIiwibWF0Y2hlZFNlbGVjdG9ycyIsImJ1dHRvbiIsImFkZFByb3AiLCJob29rIiwib3JpZ2luYWxFdmVudCIsImxvYWQiLCJub0J1YmJsZSIsImZvY3VzIiwiYmx1ciIsImNsaWNrIiwiYmVmb3JldW5sb2FkIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInJlbGF0ZWRUYXJnZXQiLCJ0aW1lU3RhbXAiLCJpc1NpbXVsYXRlZCIsImFsdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJjdHJsS2V5IiwiZGV0YWlsIiwiZXZlbnRQaGFzZSIsIm1ldGFLZXkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJ2aWV3Iiwia2V5Q29kZSIsImJ1dHRvbnMiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwicG9pbnRlcklkIiwicG9pbnRlclR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInRhcmdldFRvdWNoZXMiLCJ0b0VsZW1lbnQiLCJ0b3VjaGVzIiwid2hpY2giLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsIm9yaWciLCJyZWxhdGVkIiwicnhodG1sVGFnIiwicm5vSW5uZXJodG1sIiwicmNoZWNrZWQiLCJyc2NyaXB0VHlwZU1hc2tlZCIsInJjbGVhblNjcmlwdCIsIm1hbmlwdWxhdGlvblRhcmdldCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJwZGF0YU9sZCIsInBkYXRhQ3VyIiwidWRhdGFPbGQiLCJ1ZGF0YUN1ciIsImZpeElucHV0IiwiZG9tTWFuaXAiLCJjb2xsZWN0aW9uIiwiaGFzU2NyaXB0cyIsImlOb0Nsb25lIiwiaHRtbCIsIl9ldmFsVXJsIiwia2VlcERhdGEiLCJjbGVhbkRhdGEiLCJkYXRhQW5kRXZlbnRzIiwiZGVlcERhdGFBbmRFdmVudHMiLCJzcmNFbGVtZW50cyIsImRlc3RFbGVtZW50cyIsImluUGFnZSIsImRldGFjaCIsImFwcGVuZCIsInByZXBlbmQiLCJiZWZvcmUiLCJhZnRlciIsInJlcGxhY2VXaXRoIiwiYXBwZW5kVG8iLCJwcmVwZW5kVG8iLCJpbnNlcnRBZnRlciIsInJlcGxhY2VBbGwiLCJvcmlnaW5hbCIsImluc2VydCIsInJtYXJnaW4iLCJybnVtbm9ucHgiLCJnZXRTdHlsZXMiLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwiY29tcHV0ZVN0eWxlVGVzdHMiLCJjc3NUZXh0IiwiY29udGFpbmVyIiwiZGl2U3R5bGUiLCJwaXhlbFBvc2l0aW9uVmFsIiwicmVsaWFibGVNYXJnaW5MZWZ0VmFsIiwibWFyZ2luTGVmdCIsImJveFNpemluZ1JlbGlhYmxlVmFsIiwid2lkdGgiLCJtYXJnaW5SaWdodCIsInBpeGVsTWFyZ2luUmlnaHRWYWwiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsInBpeGVsUG9zaXRpb24iLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsTWFyZ2luUmlnaHQiLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJjdXJDU1MiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJyZGlzcGxheXN3YXAiLCJyY3VzdG9tUHJvcCIsImNzc1Nob3ciLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsImNzc1ByZWZpeGVzIiwiZW1wdHlTdHlsZSIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJjc3NQcm9wcyIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXgiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJnZXRXaWR0aE9ySGVpZ2h0IiwidmFsdWVJc0JvcmRlckJveCIsImNzc0hvb2tzIiwib3BhY2l0eSIsIm9yaWdOYW1lIiwiaXNDdXN0b21Qcm9wIiwic2V0UHJvcGVydHkiLCJpc0Zpbml0ZSIsImdldENsaWVudFJlY3RzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInN0ZXAiLCJmeCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJsaW5lYXIiLCJzd2luZyIsImNvcyIsIlBJIiwiZnhOb3ciLCJpblByb2dyZXNzIiwicmZ4dHlwZXMiLCJycnVuIiwic2NoZWR1bGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbnRlcnZhbCIsInRpY2siLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiaGVpZ2h0IiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvcHRzIiwib2xkZmlyZSIsInByb3BUd2VlbiIsInJlc3RvcmVEaXNwbGF5IiwiaXNCb3giLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInByZWZpbHRlcnMiLCJjdXJyZW50VGltZSIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIm9yaWdpbmFsT3B0aW9ucyIsImdvdG9FbmQiLCJjb21wbGV0ZSIsInRpbWVyIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwic3BlZWRzIiwiZmFkZVRvIiwidG8iLCJhbmltYXRlIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJjc3NGbiIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJjaGVja09uIiwib3B0U2VsZWN0ZWQiLCJyYWRpb1ZhbHVlIiwiYm9vbEhvb2siLCJyZW1vdmVBdHRyIiwiblR5cGUiLCJhdHRySG9va3MiLCJib29sIiwiYXR0ck5hbWVzIiwiZ2V0dGVyIiwibG93ZXJjYXNlTmFtZSIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicHJvcEZpeCIsInRhYmluZGV4Iiwic3RyaXBBbmRDb2xsYXBzZSIsImdldENsYXNzIiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwiY3VyVmFsdWUiLCJjbGF6eiIsImZpbmFsVmFsdWUiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwic3RhdGVWYWwiLCJjbGFzc05hbWVzIiwiaGFzQ2xhc3MiLCJycmV0dXJuIiwidmFsSG9va3MiLCJvcHRpb25TZXQiLCJyZm9jdXNNb3JwaCIsIm9ubHlIYW5kbGVycyIsImJ1YmJsZVR5cGUiLCJvbnR5cGUiLCJldmVudFBhdGgiLCJwYXJlbnRXaW5kb3ciLCJzaW11bGF0ZSIsInRyaWdnZXJIYW5kbGVyIiwiaG92ZXIiLCJmbk92ZXIiLCJmbk91dCIsImZvY3VzaW4iLCJhdHRhY2hlcyIsIm5vbmNlIiwicnF1ZXJ5IiwicGFyc2VYTUwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ0cmFkaXRpb25hbCIsInBhcmFtIiwidmFsdWVPckZ1bmN0aW9uIiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJyMjAiLCJyaGFzaCIsInJhbnRpQ2FjaGUiLCJyaGVhZGVycyIsInJsb2NhbFByb3RvY29sIiwicm5vQ29udGVudCIsInJwcm90b2NvbCIsInRyYW5zcG9ydHMiLCJhbGxUeXBlcyIsIm9yaWdpbkFuY2hvciIsImFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsInN0cnVjdHVyZSIsImRhdGFUeXBlRXhwcmVzc2lvbiIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsImFqYXhTZXR0aW5ncyIsImFqYXhIYW5kbGVSZXNwb25zZXMiLCJyZXNwb25zZXMiLCJjdCIsImZpbmFsRGF0YVR5cGUiLCJmaXJzdERhdGFUeXBlIiwibWltZVR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsImNvbnZlcnRlcnMiLCJhamF4Q29udmVydCIsInJlc3BvbnNlIiwiaXNTdWNjZXNzIiwiY29udjIiLCJjdXJyZW50IiwiY29udiIsInJlc3BvbnNlRmllbGRzIiwiZGF0YUZpbHRlciIsInRocm93cyIsImFjdGl2ZSIsImxhc3RNb2RpZmllZCIsImV0YWciLCJ1cmwiLCJpc0xvY2FsIiwicHJvdG9jb2wiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwiYWNjZXB0cyIsImpzb24iLCJhamF4U2V0dXAiLCJzZXR0aW5ncyIsImFqYXhQcmVmaWx0ZXIiLCJhamF4VHJhbnNwb3J0IiwiYWpheCIsInRyYW5zcG9ydCIsImNhY2hlVVJMIiwicmVzcG9uc2VIZWFkZXJzU3RyaW5nIiwicmVzcG9uc2VIZWFkZXJzIiwidGltZW91dFRpbWVyIiwidXJsQW5jaG9yIiwiZmlyZUdsb2JhbHMiLCJ1bmNhY2hlZCIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib3ZlcnJpZGVNaW1lVHlwZSIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsImNyb3NzRG9tYWluIiwiaG9zdCIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzdWNjZXNzIiwic2VuZCIsIm5hdGl2ZVN0YXR1c1RleHQiLCJtb2RpZmllZCIsImdldEpTT04iLCJnZXRTY3JpcHQiLCJ3cmFwQWxsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ3cmFwSW5uZXIiLCJ1bndyYXAiLCJ2aXNpYmxlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsInVzZXJuYW1lIiwieGhyRmllbGRzIiwib25sb2FkIiwib25lcnJvciIsIm9uYWJvcnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJiaW5hcnkiLCJjaGFyc2V0Iiwic2NyaXB0Q2hhcnNldCIsImV2dCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwicGFyYW1zIiwiYW5pbWF0ZWQiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJyZWN0Iiwid2luIiwicGFnZVlPZmZzZXQiLCJjbGllbnRUb3AiLCJwYWdlWE9mZnNldCIsImNsaWVudExlZnQiLCJvZmZzZXRQYXJlbnQiLCJwYXJlbnRPZmZzZXQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJob2xkUmVhZHkiLCJob2xkIiwicGFyc2VKU09OIiwiZGVmaW5lIiwiX2pRdWVyeSIsIl8kIiwiJCIsIm5vQ29uZmxpY3QiLCJyZXBsYWNlUm91dGUiLCJleHBsb2RlIiwiYXBwIiwicm91dGVyIiwicmVxdWlyZSIsIm5vdGZvdW5kIiwibWlzcyIsInBhcnNlciIsInN0cmluZ2lmaWVyIiwiYmxvY2tzIiwicmVuZGVyVk5vZGUiLCJvbGRWTm9kZSIsInRlbXBsYXRlRm4iLCJhc3QiLCJoc2NyaXB0IiwiZmlsZW5hbWUiLCJ2aXJ0dWFsRG9tIiwiUGFyc2VyIiwiVXRpbHMiLCJlbGVtZW50TmFtZVJlZ2V4cCIsImlzSlNYSWRlbnRpZmllclBhcnQiLCJsaW5lIiwiY29sdW1uIiwiX3BhcnNlVGVtcGxhdGUiLCJpc1Jvb3QiLCJicmFjZXMiLCJfYWR2YW5jZSIsIl9jaGFyIiwiX2lzSlNJbXBvcnQiLCJfc2NhbkpTSW1wb3J0IiwiX3NjYW5KUyIsIl9zY2FuSlNYIiwiRGVsaW1pdGVycyIsIl9za2lwSlNDb21tZW50IiwiX3NjYW5TdHJpbmdMaXRlcmFsIiwiX2lzRWxlbWVudFN0YXJ0IiwiX2lzRXhwZWN0IiwiX3VwZGF0ZUxpbmUiLCJfdXBkYXRlSW5kZXgiLCJfdHlwZSIsIl9lcnJvciIsIlN0cmluZ0xpdGVyYWwiLCJfcGFyc2VKU1hFbGVtZW50IiwiX3NjYW5KU1hUZXh0Iiwic3RvcENoYXJzIiwiX2NoYXJDb2RlIiwiX3NjYW5KU1hTdHJpbmdMaXRlcmFsIiwiX2V4cGVjdCIsIl9wYXJzZUpTWENvbW1lbnQiLCJfcGFyc2VBdHRyaWJ1dGVBbmRDaGlsZHJlbiIsIl9wYXJzZUpTWEF0dHJpYnV0ZSIsImRpcmVjdGl2ZXMiLCJfcGFyc2VKU1hDaGlsZHJlbiIsImhhc1ZSYXciLCJfc2tpcFdoaXRlc3BhY2UiLCJfcGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyIiwiX3BhcnNlSlNYQXR0cmlidXRlTmFtZSIsIl9wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlIiwiZXhwcmVzc2lvbiIsIl9wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiIsIl9wYXJzZUpTWFVuZXNjYXBlVGV4dCIsIl9wYXJzZUV4cHJlc3Npb24iLCJlbmRUYWciLCJfc2tpcFdoaXRlc3BhY2VCZXR3ZWVuRWxlbWVudHMiLCJfcGFyc2VKU1hDaGlsZCIsIl9wYXJzZUpTWENsb3NpbmdFbGVtZW50IiwiY2hhckF0IiwidHlwZU5hbWUiLCJTdHJpbmdpZmllciIsImF0dHJNYXAiLCJub3JtYWxpemVBcmdzIiwiZW50ZXJTdHJpbmdFeHByZXNzaW9uIiwiX3Zpc2l0SlNYRXhwcmVzc2lvbkNvbnRhaW5lciIsImhhc0Rlc3RydWN0dXJpbmciLCJfdmlzaXQiLCJfdmlzaXRKUyIsIl92aXNpdEpTWEVsZW1lbnQiLCJfdmlzaXRKU1hUZXh0IiwiX3Zpc2l0SlNYVW5lc2NhcGVUZXh0IiwiX3Zpc2l0SlNYV2lkZ2V0IiwiX3Zpc2l0SlNYQmxvY2siLCJfdmlzaXRKU1hWZHQiLCJfdmlzaXRKU1hDb21tZW50IiwiX3Zpc2l0SlNYQ2hpbGRyZW5Bc1N0cmluZyIsIl92aXNpdEpTWEF0dHJpYnV0ZSIsIl92aXNpdEpTWENoaWxkcmVuIiwiX3Zpc2l0SlNYRGlyZWN0aXZlIiwiX3NraXAiLCJkaXJlY3RpdmVGb3IiLCJkaXJlY3RpdmUiLCJfdmlzaXRKU1hEaXJlY3RpdmVJZiIsIl92aXNpdEpTWEF0dHJpYnV0ZVZhbHVlIiwiX3Zpc2l0SlNYRGlyZWN0aXZlRm9yIiwiaGFzRWxzZSIsImVtcHR5VGV4dE5vZGVzIiwic2tpcE5vZGVzIiwiaXNDb250aW51ZSIsImRpcmUiLCJpbmRpdmlkdWFsQ2xhc3NOYW1lIiwiaW5kaXZpZHVhbEtleUFuZFJlZiIsImhhc01vZGVsIiwiYWRkaXRpb24iLCJfdmlzaXRKU1hBdHRyaWJ1dGVNb2RlbCIsInZhbHVlTmFtZSIsImlucHV0VmFsdWUiLCJub1F1b3RlcyIsIl92aXNpdEpTWEJsb2NrcyIsImhhc0Jsb2NrIiwiaXNBbmNlc3RvciIsIl9ibG9ja3MiLCJwcm9jZXNzU2VsZWN0IiwiaGFzU2VsZWN0ZWQiLCJ1cGRhdGVDaGlsZE9wdGlvbkdyb3VwIiwidXBkYXRlQ2hpbGRPcHRpb24iLCJwcm9jZXNzSW5wdXQiLCJoYXNWYWx1ZSIsImlzQ2hlY2tlZFR5cGUiLCJwcm9jZXNzVGV4dGFyZWEiLCJkb21WYWx1ZSIsImVzY2FwZVRleHQiLCJpc051bWJlciIsInJlbmRlclN0eWxlc1RvU3RyaW5nIiwicmVuZGVyRGF0YXNldFRvU3RyaW5nIiwicmVuZGVyQXR0cmlidXRlc1RvU3RyaW5nIiwicmVuZGVyQXR0cmlidXRlVG9TdHJpbmciLCJlc2NhcGVTdHJpbmciLCJyZW5kZXJlZFN0cmluZyIsInN0eWxlTmFtZSIsImh5ZHJhdGVFbGVtZW50IiwiaHlkcmF0ZUh0bWxFbGVtZW50IiwiaHlkcmF0ZVRleHQiLCJoeWRyYXRlQ29tbWVudCIsImh5ZHJhdGVDb21wb25lbnRDbGFzc09ySW5zdGFuY2UiLCJjb21tZW50Iiwid2FybmluZyIsImh5ZHJhdGVDaGlsZHJlbiIsInByZXZpb3VzU2libGluZyIsIm5leHRGcmFtZSIsImlzU3VwcG9ydENzc1RyYW5zaXRpb24iLCJlbmRFdmVudHMiLCJtb3VudENoaWxkcmVuIiwidW5tb3VudENoaWxkcmVuIiwidXBkYXRlQ2hpbGRyZW4iLCJfZW50ZXJpbmdBbW91bnQiLCJfbGVhdmluZ0Ftb3VudCIsIl9oYXNKc1RyYW5zaXRpb24iLCJfcmVzZXJ2ZSIsImlzQXBwZWFyIiwiaW5pdENsYXNzTmFtZSIsIm9sZFZhbHVlIiwidHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJtb3ZlQ2xhc3MiLCJlbnRlckV2ZW50TmFtZSIsIl9sZWF2aW5nIiwicGFyZW50SW5zdGFuY2UiLCJfZ2V0UGFyZW50QW5pbWF0ZSIsIl9lbnRlckVuZCIsIlRyYW5zaXRpb25FdmVudHMiLCJfZW50ZXJpbmciLCJfY2hlY2tNb2RlIiwibm91c2UiLCJfZGVsYXlFbnRlciIsImlzTm90QW5pbWF0ZSIsIl9kZWxheUxlYXZlIiwiX2VudGVyIiwiX2xlYXZlRW5kIiwiX3RyaWdnZXJlZExlYXZlIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwiX3VubW91bnRDYW5jZWxsZWQiLCJfbGVhdmUiLCJyZXNlcnZlZENoaWxkcmVuIiwiaXNNb3ZlIiwiX2dldFBvc2l0aW9uIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsIm1hdHJpeCIsIkNTU01hdHJpeCIsIm00MiIsIm00MSIsImlzRnJvbUNoZWNrTW9kZSIsImZvckVhY2giLCJfbW92aW5nIiwiX21vdmVFbmQiLCJuZXdQb3NpdGlvbiIsIl9pbml0TW92ZSIsIl9uZWVkTW92ZSIsIl9tb3ZlIiwiX3RyaWdnZXJNb3ZlIiwiaXNVbm1vdW50Iiwib2xkUG9zaXRpb24iLCJkeCIsImR5Iiwib0R4Iiwib0R5IiwiZ2V0QW5pbWF0ZVR5cGUiLCJwcm9wZXJ0eU5hbWUiLCJpc0NzcyIsImlzVHJhbnNpdGlvbiIsIl90cmlnZ2VyRW50ZXIiLCJfdHJpZ2dlcmVkRW50ZXIiLCJfdHJpZ2dlckxlYXZlIiwiY2xhc3NMaXN0IiwiRVZFTlRfTkFNRV9NQVAiLCJ0cmFuc2l0aW9uZW5kIiwiYW5pbWF0aW9uZW5kIiwidHJhbnNpdGlvblByb3AiLCJhbmltYXRpb25Qcm9wIiwiZGV0ZWN0RXZlbnRzIiwidGVzdEVsIiwiYmFzZUV2ZW50TmFtZSIsImJhc2VFdmVudHMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiZ2V0RHVyYXRpb24iLCJhbmltYXRpb25EdXJhdGlvbiIsImR1cmF0aW9ucyIsImQiLCJldmVudExpc3RlbmVyIiwiZW5kRXZlbnQiLCJsaXN0ZW5lciIsInJhZiIsIldlYktpdENTU01hdHJpeCIsImxvYWRpbmciLCJQYWdlIiwicGFnZSIsIl9fcGFnZV9fIiwiX1ZkdCIsIiRjYWxsZWUiLCJfX2Jsb2NrcyIsIl9fdSIsIl9lIiwiX2NsYXNzTmFtZSIsIl9fbyIsIl9nZXRNb2RlbCIsIl9zZXRNb2RlbCIsIl9zZXRDaGVja2JveE1vZGVsIiwiX2RldGVjdENoZWNrYm94Q2hlY2tlZCIsIl9zZXRTZWxlY3RNb2RlbCIsIiR0aGlzIiwic2NvcGUiLCJiYXNlVXJsIiwiY3VycmVudERpciIsInBhdGhuYW1lIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwiJDEiLCJuZXdVcmwiLCJkbG9jIiwiZGxvY0hhc2hFbXB0eSIsIm1vZGUiLCJoaXN0b3J5Iiwib25IYXNoQ2hhbmdlZCIsIm9ucG9wc3RhdGUiLCJvbmhhc2hjaGFuZ2UiLCJSb3V0ZXIiLCJvbmNoYW5nZSIsIm9uQ2hhbmdlRXZlbnQiLCJkb2N1bWVudE1vZGUiLCJmcmFtZSIsIndyaXRlRnJhbWUiLCJzZXRJbnRlcnZhbCIsInNldEhhc2giLCJwdXNoU3RhdGUiLCJmIiwiY29udGVudFdpbmRvdyIsIndyaXRlIiwiY2xvc2UiLCJzeW5jSGFzaCIsIl9oYXNoIiwicm91dGVzIiwibWV0aG9kcyIsIl9tZXRob2RzIiwiX2luc2VydCIsImluc2VydEV4IiwiaGlzdG9yeVN1cHBvcnQiLCJyIiwicm91dGVUbyIsIm5ld1VSTCIsImdldFBhdGgiLCJjb252ZXJ0X2hhc2hfaW5faW5pdCIsInJlcGxhY2VTdGF0ZSIsInJ1bl9pbl9pbml0Iiwic2V0Um91dGUiLCJyb3V0ZSIsImdldFJvdXRlIiwiX2V2ZXJ5IiwiX2ZsYXR0ZW4iLCJmbGF0IiwiX2FzeW5jRXZlcnlTZXJpZXMiLCJpdGVyYXRlIiwicGFyYW1pZnlTdHJpbmciLCJtb2QiLCJyZWdpZnlTdHJpbmciLCJvdXQiLCJjYXB0dXJlcyIsInRlcm1pbmF0b3IiLCJkZWxpbWl0ZXIiLCJyaWdodCIsImNodW5rIiwiUVVFUllfU0VQQVJBVE9SIiwicmVjdXJzZSIsInN0cmljdCIsInJlc291cmNlIiwiaHRtbDVoaXN0b3J5IiwicnVuX2hhbmRsZXJfaW5faW5pdCIsImV2ZXJ5Iiwicm91dGVzRm4iLCJ0cmF2ZXJzZSIsImludm9rZWQiLCJfaW52b2tlZCIsImludm9rZSIsInVwZGF0ZUFuZEludm9rZSIsInJ1bmxpc3QiLCJyZWdleHAiLCJleGFjdCIsImZpbHRlclJvdXRlcyIsImRlZXBDb3B5IiwiYXBwbHlGaWx0ZXIiLCJuZXdSb3V0ZXMiLCJCb29sZWFuIiwibWV0aG9kVHlwZSIsInBhcmVudFR5cGUiLCJwYXJ0IiwiaW5zZXJ0T3JNb3VudCIsImxvY2FsIiwicmVuYW1lIiwicm91dGVUeXBlIiwiaXNSb3V0ZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxXQUFXLEVBQUU7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUEyRCxpRkFBaUY7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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RUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7O0FDekJBO0FBQ0E7OztBQUdBO0FBQ0Esc0NBQXVDLGNBQWMsb0JBQW9CLGdCQUFnQix3QkFBd0IsaUJBQWlCLEdBQUcsS0FBSyxtQkFBbUIsMEJBQTBCLG9CQUFvQixHQUFHLDBCQUEwQixjQUFjLHdCQUF3QixnQkFBZ0IsR0FBRyxNQUFNLG1CQUFtQixHQUFHLE1BQU0scUJBQXFCLEdBQUcsTUFBTSxxQkFBcUIsR0FBRyxRQUFRLG1CQUFtQiw4QkFBOEIsdUJBQXVCLG1CQUFtQixHQUFHLGNBQWMsa0JBQWtCLHFCQUFxQix3QkFBd0IsK0JBQStCLG1DQUFtQyx1QkFBdUIsR0FBRyxxQkFBcUIsaUJBQWlCLG1CQUFtQix1QkFBdUIsYUFBYSxzQkFBc0IsZ0JBQWdCLGlCQUFpQix3QkFBd0IsdUJBQXVCLHdCQUF3QixnQkFBZ0Isc0JBQXNCLGdCQUFnQixHQUFHLHdDQUF3QyxpQkFBaUIsR0FBRyxtQkFBbUIsaUJBQWlCLHNCQUFzQiwyQ0FBMkMscUJBQXFCLG9CQUFvQixnQkFBZ0IsV0FBVyxpQkFBaUIsR0FBRywwQkFBMEIsa0JBQWtCLG1CQUFtQixHQUFHLHlCQUF5QixvQkFBb0IsZ0JBQWdCLHNCQUFzQixHQUFHLHVCQUF1QixpQkFBaUIsdUJBQXVCLEdBQUcseUJBQXlCLDBCQUEwQixvQkFBb0IsZ0JBQWdCLEdBQUcsZ0NBQWdDLG1CQUFtQixHQUFHLDJCQUEyQix1QkFBdUIsY0FBYyxxQ0FBcUMsR0FBRyxlQUFlLHdEQUF3RCxHQUFHLFNBQVMsZ0JBQWdCLEdBQUcsUUFBUSxnQkFBZ0IsR0FBRyxXQUFXLG1CQUFtQixHQUFHOztBQUV6d0QiLCJmaWxlIjoiYnVkZGxlLWludGFjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl0gPSBmdW5jdGlvbiB3ZWJwYWNrSnNvbnBDYWxsYmFjayhjaHVua0lkcywgbW9yZU1vZHVsZXMsIGV4ZWN1dGVNb2R1bGVzKSB7XG4gXHRcdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbiBcdFx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXSwgcmVzdWx0O1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBleGVjdXRlTW9kdWxlcyk7XG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHR9O1xuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3RzIHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdDM6IDBcbiBcdH07XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuIFx0Ly8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuIFx0Ly8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSBmdW5jdGlvbiByZXF1aXJlRW5zdXJlKGNodW5rSWQpIHtcbiBcdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhID09PSAwKSB7XG4gXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHsgcmVzb2x2ZSgpOyB9KTtcbiBcdFx0fVxuXG4gXHRcdC8vIGEgUHJvbWlzZSBtZWFucyBcImN1cnJlbnRseSBsb2FkaW5nXCIuXG4gXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRDaHVua0RhdGFbMl07XG4gXHRcdH1cblxuIFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG4gXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF07XG4gXHRcdH0pO1xuIFx0XHRpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlO1xuXG4gXHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gXHRcdHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04JztcbiBcdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiBcdFx0c2NyaXB0LnRpbWVvdXQgPSAxMjAwMDA7XG5cbiBcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcbiBcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG4gXHRcdH1cbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwic3RhdGljL2NodW5rL1wiICsge1wiMFwiOlwiYzRiMjBlNGI1ZDk3MmYxMTIyYjFcIixcIjFcIjpcIjc4YjY1NmEzNjNmMzc3NWEzMDBhXCIsXCIyXCI6XCJlODU0MzZkYTQ5NTA2YmYyZDE1ZVwifVtjaHVua0lkXSArIFwiLmpzXCI7XG4gXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLCAxMjAwMDApO1xuIFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlO1xuIFx0XHRmdW5jdGlvbiBvblNjcmlwdENvbXBsZXRlKCkge1xuIFx0XHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cbiBcdFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuIFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiBcdFx0XHR2YXIgY2h1bmsgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHRcdFx0aWYoY2h1bmsgIT09IDApIHtcbiBcdFx0XHRcdGlmKGNodW5rKSB7XG4gXHRcdFx0XHRcdGNodW5rWzFdKG5ldyBFcnJvcignTG9hZGluZyBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLicpKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcbiBcdFx0XHR9XG4gXHRcdH07XG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiBcdH07XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE3KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjN2MxOTUyOTZjZWMxNGMxYzZjMSIsImNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZXhwb3J0IGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGRvY3VtZW50O1xuXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJyKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdPck51bWJlcihvKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvO1xuICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudEluc3RhbmNlKG8pIHtcbiAgICByZXR1cm4gbyAmJiB0eXBlb2Ygby5pbml0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFdmVudFByb3AocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gcHJvcE5hbWUuc3Vic3RyKDAsIDMpID09PSAnZXYtJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW52YWxpZChvKSB7XG4gICAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKG8pIHx8IG8gPT09IGZhbHNlIHx8IG8gPT09IHRydWU7XG59XG5cbmV4cG9ydCBjb25zdCBpbmRleE9mID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuY29uc3QgbmF0aXZlT2JqZWN0ID0gT2JqZWN0LmNyZWF0ZTtcbmV4cG9ydCBjb25zdCBjcmVhdGVPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKG5hdGl2ZU9iamVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlT2JqZWN0KG9iaik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgZnVuY3Rpb24gRm4oKSB7fVxuICAgICAgICAgICAgRm4ucHJvdG90eXBlID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigpO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBTaW1wbGVNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gTWFwIDogKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZU1hcCgpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gaW5kZXhPZih0aGlzLl9rZXlzLCBrZXkpO1xuICAgICAgICBpZiAoIX5pbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9rZXlzLnB1c2goa2V5KSAtIDE7XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gaW5kZXhPZih0aGlzLl9rZXlzLCBrZXkpO1xuICAgICAgICBpZiAoIX5pbmRleCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW2luZGV4XTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZih0aGlzLl9rZXlzLCBrZXkpO1xuICAgICAgICBpZiAoIX5pbmRleCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl9rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHJldHVybiBTaW1wbGVNYXA7XG59KSgpO1xuXG5leHBvcnQgY29uc3Qgc2tpcFByb3BzID0ge1xuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWUsXG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgY2xhc3NOYW1lOiB0cnVlLFxuICAgIGNoZWNrZWQ6IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWUsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICd2LW1vZGVsJzogdHJ1ZSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NraXBQcm9wKHByb3ApIHtcbiAgICAvLyB0cmVhdCBwcm9wIHdoaWNoIHN0YXJ0IHdpdGggJ18nIGFzIHByaXZhdGUgcHJvcCwgc28gc2tpcCBpdFxuICAgIHJldHVybiBza2lwUHJvcHNbcHJvcF0gfHwgcHJvcFswXSA9PT0gJ18nO1xufVxuXG5leHBvcnQgY29uc3QgYm9vbGVhblByb3BzID0ge1xuICAgIG11dGVkOiB0cnVlLFxuICAgIHNjb3BlZDogdHJ1ZSxcbiAgICBsb29wOiB0cnVlLFxuICAgIG9wZW46IHRydWUsXG4gICAgY2hlY2tlZDogdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgcmVhZE9ubHk6IHRydWUsXG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgYXV0b3BsYXk6IHRydWUsXG4gICAgY29udHJvbHM6IHRydWUsXG4gICAgc2VhbWxlc3M6IHRydWUsXG4gICAgcmV2ZXJzZWQ6IHRydWUsXG4gICAgYWxsb3dmdWxsc2NyZWVuOiB0cnVlLFxuICAgIG5vVmFsaWRhdGU6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICBzZWxlY3RlZDogdHJ1ZSxcbiAgICBpbmRldGVybWluYXRlOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmljdFByb3BzID0ge1xuICAgIHZvbHVtZTogdHJ1ZSxcbiAgICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBodG1sRm9yOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IHNlbGZDbG9zaW5nVGFncyA9IHtcbiAgICAnYXJlYSc6IHRydWUsXG4gICAgJ2Jhc2UnOiB0cnVlLFxuICAgICdicic6IHRydWUsXG4gICAgJ2NvbCc6IHRydWUsXG4gICAgJ2NvbW1hbmQnOiB0cnVlLFxuICAgICdlbWJlZCc6IHRydWUsXG4gICAgJ2hyJzogdHJ1ZSxcbiAgICAnaW1nJzogdHJ1ZSxcbiAgICAnaW5wdXQnOiB0cnVlLFxuICAgICdrZXlnZW4nOiB0cnVlLFxuICAgICdsaW5rJzogdHJ1ZSxcbiAgICAnbWVudWl0ZW0nOiB0cnVlLFxuICAgICdtZXRhJzogdHJ1ZSxcbiAgICAncGFyYW0nOiB0cnVlLFxuICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICd0cmFjayc6IHRydWUsXG4gICAgJ3dicic6IHRydWVcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBNb3VudGVkUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xufVxuTW91bnRlZFF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goZm4pO1xufTtcbk1vdW50ZWRRdWV1ZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5xdWV1ZS51bnNoaWZ0KGZuKTtcbn07XG5Nb3VudGVkUXVldWUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIHdoaWxlIChjYWxsYmFjayA9IHF1ZXVlLnNoaWZ0KCkpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgYnJvd3NlciA9IHt9O1xuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaW5kZXggPSB1YS5pbmRleE9mKCdtc2llICcpO1xuICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgYnJvd3Nlci5pc0lFID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KHVhLnN1YnN0cmluZyhpbmRleCArIDUsIHVhLmluZGV4T2YoJy4nLCBpbmRleCkpLCAxMCk7XG4gICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIGJyb3dzZXIuaXNJRTggPSB2ZXJzaW9uID09PSA4O1xuICAgIH0gZWxzZSBpZiAofnVhLmluZGV4T2YoJ2VkZ2UnKSkge1xuICAgICAgICBicm93c2VyLmlzRWRnZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh+dWEuaW5kZXhPZignc2FmYXJpJykpIHtcbiAgICAgICAgaWYgKH51YS5pbmRleE9mKCdjaHJvbWUnKSkge1xuICAgICAgICAgICAgYnJvd3Nlci5pc0Nocm9tZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicm93c2VyLmlzU2FmYXJpID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldFRleHRDb250ZW50ID0gYnJvd3Nlci5pc0lFOCA/IGZ1bmN0aW9uKGRvbSwgdGV4dCkge1xuICAgIGRvbS5pbm5lclRleHQgPSB0ZXh0O1xufSA6IGZ1bmN0aW9uKGRvbSwgdGV4dCkge1xuICAgIGRvbS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5leHBvcnQgY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5leHBvcnQgY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZXhwb3J0IGNvbnN0IHhtbE5TID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcblxuZXhwb3J0IGNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gICAgJ3hsaW5rOmhyZWYnOiB4bGlua05TLFxuICAgICd4bGluazphcmNyb2xlJzogeGxpbmtOUyxcbiAgICAneGxpbms6YWN0dWF0ZSc6IHhsaW5rTlMsXG4gICAgJ3hsaW5rOnNob3cnOiB4bGlua05TLFxuICAgICd4bGluazpyb2xlJzogeGxpbmtOUyxcbiAgICAneGxpbms6dGl0bGUnOiB4bGlua05TLFxuICAgICd4bGluazp0eXBlJzogeGxpbmtOUyxcbiAgICAneG1sOmJhc2UnOiB4bWxOUyxcbiAgICAneG1sOmxhbmcnOiB4bWxOUyxcbiAgICAneG1sOnNwYWNlJzogeG1sTlMsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy91dGlscy5qcyIsImltcG9ydCB7XG4gICAgaXNBcnJheSwgaXNTdHJpbmdPck51bWJlciwgaXNOdWxsT3JVbmRlZmluZWQsIFxuICAgIGlzQ29tcG9uZW50SW5zdGFuY2UsIGJyb3dzZXIsIGlzSW52YWxpZFxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFR5cGVzID0ge1xuICAgIFRleHQ6IDEsXG4gICAgSHRtbEVsZW1lbnQ6IDEgPDwgMSxcblxuICAgIENvbXBvbmVudENsYXNzOiAxIDw8IDIsXG4gICAgQ29tcG9uZW50RnVuY3Rpb246IDEgPDwgMyxcbiAgICBDb21wb25lbnRJbnN0YW5jZTogMSA8PCA0LFxuXG4gICAgSHRtbENvbW1lbnQ6IDEgPDwgNSxcblxuICAgIElucHV0RWxlbWVudDogMSA8PCA2LFxuICAgIFNlbGVjdEVsZW1lbnQ6IDEgPDwgNyxcbiAgICBUZXh0YXJlYUVsZW1lbnQ6IDEgPDwgOCxcbiAgICBTdmdFbGVtZW50OiAxIDw8IDksXG5cbiAgICBVbmVzY2FwZVRleHQ6IDEgPDwgMTAgLy8gZm9yIHNlcnZlciBzaWRlIHJlbmRlciB1bmVzY2FwZSB0ZXh0XG59O1xuVHlwZXMuRm9ybUVsZW1lbnQgPSBUeXBlcy5JbnB1dEVsZW1lbnQgfCBUeXBlcy5TZWxlY3RFbGVtZW50IHwgVHlwZXMuVGV4dGFyZWFFbGVtZW50O1xuVHlwZXMuRWxlbWVudCA9IFR5cGVzLkh0bWxFbGVtZW50IHwgVHlwZXMuRm9ybUVsZW1lbnQgfCBUeXBlcy5TdmdFbGVtZW50O1xuVHlwZXMuQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlID0gVHlwZXMuQ29tcG9uZW50Q2xhc3MgfCBUeXBlcy5Db21wb25lbnRJbnN0YW5jZTtcblR5cGVzLlRleHRFbGVtZW50ID0gVHlwZXMuVGV4dCB8IFR5cGVzLkh0bWxDb21tZW50O1xuXG5leHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhYnJvd3Nlci5pc0lFKSB7XG4gICAgT2JqZWN0LmZyZWV6ZShFTVBUWV9PQkopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVk5vZGUodHlwZSwgdGFnLCBwcm9wcywgY2hpbGRyZW4sIGNsYXNzTmFtZSwga2V5LCByZWYpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5yZWYgPSByZWY7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG59IFxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodGFnLCBwcm9wcywgY2hpbGRyZW4sIGNsYXNzTmFtZSwga2V5LCByZWYpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBwcm9wcyB8fCAocHJvcHMgPSBFTVBUWV9PQkopO1xuICAgIHN3aXRjaCAodHlwZW9mIHRhZykge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBUeXBlcy5JbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBUeXBlcy5TZWxlY3RFbGVtZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gVHlwZXMuVGV4dGFyZWFFbGVtZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFR5cGVzLlN2Z0VsZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBUeXBlcy5IdG1sRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBpZiAodGFnLnByb3RvdHlwZS5pbml0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFR5cGVzLkNvbXBvbmVudENsYXNzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGFnKHByb3BzKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gVHlwZXMuQ29tcG9uZW50RnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh0YWcuaW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZVZOb2RlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdk5vZGUgdHlwZTogJHt0YWd9YCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgJiAoVHlwZXMuQ29tcG9uZW50Q2xhc3MgfCBUeXBlcy5Db21wb25lbnRGdW5jdGlvbikpIHtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcyA9PT0gRU1QVFlfT0JKKSBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocHJvcHMuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKHByb3BzLmNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgJiBUeXBlcy5Db21wb25lbnRGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMgPT09IEVNUFRZX09CSikgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSBwcm9wcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZikgcHJvcHMucmVmID0gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhZyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBWTm9kZSh0eXBlLCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgXG4gICAgICAgIGNsYXNzTmFtZSB8fCBwcm9wcy5jbGFzc05hbWUsIFxuICAgICAgICBrZXkgfHwgcHJvcHMua2V5LCBcbiAgICAgICAgcmVmIHx8IHByb3BzLnJlZlxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKFR5cGVzLkh0bWxDb21tZW50LCBudWxsLCBFTVBUWV9PQkosIGNoaWxkcmVuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuZXNjYXBlVGV4dFZOb2RlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShUeXBlcy5VbmVzY2FwZVRleHQsIG51bGwsIEVNUFRZX09CSiwgY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKFR5cGVzLlRleHQsIG51bGwsIEVNUFRZX09CSiwgdGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWb2lkVk5vZGUoKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShUeXBlcy5Wb2lkRWxlbWVudCwgbnVsbCwgRU1QVFlfT0JKKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlVk5vZGUoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICByZXR1cm4gbmV3IFZOb2RlKFR5cGVzLkNvbXBvbmVudEluc3RhbmNlLCBpbnN0YW5jZS5jb25zdHJ1Y3RvciwgXG4gICAgICAgIHByb3BzLCBpbnN0YW5jZSwgbnVsbCwgcHJvcHMua2V5LCBwcm9wcy5yZWZcbiAgICApO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2Tm9kZXMsIGlzQWRkS2V5KSB7XG4gICAgaWYgKGlzQXJyYXkodk5vZGVzKSkge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gYWRkQ2hpbGQodk5vZGVzLCB7aW5kZXg6IDB9LCBpc0FkZEtleSk7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGVzLmxlbmd0aCA/IGNoaWxkTm9kZXMgOiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNDb21wb25lbnRJbnN0YW5jZSh2Tm9kZXMpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZVZOb2RlKHZOb2Rlcyk7XG4gICAgfSBlbHNlIGlmICh2Tm9kZXMudHlwZSAmJiAhaXNOdWxsT3JVbmRlZmluZWQodk5vZGVzLmRvbSkpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdENsb25lKHZOb2Rlcyk7XG4gICAgfVxuICAgIHJldHVybiB2Tm9kZXM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5S2V5KHZOb2RlLCByZWZlcmVuY2UsIGlzQWRkS2V5KSB7XG4gICAgaWYgKCFpc0FkZEtleSkgcmV0dXJuIHZOb2RlO1xuICAgIC8vIHN0YXJ0IHdpdGggJy4nIG1lYW5zIHRoZSB2Tm9kZSBoYXMgYmVlbiBzZXQga2V5IGJ5IGluZGV4XG4gICAgLy8gd2Ugd2lsbCByZXNldCB0aGUga2V5IHdoZW4gaXQgY29tZXMgYmFjayBhZ2FpblxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2Tm9kZS5rZXkpIHx8IHZOb2RlLmtleVswXSA9PT0gJy4nKSB7XG4gICAgICAgIHZOb2RlLmtleSA9IGAuJCR7cmVmZXJlbmNlLmluZGV4Kyt9YDtcbiAgICB9IFxuICAgIHJldHVybiB2Tm9kZTtcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGQodk5vZGVzLCByZWZlcmVuY2UsIGlzQWRkS2V5KSB7XG4gICAgbGV0IG5ld1ZOb2RlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gdk5vZGVzW2ldO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobikpIHtcbiAgICAgICAgICAgIGlmICghbmV3Vk5vZGVzKSB7XG4gICAgICAgICAgICAgICAgbmV3Vk5vZGVzID0gdk5vZGVzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobikpIHtcbiAgICAgICAgICAgIGlmICghbmV3Vk5vZGVzKSB7XG4gICAgICAgICAgICAgICAgbmV3Vk5vZGVzID0gdk5vZGVzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Vk5vZGVzID0gbmV3Vk5vZGVzLmNvbmNhdChhZGRDaGlsZChuLCByZWZlcmVuY2UsIGlzQWRkS2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdPck51bWJlcihuKSkge1xuICAgICAgICAgICAgaWYgKCFuZXdWTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdWTm9kZXMgPSB2Tm9kZXMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZXMucHVzaChhcHBseUtleShjcmVhdGVUZXh0Vk5vZGUobiksIHJlZmVyZW5jZSwgaXNBZGRLZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbXBvbmVudEluc3RhbmNlKG4pKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1ZOb2Rlcykge1xuICAgICAgICAgICAgICAgIG5ld1ZOb2RlcyA9IHZOb2Rlcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZOb2Rlcy5wdXNoKGFwcGx5S2V5KGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlVk5vZGUobiksIHJlZmVyZW5jZSwgaXNBZGRLZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChuLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICghbmV3Vk5vZGVzKSB7XG4gICAgICAgICAgICAgICAgbmV3Vk5vZGVzID0gdk5vZGVzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4uZG9tIHx8IChuLmtleSAmJiBuLmtleVswXSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZOb2Rlcy5wdXNoKGFwcGx5S2V5KGRpcmVjdENsb25lKG4pLCByZWZlcmVuY2UsIGlzQWRkS2V5KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZOb2Rlcy5wdXNoKGFwcGx5S2V5KG4sIHJlZmVyZW5jZSwgaXNBZGRLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3Vk5vZGVzIHx8IHZOb2Rlcztcbn1cblxuZnVuY3Rpb24gZGlyZWN0Q2xvbmUodk5vZGUpIHtcbiAgICBsZXQgbmV3Vk5vZGU7XG4gICAgY29uc3QgdHlwZSA9IHZOb2RlLnR5cGU7XG5cbiAgICBpZiAodHlwZSAmIFR5cGVzLkNvbXBvbmVudENsYXNzT3JJbnN0YW5jZSkge1xuICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgIGNvbnN0IHByb3BzVG9DbG9uZSA9IHZOb2RlLnByb3BzO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByb3BzVG9DbG9uZSA9PT0gRU1QVFlfT0JKIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHByb3BzVG9DbG9uZSkpIHtcbiAgICAgICAgICAgIHByb3BzID0gRU1QVFlfT0JKO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wc1RvQ2xvbmUpIHtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcHJvcHNUb0Nsb25lW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdWTm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgICAgIHR5cGUsIHZOb2RlLnRhZywgcHJvcHMsIFxuICAgICAgICAgICAgdk5vZGUuY2hpbGRyZW4sIG51bGwsIFxuICAgICAgICAgICAgdk5vZGUua2V5LCB2Tm9kZS5yZWZcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmIChuZXdDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcEFycmF5ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZ09yTnVtYmVyKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEFycmF5LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNJbnZhbGlkKGNoaWxkKSAmJiBjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQXJyYXkucHVzaChkaXJlY3RDbG9uZShjaGlsZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLmNoaWxkcmVuID0gdG1wQXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZHJlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvcHMuY2hpbGRyZW4gPSBkaXJlY3RDbG9uZShuZXdDaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdk5vZGUuY2hpbGRyZW47XG4gICAgICAgIGxldCBwcm9wcztcbiAgICAgICAgY29uc3QgcHJvcHNUb0Nsb25lID0gdk5vZGUucHJvcHM7XG5cbiAgICAgICAgaWYgKHByb3BzVG9DbG9uZSA9PT0gRU1QVFlfT0JKIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHByb3BzVG9DbG9uZSkpIHtcbiAgICAgICAgICAgIHByb3BzID0gRU1QVFlfT0JKO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wc1RvQ2xvbmUpIHtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcHJvcHNUb0Nsb25lW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdWTm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgICAgIHR5cGUsIHZOb2RlLnRhZywgdk5vZGUucHJvcHMsXG4gICAgICAgICAgICBjaGlsZHJlbiwgdk5vZGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgdk5vZGUua2V5LCB2Tm9kZS5yZWZcbiAgICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5UZXh0RWxlbWVudCkge1xuICAgICAgICBuZXdWTm9kZSA9IGNyZWF0ZVRleHRWTm9kZSh2Tm9kZS5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1ZOb2RlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy92bm9kZS5qcyIsIi8qKiBcbiAqIEBmaWxlb3ZlcnZpZXcgdXRpbGl0eSBtZXRob2RzXG4gKiBAYXV0aG9yIGphdmV5XG4gKiBAZGF0ZSAxNS00LTIyXG4gKi9cblxuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZCwgaXNBcnJheSwgaW5kZXhPZiwgXG4gICAgc2VsZkNsb3NpbmdUYWdzIGFzIFNlbGZDbG9zaW5nVGFnc1xufSBmcm9tICdtaXNzdGltZS9zcmMvdXRpbHMnO1xuXG5leHBvcnQge2lzTnVsbE9yVW5kZWZpbmVkLCBpc0FycmF5LCBpbmRleE9mLCBTZWxmQ2xvc2luZ1RhZ3N9O1xuXG5sZXQgaSA9IDA7XG5leHBvcnQgY29uc3QgVHlwZSA9IHsgXG4gICAgSlM6IGkrKyxcbiAgICBKU0ltcG9ydDogaSsrLFxuXG4gICAgSlNYVGV4dDogaSsrLFxuICAgIEpTWFVuZXNjYXBlVGV4dDogaSsrLFxuICAgIEpTWEVsZW1lbnQ6IGkrKyxcbiAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiBpKyssXG4gICAgSlNYQXR0cmlidXRlOiBpKyssXG4gICAgSlNYRW1wdHlFeHByZXNzaW9uOiBpKyssXG5cbiAgICBKU1hXaWRnZXQ6IGkrKyxcbiAgICBKU1hWZHQ6IGkrKyxcbiAgICBKU1hCbG9jazogaSsrLFxuICAgIEpTWENvbW1lbnQ6IGkrKyxcblxuICAgIEpTWERpcmVjdGl2ZTogaSsrLFxufTtcbmV4cG9ydCBjb25zdCBUeXBlTmFtZSA9IFtdO1xuZm9yIChsZXQgdHlwZSBpbiBUeXBlKSB7XG4gICAgVHlwZU5hbWVbVHlwZVt0eXBlXV0gPSB0eXBlO1xufVxuXG4vLyB3aGljaCBjaGlsZHJlbiBtdXN0IGJlIHRleHRcbmV4cG9ydCBjb25zdCBUZXh0VGFncyA9IHtcbiAgICBzdHlsZTogdHJ1ZSxcbiAgICBzY3JpcHQ6IHRydWUsXG4gICAgdGV4dGFyZWE6IHRydWVcbn07XG5cbmV4cG9ydCBjb25zdCBEaXJlY3RpdmVzID0ge1xuICAgICd2LWlmJzogdHJ1ZSxcbiAgICAndi1lbHNlLWlmJzogdHJ1ZSxcbiAgICAndi1lbHNlJzogdHJ1ZSxcbiAgICAndi1mb3InOiB0cnVlLFxuICAgICd2LWZvci12YWx1ZSc6IHRydWUsXG4gICAgJ3YtZm9yLWtleSc6IHRydWUsXG4gICAgJ3YtcmF3JzogdHJ1ZVxufTtcblxuZXhwb3J0IGNvbnN0IE9wdGlvbnMgPSB7XG4gICAgYXV0b1JldHVybjogdHJ1ZSxcbiAgICBvbmx5U291cmNlOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXJzOiBbJ3snLCAnfSddLFxuICAgIC8vIHJlbW92ZSBgd2l0aGAgc3RhdGVtZW50XG4gICAgbm9XaXRoOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHJlbmRlcmluZyBvbiBzZXJ2ZXIgb3Igbm90XG4gICAgc2VydmVyOiBmYWxzZSxcbiAgICAvLyBza2lwIGFsbCB3aGl0ZXNwYWNlcyBpbiB0ZW1wbGF0ZVxuICAgIHNraXBXaGl0ZXNwYWNlOiB0cnVlLFxuICAgIHNldE1vZGVsOiBmdW5jdGlvbihkYXRhLCBrZXksIHZhbHVlLCBzZWxmKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgZ2V0TW9kZWw6IGZ1bmN0aW9uKGRhdGEsIGtleSkge1xuICAgICAgICByZXR1cm4gZGF0YVtrZXldOyBcbiAgICB9LFxuICAgIGRpc2FibGVTcGxpdFRleHQ6IGZhbHNlIC8vIHNwbGl0IHRleHQgd2l0aCA8IS0tLS0+XG59O1xuXG5leHBvcnQgY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBjb25zdCBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID4gLTEgJiYgbGVuZ3RoICUgMSA9PT0gMCAmJiBsZW5ndGggPD0gOTAwNzE5OTI1NDc0MDk5MSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgdGhpc0FyZykge1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlci5jYWxsKHRoaXNBcmcsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfSBcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGl0ZXIuY2FsbCh0aGlzQXJnLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqOyBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcChvYmosIGl0ZXIsIHRoaXNBcmdzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgICAgcmV0LnB1c2goaXRlci5jYWxsKHRoaXNBcmdzLCB2YWx1ZSwga2V5LCBvYmopKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWUob2JqKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG9iaikpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHJldHVybiBvYmo7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSAmJiBvYmpba2V5XSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJyAnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaGFyQ29kZSkge1xuICAgIHJldHVybiAoKGNoYXJDb2RlIDw9IDE2MCAmJiAoY2hhckNvZGUgPj0gOSAmJiBjaGFyQ29kZSA8PSAxMykgfHwgY2hhckNvZGUgPT0gMzIgfHwgY2hhckNvZGUgPT0gMTYwKSB8fCBjaGFyQ29kZSA9PSA1NzYwIHx8IGNoYXJDb2RlID09IDYxNTggfHxcbiAgICAoY2hhckNvZGUgPj0gODE5MiAmJiAoY2hhckNvZGUgPD0gODIwMiB8fCBjaGFyQ29kZSA9PSA4MjMyIHx8IGNoYXJDb2RlID09IDgyMzMgfHwgY2hhckNvZGUgPT0gODIzOSB8fCBjaGFyQ29kZSA9PSA4Mjg3IHx8IGNoYXJDb2RlID09IDEyMjg4IHx8IGNoYXJDb2RlID09IDY1Mjc5KSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHN0cikge1xuICAgIHZhciBpbmRleCA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBpc1doaXRlU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cblxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgaW5kZXggKyAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLCBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKGluZGV4KysgPCBsZW5ndGggJiYgaXNXaGl0ZVNwYWNlKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG5cbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlbGltaXRlcnMoZGVsaW1pdGVycykge1xuICAgIGlmICghaXNBcnJheShkZWxpbWl0ZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBhcnJheSBsaWtlIFtcInt7XCIsIFwifX1cIl0nKTtcbiAgICB9XG4gICAgT3B0aW9ucy5kZWxpbWl0ZXJzID0gZGVsaW1pdGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlbGltaXRlcnMoKSB7XG4gICAgcmV0dXJuIE9wdGlvbnMuZGVsaW1pdGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgZXh0ZW5kKE9wdGlvbnMsIGtleSk7XG4gICAgfSBcbiAgICByZXR1cm4gT3B0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VsZkNsb3NpbmdUYWcodGFnKSB7XG4gICAgcmV0dXJuIFNlbGZDbG9zaW5nVGFnc1t0YWddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0VGFnKHRhZykge1xuICAgIHJldHVybiBUZXh0VGFnc1t0YWddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEaXJlY3RpdmUobmFtZSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChEaXJlY3RpdmVzLCBuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCguLi5hcmdzKSB7XG4gICAgdmFyIGRlc3QgPSBhcmdzWzBdO1xuICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2hlY2tib3hNb2RlbChkYXRhLCBrZXksIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSwgZSwgc2VsZikge1xuICAgIHZhciB2YWx1ZSA9IE9wdGlvbnMuZ2V0TW9kZWwoZGF0YSwga2V5KSxcbiAgICAgICAgY2hlY2tlZCA9IGUudGFyZ2V0LmNoZWNrZWQ7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCk7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4T2YodmFsdWUsIHRydWVWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICBpZiAoIX5pbmRleCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2godHJ1ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBjaGVja2VkID8gdHJ1ZVZhbHVlIDogZmFsc2VWYWx1ZTtcbiAgICB9XG4gICAgT3B0aW9ucy5zZXRNb2RlbChkYXRhLCBrZXksIHZhbHVlLCBzZWxmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdENoZWNrYm94Q2hlY2tlZChkYXRhLCBrZXksIHRydWVWYWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IE9wdGlvbnMuZ2V0TW9kZWwoZGF0YSwga2V5KTtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YodmFsdWUsIHRydWVWYWx1ZSkgPiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWVWYWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTZWxlY3RNb2RlbChkYXRhLCBrZXksIGUsIHNlbGYpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgIG11bHRpcGxlID0gdGFyZ2V0Lm11bHRpcGxlLFxuICAgICAgICB2YWx1ZSwgaSwgb3B0LFxuICAgICAgICBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG5cbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9wdCA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChpc051bGxPclVuZGVmaW5lZChvcHQuX3ZhbHVlKSA/IG9wdC52YWx1ZSA6IG9wdC5fdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9wdCA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc051bGxPclVuZGVmaW5lZChvcHQuX3ZhbHVlKSA/IG9wdC52YWx1ZSA6IG9wdC5fdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3B0aW9ucy5zZXRNb2RlbChkYXRhLCBrZXksIHZhbHVlLCBzZWxmKTtcbn1cblxuZXhwb3J0IGNvbnN0IGVycm9yID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgIHJldHVybiBoYXNDb25zb2xlID8gZnVuY3Rpb24oZSkge2NvbnNvbGUuZXJyb3IoZS5zdGFjayk7fSA6IG5vb3A7XG59KSgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3ZkdC9zcmMvbGliL3V0aWxzLmpzIiwiaW1wb3J0IFZkdCBmcm9tICcuL2xpYi92ZHQnO1xuXG5leHBvcnQgZGVmYXVsdCBWZHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdmR0L3NyYy9jbGllbnQuanMiLCJpbXBvcnQge1R5cGVzLCBFTVBUWV9PQkp9IGZyb20gJy4vdm5vZGUnO1xuaW1wb3J0IHtcbiAgICBjcmVhdGVFbGVtZW50LFxuICAgIGNyZWF0ZUVsZW1lbnRzLCBcbiAgICByZW1vdmVFbGVtZW50cywgXG4gICAgcmVtb3ZlRWxlbWVudCxcbiAgICByZW1vdmVDb21wb25lbnRDbGFzc09ySW5zdGFuY2UsXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4sXG4gICAgY3JlYXRlQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlLFxuICAgIGNyZWF0ZUNvbXBvbmVudEZ1bmN0aW9uLFxuICAgIGNyZWF0ZUNvbXBvbmVudEZ1bmN0aW9uVk5vZGUsXG4gICAgY3JlYXRlUmVmLFxuICAgIHJlcGxhY2VDaGlsZCxcbiAgICBhcHBlbmRDaGlsZFxufSBmcm9tICcuL3Zkb20nO1xuaW1wb3J0IHtpc09iamVjdCwgaXNBcnJheSwgaXNOdWxsT3JVbmRlZmluZWQsIFxuICAgIGlzU2tpcFByb3AsIE1vdW50ZWRRdWV1ZSwgaXNFdmVudFByb3AsIFxuICAgIGJvb2xlYW5Qcm9wcywgc3RyaWN0UHJvcHMsXG4gICAgYnJvd3Nlciwgc2V0VGV4dENvbnRlbnQsIGlzU3RyaW5nT3JOdW1iZXIsXG4gICAgbmFtZXNwYWNlc1xufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7aGFuZGxlRXZlbnR9IGZyb20gJy4vZXZlbnQnO1xuaW1wb3J0IHtwcm9jZXNzRm9ybX0gZnJvbSAnLi93cmFwcGVycy9wcm9jZXNzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoKGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKSB7XG4gICAgbGV0IGlzVHJpZ2dlciA9IHRydWU7XG4gICAgaWYgKG1vdW50ZWRRdWV1ZSkge1xuICAgICAgICBpc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudGVkUXVldWUgPSBuZXcgTW91bnRlZFF1ZXVlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRvbSA9IHBhdGNoVk5vZGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgIGlmIChpc1RyaWdnZXIpIHtcbiAgICAgICAgbW91bnRlZFF1ZXVlLnRyaWdnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoVk5vZGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBpZiAobGFzdFZOb2RlICE9PSBuZXh0Vk5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dFR5cGUgPSBuZXh0Vk5vZGUudHlwZTtcbiAgICAgICAgY29uc3QgbGFzdFR5cGUgPSBsYXN0Vk5vZGUudHlwZTtcblxuICAgICAgICBpZiAobmV4dFR5cGUgJiBUeXBlcy5FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobGFzdFR5cGUgJiBUeXBlcy5FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hFbGVtZW50KGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUVsZW1lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUeXBlICYgVHlwZXMuVGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0VHlwZSAmIFR5cGVzLlRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hUZXh0KGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUVsZW1lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBpc1NWRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFR5cGUgJiBUeXBlcy5Db21wb25lbnRDbGFzcykge1xuICAgICAgICAgICAgaWYgKGxhc3RUeXBlICYgVHlwZXMuQ29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENvbXBvbmVudENsYXNzKGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUVsZW1lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyB9IGVsc2UgaWYgKG5leHRUeXBlICYgVHlwZXMuQ29tcG9uZW50RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIChsYXN0VHlwZSAmIFR5cGVzLkNvbXBvbmVudEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcGF0Y2hDb21wb25lbnRGdW5jdGlvbihsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUpO1xuICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlRWxlbWVudChsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUeXBlICYgVHlwZXMuQ29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChsYXN0VHlwZSAmIFR5cGVzLkNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hDb21wb25lbnRJbnRhbmNlKGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUVsZW1lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0Vk5vZGUuZG9tO1xufVxuXG5mdW5jdGlvbiBwYXRjaEVsZW1lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBjb25zdCBkb20gPSBsYXN0Vk5vZGUuZG9tO1xuICAgIGNvbnN0IGxhc3RQcm9wcyA9IGxhc3RWTm9kZS5wcm9wcztcbiAgICBjb25zdCBuZXh0UHJvcHMgPSBuZXh0Vk5vZGUucHJvcHM7XG4gICAgY29uc3QgbGFzdENoaWxkcmVuID0gbGFzdFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IG5leHRDaGlsZHJlbiA9IG5leHRWTm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBsYXN0Q2xhc3NOYW1lID0gbGFzdFZOb2RlLmNsYXNzTmFtZTtcbiAgICBjb25zdCBuZXh0Q2xhc3NOYW1lID0gbmV4dFZOb2RlLmNsYXNzTmFtZTtcbiAgICBjb25zdCBuZXh0VHlwZSA9IG5leHRWTm9kZS50eXBlO1xuXG4gICAgbmV4dFZOb2RlLmRvbSA9IGRvbTtcbiAgICBuZXh0Vk5vZGUucGFyZW50Vk5vZGUgPSBwYXJlbnRWTm9kZTtcblxuICAgIGlzU1ZHID0gaXNTVkcgfHwgKG5leHRUeXBlICYgVHlwZXMuU3ZnRWxlbWVudCkgPiAwXG5cbiAgICBpZiAobGFzdFZOb2RlLnRhZyAhPT0gbmV4dFZOb2RlLnRhZyB8fCBsYXN0Vk5vZGUua2V5ICE9PSBuZXh0Vk5vZGUua2V5KSB7XG4gICAgICAgIHJlcGxhY2VFbGVtZW50KGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGFzdENoaWxkcmVuICE9PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4obGFzdENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIGRvbSwgbW91bnRlZFF1ZXVlLCBuZXh0Vk5vZGUsIFxuICAgICAgICAgICAgICAgIGlzU1ZHID09PSB0cnVlICYmIG5leHRWTm9kZS50YWcgIT09ICdmb3JlaWduT2JqZWN0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0UHJvcHMgIT09IG5leHRQcm9wcykge1xuICAgICAgICAgICAgcGF0Y2hQcm9wcyhsYXN0Vk5vZGUsIG5leHRWTm9kZSwgaXNTVkcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RDbGFzc05hbWUgIT09IG5leHRDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChuZXh0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1NWRykge1xuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBuZXh0Q2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRSZWYgPSBuZXh0Vk5vZGUucmVmO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG5leHRSZWYpICYmIGxhc3RWTm9kZS5yZWYgIT09IG5leHRSZWYpIHtcbiAgICAgICAgICAgIGNyZWF0ZVJlZihkb20sIG5leHRSZWYsIG1vdW50ZWRRdWV1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gcGF0Y2hDb21wb25lbnRDbGFzcyhsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRykge1xuICAgIGNvbnN0IGxhc3RUYWcgPSBsYXN0Vk5vZGUudGFnO1xuICAgIGNvbnN0IG5leHRUYWcgPSBuZXh0Vk5vZGUudGFnO1xuICAgIGNvbnN0IGRvbSA9IGxhc3RWTm9kZS5kb207XG5cbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgbGV0IG5ld0RvbTtcblxuICAgIGlmIChsYXN0VGFnICE9PSBuZXh0VGFnIHx8IGxhc3RWTm9kZS5rZXkgIT09IG5leHRWTm9kZS5rZXkpIHtcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGNhbGwgdGhpcyByZW1vdmUgZnVuY3Rpb24gaW4gY29tcG9uZW50J3MgaW5pdCBtZXRob2RcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBzaG91bGQgYmUgZGVzdHJveWVkIHVudGlsIGFzeW5jIGNvbXBvbmVudCBoYXMgcmVuZGVyZWRcbiAgICAgICAgLy8gcmVtb3ZlQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlKGxhc3RWTm9kZSwgbnVsbCwgbmV4dFZOb2RlKTtcbiAgICAgICAgbmV3RG9tID0gY3JlYXRlQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlKG5leHRWTm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGxhc3RWTm9kZSwgZmFsc2UsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UgPSBsYXN0Vk5vZGUuY2hpbGRyZW47XG4gICAgICAgIGluc3RhbmNlLm1vdW50ZWRRdWV1ZSA9IG1vdW50ZWRRdWV1ZTtcbiAgICAgICAgaW5zdGFuY2UuaXNSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFuY2UucGFyZW50Vk5vZGUgPSBwYXJlbnRWTm9kZTtcbiAgICAgICAgaW5zdGFuY2Uudk5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgICAgIGluc3RhbmNlLmlzU1ZHID0gaXNTVkc7XG4gICAgICAgIG5ld0RvbSA9IGluc3RhbmNlLnVwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG4gICAgICAgIG5leHRWTm9kZS5kb20gPSBuZXdEb207XG4gICAgICAgIG5leHRWTm9kZS5jaGlsZHJlbiA9IGluc3RhbmNlO1xuICAgICAgICBuZXh0Vk5vZGUucGFyZW50Vk5vZGUgPSBwYXJlbnRWTm9kZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGZvciBpbnRhY3QuanMsIHRoZSBkb20gd2lsbCBub3QgYmUgcmVtb3ZlZCBhbmRcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCB3aWxsIG5vdCBiZSBkZXN0b3J5ZWQsIHNvIHRoZSByZWZcbiAgICAgICAgLy8gZnVuY3Rpb24gbmVlZCBiZSBjYWxsZWQgaW4gdXBkYXRlIG1ldGhvZC5cbiAgICAgICAgY29uc3QgcmVmID0gbmV4dFZOb2RlLnJlZjtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJoYXBzIHRoZSBkb20gaGFzIGJlIHJlcGxhY2VkXG4gICAgaWYgKGRvbSAhPT0gbmV3RG9tICYmIGRvbS5wYXJlbnROb2RlICYmXG4gICAgICAgIC8vIHdoZW4gZG9tIGhhcyBiZSByZXBsYWNlZCwgaXRzIHBhcmVudE5vZGUgbWF5YmUgYmUgZnJhZ21lbnQgaW4gSUU4XG4gICAgICAgIGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lICE9PSAnI2RvY3VtZW50LWZyYWdtZW50J1xuICAgICkge1xuICAgICAgICByZXBsYWNlQ2hpbGQocGFyZW50RG9tLCBsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaENvbXBvbmVudEludGFuY2UobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBjb25zdCBsYXN0SW5zdGFuY2UgPSBsYXN0Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgbmV4dEluc3RhbmNlID0gbmV4dFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGRvbSA9IGxhc3RWTm9kZS5kb207XG5cbiAgICBsZXQgbmV3RG9tO1xuXG4gICAgaWYgKGxhc3RJbnN0YW5jZSAhPT0gbmV4dEluc3RhbmNlKSB7XG4gICAgICAgIC8vIHJlbW92ZUNvbXBvbmVudENsYXNzT3JJbnN0YW5jZShsYXN0Vk5vZGUsIG51bGwsIG5leHRWTm9kZSk7XG4gICAgICAgIG5ld0RvbSA9IGNyZWF0ZUNvbXBvbmVudENsYXNzT3JJbnN0YW5jZShuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBsYXN0Vk5vZGUsIGZhbHNlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5tb3VudGVkUXVldWUgPSBtb3VudGVkUXVldWU7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5pc1JlbmRlciA9IGZhbHNlO1xuICAgICAgICBsYXN0SW5zdGFuY2UucGFyZW50Vk5vZGUgPSBwYXJlbnRWTm9kZTtcbiAgICAgICAgbmV3RG9tID0gbGFzdEluc3RhbmNlLnVwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG4gICAgICAgIG5leHRWTm9kZS5kb20gPSBuZXdEb207XG4gICAgICAgIG5leHRWTm9kZS5wYXJlbnRWTm9kZSA9IHBhcmVudFZOb2RlO1xuXG4gICAgICAgIGNvbnN0IHJlZiA9IG5leHRWTm9kZS5yZWY7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvbSAhPT0gbmV3RG9tICYmIGRvbS5wYXJlbnROb2RlICYmIFxuICAgICAgICAvLyB3aGVuIGRvbSBoYXMgYmUgcmVwbGFjZWQsIGl0cyBwYXJlbnROb2RlIG1heWJlIGJlIGZyYWdtZW50IGluIElFOFxuICAgICAgICBkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudC1mcmFnbWVudCdcbiAgICApIHtcbiAgICAgICAgcmVwbGFjZUNoaWxkKHBhcmVudERvbSwgbGFzdFZOb2RlLCBuZXh0Vk5vZGUpO1xuICAgIH1cbn1cblxuLy8gZnVuY3Rpb24gcGF0Y2hDb21wb25lbnRGdW5jdGlvbihsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUpIHtcbiAgICAvLyBjb25zdCBsYXN0VGFnID0gbGFzdFZOb2RlLnRhZztcbiAgICAvLyBjb25zdCBuZXh0VGFnID0gbmV4dFZOb2RlLnRhZztcblxuICAgIC8vIGlmIChsYXN0Vk5vZGUua2V5ICE9PSBuZXh0Vk5vZGUua2V5KSB7XG4gICAgICAgIC8vIHJlbW92ZUVsZW1lbnRzKGxhc3RWTm9kZS5jaGlsZHJlbiwgcGFyZW50RG9tKTtcbiAgICAgICAgLy8gY3JlYXRlQ29tcG9uZW50RnVuY3Rpb24obmV4dFZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSk7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gbmV4dFZOb2RlLmRvbSA9IGxhc3RWTm9kZS5kb207XG4gICAgICAgIC8vIGNyZWF0ZUNvbXBvbmVudEZ1bmN0aW9uVk5vZGUobmV4dFZOb2RlKTtcbiAgICAgICAgLy8gcGF0Y2hDaGlsZHJlbihsYXN0Vk5vZGUuY2hpbGRyZW4sIG5leHRWTm9kZS5jaGlsZHJlbiwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUpO1xuICAgIC8vIH1cbi8vIH1cblxuZnVuY3Rpb24gcGF0Y2hDaGlsZHJlbihsYXN0Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRykge1xuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChsYXN0Q2hpbGRyZW4pKSB7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobmV4dENoaWxkcmVuKSkge1xuICAgICAgICAgICAgY3JlYXRlRWxlbWVudHMobmV4dENoaWxkcmVuLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgZmFsc2UsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5leHRDaGlsZHJlbikpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nT3JOdW1iZXIobGFzdENoaWxkcmVuKSkge1xuICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50RG9tLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVFbGVtZW50cyhsYXN0Q2hpbGRyZW4sIHBhcmVudERvbSk7IFxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZ09yTnVtYmVyKG5leHRDaGlsZHJlbikpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nT3JOdW1iZXIobGFzdENoaWxkcmVuKSkge1xuICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50RG9tLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudHMobGFzdENoaWxkcmVuLCBwYXJlbnREb20pO1xuICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50RG9tLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGxhc3RDaGlsZHJlbikpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkobmV4dENoaWxkcmVuKSkge1xuICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbkJ5S2V5KGxhc3RDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnRzKGxhc3RDaGlsZHJlbiwgcGFyZW50RG9tKTtcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQobmV4dENoaWxkcmVuLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgZmFsc2UsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkobmV4dENoaWxkcmVuKSkge1xuICAgICAgICBpZiAoaXNTdHJpbmdPck51bWJlcihsYXN0Q2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnREb20sICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQobGFzdENoaWxkcmVuLCBwYXJlbnREb20pO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZUVsZW1lbnRzKG5leHRDaGlsZHJlbiwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGZhbHNlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdPck51bWJlcihsYXN0Q2hpbGRyZW4pKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudERvbSwgJycpO1xuICAgICAgICBjcmVhdGVFbGVtZW50KG5leHRDaGlsZHJlbiwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGZhbHNlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoVk5vZGUobGFzdENoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hDaGlsZHJlbkJ5S2V5KGEsIGIsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBsZXQgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGxldCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gICAgbGV0IGFFbmQgPSBhTGVuZ3RoIC0gMTtcbiAgICBsZXQgYkVuZCA9IGJMZW5ndGggLSAxO1xuICAgIGxldCBhU3RhcnQgPSAwO1xuICAgIGxldCBiU3RhcnQgPSAwO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBhTm9kZTtcbiAgICBsZXQgYk5vZGU7XG4gICAgbGV0IG5leHROb2RlO1xuICAgIGxldCBuZXh0UG9zO1xuICAgIGxldCBub2RlO1xuICAgIGxldCBhU3RhcnROb2RlID0gYVthU3RhcnRdO1xuICAgIGxldCBiU3RhcnROb2RlID0gYltiU3RhcnRdO1xuICAgIGxldCBhRW5kTm9kZSA9IGFbYUVuZF07XG4gICAgbGV0IGJFbmROb2RlID0gYltiRW5kXTtcblxuICAgIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB3aGlsZSAoYVN0YXJ0Tm9kZS5rZXkgPT09IGJTdGFydE5vZGUua2V5KSB7XG4gICAgICAgICAgICBwYXRjaFZOb2RlKGFTdGFydE5vZGUsIGJTdGFydE5vZGUsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgKythU3RhcnQ7XG4gICAgICAgICAgICArK2JTdGFydDtcbiAgICAgICAgICAgIGlmIChhU3RhcnQgPiBhRW5kIHx8IGJTdGFydCA+IGJFbmQpIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFTdGFydE5vZGUgPSBhW2FTdGFydF07XG4gICAgICAgICAgICBiU3RhcnROb2RlID0gYltiU3RhcnRdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhRW5kTm9kZS5rZXkgPT09IGJFbmROb2RlLmtleSkge1xuICAgICAgICAgICAgcGF0Y2hWTm9kZShhRW5kTm9kZSwgYkVuZE5vZGUsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgLS1hRW5kO1xuICAgICAgICAgICAgLS1iRW5kO1xuICAgICAgICAgICAgaWYgKGFFbmQgPCBhU3RhcnQgfHwgYkVuZCA8IGJTdGFydCkge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYUVuZE5vZGUgPSBhW2FFbmRdO1xuICAgICAgICAgICAgYkVuZE5vZGUgPSBiW2JFbmRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFFbmROb2RlLmtleSA9PT0gYlN0YXJ0Tm9kZS5rZXkpIHtcbiAgICAgICAgICAgIHBhdGNoVk5vZGUoYUVuZE5vZGUsIGJTdGFydE5vZGUsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgZG9tLmluc2VydEJlZm9yZShiU3RhcnROb2RlLmRvbSwgYVN0YXJ0Tm9kZS5kb20pO1xuICAgICAgICAgICAgLS1hRW5kO1xuICAgICAgICAgICAgKytiU3RhcnQ7XG4gICAgICAgICAgICBhRW5kTm9kZSA9IGFbYUVuZF07XG4gICAgICAgICAgICBiU3RhcnROb2RlID0gYltiU3RhcnRdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYVN0YXJ0Tm9kZS5rZXkgPT09IGJFbmROb2RlLmtleSkge1xuICAgICAgICAgICAgcGF0Y2hWTm9kZShhU3RhcnROb2RlLCBiRW5kTm9kZSwgZG9tLCBtb3VudGVkUXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRyk7IFxuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmQoYkVuZCwgYkxlbmd0aCwgYkVuZE5vZGUuZG9tLCBiLCBkb20pO1xuICAgICAgICAgICAgKythU3RhcnQ7XG4gICAgICAgICAgICAtLWJFbmQ7XG4gICAgICAgICAgICBhU3RhcnROb2RlID0gYVthU3RhcnRdO1xuICAgICAgICAgICAgYkVuZE5vZGUgPSBiW2JFbmRdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGFTdGFydCA+IGFFbmQpIHtcbiAgICAgICAgd2hpbGUgKGJTdGFydCA8PSBiRW5kKSB7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZChcbiAgICAgICAgICAgICAgICBiRW5kLCBiTGVuZ3RoLCBcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KGJbYlN0YXJ0XSwgbnVsbCwgbW91bnRlZFF1ZXVlLCBmYWxzZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKSxcbiAgICAgICAgICAgICAgICBiLCBkb20sIHRydWUgLyogZGV0ZWN0UGFyZW50OiBmb3IgYW5pbWF0ZSwgaWYgdGhlIHBhcmVudE5vZGUgZXhpc3RzLCB0aGVuIGRvIG5vdGhpbmcqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICsrYlN0YXJ0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChiU3RhcnQgPiBiRW5kKSB7XG4gICAgICAgIHdoaWxlIChhU3RhcnQgPD0gYUVuZCkge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChhW2FTdGFydF0sIGRvbSk7XG4gICAgICAgICAgICArK2FTdGFydDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFMZW5ndGggPSBhRW5kIC0gYVN0YXJ0ICsgMTtcbiAgICAgICAgYkxlbmd0aCA9IGJFbmQgLSBiU3RhcnQgKyAxO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gbmV3IEFycmF5KGJMZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzb3VyY2VzW2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XG5cbiAgICAgICAgaWYgKGJMZW5ndGggPD0gNCB8fCBhTGVuZ3RoICogYkxlbmd0aCA8PSAxNikge1xuICAgICAgICAgICAgZm9yIChpID0gYVN0YXJ0OyBpIDw9IGFFbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFOb2RlID0gYVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA8IGJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYlN0YXJ0OyBqIDw9IGJFbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYk5vZGUgPSBiW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFOb2RlLmtleSA9PT0gYk5vZGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlc1tqIC0gYlN0YXJ0XSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoVk5vZGUoYU5vZGUsIGJOb2RlLCBkb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3BhdGNoZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5SW5kZXggPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IGJTdGFydDsgaSA8PSBiRW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXlJbmRleFtiW2ldLmtleV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gYVN0YXJ0OyBpIDw9IGFFbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFOb2RlID0gYVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA8IGJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaiA9IGtleUluZGV4W2FOb2RlLmtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJOb2RlID0gYltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNbaiAtIGJTdGFydF0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZOb2RlKGFOb2RlLCBiTm9kZSwgZG9tLCBtb3VudGVkUXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3BhdGNoZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYUxlbmd0aCA9PT0gYS5sZW5ndGggJiYgcGF0Y2hlZCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlQWxsQ2hpbGRyZW4oZG9tLCBhKTtcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIG1heWJlIGhhdmUgYW5pbWF0aW9uXG4gICAgICAgICAgICByZW1vdmVFbGVtZW50cyhhLCBkb20pO1xuICAgICAgICAgICAgd2hpbGUgKGJTdGFydCA8IGJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KGJbYlN0YXJ0XSwgZG9tLCBtb3VudGVkUXVldWUsIGZhbHNlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgICsrYlN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc29tZSBicm93c2VycywgZS5nLiBpZSwgbXVzdCBpbnNlcnQgYmVmb3JlIHJlbW92ZSBmb3Igc29tZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gZS5nLiBzZWxlY3Qvb3B0aW9uLCBvdGhlcndpc2UgdGhlIHNlbGVjdGVkIHByb3BlcnR5IHdpbGwgYmUgd2VpcmRcbiAgICAgICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcSA9IGxpc0FsZ29yaXRobShzb3VyY2VzKTtcbiAgICAgICAgICAgICAgICBqID0gc2VxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gYkxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzW2ldID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaSArIGJTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE9yQXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcywgYi5sZW5ndGgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoYltwb3NdLCBudWxsLCBtb3VudGVkUXVldWUsIGZhbHNlLCBwYXJlbnRWTm9kZSwgaXNTVkcpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gc2VxW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaSArIGJTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRPckFwcGVuZChwb3MsIGIubGVuZ3RoLCBiW3Bvc10uZG9tLCBiLCBkb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhdGNoZWQgIT09IGJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBiTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNbaV0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpICsgYlN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLCBiLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KGJbcG9zXSwgbnVsbCwgbW91bnRlZFF1ZXVlLCBmYWxzZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLCBkb20sIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gYUxlbmd0aCAtIHBhdGNoZWQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBhTm9kZSA9IGFbYVN0YXJ0KytdO1xuICAgICAgICAgICAgICAgIGlmIChhTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KGFOb2RlLCBkb20pO1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsaXNBbGdvcml0aG0oYXJyKSB7XG4gICAgbGV0IHAgPSBhcnIuc2xpY2UoMCk7XG4gICAgbGV0IHJlc3VsdCA9IFswXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgdTtcbiAgICBsZXQgdjtcbiAgICBsZXQgYztcbiAgICBsZXQgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IGFyckkgPSBhcnJbaV07XG4gICAgICAgIGlmIChhcnJJID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgICAgICBwW2ldID0gajtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdSA9IDA7XG4gICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgICAgICBjID0gKCh1ICsgdikgLyAyKSB8IDA7XG4gICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdiA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xuICAgICAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHUgPSByZXN1bHQubGVuZ3RoO1xuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xuICAgIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgICAgIHYgPSBwW3ZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZChwb3MsIGxlbmd0aCwgbmV3RG9tLCBub2RlcywgZG9tLCBkZXRlY3RQYXJlbnQpIHtcbiAgICBjb25zdCBuZXh0UG9zID0gcG9zICsgMTtcbiAgICAvLyBpZiAoZGV0ZWN0UGFyZW50ICYmIG5ld0RvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIHJldHVybjtcbiAgICAvLyB9IGVsc2VcbiAgICBpZiAobmV4dFBvcyA8IGxlbmd0aCkge1xuICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKG5ld0RvbSwgbm9kZXNbbmV4dFBvc10uZG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcbiAgICAgICAgLy8gYXBwZW5kQ2hpbGQoZG9tLCBuZXdEb20pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICByZW1vdmVFbGVtZW50KGxhc3RWTm9kZSwgbnVsbCwgbmV4dFZOb2RlKTtcbiAgICBjcmVhdGVFbGVtZW50KG5leHRWTm9kZSwgbnVsbCwgbW91bnRlZFF1ZXVlLCBmYWxzZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICByZXBsYWNlQ2hpbGQocGFyZW50RG9tLCBsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHBhdGNoVGV4dChsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tKSB7XG4gICAgY29uc3QgbmV4dFRleHQgPSBuZXh0Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgZG9tID0gbGFzdFZOb2RlLmRvbTtcbiAgICBuZXh0Vk5vZGUuZG9tID0gZG9tO1xuICAgIGlmIChsYXN0Vk5vZGUuY2hpbGRyZW4gIT09IG5leHRUZXh0KSB7XG4gICAgICAgIGRvbS5ub2RlVmFsdWUgPSBuZXh0VGV4dDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaFByb3BzKGxhc3RWTm9kZSwgbmV4dFZOb2RlLCBpc1NWRykge1xuICAgIGNvbnN0IGxhc3RQcm9wcyA9IGxhc3RWTm9kZS5wcm9wcztcbiAgICBjb25zdCBuZXh0UHJvcHMgPSBuZXh0Vk5vZGUucHJvcHM7XG4gICAgY29uc3QgZG9tID0gbmV4dFZOb2RlLmRvbTtcbiAgICBsZXQgcHJvcDtcbiAgICBpZiAobmV4dFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgY29uc3QgaXNGb3JtRWxlbWVudCA9IChuZXh0Vk5vZGUudHlwZSAmIFR5cGVzLkZvcm1FbGVtZW50KSA+IDA7XG4gICAgICAgIGZvciAocHJvcCBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHBhdGNoUHJvcChwcm9wLCBsYXN0UHJvcHNbcHJvcF0sIG5leHRQcm9wc1twcm9wXSwgZG9tLCBpc0Zvcm1FbGVtZW50LCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRm9ybUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NGb3JtKG5leHRWTm9kZSwgZG9tLCBuZXh0UHJvcHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgZm9yIChwcm9wIGluIGxhc3RQcm9wcykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpc1NraXBQcm9wKHByb3ApICYmXG4gICAgICAgICAgICAgICAgaXNOdWxsT3JVbmRlZmluZWQobmV4dFByb3BzW3Byb3BdKSAmJlxuICAgICAgICAgICAgICAgICFpc051bGxPclVuZGVmaW5lZChsYXN0UHJvcHNbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZW1vdmVQcm9wKHByb3AsIGxhc3RQcm9wc1twcm9wXSwgZG9tKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaFByb3AocHJvcCwgbGFzdFZhbHVlLCBuZXh0VmFsdWUsIGRvbSwgaXNGb3JtRWxlbWVudCwgaXNTVkcpIHtcbiAgICBpZiAobGFzdFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgaWYgKGlzU2tpcFByb3AocHJvcCkgfHwgaXNGb3JtRWxlbWVudCAmJiBwcm9wID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYm9vbGVhblByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgICBkb21bcHJvcF0gPSAhIW5leHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3RQcm9wc1twcm9wXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc051bGxPclVuZGVmaW5lZChuZXh0VmFsdWUpID8gJycgOiBuZXh0VmFsdWU7XG4gICAgICAgICAgICAvLyBJRTggdGhlIHZhbHVlIG9mIG9wdGlvbiBpcyBlcXVhbCB0byBpdHMgdGV4dCBhcyBkZWZhdWx0XG4gICAgICAgICAgICAvLyBzbyBzZXQgaXQgZm9yY2VseVxuICAgICAgICAgICAgaWYgKGRvbVtwcm9wXSAhPT0gdmFsdWUgfHwgYnJvd3Nlci5pc0lFOCkge1xuICAgICAgICAgICAgICAgIGRvbVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGEgcHJpdmF0ZSBwcm9wZXJ0eSBfdmFsdWUgZm9yIHNlbGVjdGluZyBhbiBub24tc3RyaW5nIHZhbHVlIFxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICBkb20uX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdWxsT3JVbmRlZmluZWQobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgcmVtb3ZlUHJvcChwcm9wLCBsYXN0VmFsdWUsIGRvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFByb3AocHJvcCkpIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50KHByb3Auc3Vic3RyKDMpLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICBwYXRjaFByb3BCeU9iamVjdChwcm9wLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgZG9tLmlubmVySFRNTCA9IG5leHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1NWRyAmJiBuYW1lc3BhY2VzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZXNbcHJvcF0sIHByb3AsIG5leHRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUocHJvcCwgbmV4dFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcChwcm9wLCBsYXN0VmFsdWUsIGRvbSkge1xuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobGFzdFZhbHVlKSkge1xuICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICBkb20udmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbGFzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZGF0YXNldCc6XG4gICAgICAgICAgICAgICAgcmVtb3ZlRGF0YXNldChsYXN0VmFsdWUsIGRvbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgICAgICAgICAgICAgZG9tLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9vbGVhblByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgICBkb21bcHJvcF0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50UHJvcChwcm9wKSkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnQocHJvcC5zdWJzdHIoMyksIGxhc3RWYWx1ZSwgbnVsbCwgZG9tKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChsYXN0VmFsdWUpKXtcbiAgICAgICAgICAgIGNvbnN0IGRvbVByb3AgPSBkb21bcHJvcF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRvbVtwcm9wXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tW3Byb3BdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbVByb3Bba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCByZW1vdmVEYXRhc2V0ID0gYnJvd3Nlci5pc0lFIHx8IGJyb3dzZXIuaXNTYWZhcmkgPyBcbiAgICBmdW5jdGlvbihsYXN0VmFsdWUsIGRvbSkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbGFzdFZhbHVlKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKGBkYXRhLSR7a2ViYWJDYXNlKGtleSl9YCk7XG4gICAgICAgIH1cbiAgICB9IDpcbiAgICBmdW5jdGlvbihsYXN0VmFsdWUsIGRvbSkge1xuICAgICAgICBjb25zdCBkb21Qcm9wID0gZG9tLmRhdGFzZXQ7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkb21Qcm9wW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuXG5mdW5jdGlvbiBwYXRjaFByb3BCeU9iamVjdChwcm9wLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKSB7XG4gICAgaWYgKGxhc3RWYWx1ZSAmJiAhaXNPYmplY3QobGFzdFZhbHVlKSAmJiAhaXNOdWxsT3JVbmRlZmluZWQobGFzdFZhbHVlKSkge1xuICAgICAgICByZW1vdmVQcm9wKHByb3AsIGxhc3RWYWx1ZSwgZG9tKTtcbiAgICAgICAgbGFzdFZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgcmV0dXJuIHBhdGNoQXR0cmlidXRlcyhsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgcmV0dXJuIHBhdGNoU3R5bGUobGFzdFZhbHVlLCBuZXh0VmFsdWUsIGRvbSk7XG4gICAgICAgIGNhc2UgJ2RhdGFzZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhdGNoRGF0YXNldChwcm9wLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwYXRjaE9iamVjdChwcm9wLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKTtcbiAgICB9XG59XG5cbmNvbnN0IHBhdGNoRGF0YXNldCA9IGJyb3dzZXIuaXNJRSA/IFxuICAgIGZ1bmN0aW9uIHBhdGNoRGF0YXNldChwcm9wLCBsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKSB7XG4gICAgICAgIGxldCBoYXNSZW1vdmVkID0ge307XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCB2YWx1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFLZXkgPSBgZGF0YS0ke2tlYmFiQ2FzZShrZXkpfWA7XG4gICAgICAgICAgICB2YWx1ZSA9IG5leHRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoZGF0YUtleSk7IFxuICAgICAgICAgICAgICAgIGhhc1JlbW92ZWRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoZGF0YUtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobGFzdFZhbHVlKSkge1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gbGFzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5leHRWYWx1ZVtrZXldKSAmJiAhaGFzUmVtb3ZlZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtJHtrZWJhYkNhc2Uoa2V5KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IDogcGF0Y2hPYmplY3Q7XG5cbmNvbnN0IF9jYWNoZSA9IHt9O1xuY29uc3QgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nO1xuZXhwb3J0IGZ1bmN0aW9uIGtlYmFiQ2FzZSh3b3JkKSB7XG4gICAgaWYgKCFfY2FjaGVbd29yZF0pIHtcbiAgICAgICAgX2NhY2hlW3dvcmRdID0gd29yZC5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYC0ke2l0ZW0udG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9jYWNoZVt3b3JkXTtcbn1cblxuZnVuY3Rpb24gcGF0Y2hPYmplY3QocHJvcCwgbGFzdFZhbHVlLCBuZXh0VmFsdWUsIGRvbSkge1xuICAgIGxldCBkb21Qcm9wcyA9IGRvbVtwcm9wXTtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZG9tUHJvcHMpKSB7XG4gICAgICAgIGRvbVByb3BzID0gZG9tW3Byb3BdID0ge307XG4gICAgfVxuICAgIGxldCBrZXk7XG4gICAgbGV0IHZhbHVlO1xuICAgIGZvciAoa2V5IGluIG5leHRWYWx1ZSkge1xuICAgICAgICBkb21Qcm9wc1trZXldID0gbmV4dFZhbHVlW2tleV07XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobGFzdFZhbHVlKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChuZXh0VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tUHJvcHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hBdHRyaWJ1dGVzKGxhc3RWYWx1ZSwgbmV4dFZhbHVlLCBkb20pIHtcbiAgICBjb25zdCBoYXNSZW1vdmVkID0ge307XG4gICAgbGV0IGtleTtcbiAgICBsZXQgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gbmV4dFZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gbmV4dFZhbHVlW2tleV07XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIGhhc1JlbW92ZWRba2V5XSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobGFzdFZhbHVlKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChuZXh0VmFsdWVba2V5XSkgJiYgIWhhc1JlbW92ZWRba2V5XSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShsYXN0VmFsdWUsIG5leHRWYWx1ZSwgZG9tKSB7XG4gICAgY29uc3QgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgY29uc3QgaGFzUmVtb3ZlZCA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgbGV0IHZhbHVlO1xuICAgIGZvciAoa2V5IGluIG5leHRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IG5leHRWYWx1ZVtrZXldO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBkb21TdHlsZVtrZXldID0gJyc7XG4gICAgICAgICAgICBoYXNSZW1vdmVkW2tleV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tU3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobGFzdFZhbHVlKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChuZXh0VmFsdWVba2V5XSkgJiYgIWhhc1JlbW92ZWRba2V5XSkge1xuICAgICAgICAgICAgICAgIGRvbVN0eWxlW2tleV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvdnBhdGNoLmpzIiwiaW1wb3J0IHtUeXBlcywgY3JlYXRlVGV4dFZOb2RlLCBFTVBUWV9PQkp9IGZyb20gJy4vdm5vZGUnO1xuaW1wb3J0IHtwYXRjaFByb3B9IGZyb20gJy4vdnBhdGNoJztcbmltcG9ydCB7aGFuZGxlRXZlbnR9IGZyb20gJy4vZXZlbnQnO1xuaW1wb3J0IHtcbiAgICBNb3VudGVkUXVldWUsIGlzQXJyYXksIGlzU3RyaW5nT3JOdW1iZXIsXG4gICAgaXNOdWxsT3JVbmRlZmluZWQsIGlzRXZlbnRQcm9wLCBkb2MgYXMgZG9jdW1lbnQsXG4gICAgc2V0VGV4dENvbnRlbnQsIHN2Z05TXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtwcm9jZXNzRm9ybX0gZnJvbSAnLi93cmFwcGVycy9wcm9jZXNzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2Tm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRykge1xuICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2Tm9kZSkpIHJldHVybjtcbiAgICBsZXQgaXNUcmlnZ2VyID0gdHJ1ZTtcbiAgICBpZiAobW91bnRlZFF1ZXVlKSB7XG4gICAgICAgIGlzVHJpZ2dlciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50ZWRRdWV1ZSA9IG5ldyBNb3VudGVkUXVldWUoKTtcbiAgICB9XG4gICAgY29uc3QgZG9tID0gY3JlYXRlRWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIHRydWUgLyogaXNSZW5kZXIgKi8sIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgaWYgKGlzVHJpZ2dlcikge1xuICAgICAgICBtb3VudGVkUXVldWUudHJpZ2dlcigpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGlzUmVuZGVyLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBjb25zdCB0eXBlID0gdk5vZGUudHlwZTtcbiAgICBpZiAodHlwZSAmIFR5cGVzLkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUh0bWxFbGVtZW50KHZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgaXNSZW5kZXIsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgfSBlbHNlIGlmICh0eXBlICYgVHlwZXMuVGV4dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVGV4dEVsZW1lbnQodk5vZGUsIHBhcmVudERvbSk7XG4gICAgfSBlbHNlIGlmICh0eXBlICYgVHlwZXMuQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnRDbGFzc09ySW5zdGFuY2Uodk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBudWxsLCBpc1JlbmRlciwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAvLyB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5Db21wb25lbnRGdW5jdGlvbikge1xuICAgICAgICAvLyByZXR1cm4gY3JlYXRlQ29tcG9uZW50RnVuY3Rpb24odk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBpc05vdEFwcGVuZENoaWxkLCBpc1JlbmRlcik7XG4gICAgLy8gfSBlbHNlIGlmICh0eXBlICYgVHlwZXMuQ29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gcmV0dXJuIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZOb2RlLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlICYgVHlwZXMuSHRtbENvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1lbnRFbGVtZW50KHZOb2RlLCBwYXJlbnREb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB2bm9kZSB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIdG1sRWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGlzUmVuZGVyLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBjb25zdCB0eXBlID0gdk5vZGUudHlwZTtcblxuICAgIGlzU1ZHID0gaXNTVkcgfHwgKHR5cGUgJiBUeXBlcy5TdmdFbGVtZW50KSA+IDA7XG5cbiAgICBjb25zdCBkb20gPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQodk5vZGUudGFnLCBpc1NWRyk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBwcm9wcyA9IHZOb2RlLnByb3BzO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHZOb2RlLmNsYXNzTmFtZTtcblxuICAgIHZOb2RlLmRvbSA9IGRvbTtcbiAgICB2Tm9kZS5wYXJlbnRWTm9kZSA9IHBhcmVudFZOb2RlO1xuXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjaGlsZHJlbikpIHtcbiAgICAgICAgY3JlYXRlRWxlbWVudHMoY2hpbGRyZW4sIGRvbSwgbW91bnRlZFF1ZXVlLCBpc1JlbmRlciwgdk5vZGUsXG4gICAgICAgICAgICBpc1NWRyA9PT0gdHJ1ZSAmJiB2Tm9kZS50YWcgIT09ICdmb3JlaWduT2JqZWN0J1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2xhc3NOYW1lKSkge1xuICAgICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbiBJRTgsIHRoZSBzZWxlY3QgdmFsdWUgd2lsbCBiZSBzZXQgdG8gdGhlIGZpcnN0IG9wdGlvbidzIHZhbHVlIGZvcmNlbHlcbiAgICAvLyB3aGVuIGl0IGlzIGFwcGVuZGVkIHRvIHBhcmVudCBkb20uIFdlIGNoYW5nZSBpdHMgdmFsdWUgaW4gcHJvY2Vzc0Zvcm0gZG9lcyBub3RcbiAgICAvLyB3b3JrLiBTbyBwcm9jZXNzRm9ybSBhZnRlciBpdCBoYXMgYmUgYXBwZW5kZWQgdG8gcGFyZW50IGRvbS5cbiAgICBsZXQgaXNGb3JtRWxlbWVudDtcbiAgICBpZiAocHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICBpc0Zvcm1FbGVtZW50ID0gKHZOb2RlLnR5cGUgJiBUeXBlcy5Gb3JtRWxlbWVudCkgPiAwO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgICBwYXRjaFByb3AocHJvcCwgbnVsbCwgcHJvcHNbcHJvcF0sIGRvbSwgaXNGb3JtRWxlbWVudCwgaXNTVkcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gdk5vZGUucmVmO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVmKSkge1xuICAgICAgICBjcmVhdGVSZWYoZG9tLCByZWYsIG1vdW50ZWRRdWV1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudERvbSkge1xuICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9ybUVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzc0Zvcm0odk5vZGUsIGRvbSwgcHJvcHMsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBkb207XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0RWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tKSB7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodk5vZGUuY2hpbGRyZW4pO1xuICAgIHZOb2RlLmRvbSA9IGRvbTtcblxuICAgIGlmIChwYXJlbnREb20pIHtcbiAgICAgICAgcGFyZW50RG9tLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudENsYXNzT3JJbnN0YW5jZSh2Tm9kZSwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGxhc3RWTm9kZSwgaXNSZW5kZXIsIHBhcmVudFZOb2RlLCBpc1NWRykge1xuICAgIGNvbnN0IHByb3BzID0gdk5vZGUucHJvcHM7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB2Tm9kZS50eXBlICYgVHlwZXMuQ29tcG9uZW50Q2xhc3MgP1xuICAgICAgICBuZXcgdk5vZGUudGFnKHByb3BzKSA6IHZOb2RlLmNoaWxkcmVuO1xuICAgIGluc3RhbmNlLnBhcmVudERvbSA9IHBhcmVudERvbTtcbiAgICBpbnN0YW5jZS5tb3VudGVkUXVldWUgPSBtb3VudGVkUXVldWU7XG4gICAgaW5zdGFuY2UuaXNSZW5kZXIgPSBpc1JlbmRlcjtcbiAgICBpbnN0YW5jZS5wYXJlbnRWTm9kZSA9IHBhcmVudFZOb2RlO1xuICAgIGluc3RhbmNlLmlzU1ZHID0gaXNTVkc7XG4gICAgaW5zdGFuY2Uudk5vZGUgPSB2Tm9kZTtcbiAgICBjb25zdCBkb20gPSBpbnN0YW5jZS5pbml0KGxhc3RWTm9kZSwgdk5vZGUpO1xuICAgIGNvbnN0IHJlZiA9IHZOb2RlLnJlZjtcblxuICAgIHZOb2RlLmRvbSA9IGRvbTtcbiAgICB2Tm9kZS5jaGlsZHJlbiA9IGluc3RhbmNlO1xuICAgIHZOb2RlLnBhcmVudFZOb2RlID0gcGFyZW50Vk5vZGU7XG5cbiAgICBpZiAocGFyZW50RG9tKSB7XG4gICAgICAgIGFwcGVuZENoaWxkKHBhcmVudERvbSwgZG9tKTtcbiAgICAgICAgLy8gcGFyZW50RG9tLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb3VudGVkUXVldWUucHVzaCgoKSA9PiBpbnN0YW5jZS5tb3VudChsYXN0Vk5vZGUsIHZOb2RlKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RnVuY3Rpb24odk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlKSB7XG4gICAgY29uc3QgcHJvcHMgPSB2Tm9kZS5wcm9wcztcbiAgICBjb25zdCByZWYgPSB2Tm9kZS5yZWY7XG5cbiAgICBjcmVhdGVDb21wb25lbnRGdW5jdGlvblZOb2RlKHZOb2RlKTtcblxuICAgIGxldCBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xuICAgIGxldCBkb207XG4gICAgLy8gc3VwcG9ydCBDb21wb25lbnRGdW5jdGlvbiByZXR1cm4gYW4gYXJyYXkgZm9yIG1hY3JvIHVzYWdlXG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGRvbSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkb20ucHVzaChjcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9tID0gY3JlYXRlRWxlbWVudCh2Tm9kZS5jaGlsZHJlbiwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUpO1xuICAgIH1cbiAgICB2Tm9kZS5kb20gPSBkb207XG5cbiAgICAvLyBpZiAocGFyZW50RG9tKSB7XG4gICAgICAgIC8vIHBhcmVudERvbS5hcHBlbmRDaGlsZChkb20pO1xuICAgIC8vIH1cblxuICAgIGlmIChyZWYpIHtcbiAgICAgICAgY3JlYXRlUmVmKGRvbSwgcmVmLCBtb3VudGVkUXVldWUpO1xuICAgIH1cblxuICAgIHJldHVybiBkb207XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21tZW50RWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tKSB7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh2Tm9kZS5jaGlsZHJlbik7XG4gICAgdk5vZGUuZG9tID0gZG9tO1xuXG4gICAgaWYgKHBhcmVudERvbSkge1xuICAgICAgICBwYXJlbnREb20uYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RnVuY3Rpb25WTm9kZSh2Tm9kZSkge1xuICAgIGxldCByZXN1bHQgPSB2Tm9kZS50YWcodk5vZGUucHJvcHMpO1xuICAgIGlmIChpc1N0cmluZ09yTnVtYmVyKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVGV4dFZOb2RlKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50RnVuY3Rpb24gJHt2Tm9kZS50YWcubmFtZX0gcmV0dXJuZWQgYSBpbnZhbGlkIHZOb2RlYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2Tm9kZS5jaGlsZHJlbiA9IHJlc3VsdDtcblxuICAgIHJldHVybiB2Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKHZOb2RlcywgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIGlzUmVuZGVyLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBpZiAoaXNTdHJpbmdPck51bWJlcih2Tm9kZXMpKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudERvbSwgdk5vZGVzKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodk5vZGVzKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3JlYXRlRWxlbWVudCh2Tm9kZXNbaV0sIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBpc1JlbmRlciwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQodk5vZGVzLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgaXNSZW5kZXIsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudHModk5vZGVzLCBwYXJlbnREb20pIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodk5vZGVzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZOb2RlcykpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodk5vZGVzW2ldLCBwYXJlbnREb20pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudCh2Tm9kZXMsIHBhcmVudERvbSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCh2Tm9kZSwgcGFyZW50RG9tLCBuZXh0Vk5vZGUpIHtcbiAgICBjb25zdCB0eXBlID0gdk5vZGUudHlwZTtcbiAgICBpZiAodHlwZSAmIFR5cGVzLkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUh0bWxFbGVtZW50KHZOb2RlLCBwYXJlbnREb20pO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLlRleHRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiByZW1vdmVUZXh0KHZOb2RlLCBwYXJlbnREb20pO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLkNvbXBvbmVudENsYXNzT3JJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlKHZOb2RlLCBwYXJlbnREb20sIG5leHRWTm9kZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlICYgVHlwZXMuQ29tcG9uZW50RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUNvbXBvbmVudEZ1bmN0aW9uKHZOb2RlLCBwYXJlbnREb20pO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUh0bWxFbGVtZW50KHZOb2RlLCBwYXJlbnREb20pIHtcbiAgICBjb25zdCByZWYgPSB2Tm9kZS5yZWY7XG4gICAgY29uc3QgcHJvcHMgPSB2Tm9kZS5wcm9wcztcbiAgICBjb25zdCBkb20gPSB2Tm9kZS5kb207XG5cbiAgICBpZiAocmVmKSB7XG4gICAgICAgIHJlZihudWxsKTtcbiAgICB9XG5cbiAgICByZW1vdmVFbGVtZW50cyh2Tm9kZS5jaGlsZHJlbiwgbnVsbCk7XG5cbiAgICAvLyByZW1vdmUgZXZlbnRcbiAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwcm9wKSAmJiBpc0V2ZW50UHJvcChuYW1lKSkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnQobmFtZS5zdWJzdHIoMCwgMyksIHByb3AsIG51bGwsIGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyZW50RG9tKSB7XG4gICAgICAgIHBhcmVudERvbS5yZW1vdmVDaGlsZChkb20pO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRleHQodk5vZGUsIHBhcmVudERvbSkge1xuICAgIGlmIChwYXJlbnREb20pIHtcbiAgICAgICAgcGFyZW50RG9tLnJlbW92ZUNoaWxkKHZOb2RlLmRvbSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50RnVuY3Rpb24odk5vZGUsIHBhcmVudERvbSkge1xuICAgIGNvbnN0IHJlZiA9IHZOb2RlLnJlZjtcbiAgICBpZiAocmVmKSB7XG4gICAgICAgIHJlZihudWxsKTtcbiAgICB9XG4gICAgcmVtb3ZlRWxlbWVudCh2Tm9kZS5jaGlsZHJlbiwgcGFyZW50RG9tKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbXBvbmVudENsYXNzT3JJbnN0YW5jZSh2Tm9kZSwgcGFyZW50RG9tLCBuZXh0Vk5vZGUpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IHJlZiA9IHZOb2RlLnJlZjtcblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95KHZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSk7XG4gICAgfVxuXG4gICAgaWYgKHJlZikge1xuICAgICAgICByZWYobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gaW5zdGFuY2UgZGVzdHJveSBtZXRob2Qgd2lsbCByZW1vdmUgZXZlcnl0aGluZ1xuICAgIC8vIHJlbW92ZUVsZW1lbnRzKHZOb2RlLnByb3BzLmNoaWxkcmVuLCBudWxsKTtcblxuICAgIGlmIChwYXJlbnREb20pIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50RG9tLCB2Tm9kZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsQ2hpbGRyZW4oZG9tLCB2Tm9kZXMpIHtcbiAgICAvLyBzZXRUZXh0Q29udGVudChkb20sICcnKTtcbiAgICAvLyByZW1vdmVFbGVtZW50cyh2Tm9kZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUNoaWxkKHBhcmVudERvbSwgbGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHtcbiAgICBjb25zdCBsYXN0RG9tID0gbGFzdFZOb2RlLmRvbTtcbiAgICBjb25zdCBuZXh0RG9tID0gbmV4dFZOb2RlLmRvbTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbGFzdERvbS5wYXJlbnROb2RlO1xuICAgIC8vIG1heWJlIHRoZSBsYXN0RG9tIGhhcyBiZSBtb3ZlZFxuICAgIGlmICghcGFyZW50RG9tIHx8IHBhcmVudE5vZGUgIT09IHBhcmVudERvbSkgcGFyZW50RG9tID0gcGFyZW50Tm9kZTtcbiAgICBpZiAobGFzdERvbS5fdW5tb3VudCkge1xuICAgICAgICBsYXN0RG9tLl91bm1vdW50KGxhc3RWTm9kZSwgcGFyZW50RG9tKTtcbiAgICAgICAgaWYgKCFuZXh0RG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXh0RG9tKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudERvbS5yZXBsYWNlQ2hpbGQobmV4dERvbSwgbGFzdERvbSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50RG9tLCB2Tm9kZSkge1xuICAgIGNvbnN0IGRvbSA9IHZOb2RlLmRvbTtcbiAgICBpZiAoZG9tLl91bm1vdW50KSB7XG4gICAgICAgIGRvbS5fdW5tb3VudCh2Tm9kZSwgcGFyZW50RG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnREb20ucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnREb20sIGRvbSkge1xuICAgIC8vIGluIElFOCwgd2hlbiBhIGVsZW1lbnQgaGFzIGFwcGVuZENoaWxkLFxuICAgIC8vIHRoZW4gaXRzIHBhcmVudE5vZGUgd2lsbCBiZSBIVE1MRG9jdW1lbnQgb2JqZWN0LFxuICAgIC8vIHNvIGNoZWNrIHRoZSB0YWdOYW1lIGZvciB0aGlzIGNhc2VcbiAgICBpZiAoIWRvbS5wYXJlbnROb2RlIHx8ICFkb20ucGFyZW50Tm9kZS50YWdOYW1lKSB7XG4gICAgICAgIHBhcmVudERvbS5hcHBlbmRDaGlsZChkb20pO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZihkb20sIHJlZiwgbW91bnRlZFF1ZXVlKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbW91bnRlZFF1ZXVlLnB1c2goKCkgPT4gcmVmKGRvbSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVmIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IGdvdCBcIiR7SlNPTi5zdHJpbmdpZnkocmVmKX1cImApO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvY3VtZW50Q3JlYXRlRWxlbWVudCh0YWcsIGlzU1ZHKSB7XG4gICAgaWYgKGlzU1ZHID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL3Zkb20uanMiLCJpbXBvcnQge2V4dGVuZCwgaXNBcnJheSwgZWFjaCwgaXNPYmplY3QsIGhhc093biwgbm9vcH0gZnJvbSAndmR0L3NyYy9saWIvdXRpbHMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZCwgaW5kZXhPZn0gZnJvbSAnbWlzc3RpbWUvc3JjL3V0aWxzJztcbmltcG9ydCBWZHQgZnJvbSAndmR0JztcblxuZXhwb3J0IHtleHRlbmQsIGlzQXJyYXksIGVhY2gsIGlzT2JqZWN0LCBoYXNPd24sIGlzTnVsbE9yVW5kZWZpbmVkLCBub29wfTtcblxuZXhwb3J0IGNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0IGNvbnN0IFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5leHBvcnQgY29uc3QgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xuXG4vKipcbiAqIGluaGVyaXRcbiAqIEBwYXJhbSBQYXJlbnRcbiAqIEBwYXJhbSBwcm90b3R5cGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuY29uc3QgaXNTdXBwb3J0R2V0RGVzY3JpcHRvciA9ICgoKSA9PiB7XG4gICAgY29uc3QgYSA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgJ2EnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KSgpO1xuZnVuY3Rpb24gc2V0UHJvdG90eXBlKFBhcmVudCwgQ2hpbGQsIG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJvdG90eXBlID0gQ2hpbGQucHJvdG90eXBlO1xuICAgIGxldCB0bXA7XG4gICAgaWYgKFxuICAgICAgICBpc1N1cHBvcnRHZXREZXNjcmlwdG9yICYmIFxuICAgICAgICAodG1wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihQYXJlbnQucHJvdG90eXBlLCBuYW1lKSkgJiZcbiAgICAgICAgdG1wLmdldFxuICAgICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbmhlcml0KFBhcmVudCwgcHJvdG90eXBlKSB7XG4gICAgbGV0IENoaWxkID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICByZXR1cm4gUGFyZW50LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgZWFjaChwcm90b3R5cGUsIGZ1bmN0aW9uKHByb3RvLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnZGlzcGxheU5hbWUnKSB7XG4gICAgICAgICAgICBDaGlsZC5kaXNwbGF5TmFtZSA9IHByb3RvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcocHJvdG8pKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBWZHQuY29tcGlsZShwcm90byk7XG4gICAgICAgICAgICAgICAgcHJvdG90eXBlLnRlbXBsYXRlID0gcHJvdG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgX3N1cGVyID0gUGFyZW50LnRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKCFfc3VwZXIgfHwgX3N1cGVyID09PSB0ZW1wbGF0ZURlY29yYXRvcikge1xuICAgICAgICAgICAgICAgIF9zdXBlciA9IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm90by5fc3VwZXIgPSBfc3VwZXI7IFxuICAgICAgICAgICAgQ2hpbGQudGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gc2V0UHJvdG90eXBlKFBhcmVudCwgQ2hpbGQsICd0ZW1wbGF0ZScsIHByb3RvKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNGdW5jdGlvbihwcm90bykpIHtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZVtuYW1lXSA9IHByb3RvO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZuID0gKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBfc3VwZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXJlbnQucHJvdG90eXBlW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIF9zdXBlckFwcGx5ID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFyZW50LnByb3RvdHlwZVtuYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZiA9IHRoaXMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIF9fc3VwZXIgPSBzZWxmLl9zdXBlcixcbiAgICAgICAgICAgICAgICAgICAgX19zdXBlckFwcGx5ID0gc2VsZi5fc3VwZXJBcHBseSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9zdXBlciA9IF9zdXBlcjtcbiAgICAgICAgICAgICAgICBzZWxmLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb3RvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fc3VwZXIgPSBfX3N1cGVyO1xuICAgICAgICAgICAgICAgIHNlbGYuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgICAgICBzZXRQcm90b3R5cGUoUGFyZW50LCBDaGlsZCwgbmFtZSwgZm4pOyBcbiAgICB9KTtcbiAgICBDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICAgIGZvciAobGV0IGtleSBpbiBQYXJlbnQpIHtcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbChDaGlsZCwga2V5KSkge1xuICAgICAgICAgICAgQ2hpbGRba2V5XSA9IFBhcmVudFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ2hpbGQuX19zdXBlciA9IFBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gQ2hpbGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZURlY29yYXRvcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSB0YXJnZXQudGVtcGxhdGU7XG4gICAgICAgIGlmIChpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gVmR0LmNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICBsZXQgX3N1cGVyO1xuICAgICAgICBpZiAodHlwZW9mIFBhcmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaXMgZGVmaW5lIGJ5IHN0YXRpY1xuICAgICAgICAgICAgX3N1cGVyID0gUGFyZW50LnRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKCFfc3VwZXIgfHwgX3N1cGVyID09PSB0ZW1wbGF0ZURlY29yYXRvcikge1xuICAgICAgICAgICAgICAgIF9zdXBlciA9IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyBkZWZpbmUgYnkgcHJvdG90eXBlXG4gICAgICAgICAgICBfc3VwZXIgPSBQYXJlbnQuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAoIV9zdXBlciB8fCBfc3VwZXIgPT09IHRlbXBsYXRlRGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyID0gUGFyZW50LnRlbXBsYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLl9zdXBlciA9IF9zdXBlcjtcblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZm9yOiBzdGF0aWMgdGVtcGxhdGUgPSAnJ1xuICAgICAgICAgICAgdGFyZ2V0LnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3I6IGdldCB0ZW1wbGF0ZSgpIHsgfVxuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN0YXRpYyB0ZW1wbGF0ZS4gTWF5YmUgaXQgaW5oZXJpdGVkIGZyb20gcGFyZW50XG4gICAgICAgICAgICB0YXJnZXQuY29uc3RydWN0b3IudGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCBuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGxldCBmbiA9ICgpID0+IHt9O1xuICAgIGZuLnByb3RvdHlwZSA9IG9iamVjdDtcbiAgICByZXR1cm4gbmV3IGZuKCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0KG9iaiwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgbGV0IHZhbHVlID0gaXNOdWxsT3JVbmRlZmluZWQob2JqKSA/IHVuZGVmaW5lZCA6IG9ialtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmopIDogdmFsdWU7XG59XG5cbmxldCBleGVjdXRlQm91bmQgPSAoc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykgPT4ge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgbGV0IHNlbGYgPSBjcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIGxldCByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChpc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xufTtcbmxldCBuYXRpdmVCaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5leHBvcnQgZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0LCAuLi5hcmdzKSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVCaW5kLmNhbGwoZnVuYywgY29udGV4dCwgLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgbGV0IGJvdW5kID0gZnVuY3Rpb24oLi4uYXJnczEpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgWy4uLmFyZ3MsIC4uLmFyZ3MxXSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG59XG5cbmxldCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxudmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGEpIHx8IGlzTnVsbE9yVW5kZWZpbmVkKGIpKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oYUN0b3IpICYmIFxuICAgICAgICAgICAgICAgIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBcbiAgICAgICAgICAgICAgICBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yXG4gICAgICAgICAgICApICYmIFxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgICAgdmFyIGFLZXlzID0ga2V5cyhhKSwga2V5O1xuICAgICAgICBsZW5ndGggPSBhS2V5cy5sZW5ndGg7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAgICAgIGtleSA9IGFLZXlzW2xlbmd0aF07XG4gICAgICAgICAgICBpZiAoIShoYXNPd24uY2FsbChiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG59XG5cbmxldCBpZENvdW50ZXIgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgIGxldCBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG59XG5cbmV4cG9ydCBsZXQga2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBlYWNoKG9iaiwgKHZhbHVlLCBrZXkpID0+IHJldC5wdXNoKGtleSkpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBlYWNoKG9iaiwgKHZhbHVlKSA9PiByZXQucHVzaCh2YWx1ZSkpO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmxldCBwYXRoTWFwID0ge30sXG4gICAgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2csXG4gICAgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2csXG4gICAgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RQYXRoKHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSByZXR1cm4gcGF0aDtcbiAgICBpZiAocGF0aE1hcFtwYXRoXSkgcmV0dXJuIHBhdGhNYXBbcGF0aF07XG5cbiAgICBsZXQgcmV0ID0gW107XG4gICAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICB9XG4gICAgcGF0aC5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICAgICByZXQucHVzaChxdW90ZSA/IHBhdGgucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgIH0pO1xuICAgIHBhdGhNYXBbcGF0aF0gPSByZXQ7XG5cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iamVjdCwgcGF0aCkpIHJldHVybiBvYmplY3RbcGF0aF07XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgpO1xuXG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoIWlzTnVsbE9yVW5kZWZpbmVkKG9iamVjdCkgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3BhdGhbaW5kZXgrK11dO1xuICAgIH1cblxuICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT09IGxlbmd0aCAmJiBvYmplY3QgIT09IHVuZGVmaW5lZCkgPyBvYmplY3QgOiBkZWZhdWx0VmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqZWN0LCBwYXRoKSkge1xuICAgICAgICBvYmplY3RbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCk7XG5cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgIG5lc3RlZCA9IG9iamVjdDtcbiAgICB3aGlsZSAoIWlzTnVsbE9yVW5kZWZpbmVkKG5lc3RlZCkgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoaW5kZXggIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKSA/IG9ialZhbHVlIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICB9XG4gICAgICAgIG5lc3RlZFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbmNvbnN0IGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG5leHBvcnQgY29uc3Qgd2FybiA9IGhhc0NvbnNvbGUgPyBcbiAgICBmdW5jdGlvbigpIHsgXG4gICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH0gOiBub29wO1xuZXhwb3J0IGNvbnN0IGVycm9yID0gaGFzQ29uc29sZSA/XG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9IDogbm9vcDtcblxuZnVuY3Rpb24gaXNOYXRpdmUoQ3Rvcikge1xuICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKTtcbn1cbmNvbnN0IG5leHRUaWNrID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgcC50aGVuKGNhbGxiYWNrKS5jYXRjaChlcnIgPT4gZXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvbiBpbiB2dWVcbiAgICAgICAgICAgIGlmIChpc0lPUykgc2V0VGltZW91dChub29wKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoIFxuICAgICAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgICAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICAgICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICAgICkpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbnN0IG5leHRUaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IF9jYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2NhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9jYWxsYmFja3NbaV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKS5vYnNlcnZlKG5vZGUsIHtcbiAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgaSA9IChpICsgMSkgJSAyO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gU3RyaW5nKGkpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5leHBvcnQgZnVuY3Rpb24gTmV4dFRpY2soZWFjaENhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5lYWNoQ2FsbGJhY2sgPSBlYWNoQ2FsbGJhY2s7XG4gICAgbmV4dFRpY2soKCkgPT4gdGhpcy5jYWxsYmFjaygpKTtcbn1cbk5leHRUaWNrLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRhdGEpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7IFxuICAgIGlmICh0aGlzLmVhY2hDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmVhY2hDYWxsYmFjayhkYXRhKTtcbiAgICB9XG59O1xuXG5jb25zdCB3b250QmluZCA9IFtcbiAgICAnY29uc3RydWN0b3InLFxuICAgICd0ZW1wbGF0ZScsXG4gICAgJ2RlZmF1bHRzJyxcbiAgICAvLyAnX2luaXQnLFxuICAgIC8vICdfbW91bnQnLFxuICAgIC8vICdfY3JlYXRlJyAsXG4gICAgLy8gJ191cGRhdGUnLFxuICAgIC8vICdfYmVmb3JlVXBkYXRlJyxcbiAgICAvLyAnX191cGRhdGUnLFxuICAgIC8vICdfcGF0Y2hQcm9wcycsXG4gICAgLy8gJ19kZXN0cm95JyxcbiAgICAvLyAnaW5pdCcsXG4gICAgLy8gJ3VwZGF0ZScsXG4gICAgLy8gJ21vdW50JyxcbiAgICAvLyAnZGVzdG9yeScsXG4gICAgLy8gJ3RvU3RyaW5nJyxcbiAgICAvLyAnaHlkcmF0ZScsXG4gICAgLy8gJ2dldCcsXG4gICAgLy8gJ3NldCcsXG4gICAgLy8gJ29uJyxcbiAgICAvLyAnb25lJyxcbiAgICAvLyAnb2ZmJyxcbiAgICAvLyAndHJpZ2dlcicsXG4gICAgLy8gJ19pbml0TW91bnRlZFF1ZXVlJyxcbiAgICAvLyAnX3RyaWdnZXJNb3VudGVkUXVldWUnLFxuICAgIC8vICdfdHJpZ2dlckNoYW5nZWRFdmVudCcsXG5dO1xuaWYgKHR5cGVvZiBPYmplY3QuZ2V0UHJvdG90eXBlT2YgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgXCJcIi5fX3Byb3RvX18gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuX19wcm90b19fO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgICAgICAgICAvLyBNYXkgYnJlYWsgaWYgdGhlIGNvbnN0cnVjdG9yIGhhcyBiZWVuIHRhbXBlcmVkIHdpdGhcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9O1xuICAgIH1cbn0gXG5cbmlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGtleXM7IFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXV0b2JpbmQocHJvdG90eXBlLCBjb250ZXh0LCBJbnRhY3QsIGJvdW5kKSB7XG4gICAgaWYgKCFwcm90b3R5cGUpIHJldHVybjtcbiAgICBpZiAocHJvdG90eXBlID09PSBJbnRhY3QucHJvdG90eXBlKSByZXR1cm47XG5cbiAgICBjb25zdCB0b0JpbmQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpO1xuICAgIGVhY2godG9CaW5kLCAobWV0aG9kKSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gcHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB3YXJuKGBBdXRvYmluZDogJyR7bWV0aG9kfScgbWV0aG9kIG5vdCBmb3VuZCBpbiBjbGFzcy5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh+aW5kZXhPZih3b250QmluZCwgbWV0aG9kKSB8fCBib3VuZFttZXRob2RdIHx8IHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dFttZXRob2RdID0gYmluZChmbiwgY29udGV4dCk7XG4gICAgICAgIGJvdW5kW21ldGhvZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gYmluZCBzdXBlciBtZXRob2RcbiAgICBhdXRvYmluZChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSwgY29udGV4dCwgSW50YWN0LCBib3VuZCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaW50YWN0L3NyYy91dGlscy5qcyIsImltcG9ydCB7cHJvY2Vzc1NlbGVjdH0gZnJvbSAnLi9zZWxlY3QnO1xuaW1wb3J0IHtwcm9jZXNzSW5wdXR9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHtwcm9jZXNzVGV4dGFyZWF9IGZyb20gJy4vdGV4dGFyZWEnO1xuaW1wb3J0IHtUeXBlc30gZnJvbSAnLi4vdm5vZGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0Zvcm0odk5vZGUsIGRvbSwgbmV4dFByb3BzLCBpc1JlbmRlcikge1xuICAgIGNvbnN0IHR5cGUgPSB2Tm9kZS50eXBlO1xuICAgIGlmICh0eXBlICYgVHlwZXMuSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3NJbnB1dCh2Tm9kZSwgZG9tLCBuZXh0UHJvcHMsIGlzUmVuZGVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5UZXh0YXJlYUVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzc1RleHRhcmVhKHZOb2RlLCBkb20sIG5leHRQcm9wcywgaXNSZW5kZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLlNlbGVjdEVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzc1NlbGVjdCh2Tm9kZSwgZG9tLCBuZXh0UHJvcHMsIGlzUmVuZGVyKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL3dyYXBwZXJzL3Byb2Nlc3MuanMiLCJpbXBvcnQgSW50YWN0IGZyb20gJy4vaW50YWN0JztcbmltcG9ydCBWZHQgZnJvbSAndmR0JztcbmltcG9ydCBBbmltYXRlIGZyb20gJy4vYW5pbWF0ZSc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuSW50YWN0LnByb3RvdHlwZS5BbmltYXRlID0gQW5pbWF0ZTtcbkludGFjdC5BbmltYXRlID0gQW5pbWF0ZTtcbkludGFjdC5WZHQgPSBWZHQ7XG5JbnRhY3QudXRpbHMgPSB1dGlscztcblZkdC5jb25maWd1cmUoe1xuICAgIGdldE1vZGVsKHNlbGYsIGtleSkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXQoa2V5KTtcbiAgICB9LFxuICAgIHNldE1vZGVsKHNlbGYsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gc2VsZi5zZXQoa2V5LCB2YWx1ZSwge2FzeW5jOiB0cnVlfSk7XG4gICAgICAgIHNlbGYuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBJbnRhY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaW50YWN0L3NyYy9pbmRleC5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMyIsImltcG9ydCB7XG4gICAgaW5oZXJpdCwgZXh0ZW5kLCByZXN1bHQsIGVhY2gsIGlzRnVuY3Rpb24sIGF1dG9iaW5kLCBcbiAgICBpc0VxdWFsLCB1bmlxdWVJZCwgZ2V0LCBzZXQsIGNhc3RQYXRoLCBoYXNPd24sXG4gICAga2V5cywgaXNPYmplY3QsIGlzU3RyaW5nLCBOZXh0VGljaywgdGVtcGxhdGVEZWNvcmF0b3IsXG4gICAgd2FybiwgZXJyb3IsXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IFZkdCBmcm9tICd2ZHQnO1xuaW1wb3J0IHtoYywgcmVuZGVyLCBoeWRyYXRlUm9vdCwgaH0gZnJvbSAnbWlzc3RpbWUnO1xuaW1wb3J0IHtyZW1vdmVDb21wb25lbnRDbGFzc09ySW5zdGFuY2V9IGZyb20gJ21pc3N0aW1lL3NyYy92ZG9tJztcbmltcG9ydCB7RU1QVFlfT0JKLCBUeXBlc30gZnJvbSAnbWlzc3RpbWUvc3JjL3Zub2RlJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWQsIGlzRXZlbnRQcm9wLCBNb3VudGVkUXVldWV9IGZyb20gJ21pc3N0aW1lL3NyYy91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEludGFjdChwcm9wcykge1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gICAgLy8gSW50YWN0LnRlbXBsYXRlIGlzIGEgZGVjb3JhdG9yXG4gICAgaWYgKCF0ZW1wbGF0ZSB8fCB0ZW1wbGF0ZSA9PT0gdGVtcGxhdGVEZWNvcmF0b3IpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIH1cbiAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBpbnN0YW50aWF0ZSB3aGVuIHRlbXBsYXRlIGRvZXMgbm90IGV4aXN0LicpO1xuICAgIH1cbiAgICAgXG4gICAgYXV0b2JpbmQoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB0aGlzLCBJbnRhY3QsIHt9KTtcbiAgICBcbiAgICBwcm9wcyA9IGV4dGVuZCh7fSwgcmVzdWx0KHRoaXMsICdkZWZhdWx0cycpLCBwcm9wcyk7XG5cbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB0aGlzLnByb3BzID0ge307XG4gICAgdGhpcy52ZHQgPSBWZHQodGVtcGxhdGUpO1xuICAgIHRoaXMuc2V0KHByb3BzLCB7c2lsZW50OiB0cnVlfSk7XG4gICAgLy8gdGhpcy5fcGF0Y2hQcm9wcyhudWxsLCBwcm9wcywge3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgLy8gZm9yIGNvbXBhdGliaWxpdHkgdjEuMFxuICAgIHRoaXMud2lkZ2V0cyA9IHRoaXMudmR0LndpZGdldHMgfHwge307XG4gICAgdGhpcy5fd2lkZ2V0ID0gdGhpcy5wcm9wcy53aWRnZXQgfHwgdW5pcXVlSWQoJ3dpZGdldCcpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBmb3Igc3RyaW5nIHJlZlxuICAgIHRoaXMucmVmcyA9IHRoaXMud2lkZ2V0cztcblxuICAgIHRoaXMudW5pcXVlSWQgPSB0aGlzLl93aWRnZXQ7XG5cbiAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlIGZsYWcgaXMgZmFsc2UsIGV2ZXJ5IHNldCBvcGVyYXRpb24gd2lsbCBub3QgbGVhZCB0byB1cGRhdGUgXG4gICAgdGhpcy5fc3RhcnRSZW5kZXIgPSBmYWxzZTtcblxuICAgIC8vIGZvciBkZWJ1Z1xuICAgIHRoaXMuZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lO1xuXG4gICAgLy8gYmluZCBldmVudHNcbiAgICBlYWNoKHRoaXMucHJvcHMgLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoaXNFdmVudFByb3Aoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5vbihrZXkuc3Vic3RyKDMpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZUNvdW50ID0gMDtcblxuICAgIGNvbnN0IGluaXRlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJyRpbml0ZWQnLCB0aGlzKTtcbiAgICB9O1xuICAgIGNvbnN0IHJldCA9IHRoaXMuX2luaXQoKTtcbiAgICBpZiAocmV0ICYmIHJldC50aGVuKSB7XG4gICAgICAgIHJldC50aGVuKGluaXRlZCwgZXJyID0+IHtcbiAgICAgICAgICAgIGVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24gaW4gX2luaXQ6ICcsIGVycik7XG4gICAgICAgICAgICBpbml0ZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGVkKCk7XG4gICAgfVxufVxuXG5JbnRhY3QucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBJbnRhY3QsXG5cbiAgICBkZWZhdWx0cygpIHt9LFxuXG4gICAgX2luaXQocHJvcHMpIHt9LFxuICAgIF9jcmVhdGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHt9LFxuICAgIF9tb3VudChsYXN0Vk5vZGUsIG5leHRWTm9kZSkge30sXG4gICAgX2JlZm9yZVVwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSkge30sXG4gICAgX3VwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSkge30sXG4gICAgX2Rlc3Ryb3kobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSkge30sXG5cbiAgICBoeWRyYXRlKHZOb2RlLCBkb20pIHtcbiAgICAgICAgY29uc3QgdmR0ID0gdGhpcy52ZHQ7XG4gICAgICAgIGlmICghdGhpcy5pbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25lKCckaW5pdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmh5ZHJhdGUodk5vZGUsIGRvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2Tm9kZS5kb20gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyTW91bnRlZFF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudChudWxsLCB2Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdmR0Lmh5ZHJhdGUoXG4gICAgICAgICAgICB0aGlzLCBkb20sIHRoaXMubW91bnRlZFF1ZXVlLCBcbiAgICAgICAgICAgIHRoaXMucGFyZW50RG9tLCB2Tm9kZSwgdGhpcy5pc1NWRyxcbiAgICAgICAgICAgIHRoaXMuZ2V0KCdfYmxvY2tzJylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJpZ2dlcignJHJlbmRlcmVkJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZShudWxsLCB2Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9LFxuXG4gICAgaW5pdChsYXN0Vk5vZGUsIG5leHRWTm9kZSkge1xuICAgICAgICBjb25zdCB2ZHQgPSB0aGlzLnZkdDtcbiAgICAgICAgdGhpcy5fbGFzdFZOb2RlID0gbGFzdFZOb2RlO1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGVkKSB7XG4gICAgICAgICAgICAvLyDmlK/mjIHlvILmraXnu4Tku7ZcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIGlmIChsYXN0Vk5vZGUpIHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IGxhc3RWTm9kZS5kb207XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEluc3RhbmNlID0gbGFzdFZOb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHZkdC52Tm9kZSA9IGxhc3RJbnN0YW5jZS52ZHQudk5vZGU7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5LiK5LiA5Liq57uE5Lu25piv5byC5q2l57uE5Lu277yM5bm25LiU5Lmf6L+Y5rKh5riy5p+T5a6M5oiQ77yM5YiZ55u05o6lZGVzdHJveeaOiVxuICAgICAgICAgICAgICAgIC8vIOiuqeWug+S4jeWGjea4suafk+S6hlxuICAgICAgICAgICAgICAgIGlmICghbGFzdEluc3RhbmNlLmluaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDb21wb25lbnRDbGFzc09ySW5zdGFuY2UobGFzdFZOb2RlLCBudWxsLCBuZXh0Vk5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgdk5vZGUgPSBoYygnIScpO1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gcmVuZGVyKHZOb2RlKTtcbiAgICAgICAgICAgICAgICB2ZHQudk5vZGUgPSB2Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOe7hOS7tumUgOavgeS6i+S7tuS5n+S8muino+e7ke+8jOaJgOS7pei/memHjOaXoOmcgOWIpOaWree7hOS7tuaYr+WQpumUgOavgeS6hlxuICAgICAgICAgICAgdGhpcy5vbmUoJyRpbml0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuaW5pdChsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9tID0gbmV4dFZOb2RlLmRvbTtcbiAgICAgICAgICAgICAgICAvLyDlrZjlnKjkuIDnp43mg4XlhrXvvIznu4Tku7bnmoTnrKzkuIDkuKrlhYPntKDmmK/kuIDkuKrnu4Tku7bvvIzku5bku6znrqHnkIbnmoTmmK/lkIzkuIDkuKpkb21cbiAgICAgICAgICAgICAgICAvLyDkvYbmmK/lvZPnrKzkuIDkuKrlhYPntKDnmoRkb23lj5jmm7Tml7bvvIzniLbnu4Tku7bnmoR2Tm9kZeWNtOayoeacieWPmFxuICAgICAgICAgICAgICAgIC8vIOaJgOS7pei/memHjOW8uuWItuS/neaMgeS4gOiHtFxuICAgICAgICAgICAgICAgIG5leHRWTm9kZS5kb20gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmICghbGFzdFZOb2RlIHx8IGxhc3RWTm9kZS5rZXkgIT09IG5leHRWTm9kZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsZW1lbnQsIGRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJNb3VudGVkUXVldWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50KGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmR0Lm5vZGUgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgLy8g5aaC5p6ca2V55LiN55u45ZCM77yM5YiZ5LiN5aSN55SoZG9t77yM55u05o6l6L+U5Zue5pawZG9t5p2l5pu/5o2iXG4gICAgICAgIGlmIChsYXN0Vk5vZGUgJiYgbGFzdFZOb2RlLmtleSA9PT0gbmV4dFZOb2RlLmtleSkge1xuICAgICAgICAgICAgLy8gZGVzdHJveSB0aGUgbGFzdCBjb21wb25lbnRcbiAgICAgICAgICAgIGlmICghbGFzdFZOb2RlLmNoaWxkcmVuLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNvbXBvbmVudENsYXNzT3JJbnN0YW5jZShsYXN0Vk5vZGUsIG51bGwsIG5leHRWTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gbWFrZSB0aGUgZG9tIG5vdCBiZSByZXBsYWNlZCwgYnV0IHVwZGF0ZSB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgIHZkdC52Tm9kZSA9IGxhc3RWTm9kZS5jaGlsZHJlbi52ZHQudk5vZGU7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB2ZHQudXBkYXRlKFxuICAgICAgICAgICAgICAgIHRoaXMsIHRoaXMucGFyZW50RG9tLCB0aGlzLm1vdW50ZWRRdWV1ZSxcbiAgICAgICAgICAgICAgICBuZXh0Vk5vZGUsIHRoaXMuaXNTVkcsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXQoJ19ibG9ja3MnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYXN0Vk5vZGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDb21wb25lbnRDbGFzc09ySW5zdGFuY2UobGFzdFZOb2RlLCBudWxsLCBuZXh0Vk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gdmR0LnJlbmRlcihcbiAgICAgICAgICAgICAgICB0aGlzLCB0aGlzLnBhcmVudERvbSwgdGhpcy5tb3VudGVkUXVldWUsIFxuICAgICAgICAgICAgICAgIG5leHRWTm9kZSwgdGhpcy5pc1NWRyxcbiAgICAgICAgICAgICAgICB0aGlzLmdldCgnX2Jsb2NrcycpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1VwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJyRyZW5kZXJlZCcsIHRoaXMpO1xuICAgICAgICB0aGlzLl9jcmVhdGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZHQucmVuZGVyU3RyaW5nKHRoaXMsIHRoaXMuZ2V0KCdfYmxvY2tzJykpOyBcbiAgICB9LFxuXG4gICAgbW91bnQobGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHtcbiAgICAgICAgLy8g5byC5q2l57uE5Lu277yM55u05o6l6L+U5ZueXG4gICAgICAgIGlmICghdGhpcy5pbml0ZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCckbW91bnRlZCcsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tb3VudChsYXN0Vk5vZGUsIG5leHRWTm9kZSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSwgZnJvbVBlbmRpbmcpIHtcbiAgICAgICAgLy8g5aaC5p6c6K+l57uE5Lu25bey6KKr6ZSA5q+B77yM5YiZ5LiN5pu05pawXG4gICAgICAgIC8vIOe7hOS7tueahOmUgOavgemhuuW6j+aYr+S7juiHquS4i+iAjOS4iumAkOatpemUgOavgeeahO+8jOWvueS6juWtkOe7hOS7tu+8jOWNs+S9v+WwhuimgemUgOavgeS5n+imgeabtOaWsFxuICAgICAgICAvLyDlj6rmnInniLbnu4Tku7booqvplIDmr4HkuobmiY3kuI3ljrvmm7TmlrDvvIzniLbnu4Tku7bnmoTmm7TmlrDmmK/msqHmnIl2Tm9kZeWPguaVsFxuICAgICAgICBpZiAoIWxhc3RWTm9kZSAmJiAhbmV4dFZOb2RlICYmIHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZOb2RlID8gbGFzdFZOb2RlLmRvbSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzov5jmsqHmnInmuLLmn5PvvIzliJnnrYnlvoXnu5PmnZ/lho3ljrvmm7TmlrBcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nVXBkYXRlID0gZnVuY3Rpb24obGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShsYXN0Vk5vZGUsIG5leHRWTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWTm9kZSA/IGxhc3RWTm9kZS5kb20gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5leHRWTm9kZSAmJiAhZnJvbVBlbmRpbmcgJiYgdGhpcy5fdXBkYXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIOWmguaenOebtOaOpeiwg+eUqHVwZGF0ZeaWueazle+8jOWImeimgea4hemZpG1vdW50ZWRRdWV1ZVxuICAgICAgICAgICAgLy8g5aaC5p6c5ZyocmVuZGVy55qE6L+H56iL5Lit77yM5Y+I6Kem5Y+R5LqGdXBkYXRl77yM5YiZ5q2k5pe2XG4gICAgICAgICAgICAvLyDkuI3og73muIXnqbpcbiAgICAgICAgICAgIHRoaXMubW91bnRlZFF1ZXVlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWmguaenOS4jeWtmOWcqG5leHRWTm9kZe+8jOWImeS4uuebtOaOpeiwg+eUqHVwZGF0ZeaWueazleabtOaWsOiHquW3sVxuICAgICAgICAvLyDlkKbliJnliJnmmK/niLbnu4Tku7bop6blj5HnmoTlrZDnu4Tku7bmm7TmlrDvvIzmraTml7bpnIDopoHmm7TmlrDkuIDkupvnirbmgIFcbiAgICAgICAgLy8g5pyJ5LiA56eN5oOF5Ya177yM5Zyo54i257uE5Lu25Yid5qyh5riy5p+T5pe277yM5a2Q57uE5Lu25riy5p+T6L+H56iL5Lit77yMXG4gICAgICAgIC8vIOWPiOinpuWPkeS6hueItue7hOS7tueahOaVsOaNruWPmOabtO+8jOatpOaXtueItue7hOS7tua4suafk+WujOaIkOaJp+ihjF9wZW5kaW5nVXBkYXRlXG4gICAgICAgIC8vIOaYr+ayoeaciWxhc3RWTm9kZeeahFxuICAgICAgICBpZiAobmV4dFZOb2RlICYmIGxhc3RWTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fcGF0Y2hQcm9wcyhsYXN0Vk5vZGUucHJvcHMsIG5leHRWTm9kZS5wcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuX3VwZGF0ZUNvdW50O1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRlQ291bnQgPiAxKSByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRlQ291bnQgPT09IDEpIHJldHVybiB0aGlzLl9fdXBkYXRlKGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICB9LFxuXG4gICAgX191cGRhdGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHtcbiAgICAgICAgdGhpcy5fYmVmb3JlVXBkYXRlKGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICAgICAgLy8g55u05o6l6LCD55SodXBkYXRl5pa55rOV77yM5L+d5oyBcGFyZW50Vk5vZGXkuI3lj5hcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy52ZHQudXBkYXRlKFxuICAgICAgICAgICAgdGhpcywgdGhpcy5wYXJlbnREb20sIHRoaXMubW91bnRlZFF1ZXVlLFxuICAgICAgICAgICAgbmV4dFZOb2RlIHx8IHRoaXMudk5vZGUsIHRoaXMuaXNTVkcsXG4gICAgICAgICAgICB0aGlzLmdldCgnX2Jsb2NrcycpXG4gICAgICAgICk7XG4gICAgICAgIC8vIOiuqeaVtOS4quabtOaWsOWujOaIkO+8jOaJjeWOu+inpuWPkV91cGRhdGXnlJ/lkb3lkajmnJ/lh73mlbBcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZFF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLm1vdW50ZWRRdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUobGFzdFZOb2RlLCBuZXh0Vk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgtLXRoaXMuX3VwZGF0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5pu05paw5a6M5oiQ77yM5Y+R546w6L+Y5pyJ5pu05paw77yM5YiZ5piv5Zyo5pu05paw6L+H56iL5Lit5Y+I6Kem5Y+R5LqG5pu05pawXG4gICAgICAgICAgICAvLyDmraTml7bnm7TmjqXlsIZfdXBkYXRlQ291bnTnva7kuLox77yM5Zug5Li65omA5pyJ5pWw5o2u6YO95bey5pu05paw77yM5Y+q5YGa5pyA5ZCO5LiA5qyh5qih5p2/5pu05paw5Y2z5Y+vXG4gICAgICAgICAgICAvLyAtLXRoaXMuX3VwZGF0ZUNvdW505Lya5bCG6K+l5YC86K6+5Li6MO+8jOaJgOS7pei/memHjOiuvuS4ujFcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvdW50ID0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50OyAgICAgICBcbiAgICB9LFxuXG4gICAgX3BhdGNoUHJvcHMobGFzdFByb3BzLCBuZXh0UHJvcHMsIG9wdGlvbnMgPSB7dXBkYXRlOiBmYWxzZSwgX2Zyb21QYXRjaFByb3BzOiB0cnVlfSkge1xuICAgICAgICBsYXN0UHJvcHMgPSBsYXN0UHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBuZXh0UHJvcHMgPSBuZXh0UHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBsZXQgbGFzdFZhbHVlO1xuICAgICAgICBsZXQgbmV4dFZhbHVlO1xuICAgICAgICBpZiAobGFzdFByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIC8vIOmcgOimgeWFiOWkhOeQhuS6i+S7tu+8jOWboOS4unByb3Dlj5jmm7Tlj6/og73op6blj5Hnm7jlupTnmoTkuovku7ZcbiAgICAgICAgICAgIGxldCBsYXN0UHJvcHNXaXRob3V0RXZlbnRzO1xuICAgICAgICAgICAgbGV0IG5leHRQcm9wc1dpdGhvdXRFdmVudHM7XG4gICAgICAgICAgICBpZiAobmV4dFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0VmFsdWUgPSBuZXh0UHJvcHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V2ZW50UHJvcChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQocHJvcCwgbmV4dFZhbHVlLCB7c2lsZW50OiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBsYXN0UHJvcHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5pu05o2i5LqL5Lu255uR5ZCs5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50TmFtZSA9IHByb3Auc3Vic3RyKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihsYXN0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6Kej57uR5LqL5Lu255uR5ZCs5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYocHJvcC5zdWJzdHIoMyksIGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRQcm9wc1dpdGhvdXRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNXaXRob3V0RXZlbnRzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNXaXRob3V0RXZlbnRzW3Byb3BdID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0UHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGxhc3RQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbChuZXh0UHJvcHMsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gbGFzdFByb3BzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0V2ZW50UHJvcChwcm9wKSAmJiBpc0Z1bmN0aW9uKGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQocHJvcCwgdW5kZWZpbmVkLCB7c2lsZW50OiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+S6i+S7tu+8jOWImeimgeino+e7keS6i+S7tlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihwcm9wLnN1YnN0cigzKSwgbGFzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RQcm9wc1dpdGhvdXRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9wc1dpdGhvdXRFdmVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcHNXaXRob3V0RXZlbnRzW3Byb3BdID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNXaXRob3V0RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KG5leHRQcm9wc1dpdGhvdXRFdmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBsYXN0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gbGFzdFByb3BzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFdmVudFByb3AocHJvcCkgJiYgaXNGdW5jdGlvbihsYXN0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChwcm9wLCB1bmRlZmluZWQsIHtzaWxlbnQ6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+S6i+S7tu+8jOWImeimgeino+e7keS6i+S7tlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYocHJvcC5zdWJzdHIoMyksIGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RQcm9wc1dpdGhvdXRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcHNXaXRob3V0RXZlbnRzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcHNXaXRob3V0RXZlbnRzW3Byb3BdID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlsIbkuI3lrZjlnKhuZXh0UHJvcHPkuK3vvIzkvYblrZjlnKhsYXN0UHJvcHPkuK3nmoTlsZ7mgKfvvIznu5/nu5/nva7kuLrpu5jorqTlgLxcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRzID0gcmVzdWx0KHRoaXMsICdkZWZhdWx0cycpIHx8IEVNUFRZX09CSjsgXG4gICAgICAgICAgICBpZiAobGFzdFByb3BzV2l0aG91dEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gbGFzdFByb3BzV2l0aG91dEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChwcm9wLCBkZWZhdWx0c1twcm9wXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3kobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB3YXJuKCdkZXN0cm95ZWQgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZHQgPSB0aGlzLnZkdDtcbiAgICAgICAgLy8g5byC5q2l57uE5Lu277yM5Y+v6IO96L+Y5rKh5pyJ5riy5p+TXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlZCkge1xuICAgICAgICAgICAgLy8g5byC5q2l57uE5Lu277yM5Y+q5pyJ5byA5aeL5riy5p+T5pe25omN6ZSA5q+B5LiK5LiA5Liq57uE5Lu2XG4gICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInmuLLmn5PlvZPliY3lvILmraXnu4Tku7blsLHooqvplIDmr4HkuobvvIzliJnopoFcbiAgICAgICAgICAgIC8vIOWcqOi/memHjOmUgOavgeS4iuS4gOS4que7hOS7tlxuICAgICAgICAgICAgY29uc3QgX2xhc3RWTm9kZSA9IHRoaXMuX2xhc3RWTm9kZTtcbiAgICAgICAgICAgIGlmIChfbGFzdFZOb2RlICYmICFfbGFzdFZOb2RlLmNoaWxkcmVuLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNvbXBvbmVudENsYXNzT3JJbnN0YW5jZShfbGFzdFZOb2RlLCBudWxsLCBsYXN0Vk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgIW5leHRWTm9kZSB8fCBcbiAgICAgICAgICAgICEobmV4dFZOb2RlLnR5cGUgJiBUeXBlcy5Db21wb25lbnRDbGFzc09ySW5zdGFuY2UpIHx8XG4gICAgICAgICAgICBuZXh0Vk5vZGUua2V5ICE9PSBsYXN0Vk5vZGUua2V5XG4gICAgICAgICkge1xuICAgICAgICAgICAgdmR0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzlrZjlnKhuZXh0Vk5vZGXvvIzlubbkuJRuZXh0Vk5vZGXkuZ/mmK/kuIDkuKrnu4Tku7bnsbvlnovvvIxcbiAgICAgICAgLy8g5bm25LiU77yM5a6D5L+p55qEa2V555u4562J77yM5YiZ5LiN5Y67ZGVzdHJvee+8jOiAjOaYr+WcqOS4i+S4gOS4que7hOS7tmluaXTml7ZcbiAgICAgICAgLy8g5aSN55So5LiK5LiA5LiqZG9t77yM54S25ZCOZGVzdHJveeS4iuS4gOS4quWFg+e0oFxuICAgICAgICB0aGlzLl9kZXN0cm95KGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJyRkZXN0cm95ZWQnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vZmYoKTtcbiAgICB9LFxuXG4gICAgLy8gZnVuY3Rpb24gbmFtZSBjb25mbGljdCB3aXRoIHV0aWxzLmdldFxuICAgIGdldDogZnVuY3Rpb24gX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiBnZXQodGhpcy5wcm9wcywga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIF9zZXQoa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGtleSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGxldCBpc1NldEJ5T2JqZWN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgICAgICAgIGlzU2V0QnlPYmplY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe1xuICAgICAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIF9mcm9tUGF0Y2hQcm9wczogZmFsc2UsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAvLyDlhbzlrrnogIHniYjmnKxcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKG9wdGlvbnMsICdnbG9iYWwnKSkge1xuICAgICAgICAgICAgb3B0aW9ucy51cGRhdGUgPSBvcHRpb25zLmdsb2JhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHt9O1xuXG4gICAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5YmN6Z2i5YGa5LqGdW5kZWZpbmVk55qE5Yik5pat77yM6L+Z6YeM5LiN5Y+v6IO95Li6dW5kZWZpbmVk5LqGXG4gICAgICAgIGlmIChpc1NldEJ5T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRWYWx1ZSA9IGtleVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RWYWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWwobGFzdFZhbHVlLCBuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW3Byb3BdID0gW2xhc3RWYWx1ZSwgbmV4dFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIOWNs+S9v+ebuOetie+8jOS5n+imgemHjeaWsOWkjeWItu+8jOWboOS4uuacieWPr+iDveW8leeUqOWcsOWdgOWPmOabtFxuICAgICAgICAgICAgICAgICAgICBwcm9wc1twcm9wXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOmdmem7mOabtOaWsO+8jOWImeebtOaOpei1i+WAvFxuICAgICAgICAgICAgICAgIGV4dGVuZChwcm9wcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFZhbHVlID0gZ2V0KHByb3BzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbChsYXN0VmFsdWUsIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbChwcm9wcywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1trZXldID0gW2xhc3RWYWx1ZSwgdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gY2FzdFBhdGgoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+WDjydhLmIuYyfov5nmoLforr7nva7lsZ7mgKfvvIzogIzor6XlsZ7mgKfkuI3lrZjlnKhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS+neasoeinpuWPkWNoYW5nZTphLmIuY+OAgWNoYW5nZTphLmLjgIFjaGFuZ2U6Yei/meagt+eahOS6i+S7tlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5YWI5LiN6K6+572ucHJvcHPvvIzljrvlj5bogIHlgLxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfcHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBhdGguc2xpY2UoMCwgaSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbGFzdFZhbHVlID0gZ2V0KHByb3BzLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW3Byb3BdID0gW19sYXN0VmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6K6+572ucHJvcHPlkI7vvIzljrvlj5bmlrDlgLxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWvueS6juW8leeUqOaVsOaNruexu+Wei++8jOaWsOiAgeWAvOWPr+iDveS4gOagt1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHByb3BzLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9wID0gX3Byb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXNbcHJvcF0ucHVzaChnZXQocHJvcHMsIHByb3ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWQpuWIme+8jOWPquinpuWPkWNoYW5nZTphLmIuY1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1trZXldID0gW2xhc3RWYWx1ZSwgdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldChwcm9wcywga2V5LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KHByb3BzLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXQocHJvcHMsIGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gY2hhbmdlc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5fZnJvbVBhdGNoUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhICRyZWNlaXZlIGV2ZW50IHRvIHNob3cgdGhhdCB3ZSByZWNlaXZlZCBhIGRpZmZlcmVudCBwcm9wXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihgJHJlY2VpdmU6JHtwcm9wfWAsIHRoaXMsIHZhbHVlc1sxXSwgdmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBgY2hhbmdlKmAgZXZlbnRzXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGAkY2hhbmdlOiR7cHJvcH1gLCB0aGlzLCB2YWx1ZXNbMV0sIHZhbHVlc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VLZXlzID0ga2V5cyhjaGFuZ2VzKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCckY2hhbmdlJywgdGhpcywgY2hhbmdlS2V5cyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVwZGF0ZSAmJiB0aGlzLl9zdGFydFJlbmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJDaGFuZ2UgPSAoY2hhbmdlcywgY2hhbmdlS2V5cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlZEV2ZW50KGNoYW5nZXMsIGNoYW5nZUtleXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl8kbmV4dFRpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXyRuZXh0VGljayA9IG5ldyBOZXh0VGljayhmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5bCG5q+P5qyh5pS55Y+Y55qE5bGe5oCn5pS+5YWl5pWw57uEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuXyRuZXh0VGljay5hcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8kbmV4dFRpY2suZmlyZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWQiOW5tuaJp+ihjOabtOaWsOWQju+8jOinpuWPkeaJgOaciSRjaGFuZ2Vk5LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZChjaGFuZ2VzLCBhcmdzW2ldKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl8kbmV4dFRpY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZShjaGFuZ2VzLCBrZXlzKGNoYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZShjaGFuZ2VzLCBjaGFuZ2VLZXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW91bnRlZFF1ZXVlICYmIHRoaXMuX3N0YXJ0UmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5piv54i257uE5Lu25a+86Ie05a2Q57uE5Lu25pu05paw77yM5q2k5pe25a2Y5ZyobW91bnRlZFF1ZXVlXG4gICAgICAgICAgICAgICAgLy8g5YiZ5Zyo57uE5Lu25pWw5pu05paw5a6M5q+V77yM6Kem5Y+RJGNoYW5nZWTkuovku7ZcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50ZWRRdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZWRFdmVudChjaGFuZ2VzLCBjaGFuZ2VLZXlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAodGhpcy5fZXZlbnRzW25hbWVdIHx8ICh0aGlzLl9ldmVudHNbbmFtZV0gPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbmUobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7IFxuICAgICAgICAgICAgdGhpcy5vZmYobmFtZSwgZm4pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGZuKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb2ZmKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGNiLCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoY2IgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdHJpZ2dlcihuYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLl9ldmVudHNbbmFtZV07XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2luaXRNb3VudGVkUXVldWUoKSB7XG4gICAgICAgIHRoaXMubW91bnRlZFF1ZXVlID0gbmV3IE1vdW50ZWRRdWV1ZSgpO1xuICAgIH0sXG5cbiAgICBfdHJpZ2dlck1vdW50ZWRRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5tb3VudGVkUXVldWUudHJpZ2dlcigpO1xuICAgIH0sXG5cbiAgICBfdHJpZ2dlckNoYW5nZWRFdmVudChjaGFuZ2VzLCBjaGFuZ2VLZXlzKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IGNoYW5nZXNbcHJvcF07XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoYCRjaGFuZ2VkOiR7cHJvcH1gLCB0aGlzLCB2YWx1ZXNbMV0sIHZhbHVlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCckY2hhbmdlZCcsIHRoaXMsIGNoYW5nZUtleXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIOe7p+aJv+afkOS4que7hOS7tlxuICpcbiAqIEBwYXJhbSBwcm90b3R5cGVcbiAqL1xuSW50YWN0LmV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvdHlwZSA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnByb3RvdHlwZS5kZWZhdWx0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3RvdHlwZS5kZWZhdWx0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJvdG90eXBlLmRlZmF1bHRzID0gZXh0ZW5kKHt9LCB0aGlzLnByb3RvdHlwZS5kZWZhdWx0cywgcHJvdG90eXBlLmRlZmF1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaGVyaXQodGhpcywgcHJvdG90eXBlKTtcbn07XG5cbi8qKlxuICog5oyC6L2957uE5Lu25YiwZG9t5LitXG4gKiBAcGFyYW0gQ29tcG9uZW50IHtJbnRhY3R9IEludGFjdOexu+aIluWtkOexu1xuICogQHBhcmFtIG5vZGUge05vZGV9IGh0bWzoioLngrlcbiAqL1xuSW50YWN0Lm1vdW50ID0gZnVuY3Rpb24oQ29tcG9uZW50LCBub2RlKSB7XG4gICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdCBhIHBhcmVudCBkb20gdG8gbW91bnQgQ29tcG9uZW50LCBidXQgZ290ICR7bm9kZX1gKTtcbiAgICBjb25zdCB2Tm9kZSA9IGgoQ29tcG9uZW50KTtcbiAgICBjb25zdCBtb3VudGVkUXVldWUgPSBuZXcgTW91bnRlZFF1ZXVlKCk7XG4gICAgcmVuZGVyKHZOb2RlLCBub2RlLCBtb3VudGVkUXVldWUpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdk5vZGUuY2hpbGRyZW47XG4gICAgLy8g5aaC5p6c5LiN5piv5byC5q2l57uE5Lu277yM5YiZ6Kem5Y+RbW91bnTkuovku7bvvIzlkKbliJlcbiAgICAvLyDkuqTnu5nnu4Tku7bnmoRpbml05pa55rOV77yM562J5byC5q2l5aSE55CG5a6M5oiQ5ZCO6Kem5Y+RXG4gICAgaWYgKGluc3RhbmNlLmluaXRlZCkge1xuICAgICAgICBtb3VudGVkUXVldWUudHJpZ2dlcigpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG5JbnRhY3QuaHlkcmF0ZSA9IGZ1bmN0aW9uKENvbXBvbmVudCwgbm9kZSkge1xuICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKGBleHBlY3QgYSBwYXJlbnQgZG9tIHRvIGh5ZHJhdGUgQ29tcG9uZW50LCBidXQgZ290ICR7bm9kZX1gKTtcbiAgICBjb25zdCB2Tm9kZSA9IGgoQ29tcG9uZW50KTtcbiAgICBoeWRyYXRlUm9vdCh2Tm9kZSwgbm9kZSk7XG4gICAgcmV0dXJuIHZOb2RlLmNoaWxkcmVuO1xufTtcblxuLy8gRVM3IERlY29yYXRvciBmb3IgdGVtcGxhdGVcbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50YWN0LCAndGVtcGxhdGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogdGVtcGxhdGVEZWNvcmF0b3IsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ludGFjdC9zcmMvaW50YWN0LmpzIiwiaW1wb3J0IHtjcmVhdGVWTm9kZSwgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVVbmVzY2FwZVRleHRWTm9kZSwgVHlwZXN9IGZyb20gJy4vdm5vZGUnO1xuaW1wb3J0IHtwYXRjaH0gZnJvbSAnLi92cGF0Y2gnO1xuaW1wb3J0IHtyZW5kZXIsIHJlbW92ZUVsZW1lbnR9IGZyb20gJy4vdmRvbSc7XG5pbXBvcnQge01vdW50ZWRRdWV1ZX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge3RvU3RyaW5nfSBmcm9tICcuL3Rvc3RyaW5nJztcbmltcG9ydCB7aHlkcmF0ZVJvb3QsIGh5ZHJhdGV9IGZyb20gJy4vaHlkcmF0aW9uJztcblxuZXhwb3J0IHtcbiAgICBjcmVhdGVWTm9kZSBhcyBoLCBcbiAgICBwYXRjaCxcbiAgICByZW5kZXIsIFxuICAgIGNyZWF0ZUNvbW1lbnRWTm9kZSBhcyBoYywgXG4gICAgY3JlYXRlVW5lc2NhcGVUZXh0Vk5vZGUgYXMgaHUsXG4gICAgcmVtb3ZlRWxlbWVudCBhcyByZW1vdmUsXG4gICAgTW91bnRlZFF1ZXVlLFxuICAgIHRvU3RyaW5nIGFzIHJlbmRlclN0cmluZyxcbiAgICBoeWRyYXRlUm9vdCwgXG4gICAgaHlkcmF0ZSxcbiAgICBUeXBlcyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL2luZGV4LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJpbXBvcnQge1NpbXBsZU1hcCwgaXNOdWxsT3JVbmRlZmluZWQsIGNyZWF0ZU9iamVjdCwgZG9jIGFzIGRvY3VtZW50LCBicm93c2VyfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgQUxMX1BST1BTID0gW1xuICAgIFwiYWx0S2V5XCIsIFwiYnViYmxlc1wiLCBcImNhbmNlbGFibGVcIiwgXCJjdHJsS2V5XCIsXG4gICAgXCJldmVudFBoYXNlXCIsIFwibWV0YUtleVwiLCBcInJlbGF0ZWRUYXJnZXRcIiwgXCJzaGlmdEtleVwiLFxuICAgIFwidGFyZ2V0XCIsIFwidGltZVN0YW1wXCIsIFwidHlwZVwiLCBcInZpZXdcIiwgXCJ3aGljaFwiXG5dO1xuY29uc3QgS0VZX1BST1BTID0gW1wiY2hhclwiLCBcImNoYXJDb2RlXCIsIFwia2V5XCIsIFwia2V5Q29kZVwiXTtcbmNvbnN0IE1PVVNFX1BST1BTID0gW1xuICAgIFwiYnV0dG9uXCIsIFwiYnV0dG9uc1wiLCBcImNsaWVudFhcIiwgXCJjbGllbnRZXCIsIFwibGF5ZXJYXCIsXG4gICAgXCJsYXllcllcIiwgXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiLCBcInBhZ2VYXCIsIFwicGFnZVlcIixcbiAgICBcInNjcmVlblhcIiwgXCJzY3JlZW5ZXCIsIFwidG9FbGVtZW50XCJcbl07XG5cbmNvbnN0IHJrZXlFdmVudCA9IC9ea2V5fGlucHV0LztcbmNvbnN0IHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51KXxjbGljay87XG5cbmZ1bmN0aW9uIEV2ZW50KGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMTF9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcHJvcEtleSA9IEFMTF9QUk9QU1tpXTtcbiAgICAgICAgdGhpc1twcm9wS2V5XSA9IGVbcHJvcEtleV07XG4gICAgfVxuICAgIFxuICAgIGlmICghZS50YXJnZXQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBlLnNyY0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdGhpcy5fcmF3RXZlbnQgPSBlO1xufVxuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3Jhd0V2ZW50O1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxufTtcbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fcmF3RXZlbnQ7ICAgIFxuICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufTtcblxuZnVuY3Rpb24gTW91c2VFdmVudChlKSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzLCBlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IE1PVVNFX1BST1BTLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBtb3VzZVByb3BLZXkgPSBNT1VTRV9QUk9QU1tqXTtcbiAgICAgICAgdGhpc1ttb3VzZVByb3BLZXldID0gZVttb3VzZVByb3BLZXldO1xuICAgIH1cbn1cbk1vdXNlRXZlbnQucHJvdG90eXBlID0gY3JlYXRlT2JqZWN0KEV2ZW50LnByb3RvdHlwZSk7XG5Nb3VzZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdXNlRXZlbnQ7XG5cbmZ1bmN0aW9uIEtleUV2ZW50KGUpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIGUpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgS0VZX1BST1BTLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBrZXlQcm9wS2V5ID0gS0VZX1BST1BTW2pdO1xuICAgICAgICB0aGlzW2tleVByb3BLZXldID0gZVtrZXlQcm9wS2V5XTtcbiAgICB9XG59XG5LZXlFdmVudC5wcm90b3R5cGUgPSBjcmVhdGVPYmplY3QoRXZlbnQucHJvdG90eXBlKTtcbktleUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleUV2ZW50O1xuXG5mdW5jdGlvbiBwcm94eUV2ZW50KGUpIHtcbiAgICBpZiAocmtleUV2ZW50LnRlc3QoZS50eXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEtleUV2ZW50KGUpO1xuICAgIH0gZWxzZSBpZiAocm1vdXNlRXZlbnQudGVzdChlLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW91c2VFdmVudChlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50KGUpO1xuICAgIH1cbn1cblxubGV0IGFkZEV2ZW50TGlzdGVuZXI7XG5sZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbmlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZG9tLCBuYW1lLCBmbikge1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmbiwgZmFsc2UpO1xuICAgIH07XG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZG9tLCBuYW1lLCBmbikge1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmbik7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGRvbSwgbmFtZSwgZm4pIHtcbiAgICAgICAgZm4uY2IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgZSA9IHByb3h5RXZlbnQoZSk7XG4gICAgICAgICAgICBmbihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9tLmF0dGFjaEV2ZW50KGBvbiR7bmFtZX1gLCBmbi5jYik7XG4gICAgfTtcblxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihkb20sIG5hbWUsIGZuKSB7XG4gICAgICAgIGRvbS5kZXRhY2hFdmVudChgb24ke25hbWV9YCwgZm4uY2IgfHwgZm4pO1xuICAgIH07XG59XG5cbmNvbnN0IGRlbGVnYXRlZEV2ZW50cyA9IHt9O1xuY29uc3QgdW5EZWxlZ2F0ZXNFdmVudHMgPSB7XG4gICAgJ21vdXNlZW50ZXInOiB0cnVlLFxuICAgICdtb3VzZWxlYXZlJzogdHJ1ZSxcbiAgICAncHJvcGVydHljaGFuZ2UnOiB0cnVlLFxuICAgICdzY3JvbGwnOiB0cnVlLFxufTtcblxuLy8gY2hhbmdlIGV2ZW50IGNhbiBub3QgYmUgZGVsZXRlZ2F0ZWQgaW4gSUU4IFxuaWYgKGJyb3dzZXIuaXNJRTgpIHtcbiAgICB1bkRlbGVnYXRlc0V2ZW50cy5jaGFuZ2UgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXZlbnQobmFtZSwgbGFzdEV2ZW50LCBuZXh0RXZlbnQsIGRvbSkge1xuICAgIGlmIChuYW1lID09PSAnYmx1cicpIHtcbiAgICAgICAgbmFtZSA9ICdmb2N1c291dCc7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnZm9jdXMnKSB7XG4gICAgICAgIG5hbWUgPSAnZm9jdXNpbic7XG4gICAgfSBlbHNlIGlmIChicm93c2VyLmlzSUU4ICYmIG5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgbmFtZSA9ICdwcm9wZXJ0eWNoYW5nZSc7XG4gICAgfVxuXG4gICAgaWYgKCF1bkRlbGVnYXRlc0V2ZW50c1tuYW1lXSkge1xuICAgICAgICBsZXQgZGVsZWdhdGVkUm9vdHMgPSBkZWxlZ2F0ZWRFdmVudHNbbmFtZV07XG5cbiAgICAgICAgaWYgKG5leHRFdmVudCkge1xuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZWRSb290cykge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlZFJvb3RzID0ge2l0ZW1zOiBuZXcgU2ltcGxlTWFwKCksIGRvY0V2ZW50OiBudWxsfTtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZWRSb290cy5kb2NFdmVudCA9IGF0dGFjaEV2ZW50VG9Eb2N1bWVudChuYW1lLCBkZWxlZ2F0ZWRSb290cyk7IFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlZEV2ZW50c1tuYW1lXSA9IGRlbGVnYXRlZFJvb3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZWdhdGVkUm9vdHMuaXRlbXMuc2V0KGRvbSwgbmV4dEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWxlZ2F0ZWRSb290cykge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBkZWxlZ2F0ZWRSb290cy5pdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5kZWxldGUoZG9tKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIG5hbWUsIGRlbGVnYXRlZFJvb3RzLmRvY0V2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlbGVnYXRlZFJvb3RzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsYXN0RXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tLCBuYW1lLCBsYXN0RXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0RXZlbnQpIHtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBuYW1lLCBuZXh0RXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50LCB0YXJnZXQsIGl0ZW1zLCBjb3VudCwgaXNDbGljaykge1xuICAgIGNvbnN0IGV2ZW50VG9UcmlnZ2VyID0gaXRlbXMuZ2V0KHRhcmdldCk7XG4gICAgaWYgKGV2ZW50VG9UcmlnZ2VyKSB7XG4gICAgICAgIGNvdW50LS07XG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGV2ZW50VG9UcmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50Ll9yYXdFdmVudC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudERvbSA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQocGFyZW50RG9tKSB8fCAoaXNDbGljayAmJiBwYXJlbnREb20ubm9kZVR5cGUgPT09IDEgJiYgcGFyZW50RG9tLmRpc2FibGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBhcmVudERvbSwgaXRlbXMsIGNvdW50LCBpc0NsaWNrKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaEV2ZW50VG9Eb2N1bWVudChuYW1lLCBkZWxlZ2F0ZWRSb290cykge1xuICAgIHZhciBkb2NFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZGVsZWdhdGVkUm9vdHMuaXRlbXMuc2l6ZTtcbiAgICAgICAgZXZlbnQgfHwgKGV2ZW50ID0gd2luZG93LmV2ZW50KTtcbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgZXZlbnQgPSBwcm94eUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQsIGV2ZW50LnRhcmdldCwgZGVsZWdhdGVkUm9vdHMuaXRlbXMsIGNvdW50LCBldmVudC50eXBlID09PSAnY2xpY2snKTsgXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIG5hbWUsIGRvY0V2ZW50KTtcbiAgICByZXR1cm4gZG9jRXZlbnQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL2V2ZW50LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4yLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTAzLTIwVDE4OjU5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4yLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcblx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBcIj50Ym9keVwiLCBlbGVtIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSxcblx0XHR2YWwgPSAwO1xuXG5cdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRpZiAoIGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0aSA9IDQ7XG5cblx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHR9IGVsc2Uge1xuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL0hlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiICkge1xuXHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSBdO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2MsIGRvY0VsZW0sIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0d2luID0gZG9jLmRlZmF1bHRWaWV3O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIW5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJpbXBvcnQgQXBwIGZyb20gJy4vY29tcG9uZW50cy9hcHAnO1xuaW1wb3J0IHtSb3V0ZXJ9IGZyb20gJ2RpcmVjdG9yJztcbmltcG9ydCBjc3MgZnJvbSAnLi9jc3MvbGF5b3V0LnN0eWwnO1xuXG5Sb3V0ZXIucHJvdG90eXBlLnJlcGxhY2VSb3V0ZSA9IGZ1bmN0aW9uIChpLCB2LCB2YWwpIHtcbiAgdmFyIHVybCA9IHRoaXMuZXhwbG9kZSgpO1xuXG4gIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJsW2ldID0gdjtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHVybC5zcGxpY2UoaSwgdiwgcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdXJsID0gW2ldO1xuICB9XG5cbiAgdmFyIHMgPSB1cmw7XG5cbiAgZG9jdW1lbnQubG9jYXRpb24ucmVwbGFjZSgoc1swXSA9PT0gJyMnKSA/IHMgOiAnIycgKyBzKTtcbiAgcmV0dXJuIHVybDtcbn1cblxuY29uc3QgYXBwID0gSW50YWN0Lm1vdW50KEFwcCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhZ2UnKSk7XG5cbmNvbnN0IHJvdXRlciA9IFJvdXRlcih7XG4gICAgJy8nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVxdWlyZShbJy4vcGFnZXMvaW5kZXgnXSwgYXBwLnJ1bigpKTtcbiAgICB9LFxuICAgICcvZG9jdW1lbnQnOiB7XG4gICAgICAgICcvOnRpdGxlJzoge1xuICAgICAgICAgICAgb246IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZShbJy4vcGFnZXMvZG9jdW1lbnQnXSwgYXBwLnJ1bih7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcm91dGVyLnJlcGxhY2VSb3V0ZSgnL2RvY3VtZW50L3N0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICcvYXBpJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlcXVpcmUoWycuL3BhZ2VzL2FwaSddLCBhcHAucnVuKHtcbiAgICAgICAgICAgIHRpdGxlOiAnYXBpJ1xuICAgICAgICB9KSk7XG4gICAgfVxufSkuY29uZmlndXJlKHtcbiAgICBub3Rmb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvdXRlci5yZXBsYWNlUm91dGUoJy8nKTtcbiAgICB9XG59KTtcblxucm91dGVyLmluaXQoJy8nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21haW4uanMiLCJpbXBvcnQgUGFyc2VyIGZyb20gJy4vcGFyc2VyJztcbmltcG9ydCBTdHJpbmdpZmllciBmcm9tICcuL3N0cmluZ2lmaWVyJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0ICogYXMgbWlzcyBmcm9tICdtaXNzdGltZSc7XG5cbmNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcbmNvbnN0IHN0cmluZ2lmaWVyID0gbmV3IFN0cmluZ2lmaWVyKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZkdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmR0KSkgcmV0dXJuIG5ldyBWZHQoc291cmNlLCBvcHRpb25zKTtcblxuICAgIHRoaXMudGVtcGxhdGUgPSBjb21waWxlKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLnZOb2RlID0gbnVsbDtcbiAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgIHRoaXMud2lkZ2V0cyA9IHt9O1xuICAgIHRoaXMuYmxvY2tzID0ge307XG59XG5WZHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBWZHQsXG5cbiAgICByZW5kZXIoZGF0YSwgcGFyZW50RG9tLCBxdWV1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHLCBibG9ja3MpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJWTm9kZShkYXRhLCBibG9ja3MpO1xuICAgICAgICB0aGlzLm5vZGUgPSBtaXNzLnJlbmRlcih0aGlzLnZOb2RlLCBwYXJlbnREb20sIHF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgfSxcblxuICAgIHJlbmRlclZOb2RlKGRhdGEsIGJsb2Nrcykge1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIChibG9ja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLnZOb2RlID0gdGhpcy50ZW1wbGF0ZSh0aGlzLmRhdGEsIFZkdCwgdGhpcy5ibG9ja3MsIHRoaXMudGVtcGxhdGUpIHx8IG1pc3MuaGMoJ2VtcHR5Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudk5vZGU7XG4gICAgfSxcblxuICAgIHJlbmRlclN0cmluZyhkYXRhLCBibG9ja3MpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJWTm9kZShkYXRhLCBibG9ja3MpO1xuXG4gICAgICAgIHJldHVybiBtaXNzLnJlbmRlclN0cmluZyh0aGlzLnZOb2RlLCBudWxsLCBWZHQuY29uZmlndXJlKCkuZGlzYWJsZVNwbGl0VGV4dCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZShkYXRhLCBwYXJlbnREb20sIHF1ZXVlLCBwYXJlbnRWTm9kZSwgaXNTVkcsIGJsb2Nrcykge1xuICAgICAgICB2YXIgb2xkVk5vZGUgPSB0aGlzLnZOb2RlO1xuICAgICAgICB0aGlzLnJlbmRlclZOb2RlKGRhdGEsIGJsb2Nrcyk7XG4gICAgICAgIHRoaXMubm9kZSA9IG1pc3MucGF0Y2gob2xkVk5vZGUsIHRoaXMudk5vZGUsIHBhcmVudERvbSwgcXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICB9LFxuXG4gICAgaHlkcmF0ZShkYXRhLCBkb20sIHF1ZXVlLCBwYXJlbnREb20sIHBhcmVudFZOb2RlLCBpc1NWRywgYmxvY2tzKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVk5vZGUoZGF0YSwgYmxvY2tzKTtcbiAgICAgICAgbWlzcy5oeWRyYXRlKHRoaXMudk5vZGUsIGRvbSwgcXVldWUsIHBhcmVudERvbSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy52Tm9kZS5kb207XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICB9LFxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbWlzcy5yZW1vdmUodGhpcy52Tm9kZSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY29tcGlsZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGVtcGxhdGVGbjtcblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdjAuMi4yXG4gICAgaWYgKG9wdGlvbnMgPT09IHRydWUgfHwgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucyA9IHthdXRvUmV0dXJuOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKHt9LCB1dGlscy5jb25maWd1cmUoKSwgb3B0aW9ucyk7XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBzb3VyY2UpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2Uoc291cmNlLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBoc2NyaXB0ID0gc3RyaW5naWZpZXIuc3RyaW5naWZ5KGFzdCwgb3B0aW9ucy5hdXRvUmV0dXJuKTtcblxuICAgICAgICAgICAgaHNjcmlwdCA9IFtcbiAgICAgICAgICAgICAgICAnX1ZkdCB8fCAoX1ZkdCA9IFZkdCk7JyxcbiAgICAgICAgICAgICAgICAnb2JqIHx8IChvYmogPSB7fSk7JyxcbiAgICAgICAgICAgICAgICAnYmxvY2tzIHx8IChibG9ja3MgPSB7fSk7JyxcbiAgICAgICAgICAgICAgICAndmFyIGggPSBfVmR0Lm1pc3MuaCwgaGMgPSBfVmR0Lm1pc3MuaGMsIGh1ID0gX1ZkdC5taXNzLmh1LCB3aWRnZXRzID0gdGhpcyAmJiB0aGlzLndpZGdldHMgfHwge30sIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSB7fSwnLFxuICAgICAgICAgICAgICAgICAgICAnX191ID0gX1ZkdC51dGlscywgZXh0ZW5kID0gX191LmV4dGVuZCwgX2UgPSBfX3UuZXJyb3IsIF9jbGFzc05hbWUgPSBfX3UuY2xhc3NOYW1lLCcsXG4gICAgICAgICAgICAgICAgICAgICdfX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsJyxcbiAgICAgICAgICAgICAgICAgICAgJ19zZXRDaGVja2JveE1vZGVsID0gX191LnNldENoZWNrYm94TW9kZWwsIF9kZXRlY3RDaGVja2JveENoZWNrZWQgPSBfX3UuZGV0ZWN0Q2hlY2tib3hDaGVja2VkLCcsXG4gICAgICAgICAgICAgICAgICAgICdfc2V0U2VsZWN0TW9kZWwgPSBfX3Uuc2V0U2VsZWN0TW9kZWwsJyxcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMuc2VydmVyID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVxdWlyZSA9IGZ1bmN0aW9uKGZpbGUpIHsgcmV0dXJuIF9WZHQucmVxdWlyZShmaWxlLCBcIicgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIikgfSwgJyA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgICdzZWxmID0gdGhpcy5kYXRhLCAkdGhpcyA9IHRoaXMsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9ICgkY2FsbGVlIHx8IHt9KS5fc3VwZXInLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubm9XaXRoID8gaHNjcmlwdCA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGggKG9iaikgeycsXG4gICAgICAgICAgICAgICAgICAgICAgICBoc2NyaXB0LFxuICAgICAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgICAgICBdLmpvaW4oJ1xcbicpXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGVtcGxhdGVGbiA9IG9wdGlvbnMub25seVNvdXJjZSA/IGZ1bmN0aW9uKCkge30gOiBuZXcgRnVuY3Rpb24oJ29iaicsICdfVmR0JywgJ2Jsb2NrcycsICckY2FsbGVlJywgaHNjcmlwdCk7XG4gICAgICAgICAgICB0ZW1wbGF0ZUZuLnNvdXJjZSA9ICdmdW5jdGlvbihvYmosIF9WZHQsIGJsb2NrcywgJGNhbGxlZSkge1xcbicgKyBoc2NyaXB0ICsgJ1xcbn0nO1xuICAgICAgICAgICAgdGVtcGxhdGVGbi5oZWFkID0gc3RyaW5naWZpZXIuaGVhZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICB0ZW1wbGF0ZUZuID0gc291cmNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBhIHN0cmluZyBvciBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZUZuO1xufVxuXG5WZHQucGFyc2VyID0gcGFyc2VyO1xuVmR0LnN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXI7XG5WZHQubWlzcyA9IG1pc3M7XG5WZHQuY29tcGlsZSA9IGNvbXBpbGU7XG5WZHQudXRpbHMgPSB1dGlscztcblZkdC5zZXREZWxpbWl0ZXJzID0gdXRpbHMuc2V0RGVsaW1pdGVycztcblZkdC5nZXREZWxpbWl0ZXJzID0gdXRpbHMuZ2V0RGVsaW1pdGVycztcblZkdC5jb25maWd1cmUgPSB1dGlscy5jb25maWd1cmU7XG5cbi8vIGZvciBjb21wYXRpYmlsaXR5IHYxLjBcblZkdC52aXJ0dWFsRG9tID0gbWlzczsgXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdmR0L3NyYy9saWIvdmR0LmpzIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IHBhcnNlIGpzeCB0byBhc3RcbiAqIEBhdXRob3IgamF2ZXlcbiAqIEBkYXRlIDE1LTQtMjJcbiAqL1xuXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcblxuY29uc3Qge1R5cGUsIFR5cGVOYW1lfSA9IFV0aWxzO1xuY29uc3QgZWxlbWVudE5hbWVSZWdleHAgPSAvXjxcXHcrOj9cXHMqW1xce1xcd1xcLz5dLztcbi8vIGNvbnN0IGltcG9ydFJlZ2V4cCA9IC9eXFxzKlxcYmltcG9ydFxcYi87XG5cbmZ1bmN0aW9uIGlzSlNYSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICByZXR1cm4gKGNoID09PSA1OCkgfHwgKGNoID09PSA5NSkgfHwgKGNoID09PSA0NSkgfHwgY2ggPT09IDM2IHx8IGNoID09PSA0NiB8fCAgLy8gOiBfICh1bmRlcnNjb3JlKSAtICQgLlxuICAgICAgICAoY2ggPj0gNjUgJiYgY2ggPD0gOTApIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAoY2ggPj0gOTcgJiYgY2ggPD0gMTIyKSB8fCAgICAgICAgLy8gYS4uelxuICAgICAgICAoY2ggPj0gNDggJiYgY2ggPD0gNTcpOyAgICAgICAgIC8vIDAuLjlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIHRoaXMuc291cmNlID0gJyc7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5QYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBQYXJzZXIsXG5cbiAgICBwYXJzZTogZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gVXRpbHMudHJpbVJpZ2h0KHNvdXJjZSk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxpbmUgPSAxO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5zb3VyY2UubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh7fSwgVXRpbHMuY29uZmlndXJlKCksIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRlbXBsYXRlKHRydWUpO1xuICAgIH0sXG5cbiAgICBfcGFyc2VUZW1wbGF0ZTogZnVuY3Rpb24oaXNSb290KSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdLFxuICAgICAgICAgICAgYnJhY2VzID0ge2NvdW50OiAwfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCAmJiBicmFjZXMuY291bnQgPj0gMCkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLl9hZHZhbmNlKGJyYWNlcywgaXNSb290KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIF9hZHZhbmNlOiBmdW5jdGlvbihicmFjZXMsIGlzUm9vdCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9jaGFyKCk7XG4gICAgICAgIGlmIChpc1Jvb3QgJiYgdGhpcy5faXNKU0ltcG9ydCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbkpTSW1wb3J0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggIT09ICc8Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYW5KUyhicmFjZXMsIGlzUm9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbkpTWCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zY2FuSlM6IGZ1bmN0aW9uKGJyYWNlcywgaXNSb290KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICBEZWxpbWl0ZXJzID0gdGhpcy5vcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fc2tpcEpTQ29tbWVudCgpO1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5fY2hhcigpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFwnJyB8fCBjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlbGVtZW50KDxkaXY+KSBpbiBxdW90ZXNcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0VsZW1lbnRTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUm9vdCAmJiB0aGlzLl9pc0pTSW1wb3J0KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VzLmNvdW50Kys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChicmFjZXMuY291bnQgPiAwICYmIGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VzLmNvdW50LS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0V4cGVjdChEZWxpbWl0ZXJzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGFyc2VUZW1wbGF0ZSBicmVha1xuICAgICAgICAgICAgICAgICAgICBicmFjZXMuY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUoVHlwZS5KUywge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NjYW5KU0ltcG9ydCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoNyk7IC8vICdpbXBvcnQgJy5sZW5ndGhcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5fY2hhcigpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoY2ggPT09ICdcXCcnIHx8IGNoID09PSAnXCInKSAmJiBcbiAgICAgICAgICAgICAgICAoKGNoID0gdGhpcy5fY2hhcigpKSA9PT0gJzsnIHx8IGNoID09PSAnXFxuJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUoVHlwZS5KU0ltcG9ydCwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NjYW5TdHJpbmdMaXRlcmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5fY2hhcigpLFxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4LFxuICAgICAgICAgICAgc3RyID0gJyc7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUluZGV4KCk7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5fY2hhcigpO1xuICAgICAgICAgICAgaWYgKGNoLmNoYXJDb2RlQXQoMCkgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoKTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5fY2hhcih0aGlzLl91cGRhdGVJbmRleCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKCdVbmNsb3NlZCBxdW90ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUoVHlwZS5TdHJpbmdMaXRlcmFsLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2NhbkpTWDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUpTWEVsZW1lbnQoKTtcbiAgICB9LFxuXG4gICAgX3NjYW5KU1hUZXh0OiBmdW5jdGlvbihzdG9wQ2hhcnMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgIGwgPSBzdG9wQ2hhcnMubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGNoYXJDb2RlO1xuXG4gICAgICAgIGxvb3A6XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gdGhpcy5fY2hhckNvZGUoKTtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1doaXRlU3BhY2UoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcENoYXJzW2ldID09PSAnZnVuY3Rpb24nICYmIHN0b3BDaGFyc1tpXS5jYWxsKHRoaXMpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNFeHBlY3Qoc3RvcENoYXJzW2ldKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUoVHlwZS5KU1hUZXh0LCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2NhbkpTWFN0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLl9jaGFyKCk7XG4gICAgICAgIGlmIChxdW90ZSAhPT0gJ1xcJycgJiYgcXVvdGUgIT09ICdcIicgJiYgcXVvdGUgIT09ICdgJykge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxb3V0ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUluZGV4KCk7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX3NjYW5KU1hUZXh0KFtxdW90ZV0pO1xuICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfSxcblxuICAgIF9wYXJzZUpTWEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9leHBlY3QoJzwnKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgIHJldCA9IHt9LFxuICAgICAgICAgICAgZmxhZyA9IHRoaXMuX2NoYXJDb2RlKCk7XG4gICAgICAgIGlmIChmbGFnID49IDY1ICYmIGZsYWcgPD0gOTAvKiB1cHBlciBjYXNlICovKSB7XG4gICAgICAgICAgICAvLyBpcyBhIHdpZGdldFxuICAgICAgICAgICAgdGhpcy5fdHlwZShUeXBlLkpTWFdpZGdldCwgcmV0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0V4cGVjdCgnIS0tJykpIHtcbiAgICAgICAgICAgIC8vIGlzIGh0bWwgY29tbWVudFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlSlNYQ29tbWVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoYXJDb2RlKHRoaXMuaW5kZXggKyAxKSA9PT0gNTgvKiA6ICovKXtcbiAgICAgICAgICAgIC8vIGlzIGEgZGlyZWN0aXZlXG4gICAgICAgICAgICBzdGFydCArPSAyO1xuICAgICAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTY6IC8vIHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHlwZShUeXBlLkpTWFZkdCwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5ODogLy8gYlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlKFR5cGUuSlNYQmxvY2ssIHJldCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yKCdVbmtub3duIGRpcmVjdGl2ZSAnICsgU3RyaW5nLmZyb21DaGFyQ29kZShmbGFnKSArICc6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzIGFuIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuX3R5cGUoVHlwZS5KU1hFbGVtZW50LCByZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0pTWElkZW50aWZpZXJQYXJ0KHRoaXMuX2NoYXJDb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0LnZhbHVlID0gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUF0dHJpYnV0ZUFuZENoaWxkcmVuKHJldCk7XG4gICAgfSxcblxuICAgIF9wYXJzZUF0dHJpYnV0ZUFuZENoaWxkcmVuOiBmdW5jdGlvbihyZXQpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5fcGFyc2VKU1hBdHRyaWJ1dGUoKTtcbiAgICAgICAgVXRpbHMuZXh0ZW5kKHJldCwge1xuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cnMuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGF0dHJzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmV0LmRpcmVjdGl2ZXMubGVuZ3RoKSBkZWxldGUgcmV0LmRpcmVjdGl2ZXM7XG5cbiAgICAgICAgaWYgKHJldC50eXBlID09PSBUeXBlLkpTWEVsZW1lbnQgJiYgVXRpbHMuaXNTZWxmQ2xvc2luZ1RhZyhyZXQudmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBzZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhcigpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZXhwZWN0KCc+Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2hhcigpID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHVua25vd24gc2VsZiBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuX2V4cGVjdCgnPicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXhwZWN0KCc+Jyk7XG4gICAgICAgICAgICByZXQuY2hpbGRyZW4gPSB0aGlzLl9wYXJzZUpTWENoaWxkcmVuKHJldCwgYXR0cnMuaGFzVlJhdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBfcGFyc2VKU1hBdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBbXSxcbiAgICAgICAgICAgIGhhc1ZSYXc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhcigpID09PSAnLycgfHwgdGhpcy5fY2hhcigpID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIERlbGltaXRlcnMgPSB0aGlzLm9wdGlvbnMuZGVsaW1pdGVycztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFeHBlY3QoRGVsaW1pdGVyc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBkeW5hbWljIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0LmF0dHJpYnV0ZXMucHVzaCh0aGlzLl9wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHRoaXMuX3BhcnNlSlNYQXR0cmlidXRlTmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09ICd2LXJhdycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0Lmhhc1ZSYXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYXIoKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIudmFsdWUgPSB0aGlzLl9wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgbm8tdmFsdWUgYXR0cmlidXRlIGFzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IHRoaXMuX3R5cGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBUeXBlLkpTWEV4cHJlc3Npb25Db250YWluZXIsIFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBbdGhpcy5fdHlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUeXBlLkpTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWx1ZTogJ3RydWUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgKV19XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldFthdHRyLnR5cGUgPT09IFR5cGUuSlNYQXR0cmlidXRlID8gXG4gICAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGVzJyA6ICdkaXJlY3RpdmVzJ1xuICAgICAgICAgICAgICAgIF0ucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIF9wYXJzZUpTWEF0dHJpYnV0ZU5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICBpZiAoIWlzSlNYSWRlbnRpZmllclBhcnQodGhpcy5fY2hhckNvZGUoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGlkZW50aWZpZXIgJyArIHRoaXMuX2NoYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5fY2hhckNvZGUoKTtcbiAgICAgICAgICAgIGlmICghaXNKU1hJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICBpZiAoVXRpbHMuaXNEaXJlY3RpdmUobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlKFR5cGUuSlNYRGlyZWN0aXZlLCB7bmFtZTogbmFtZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUoVHlwZS5KU1hBdHRyaWJ1dGUsIHtuYW1lOiBuYW1lfSk7XG4gICAgfSxcblxuICAgIF9wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgICAgRGVsaW1pdGVycyA9IHRoaXMub3B0aW9ucy5kZWxpbWl0ZXJzO1xuICAgICAgICBpZiAodGhpcy5faXNFeHBlY3QoRGVsaW1pdGVyc1swXSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fcGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3NjYW5KU1hTdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBfcGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBEZWxpbWl0ZXJzID0gdGhpcy5vcHRpb25zLmRlbGltaXRlcnM7XG4gICAgICAgIHRoaXMuX2V4cGVjdChEZWxpbWl0ZXJzWzBdKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRXhwZWN0KERlbGltaXRlcnNbMV0pKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5fcGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0V4cGVjdCgnPScpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGVhZCBjaGFyIGlzICc9JywgdGhlbiB0cmVhdCBpdCBhcyB1bmVzY2FwZSBzdHJpbmdcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLl9wYXJzZUpTWFVuZXNjYXBlVGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5fZXhwZWN0KERlbGltaXRlcnNbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5fcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXhwZWN0KERlbGltaXRlcnNbMV0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlKFR5cGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lciwge3ZhbHVlOiBleHByZXNzaW9ufSk7XG4gICAgfSxcblxuICAgIF9wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlKFR5cGUuSlNYRW1wdHlFeHByZXNzaW9uLCB7dmFsdWU6IG51bGx9KTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRlbXBsYXRlKCk7XG4gICAgfSxcblxuICAgIF9wYXJzZUpTWFVuZXNjYXBlVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2V4cGVjdCgnPScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZShUeXBlLkpTWFVuZXNjYXBlVGV4dCwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3BhcnNlVGVtcGxhdGUoKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3BhcnNlSlNYQ2hpbGRyZW46IGZ1bmN0aW9uKGVsZW1lbnQsIGhhc1ZSYXcpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW10sXG4gICAgICAgICAgICBlbmRUYWcgPSBlbGVtZW50LnZhbHVlICsgJz4nLFxuICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XG5cbiAgICAgICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVHlwZS5KU1hCbG9jazpcbiAgICAgICAgICAgICAgICBlbmRUYWcgPSAnPC9iOicgKyBlbmRUYWc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFR5cGUuSlNYVmR0OlxuICAgICAgICAgICAgICAgIGVuZFRhZyA9ICc8L3Q6JyArIGVuZFRhZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVHlwZS5KU1hFbGVtZW50OlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBlbmRUYWcgPSAnPC8nICsgZW5kVGFnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1ZSYXcpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFeHBlY3QoZW5kVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLl9zY2FuSlNYVGV4dChbZW5kVGFnXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2tpcFdoaXRlc3BhY2VCZXR3ZWVuRWxlbWVudHMoZW5kVGFnKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFeHBlY3QoZW5kVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuX3BhcnNlSlNYQ2hpbGQoZWxlbWVudCwgZW5kVGFnLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcnNlSlNYQ2xvc2luZ0VsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH0sXG5cbiAgICBfcGFyc2VKU1hDaGlsZDogZnVuY3Rpb24oZWxlbWVudCwgZW5kVGFnLCBwcmV2KSB7XG4gICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICBEZWxpbWl0ZXJzID0gdGhpcy5vcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRXhwZWN0KERlbGltaXRlcnNbMF0pKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc1RleHRUYWcoZWxlbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuX3NjYW5KU1hUZXh0KFtlbmRUYWcsIERlbGltaXRlcnNbMF1dKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0VsZW1lbnRTdGFydCgpKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9wYXJzZUpTWEVsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NraXBXaGl0ZXNwYWNlQmV0d2VlbkVsZW1lbnRzKGVuZFRhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9zY2FuSlNYVGV4dChbZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRXhwZWN0KGVuZFRhZykgfHwgdGhpcy5faXNFbGVtZW50U3RhcnQoKTtcbiAgICAgICAgICAgIH0sIERlbGltaXRlcnNbMF1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldC5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXQubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IHJldDtcbiAgICAgICAgICAgIHJldC5wcmV2ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgX3BhcnNlSlNYQ2xvc2luZ0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9leHBlY3QoJzwvJyk7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0pTWElkZW50aWZpZXJQYXJ0KHRoaXMuX2NoYXJDb2RlKCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgdGhpcy5fZXhwZWN0KCc+Jyk7XG4gICAgfSxcblxuICAgIF9wYXJzZUpTWENvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9leHBlY3QoJyEtLScpO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNFeHBlY3QoJy0tPicpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoYXJDb2RlKCkgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5fdHlwZShUeXBlLkpTWENvbW1lbnQsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5pbmRleClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2V4cGVjdCgnLS0+Jyk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgX2NoYXI6IGZ1bmN0aW9uKGluZGV4ID0gdGhpcy5pbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY2hhckF0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgX2NoYXJDb2RlOiBmdW5jdGlvbihpbmRleCA9IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgX3NraXBXaGl0ZXNwYWNlQmV0d2VlbkVsZW1lbnRzOiBmdW5jdGlvbihlbmRUYWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2tpcFdoaXRlc3BhY2UpIHJldHVybjtcblxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB3aGlsZSAoc3RhcnQgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2NoYXJDb2RlKHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1doaXRlU3BhY2UoY29kZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0V4cGVjdChlbmRUYWcsIHN0YXJ0KSB8fCB0aGlzLl9pc0VsZW1lbnRTdGFydChzdGFydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9za2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2tpcFdoaXRlc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHRoaXMuX2NoYXJDb2RlKCk7XG4gICAgICAgICAgICBpZiAoIVV0aWxzLmlzV2hpdGVTcGFjZShjb2RlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAxMCkge1xuICAgICAgICAgICAgICAgIC8vIGlzIFxcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUluZGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NraXBKU0NvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY2hhcigpID09PSAnLycpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuX2NoYXIodGhpcy5pbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFyQ29kZSgpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgXFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUluZGV4KDIpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRXhwZWN0KCcqLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbmRleCgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoYXJDb2RlKCkgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2V4cGVjdDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNFeHBlY3Qoc3RyKSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoJ2V4cGVjdCBzdHJpbmcgJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlSW5kZXgoc3RyLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIF9pc0V4cGVjdDogZnVuY3Rpb24oc3RyLCBpbmRleCA9IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKGluZGV4LCBpbmRleCArIHN0ci5sZW5ndGgpID09PSBzdHI7XG4gICAgfSxcblxuICAgIF9pc0VsZW1lbnRTdGFydDogZnVuY3Rpb24oaW5kZXggPSB0aGlzLmluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFyKGluZGV4KSA9PT0gJzwnICYmIFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHRoaXMuX2lzRXhwZWN0KCc8IS0tJykgfHwgXG4gICAgICAgICAgICAgICAgZWxlbWVudE5hbWVSZWdleHAudGVzdCh0aGlzLnNvdXJjZS5zbGljZShpbmRleCkpXG4gICAgICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfaXNKU0ltcG9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0V4cGVjdCgnaW1wb3J0ICcpO1xuICAgIH0sXG5cbiAgICBfdHlwZTogZnVuY3Rpb24odHlwZSwgcmV0KSB7XG4gICAgICAgIHJldCB8fCAocmV0ID0ge30pO1xuICAgICAgICByZXQudHlwZSA9IHR5cGU7XG4gICAgICAgIHJldC50eXBlTmFtZSA9IFR5cGVOYW1lW3R5cGVdO1xuICAgICAgICByZXQubGluZSA9IHRoaXMubGluZTtcbiAgICAgICAgcmV0LmNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGluZSsrO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgfSxcblxuICAgIF91cGRhdGVJbmRleDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPSAxKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuaW5kZXggKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSB0aGlzLmNvbHVtbiArIHZhbHVlO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIF9lcnJvcjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIG1zZyArICcgQXQ6IHtsaW5lOiAnICsgdGhpcy5saW5lICsgJywgY29sdW1uOiAnICsgdGhpcy5jb2x1bW4gK1xuICAgICAgICAgICAgJ30gTmVhcjogXCInICsgdGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5pbmRleCAtIDEwLCB0aGlzLmluZGV4ICsgMjApICsgJ1wiJ1xuICAgICAgICApO1xuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdmR0L3NyYy9saWIvcGFyc2VyLmpzIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IHN0cmluZ2lmeSBhc3Qgb2YganN4IHRvIGpzXG4gKiBAYXV0aG9yIGphdmV5XG4gKiBAZGF0ZSAxNS00LTIyXG4gKi9cblxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IHtUeXBlLCBUeXBlTmFtZX0gPSBVdGlscztcblxuY29uc3QgYXR0ck1hcCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAgICAgJ2Zvcic6ICdodG1sRm9yJ1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcFtuYW1lXSB8fCBuYW1lO1xuICAgIH07XG59KSgpO1xuICAgIFxuY29uc3Qgbm9ybWFsaXplQXJncyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgbCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpID0gbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gIT09ICdudWxsJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChpID09PSBsID8gYXJncyA6IGFyZ3Muc2xpY2UoMCwgaSArIDEpKS5qb2luKCcsICcpOyBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0cmluZ2lmaWVyKCkge31cblxuU3RyaW5naWZpZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBTdHJpbmdpZmllcixcblxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24oYXN0LCBhdXRvUmV0dXJuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBhdXRvUmV0dXJuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9SZXR1cm4gPSAhIWF1dG9SZXR1cm47XG4gICAgICAgIHRoaXMuZW50ZXJTdHJpbmdFeHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVhZCA9ICcnOyAvLyBzYXZlIGltcG9ydCBzeW50YXhcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcihhc3QsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hFeHByZXNzaW9uQ29udGFpbmVyOiBmdW5jdGlvbihhc3QsIGlzUm9vdCkge1xuICAgICAgICB2YXIgc3RyID0gJycsXG4gICAgICAgICAgICBsZW5ndGggPSBhc3QubGVuZ3RoLFxuICAgICAgICAgICAgaGFzRGVzdHJ1Y3R1cmluZyA9IGZhbHNlO1xuICAgICAgICBVdGlscy5lYWNoKGFzdCwgZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICAgICAgLy8gaWYgaXMgcm9vdCwgYWRkIGByZXR1cm5gIGtleXdvcmRcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZXR1cm4gJiYgaXNSb290ICYmIGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ3JldHVybiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuX3Zpc2l0KGVsZW1lbnQsIGlzUm9vdCk7XG4gICAgICAgICAgICBpZiAoaXNSb290ICYmIGVsZW1lbnQudHlwZSA9PT0gVHlwZS5KU0ltcG9ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCArPSB0bXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghaXNSb290ICYmICF0aGlzLmVudGVyU3RyaW5nRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgLy8gc3BlY2lhbCBmb3IgLi4uIHN5bnRheHRcbiAgICAgICAgICAgIHN0ciA9IFV0aWxzLnRyaW1MZWZ0KHN0cik7IFxuICAgICAgICAgICAgaWYgKHN0clswXSA9PT0gJy4nICYmIHN0clsxXSA9PT0gJy4nICYmIHN0clsyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgaGFzRGVzdHJ1Y3R1cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigzKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgW11bMF0gZm9yIHJldHVybiAvKiBjb21tZW50ICovXG4gICAgICAgICAgICBzdHIgPSAnZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gWycgKyBzdHIgKyAnXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSc7XG4gICAgICAgICAgICAvLyBzdHIgPSAnZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKCcgKyBzdHIgKyAnKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSc7XG4gICAgICAgICAgICBpZiAoaGFzRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nICsgc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgX3Zpc2l0OiBmdW5jdGlvbihlbGVtZW50LCBpc1Jvb3QpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgfHwge307XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFR5cGUuSlM6XG4gICAgICAgICAgICBjYXNlIFR5cGUuSlNJbXBvcnQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlMoZWxlbWVudCk7XG4gICAgICAgICAgICBjYXNlIFR5cGUuSlNYRWxlbWVudDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRKU1hFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgY2FzZSBUeXBlLkpTWFRleHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlNYVGV4dChlbGVtZW50KTtcbiAgICAgICAgICAgIGNhc2UgVHlwZS5KU1hVbmVzY2FwZVRleHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlNYVW5lc2NhcGVUZXh0KGVsZW1lbnQpO1xuICAgICAgICAgICAgY2FzZSBUeXBlLkpTWEV4cHJlc3Npb25Db250YWluZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcihlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZS5KU1hXaWRnZXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlNYV2lkZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgY2FzZSBUeXBlLkpTWEJsb2NrOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdEpTWEJsb2NrKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgY2FzZSBUeXBlLkpTWFZkdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRKU1hWZHQoZWxlbWVudCwgaXNSb290KTtcbiAgICAgICAgICAgIGNhc2UgVHlwZS5KU1hDb21tZW50OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdEpTWENvbW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Zpc2l0SlM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50ZXJTdHJpbmdFeHByZXNzaW9uID8gXG4gICAgICAgICAgICAnKCcgKyBlbGVtZW50LnZhbHVlICsgJyknIDogXG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlOyBcbiAgICB9LFxuXG4gICAgX3Zpc2l0SlNYRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC52YWx1ZSA9PT0gJ3NjcmlwdCcgfHwgZWxlbWVudC52YWx1ZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUeXBlLkpTWEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IFR5cGVOYW1lW1R5cGUuSlNYQXR0cmlidXRlXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2lubmVySFRNTCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUeXBlLkpTLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IFR5cGVOYW1lW1R5cGUuSlNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3Zpc2l0SlNYQ2hpbGRyZW5Bc1N0cmluZyhlbGVtZW50LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLl92aXNpdEpTWEF0dHJpYnV0ZShlbGVtZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdmFyIHJldCA9IFwiaChcIiArIG5vcm1hbGl6ZUFyZ3MoW1xuICAgICAgICAgICAgXCInXCIgKyBlbGVtZW50LnZhbHVlICsgXCInXCIsIFxuICAgICAgICAgICAgYXR0cmlidXRlcy5wcm9wcywgXG4gICAgICAgICAgICB0aGlzLl92aXNpdEpTWENoaWxkcmVuKGVsZW1lbnQuY2hpbGRyZW4pLFxuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzc05hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmtleSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucmVmXG4gICAgICAgIF0pICsgJyknO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdEpTWERpcmVjdGl2ZShlbGVtZW50LCByZXQpO1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBVdGlscy5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcy5lbGVtZW50IGhhcyBiZSBoYW5kbGVkIHJldHVybiBkaXJlY3RseVxuICAgICAgICAgICAgaWYgKGNoaWxkLl9za2lwKSByZXR1cm47XG4gICAgICAgICAgICByZXQucHVzaCh0aGlzLl92aXNpdChjaGlsZCkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gcmV0Lmxlbmd0aCA+IDEgPyAnWycgKyByZXQuam9pbignLCAnKSArICddJyA6IChyZXRbMF0gfHwgJ251bGwnKTtcbiAgICB9LFxuXG4gICAgX3Zpc2l0SlNYRGlyZWN0aXZlOiBmdW5jdGlvbihlbGVtZW50LCByZXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUZvciA9IHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcbiAgICAgICAgICAgIGtleTogJ2tleSdcbiAgICAgICAgfTtcbiAgICAgICAgVXRpbHMuZWFjaChlbGVtZW50LmRpcmVjdGl2ZXMsIGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChkaXJlY3RpdmUubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YtaWYnOlxuICAgICAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl92aXNpdEpTWERpcmVjdGl2ZUlmKGRpcmVjdGl2ZSwgcmV0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndi1lbHNlLWlmJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2LWVsc2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5fc2tpcCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaXJlY3RpdmUubmFtZSArICcgbXVzdCBiZSBsZWQgd2l0aCB2LWlmLiBBdDoge2xpbmU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5saW5lICsgJywgY29sdW1uOiAnICsgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNvbHVtbiArICd9J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YtZm9yJzpcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlRm9yLmRhdGEgPSB0aGlzLl92aXNpdEpTWEF0dHJpYnV0ZVZhbHVlKGRpcmVjdGl2ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YtZm9yLXZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlRm9yLnZhbHVlID0gdGhpcy5fdmlzaXRKU1hUZXh0KGRpcmVjdGl2ZS52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YtZm9yLWtleSc6XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUZvci5rZXkgPSB0aGlzLl92aXNpdEpTWFRleHQoZGlyZWN0aXZlLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAvLyBpZiBleGlzdHMgdi1mb3JcbiAgICAgICAgaWYgKGRpcmVjdGl2ZUZvci5kYXRhKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl92aXNpdEpTWERpcmVjdGl2ZUZvcihkaXJlY3RpdmVGb3IsIHJldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hEaXJlY3RpdmVJZjogZnVuY3Rpb24oZGlyZWN0aXZlLCByZXQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Zpc2l0SlNYQXR0cmlidXRlVmFsdWUoZGlyZWN0aXZlLnZhbHVlKSArICcgPyAnICsgcmV0ICsgJyA6ICcsXG4gICAgICAgICAgICBoYXNFbHNlID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0ID0gZWxlbWVudCxcbiAgICAgICAgICAgIGVtcHR5VGV4dE5vZGVzID0gW10sIC8vIHBlcnNpc3QgZW1wdHkgdGV4dCBub2RlLCBza2lwIHRoZW0gaWYgZmluZCB2LWVsc2UtaWYgb3Igdi1lbHNlXG4gICAgICAgICAgICBza2lwTm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBVdGlscy5lYWNoKGVtcHR5VGV4dE5vZGVzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX3NraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVtcHR5VGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9O1xuICAgICAgICB3aGlsZSAobmV4dCA9IG5leHQubmV4dCkge1xuICAgICAgICAgICAgaWYgKG5leHQudHlwZSA9PT0gVXRpbHMuVHlwZS5KU1hUZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEvXlxccyokLy50ZXN0KG5leHQudmFsdWUpKSBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGxhc3QgdGV4dCBub2RlLCBtYXJrIGFzIGhhbmRsZWRcbiAgICAgICAgICAgICAgICBlbHNlIGVtcHR5VGV4dE5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gVXRpbHMuVHlwZS5KU1hFbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSBVdGlscy5UeXBlLkpTWFdpZGdldCB8fFxuICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gVXRpbHMuVHlwZS5KU1hWZHQgfHxcbiAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IFV0aWxzLlR5cGUuSlNYQmxvY2tcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmICghbmV4dC5kaXJlY3RpdmVzIHx8ICFuZXh0LmRpcmVjdGl2ZXMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICB2YXIgaXNDb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmV4dC5kaXJlY3RpdmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZSA9IG5leHQuZGlyZWN0aXZlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBkaXJlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAndi1lbHNlLWlmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFyayB0aGlzIGVsZW1lbnQgYXMgaGFuZGxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5fc2tpcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fdmlzaXRKU1hBdHRyaWJ1dGVWYWx1ZShkaXJlLnZhbHVlKSArICcgPyAnICsgdGhpcy5fdmlzaXQobmV4dCkgKyAnIDogJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29udGludWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFyayB0ZXh0IG5vZGUgYmVmb3JlIGFzIGhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBOb2RlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3YtZWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhpcyBlbGVtZW50IGFzIGhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX3Zpc2l0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRWxzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIHRleHQgbm9kZSBiZWZvcmUgYXMgaGFuZGxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udGludWUpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzRWxzZSkgcmVzdWx0ICs9ICd1bmRlZmluZWQnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hEaXJlY3RpdmVGb3I6IGZ1bmN0aW9uKGRpcmVjdGl2ZSwgcmV0KSB7XG4gICAgICAgIHJldHVybiAnX1ZkdC51dGlscy5tYXAoJyArIGRpcmVjdGl2ZS5kYXRhICsgJywgZnVuY3Rpb24oJyArIGRpcmVjdGl2ZS52YWx1ZSArICcsICcgKyBkaXJlY3RpdmUua2V5ICsgJykge1xcbicgK1xuICAgICAgICAgICAgJ3JldHVybiAnICsgcmV0ICsgJztcXG4nICtcbiAgICAgICAgJ30sIHRoaXMpJztcbiAgICB9LFxuXG4gICAgX3Zpc2l0SlNYQ2hpbGRyZW5Bc1N0cmluZzogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB0aGlzLmVudGVyU3RyaW5nRXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICAgIFV0aWxzLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXQucHVzaCh0aGlzLl92aXNpdChjaGlsZCkpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5lbnRlclN0cmluZ0V4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJldC5qb2luKCcrJyk7XG4gICAgfSxcblxuICAgIF92aXNpdEpTWEF0dHJpYnV0ZTogZnVuY3Rpb24oZWxlbWVudCwgaW5kaXZpZHVhbENsYXNzTmFtZSwgaW5kaXZpZHVhbEtleUFuZFJlZikge1xuICAgICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JyxcbiAgICAgICAgICAgIGhhc01vZGVsID0gZmFsc2UsXG4gICAgICAgICAgICBhZGRpdGlvbiA9IHt0cnVlVmFsdWU6IHRydWUsIGZhbHNlVmFsdWU6IGZhbHNlfTtcbiAgICAgICAgVXRpbHMuZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci50eXBlID09PSBUeXBlLkpTWEV4cHJlc3Npb25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnB1c2godGhpcy5fdmlzaXRKU1hBdHRyaWJ1dGVWYWx1ZShhdHRyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGF0dHJNYXAoYXR0ci5uYW1lKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3Zpc2l0SlNYQXR0cmlidXRlVmFsdWUoYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoKG5hbWUgPT09ICd3aWRnZXQnIHx8IG5hbWUgPT09ICdyZWYnKSAmJiBhdHRyLnZhbHVlLnR5cGUgPT09IFR5cGUuSlNYVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBjb21wYXRpbGl0eSB2MS4wXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB3aWRnZXQ9XCJhXCIgdG8gcmVmPShpKSA9PiB3aWRnZXRzLmEgPSBpXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCByZWY9XCJhXCIgdG8gcmVmPShpKSA9PiB3aWRnZXRzLmEgPSBpLiBGb3IgSW50YWN0XG4gICAgICAgICAgICAgICAgcmVmID0gJ2Z1bmN0aW9uKGkpIHt3aWRnZXRzWycgKyB2YWx1ZSArICddID0gaX0nO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGNsYXNzTmFtZSBpbmRpdmlkdWFsbHlcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci52YWx1ZS50eXBlID09PSBUeXBlLkpTWEV4cHJlc3Npb25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNsYXNzPXsge2FjdGl2ZTogdHJ1ZX0gfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdfY2xhc3NOYW1lKCcgKyB2YWx1ZSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGl2aWR1YWxDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdrZXknICYmIGluZGl2aWR1YWxLZXlBbmRSZWYpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdyZWYnICYmIGluZGl2aWR1YWxLZXlBbmRSZWYpIHtcbiAgICAgICAgICAgICAgICByZWYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LW1vZGVsJykge1xuICAgICAgICAgICAgICAgIGhhc01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gcGFzcyB2LW1vZGVsIHRvIGVsZW1lbnQsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAgICAgICAgICAgICAgICAvLyByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LW1vZGVsLXRydWUnKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb24udHJ1ZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1tb2RlbC1mYWxzZScpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbi5mYWxzZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndHlwZScpIHtcbiAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSB0eXBlIHZhbHVlIGZvciB2LW1vZGVsIG9mIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICB0eXBlID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2goXCInXCIgKyBuYW1lICsgXCInOiBcIiArIHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKGhhc01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdEpTWEF0dHJpYnV0ZU1vZGVsKGVsZW1lbnQsIGhhc01vZGVsLCByZXQsIHR5cGUsIGFkZGl0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wczogcmV0Lmxlbmd0aCA/ICd7JyArIHJldC5qb2luKCcsICcpICsgJ30nIDogJ251bGwnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgfHwgJ251bGwnLFxuICAgICAgICAgICAgcmVmOiByZWYgfHwgJ251bGwnLFxuICAgICAgICAgICAga2V5OiBrZXkgfHwgJ251bGwnXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF92aXNpdEpTWEF0dHJpYnV0ZU1vZGVsOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSwgcmV0LCB0eXBlLCBhZGRpdGlvbikge1xuICAgICAgICB2YXIgdmFsdWVOYW1lID0gJ3ZhbHVlJyxcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9ICdjaGFuZ2UnOyBcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gVHlwZS5KU1hFbGVtZW50KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTmFtZSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIidmaWxlJ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9ICdjaGFuZ2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIidyYWRpbydcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCInY2hlY2tib3gnXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRydWVWYWx1ZSA9IGFkZGl0aW9uLnRydWVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VWYWx1ZSA9IGFkZGl0aW9uLmZhbHNlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBhZGRpdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNOdWxsT3JVbmRlZmluZWQoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYGNoZWNrZWQ6IF9nZXRNb2RlbChzZWxmLCAke3ZhbHVlfSkgPT09ICR7dHJ1ZVZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChgJ2V2LWNoYW5nZSc6IGZ1bmN0aW9uKF9fZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NldE1vZGVsKHNlbGYsICR7dmFsdWV9LCBfX2UudGFyZ2V0LmNoZWNrZWQgPyAke3RydWVWYWx1ZX0gOiAke2ZhbHNlVmFsdWV9LCAkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIncmFkaW8nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGBjaGVja2VkOiBfZ2V0TW9kZWwoc2VsZiwgJHt2YWx1ZX0pID09PSAke2lucHV0VmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChgJ2V2LWNoYW5nZSc6IGZ1bmN0aW9uKF9fZSkgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2V0TW9kZWwoc2VsZiwgJHt2YWx1ZX0sIF9fZS50YXJnZXQuY2hlY2tlZCA/ICR7aW5wdXRWYWx1ZX0gOiAke2ZhbHNlVmFsdWV9LCAkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChgY2hlY2tlZDogX2RldGVjdENoZWNrYm94Q2hlY2tlZChzZWxmLCAke3ZhbHVlfSwgJHtpbnB1dFZhbHVlfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGAnZXYtY2hhbmdlJzogZnVuY3Rpb24oX19lKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRDaGVja2JveE1vZGVsKHNlbGYsICR7dmFsdWV9LCAke2lucHV0VmFsdWV9LCAke2ZhbHNlVmFsdWV9LCBfX2UsICR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9ICdpbnB1dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYHZhbHVlOiBfZ2V0TW9kZWwoc2VsZiwgJHt2YWx1ZX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGAnZXYtY2hhbmdlJzogZnVuY3Rpb24oX19lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2V0U2VsZWN0TW9kZWwoc2VsZiwgJHt2YWx1ZX0sIF9fZSwgJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9ICdpbnB1dCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2goYCR7dmFsdWVOYW1lfTogX2dldE1vZGVsKHNlbGYsICR7dmFsdWV9KWApO1xuICAgICAgICAgICAgcmV0LnB1c2goYCdldi0ke2V2ZW50TmFtZX0nOiBmdW5jdGlvbihfX2UpIHsgX3NldE1vZGVsKHNlbGYsICR7dmFsdWV9LCBfX2UudGFyZ2V0LnZhbHVlLCAkdGhpcykgfWApO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gVHlwZS5KU1hXaWRnZXQpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGB2YWx1ZTogX2dldE1vZGVsKHNlbGYsICR7dmFsdWV9KWApO1xuICAgICAgICAgICAgcmV0LnB1c2goYCdldi0kY2hhbmdlOnZhbHVlJzogZnVuY3Rpb24oX19jLCBfX24pIHsgX3NldE1vZGVsKHNlbGYsICR7dmFsdWV9LCBfX24sICR0aGlzKSB9YCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Zpc2l0SlNYQXR0cmlidXRlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5pc0FycmF5KHZhbHVlKSA/IHRoaXMuX3Zpc2l0SlNYQ2hpbGRyZW4odmFsdWUpIDogdGhpcy5fdmlzaXQodmFsdWUpO1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hUZXh0OiBmdW5jdGlvbihlbGVtZW50LCBub1F1b3Rlcykge1xuICAgICAgICB2YXIgcmV0ID0gZWxlbWVudC52YWx1ZS5yZXBsYWNlKC8oW1xcJ1xcXCJcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1tcXHJcXG5dL2csICdcXFxcbicpO1xuICAgICAgICBpZiAoIW5vUXVvdGVzKSB7XG4gICAgICAgICAgICByZXQgPSBcIidcIiArIHJldCArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIF92aXNpdEpTWFVuZXNjYXBlVGV4dDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gJ2h1KCcrIHRoaXMuX3Zpc2l0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcihlbGVtZW50LnZhbHVlKSArJyknO1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hXaWRnZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qge2Jsb2NrcywgY2hpbGRyZW4sIGhhc0Jsb2NrfSA9IHRoaXMuX3Zpc2l0SlNYQmxvY2tzKGVsZW1lbnQsIGZhbHNlKTtcblxuICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXMucHVzaCh7bmFtZTogJ2NoaWxkcmVuJywgdmFsdWU6IGNoaWxkcmVufSk7XG4gICAgICAgIGVsZW1lbnQuYXR0cmlidXRlcy5wdXNoKHtuYW1lOiAnX2NvbnRleHQnLCB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogVHlwZS5KUyxcbiAgICAgICAgICAgIHZhbHVlOiAnJHRoaXMnXG4gICAgICAgIH19KTtcbiAgICAgICAgaWYgKGhhc0Jsb2NrKSB7XG4gICAgICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXMucHVzaCh7bmFtZTogJ19ibG9ja3MnLCB2YWx1ZTogYmxvY2tzfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuX3Zpc2l0SlNYQXR0cmlidXRlKGVsZW1lbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdEpTWERpcmVjdGl2ZShcbiAgICAgICAgICAgIGVsZW1lbnQsIFxuICAgICAgICAgICAgJ2goJyArIG5vcm1hbGl6ZUFyZ3MoW1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUsIFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHJvcHMsIFxuICAgICAgICAgICAgICAgICdudWxsJywgJ251bGwnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMua2V5LCBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJlZlxuICAgICAgICAgICAgXSkgKyAnKSdcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgX3Zpc2l0SlNYQmxvY2s6IGZ1bmN0aW9uKGVsZW1lbnQsIGlzQW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0SlNYRGlyZWN0aXZlKFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgJyhfYmxvY2tzW1wiJyArIGVsZW1lbnQudmFsdWUgKyAnXCJdID0gZnVuY3Rpb24ocGFyZW50KSB7cmV0dXJuICcgKyB0aGlzLl92aXNpdEpTWENoaWxkcmVuKGVsZW1lbnQuY2hpbGRyZW4pICsgJzt9KSAmJiAoX19ibG9ja3NbXCInICsgZWxlbWVudC52YWx1ZSArICdcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtcXG4nICtcbiAgICAgICAgICAgICAgICAndmFyIHNlbGYgPSB0aGlzO1xcbicgK1xuICAgICAgICAgICAgICAgICdyZXR1cm4gYmxvY2tzW1wiJyArIGVsZW1lbnQudmFsdWUgKyAnXCJdID8gYmxvY2tzW1wiJyArIGVsZW1lbnQudmFsdWUgKyAnXCJdLmNhbGwodGhpcywgZnVuY3Rpb24oKSB7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4gX2Jsb2Nrc1tcIicgKyBlbGVtZW50LnZhbHVlICsgJ1wiXS5jYWxsKHNlbGYsIHBhcmVudCk7XFxuJyArXG4gICAgICAgICAgICAgICAgJ30pIDogX2Jsb2Nrc1tcIicgKyBlbGVtZW50LnZhbHVlICsgJ1wiXS5jYWxsKHRoaXMsIHBhcmVudCk7XFxuJyArXG4gICAgICAgICAgICAnfSknICsgKGlzQW5jZXN0b3IgPyAnICYmIF9fYmxvY2tzW1wiJyArIGVsZW1lbnQudmFsdWUgKyAnXCJdLmNhbGwodGhpcyknIDogJycpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF92aXNpdEpTWEJsb2NrczogZnVuY3Rpb24oZWxlbWVudCwgaXNSb290KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBVdGlscy5lYWNoKGVsZW1lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gVHlwZS5KU1hCbG9jaykge1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHRoaXMuX3Zpc2l0SlNYQmxvY2soY2hpbGQsIGZhbHNlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBjb25zdCBfYmxvY2tzID0ge1xuICAgICAgICAgICAgdHlwZTogVHlwZS5KUyxcbiAgICAgICAgICAgIHZhbHVlOiBibG9ja3MubGVuZ3RoID8gW1xuICAgICAgICAgICAgICAgICdmdW5jdGlvbihibG9ja3MpIHsnLFxuICAgICAgICAgICAgICAgICcgICAgdmFyIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSBleHRlbmQoe30sIGJsb2Nrcyk7JyxcbiAgICAgICAgICAgICAgICBgICAgIHJldHVybiAoJHtibG9ja3Muam9pbignICYmICcpfSwgX19ibG9ja3MpO2AsXG4gICAgICAgICAgICAgICAgYH0uY2FsbCh0aGlzLCAke2lzUm9vdCA/ICdibG9ja3MnIDogJ3t9J30pYFxuICAgICAgICAgICAgXS5qb2luKCdcXG4nKSA6IGlzUm9vdCA/ICdibG9ja3MnIDogJ251bGwnXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHJldHVybiB7YmxvY2tzOiBfYmxvY2tzLCBjaGlsZHJlbjogY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4gOiBudWxsLCBoYXNCbG9jazogYmxvY2tzLmxlbmd0aH07XG4gICAgfSxcblxuICAgIF92aXNpdEpTWFZkdDogZnVuY3Rpb24oZWxlbWVudCwgaXNSb290KSB7XG4gICAgICAgIGNvbnN0IHtibG9ja3MsIGNoaWxkcmVufSA9IHRoaXMuX3Zpc2l0SlNYQmxvY2tzKGVsZW1lbnQsIGlzUm9vdCk7XG4gICAgICAgIGVsZW1lbnQuYXR0cmlidXRlcy5wdXNoKHtuYW1lOiAnY2hpbGRyZW4nLCB2YWx1ZTogY2hpbGRyZW59KTtcbiAgICAgICAgY29uc3QgcmV0ID0gW1xuICAgICAgICAgICAgJyhmdW5jdGlvbigpIHsnLFxuICAgICAgICAgICAgJyAgICB2YXIgX29iaiA9ICcgKyB0aGlzLl92aXNpdEpTWEF0dHJpYnV0ZShlbGVtZW50LCBmYWxzZSwgZmFsc2UpLnByb3BzICsgJzsnLFxuICAgICAgICAgICAgJyAgICBpZiAoX29iai5oYXNPd25Qcm9wZXJ0eShcImFyZ3VtZW50c1wiKSkgeycsXG4gICAgICAgICAgICAnICAgICAgICBleHRlbmQoX29iaiwgX29iai5hcmd1bWVudHMgPT09IHRydWUgPyBvYmogOiBfb2JqLmFyZ3VtZW50cyk7JyxcbiAgICAgICAgICAgICcgICAgICAgIGRlbGV0ZSBfb2JqLmFyZ3VtZW50czsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgICAgcmV0dXJuICcgKyBlbGVtZW50LnZhbHVlICsgJy5jYWxsKHRoaXMsIF9vYmosIF9WZHQsICcgKyB0aGlzLl92aXNpdEpTKGJsb2NrcykgKyAnLCAnICsgZWxlbWVudC52YWx1ZSArICcpJyxcbiAgICAgICAgICAgICd9KS5jYWxsKHRoaXMpJ1xuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdEpTWERpcmVjdGl2ZShlbGVtZW50LCByZXQpO1xuICAgIH0sXG5cbiAgICBfdmlzaXRKU1hDb21tZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAnaGMoJyArIHRoaXMuX3Zpc2l0SlNYVGV4dChlbGVtZW50KSArICcpJztcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3ZkdC9zcmMvbGliL3N0cmluZ2lmaWVyLmpzIiwiaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZCwgaXNBcnJheSwgaW5kZXhPZn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtUeXBlc30gZnJvbSAnLi4vdm5vZGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1NlbGVjdCh2Tm9kZSwgZG9tLCBuZXh0UHJvcHMsIGlzUmVuZGVyKSB7XG4gICAgY29uc3QgbXVsdGlwbGUgPSBuZXh0UHJvcHMubXVsdGlwbGU7XG4gICAgaWYgKG11bHRpcGxlICE9PSBkb20ubXVsdGlwbGUpIHtcbiAgICAgICAgZG9tLm11bHRpcGxlID0gbXVsdGlwbGU7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdk5vZGUuY2hpbGRyZW47XG5cbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGNoaWxkcmVuKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgICAgIGlmIChpc1JlbmRlciAmJiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV4dFByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGZsYWcgPSB7aGFzU2VsZWN0ZWQ6IGZhbHNlfTtcbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRPcHRpb25Hcm91cChjaGlsZHJlbltpXSwgdmFsdWUsIGZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGRPcHRpb25Hcm91cChjaGlsZHJlbiwgdmFsdWUsIGZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmxhZy5oYXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZG9tLnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkT3B0aW9uR3JvdXAodk5vZGUsIHZhbHVlLCBmbGFnKSB7XG4gICAgY29uc3QgdGFnID0gdk5vZGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkT3B0aW9uKGNoaWxkcmVuW2ldLCB2YWx1ZSwgZmxhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVDaGlsZE9wdGlvbihjaGlsZHJlbiwgdmFsdWUsIGZsYWcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlQ2hpbGRPcHRpb24odk5vZGUsIHZhbHVlLCBmbGFnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkT3B0aW9uKHZOb2RlLCB2YWx1ZSwgZmxhZykge1xuICAgIC8vIHNraXAgdGV4dCBhbmQgY29tbWVudCBub2RlXG4gICAgaWYgKHZOb2RlLnR5cGUgJiBUeXBlcy5IdG1sRWxlbWVudCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHZOb2RlLnByb3BzO1xuICAgICAgICBjb25zdCBkb20gPSB2Tm9kZS5kb207XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpICYmIGluZGV4T2YodmFsdWUsIHByb3BzLnZhbHVlKSAhPT0gLTEgfHwgcHJvcHMudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBkb20uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFmbGFnLmhhc1NlbGVjdGVkKSBmbGFnLmhhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc051bGxPclVuZGVmaW5lZChwcm9wcy5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9ICEhcHJvcHMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoIWZsYWcuaGFzU2VsZWN0ZWQgJiYgc2VsZWN0ZWQpIGZsYWcuaGFzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZG9tLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL3dyYXBwZXJzL3NlbGVjdC5qcyIsImltcG9ydCB7aXNOdWxsT3JVbmRlZmluZWR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NJbnB1dCh2Tm9kZSwgZG9tLCBuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB0eXBlID0gbmV4dFByb3BzLnR5cGU7XG4gICAgY29uc3QgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgY29uc3QgY2hlY2tlZCA9IG5leHRQcm9wcy5jaGVja2VkO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5leHRQcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgY29uc3QgbXVsdGlwbGUgPSBuZXh0UHJvcHMubXVsdGlwbGU7XG4gICAgY29uc3QgaGFzVmFsdWUgPSAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpO1xuXG4gICAgaWYgKG11bHRpcGxlICYmIG11bHRpcGxlICE9PSBkb20ubXVsdGlwbGUpIHtcbiAgICAgICAgZG9tLm11bHRpcGxlID0gbXVsdGlwbGU7XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSAmJiAhaGFzVmFsdWUpIHtcbiAgICAgICAgZG9tLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZSArICcnO1xuICAgIH1cbiAgICBpZiAoaXNDaGVja2VkVHlwZSh0eXBlKSkge1xuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIGRvbS5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNWYWx1ZSAmJiBkb20udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBkb20udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hlY2tlZCkpIHtcbiAgICAgICAgICAgIGRvbS5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNDaGVja2VkVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvd3JhcHBlcnMvaW5wdXQuanMiLCJpbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVGV4dGFyZWEodk5vZGUsIGRvbSwgbmV4dFByb3BzLCBpc1JlbmRlcikge1xuICAgIGNvbnN0IHZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgIGNvbnN0IGRvbVZhbHVlID0gZG9tLnZhbHVlO1xuXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5leHRQcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSBkb21WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBkb20udmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkb21WYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBkb20udmFsdWUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkb21WYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21pc3N0aW1lL3NyYy93cmFwcGVycy90ZXh0YXJlYS5qcyIsImltcG9ydCB7VHlwZXMsIEVNUFRZX09CSn0gZnJvbSAnLi92bm9kZSc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZpbmVkLCBpc0FycmF5LCBzZWxmQ2xvc2luZ1RhZ3MsXG4gICAgaXNTdHJpbmdPck51bWJlclxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7a2ViYWJDYXNlfSBmcm9tICcuL3ZwYXRjaCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyh2Tm9kZSwgcGFyZW50LCBkaXNhYmxlU3BsaXRUZXh0LCBmaXJzdENoaWxkKSB7XG4gICAgY29uc3QgdHlwZSA9IHZOb2RlLnR5cGU7XG4gICAgY29uc3QgdGFnID0gdk5vZGUudGFnO1xuICAgIGNvbnN0IHByb3BzID0gdk5vZGUucHJvcHM7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcblxuICAgIGxldCBodG1sO1xuICAgIGlmICh0eXBlICYgVHlwZXMuQ29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgdGFnKHByb3BzKTsgXG4gICAgICAgIGh0bWwgPSBpbnN0YW5jZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLkNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgIGh0bWwgPSB2Tm9kZS5jaGlsZHJlbi50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLkVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGlubmVySFRNTDtcbiAgICAgICAgaHRtbCA9IGA8JHt0YWd9YDtcblxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHZOb2RlLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gYCBjbGFzcz1cIiR7ZXNjYXBlVGV4dCh2Tm9kZS5jbGFzc05hbWUpfVwiYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gYCBzdHlsZT1cIiR7cmVuZGVyU3R5bGVzVG9TdHJpbmcodmFsdWUpfVwiYDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICBwcm9wID09PSAnY2hpbGRyZW4nIHx8IHByb3AgPT09ICdjbGFzc05hbWUnIHx8IFxuICAgICAgICAgICAgICAgICAgICBwcm9wID09PSAna2V5JyB8fCBwcm9wID09PSAncmVmJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdkZWZhdWx0VmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChwcm9wcy52YWx1ZSkgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBgIHZhbHVlPVwiJHtpc1N0cmluZyh2YWx1ZSkgPyBlc2NhcGVUZXh0KHZhbHVlKSA6IHZhbHVlfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2RlZmF1bHRDaGVja2VkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQocHJvcHMuY2hlY2tlZCkgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJyBjaGVja2VkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gcmVuZGVyQXR0cmlidXRlc1RvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHJlbmRlckRhdGFzZXRUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdvcHRpb24nICYmIHByb3AgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSByZW5kZXJBdHRyaWJ1dGVUb1N0cmluZyhwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgdmFsdWUgPT09IHBhcmVudC5wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBgIHNlbGVjdGVkYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gcmVuZGVyQXR0cmlidXRlVG9TdHJpbmcocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmQ2xvc2luZ1RhZ3NbdGFnXSkge1xuICAgICAgICAgICAgaHRtbCArPSBgIC8+YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJz4nO1xuICAgICAgICAgICAgaWYgKGlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gaW5uZXJIVE1MO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sICs9IGNoaWxkcmVuID09PSAnJyA/ICcgJyA6IGVzY2FwZVRleHQoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGNoaWxkID09PSAnJyA/ICcgJyA6IGVzY2FwZVRleHQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hpbGQudHlwZSAmIFR5cGVzLlRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0b1N0cmluZyhjaGlsZCwgdk5vZGUsIGRpc2FibGVTcGxpdFRleHQsIGluZGV4ID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gdG9TdHJpbmcoY2hpbGRyZW4sIHZOb2RlLCBkaXNhYmxlU3BsaXRUZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgKz0gYDwvJHt0YWd9PmA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5UZXh0KSB7XG4gICAgICAgIGh0bWwgPSAoZmlyc3RDaGlsZCB8fCBkaXNhYmxlU3BsaXRUZXh0ID8gJycgOiAnPCEtLS0tPicpICsgXG4gICAgICAgICAgICAoY2hpbGRyZW4gPT09ICcnID8gJyAnIDogZXNjYXBlVGV4dChjaGlsZHJlbikpO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLkh0bWxDb21tZW50KSB7XG4gICAgICAgIGh0bWwgPSBgPCEtLSR7Y2hpbGRyZW59LS0+YDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5VbmVzY2FwZVRleHQpIHtcbiAgICAgICAgaHRtbCA9IGlzTnVsbE9yVW5kZWZpbmVkKGNoaWxkcmVuKSA/ICcnIDogY2hpbGRyZW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHZOb2RlOiAke3ZOb2RlfWApO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlVGV4dCh0ZXh0KSB7XG4gICAgbGV0IHJlc3VsdCA9IHRleHQ7XG4gICAgbGV0IGVzY2FwZVN0cmluZyA9IFwiXCI7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKHRleHQuY2hhckNvZGVBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcbiAgICAgICAgICAgICAgICBlc2NhcGVTdHJpbmcgPSBcIiZxdW90O1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTogLy8gXFxcbiAgICAgICAgICAgICAgICBlc2NhcGVTdHJpbmcgPSBcIiYjMDM5O1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxuICAgICAgICAgICAgICAgIGVzY2FwZVN0cmluZyA9IFwiJmFtcDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6IC8vIDxcbiAgICAgICAgICAgICAgICBlc2NhcGVTdHJpbmcgPSBcIiZsdDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgICAgICAgICBlc2NhcGVTdHJpbmcgPSBcIiZndDtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gZXNjYXBlU3RyaW5nO1xuICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgaSAhPT0gc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHRleHQuc2xpY2Uoc3RhcnQsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcobykge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclN0eWxlc1RvU3RyaW5nKHN0eWxlcykge1xuICAgIGlmIChpc1N0cmluZ09yTnVtYmVyKHN0eWxlcykpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVuZGVyZWRTdHJpbmcgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmdPck51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN0cmluZyArPSBgJHtrZWJhYkNhc2Uoc3R5bGVOYW1lKX06JHt2YWx1ZX07YDtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkU3RyaW5nO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckRhdGFzZXRUb1N0cmluZyhkYXRhc2V0KSB7XG4gICAgbGV0IHJlbmRlcmVkU3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQga2V5IGluIGRhdGFzZXQpIHtcbiAgICAgICAgY29uc3QgZGF0YUtleSA9IGBkYXRhLSR7a2ViYWJDYXNlKGtleSl9YDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhc2V0W2tleV07XG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkU3RyaW5nICs9IGAgJHtkYXRhS2V5fT1cIiR7ZXNjYXBlVGV4dCh2YWx1ZSl9XCJgO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVuZGVyZWRTdHJpbmcgKz0gYCAke2RhdGFLZXl9PVwiJHt2YWx1ZX1cImA7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkU3RyaW5nICs9IGAgJHtkYXRhS2V5fT1cInRydWVcImA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVkU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQXR0cmlidXRlc1RvU3RyaW5nKGF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgcmVuZGVyZWRTdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICByZW5kZXJlZFN0cmluZyArPSByZW5kZXJBdHRyaWJ1dGVUb1N0cmluZyhrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlZFN0cmluZztcbn1cblxuZnVuY3Rpb24gcmVuZGVyQXR0cmlidXRlVG9TdHJpbmcoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGAgJHtrZXl9PVwiJHtlc2NhcGVUZXh0KHZhbHVlKX1cImA7XG4gICAgfSBlbHNlIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGAgJHtrZXl9PVwiJHt2YWx1ZX1cImA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYCAke2tleX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWlzc3RpbWUvc3JjL3Rvc3RyaW5nLmpzIiwiaW1wb3J0IHtUeXBlcywgRU1QVFlfT0JKfSBmcm9tICcuL3Zub2RlJztcbmltcG9ydCB7XG4gICAgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLFxuICAgIGNyZWF0ZVRleHRFbGVtZW50LCBjcmVhdGVDb21tZW50RWxlbWVudCxcbiAgICByZW5kZXJcbn0gZnJvbSAnLi92ZG9tJztcbmltcG9ydCB7XG4gICAgaXNOdWxsT3JVbmRlZmluZWQsIHNldFRleHRDb250ZW50LFxuICAgIGlzU3RyaW5nT3JOdW1iZXIsIGlzQXJyYXksIE1vdW50ZWRRdWV1ZVxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7cGF0Y2hQcm9wfSBmcm9tICcuL3ZwYXRjaCc7XG5pbXBvcnQge3Byb2Nlc3NGb3JtfSBmcm9tICcuL3dyYXBwZXJzL3Byb2Nlc3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZVJvb3Qodk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChwYXJlbnREb20pKSB7XG4gICAgICAgIGxldCBkb20gPSBwYXJlbnREb20uZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGRvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIodk5vZGUsIHBhcmVudERvbSwgbW91bnRlZFF1ZXVlLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0RvbSA9IGh5ZHJhdGUodk5vZGUsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnREb20sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAvLyBzaG91bGQgb25seSBvbmUgZW50cnlcbiAgICAgICAgd2hpbGUgKGRvbSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBwYXJlbnREb20ucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIGRvbSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RvbTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZOb2RlLCBkb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50RG9tLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBpZiAoZG9tICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBpc1RyaWdnZXIgPSB0cnVlO1xuICAgICAgICBpZiAobW91bnRlZFF1ZXVlKSB7XG4gICAgICAgICAgICBpc1RyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdW50ZWRRdWV1ZSA9IG5ldyBNb3VudGVkUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBkb20gPSBoeWRyYXRlRWxlbWVudCh2Tm9kZSwgZG9tLCBtb3VudGVkUXVldWUsIHBhcmVudERvbSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgaWYgKGlzVHJpZ2dlcikge1xuICAgICAgICAgICAgbW91bnRlZFF1ZXVlLnRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZUVsZW1lbnQodk5vZGUsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnREb20sIHBhcmVudFZOb2RlLCBpc1NWRykge1xuICAgIGNvbnN0IHR5cGUgPSB2Tm9kZS50eXBlO1xuICAgIFxuICAgIGlmICh0eXBlICYgVHlwZXMuRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaHlkcmF0ZUh0bWxFbGVtZW50KHZOb2RlLCBkb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50RG9tLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLlRleHQpIHtcbiAgICAgICAgcmV0dXJuIGh5ZHJhdGVUZXh0KHZOb2RlLCBkb20pO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmIFR5cGVzLkh0bWxDb21tZW50KSB7XG4gICAgICAgIHJldHVybiBoeWRyYXRlQ29tbWVudCh2Tm9kZSwgZG9tKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgJiBUeXBlcy5Db21wb25lbnRDbGFzc09ySW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGh5ZHJhdGVDb21wb25lbnRDbGFzc09ySW5zdGFuY2Uodk5vZGUsIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnREb20sIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoeWRyYXRlQ29tcG9uZW50Q2xhc3NPckluc3RhbmNlKHZOb2RlLCBkb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50RG9tLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBjb25zdCBwcm9wcyA9IHZOb2RlLnByb3BzO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdk5vZGUudHlwZSAmIFR5cGVzLkNvbXBvbmVudENsYXNzID9cbiAgICAgICAgbmV3IHZOb2RlLnRhZyhwcm9wcykgOiB2Tm9kZS5jaGlsZHJlbjtcbiAgICBpbnN0YW5jZS5wYXJlbnREb20gPSBwYXJlbnREb207XG4gICAgaW5zdGFuY2UubW91bnRlZFF1ZXVlID0gbW91bnRlZFF1ZXVlO1xuICAgIGluc3RhbmNlLmlzUmVuZGVyID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5wYXJlbnRWTm9kZSA9IHBhcmVudFZOb2RlO1xuICAgIGluc3RhbmNlLmlzU1ZHID0gaXNTVkc7XG4gICAgaW5zdGFuY2Uudk5vZGUgPSB2Tm9kZTtcbiAgICBsZXQgbmV3RG9tID0gaW5zdGFuY2UuaHlkcmF0ZSh2Tm9kZSwgZG9tKTtcblxuICAgIHZOb2RlLmRvbSA9IG5ld0RvbTtcbiAgICB2Tm9kZS5jaGlsZHJlbiA9IGluc3RhbmNlO1xuICAgIHZOb2RlLnBhcmVudFZOb2RlID0gcGFyZW50Vk5vZGU7XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1vdW50ZWRRdWV1ZS5wdXNoKCgpID0+IGluc3RhbmNlLm1vdW50KG51bGwsIHZOb2RlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gdk5vZGUucmVmO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKGRvbSAhPT0gbmV3RG9tICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdEb20sIGRvbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbTtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZUNvbW1lbnQodk5vZGUsIGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgICAgY29uc3QgbmV3RG9tID0gY3JlYXRlQ29tbWVudEVsZW1lbnQodk5vZGUsIG51bGwpO1xuICAgICAgICBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3RG9tLCBkb20pO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cbiAgICBjb25zdCBjb21tZW50ID0gdk5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGRvbS5kYXRhICE9PSBjb21tZW50KSB7XG4gICAgICAgIGRvbS5kYXRhID0gY29tbWVudDtcbiAgICB9XG4gICAgdk5vZGUuZG9tID0gZG9tO1xuICAgIHJldHVybiBkb207XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVUZXh0KHZOb2RlLCBkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlICE9PSAzKSB7XG4gICAgICAgIGNvbnN0IG5ld0RvbSA9IGNyZWF0ZVRleHRFbGVtZW50KHZOb2RlLCBudWxsKTtcbiAgICAgICAgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0RvbSwgZG9tKTtcblxuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSB2Tm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoZG9tLm5vZGVWYWx1ZSAhPT0gdGV4dCkge1xuICAgICAgICBkb20ubm9kZVZhbHVlID0gdGV4dDtcbiAgICB9XG4gICAgdk5vZGUuZG9tID0gZG9tO1xuXG4gICAgcmV0dXJuIGRvbTtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZUh0bWxFbGVtZW50KHZOb2RlLCBkb20sIG1vdW50ZWRRdWV1ZSwgcGFyZW50RG9tLCBwYXJlbnRWTm9kZSwgaXNTVkcpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IHByb3BzID0gdk5vZGUucHJvcHM7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdk5vZGUuY2xhc3NOYW1lO1xuICAgIGNvbnN0IHR5cGUgPSB2Tm9kZS50eXBlO1xuICAgIGNvbnN0IHJlZiA9IHZOb2RlLnJlZjtcblxuICAgIHZOb2RlLnBhcmVudFZOb2RlID0gcGFyZW50Vk5vZGU7XG4gICAgaXNTVkcgPSBpc1NWRyB8fCAodHlwZSAmIFR5cGVzLlN2Z0VsZW1lbnQpID4gMDtcblxuICAgIGlmIChkb20ubm9kZVR5cGUgIT09IDEgfHwgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdk5vZGUudGFnKSB7XG4gICAgICAgIHdhcm5pbmcoJ1NlcnZlci1zaWRlIG1hcmt1cCBkb2VzblxcJ3QgbWF0Y2ggY2xpZW50LXNpZGUgbWFya3VwJyk7XG4gICAgICAgIGNvbnN0IG5ld0RvbSA9IGNyZWF0ZUVsZW1lbnQodk5vZGUsIG51bGwsIG1vdW50ZWRRdWV1ZSwgcGFyZW50RG9tLCBwYXJlbnRWTm9kZSwgaXNTVkcpO1xuICAgICAgICBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3RG9tLCBkb20pO1xuXG4gICAgICAgIHJldHVybiBuZXdEb207XG4gICAgfVxuXG4gICAgdk5vZGUuZG9tID0gZG9tO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoY2hpbGRyZW4pKSB7XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihjaGlsZHJlbiwgZG9tLCBtb3VudGVkUXVldWUsIHZOb2RlLCBpc1NWRyk7XG4gICAgfSBlbHNlIGlmIChkb20uZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzZXRUZXh0Q29udGVudChkb20sICcnKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICBjb25zdCBpc0Zvcm1FbGVtZW50ID0gKHR5cGUgJiBUeXBlcy5Gb3JtRWxlbWVudCkgPiAwO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgICBwYXRjaFByb3AocHJvcCwgbnVsbCwgcHJvcHNbcHJvcF0sIGRvbSwgaXNGb3JtRWxlbWVudCwgaXNTVkcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Zvcm1FbGVtZW50KSB7XG4gICAgICAgICAgICBwcm9jZXNzRm9ybSh2Tm9kZSwgZG9tLCBwcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkb20uY2xhc3NOYW1lICE9PSAnJykge1xuICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cblxuICAgIGlmIChyZWYpIHtcbiAgICAgICAgY3JlYXRlUmVmKGRvbSwgcmVmLCBtb3VudGVkUXVldWUpO1xuICAgIH1cblxuICAgIHJldHVybiBkb207XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIHBhcmVudFZOb2RlLCBpc1NWRykge1xuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHBhcmVudERvbSk7XG4gICAgbGV0IGRvbSA9IHBhcmVudERvbS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGlzU3RyaW5nT3JOdW1iZXIoY2hpbGRyZW4pKSB7XG4gICAgICAgIGlmIChkb20gIT09IG51bGwgJiYgZG9tLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVWYWx1ZSAhPT0gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBkb20ubm9kZVZhbHVlID0gY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4gPT09ICcnKSB7XG4gICAgICAgICAgICBwYXJlbnREb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudERvbSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBoeWRyYXRlRWxlbWVudChjaGlsZCwgZG9tLCBtb3VudGVkUXVldWUsIHBhcmVudERvbSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChjaGlsZCwgcGFyZW50RG9tLCBtb3VudGVkUXVldWUsIHRydWUsIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaHlkcmF0ZUVsZW1lbnQoY2hpbGRyZW4sIGRvbSwgbW91bnRlZFF1ZXVlLCBwYXJlbnREb20sIHBhcmVudFZOb2RlLCBpc1NWRyk7XG4gICAgICAgICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KGNoaWxkcmVuLCBwYXJlbnREb20sIG1vdW50ZWRRdWV1ZSwgdHJ1ZSwgcGFyZW50Vk5vZGUsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIGFueSBvdGhlciBET00gbm9kZXMsIHRoZXJlIHNob3VsZCBiZSBvbiBhIHNpbmdsZSBlbnRyeSBmb3IgdGhlIHJvb3RcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICBwYXJlbnREb20ucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICAgICAgZG9tID0gbmV4dFNpYmxpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihwYXJlbnREb20pIHtcbiAgICBsZXQgZG9tID0gcGFyZW50RG9tLmZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT09IDggJiYgZG9tLmRhdGEgPT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0RG9tID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHBhcmVudERvbS5yZW1vdmVDaGlsZChkb20pO1xuICAgICAgICAgICAgZG9tID0gbGFzdERvbSB8fCBwYXJlbnREb20uZmlyc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3Qgd2FybmluZyA9IHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59IDogZnVuY3Rpb24oKSB7fTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9taXNzdGltZS9zcmMvaHlkcmF0aW9uLmpzIiwiaW1wb3J0IEludGFjdCBmcm9tICcuL2ludGFjdCc7XG5pbXBvcnQge1R5cGVzfSBmcm9tICdtaXNzdGltZS9zcmMvdm5vZGUnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmaW5lZCwgbm9vcCwgaW5Ccm93c2VyLCBrZXlzfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBWZHQgZnJvbSAndmR0JztcblxubGV0IEFuaW1hdGU7XG5leHBvcnQgZGVmYXVsdCBBbmltYXRlID0gSW50YWN0LmV4dGVuZCh7XG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgJ2E6dGFnJzogJ2RpdicsXG4gICAgICAgICdhOnRyYW5zaXRpb24nOiAnYW5pbWF0ZScsXG4gICAgICAgICdhOmFwcGVhcic6IGZhbHNlLFxuICAgICAgICAnYTptb2RlJzogJ2JvdGgnLCAvLyBvdXQtaW4gfCBpbi1vdXQgfCBib3RoXG4gICAgICAgICdhOmRpc2FibGVkJzogZmFsc2UsIC8vIOWPquWBmuWKqOeUu+euoeeQhuiAhe+8jOiHquW3seS4jei/m+ihjOWKqOeUu1xuICAgICAgICAnYTptb3ZlJzogdHJ1ZSwgLy8g5piv5ZCm5omn6KGMbW92ZeWKqOeUu1xuICAgICAgICAnYTpjc3MnOiB0cnVlLCAvLyDmmK/lkKbkvb/nlKhjc3PliqjnlLvvvIzlpoLmnpzoh6rlrprkuYnliqjnlLvlh73mlbDvvIzlj6/ku6XlsIblroPnva7kuLpmYWxzZVxuICAgICAgICAnYTpkZWxheURlc3Ryb3knOiB0cnVlLCAvLyDmmK/lkKbliqjnlLvlrozmiJDmiY1kZXN0cm955a2Q5YWD57SgXG4gICAgfSxcblxuICAgIHRlbXBsYXRlKCkge1xuICAgICAgICBjb25zdCBoID0gVmR0Lm1pc3MuaDtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMuZGF0YTtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNlbGYuZ2V0KCdhOnRhZycpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICBjb25zdCBfcHJvcHMgPSBzZWxmLmdldCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gX3Byb3BzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAga2V5ICE9PSAncmVmJyAmJiBcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdrZXknICYmIFxuICAgICAgICAgICAgICAgIChrZXlbMF0gIT09ICdhJyB8fCBrZXlbMV0gIT09ICc6JykgJiYgXG4gICAgICAgICAgICAgICAga2V5LnN1YnN0cigwLCA1KSAhPT0gJ2V2LWE6J1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IF9wcm9wc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKHRhZ05hbWUsIHByb3BzLCBzZWxmLmdldCgnY2hpbGRyZW4nKSk7XG4gICAgfSxcblxuICAgIF9pbml0KCkge1xuICAgICAgICB0aGlzLmlzU3VwcG9ydENzc1RyYW5zaXRpb24gPSBlbmRFdmVudHMubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdXBwb3J0Q3NzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgLy8g5aaC5p6c5LiN5pSv5oyBY3Nz5Yqo55S777yM5YiZ5YWz6ZetY3NzXG4gICAgICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgICAgICAgJ2E6Y3NzJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2E6bW92ZSc6IGZhbHNlXG4gICAgICAgICAgICB9LCB7c2lsZW50OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdW50Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy51bm1vdW50Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX2VudGVyaW5nQW1vdW50ID0gMDtcbiAgICAgICAgdGhpcy5fbGVhdmluZ0Ftb3VudCA9IDA7XG4gICAgfSxcblxuICAgIF9oYXNKc1RyYW5zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGV2ZW50cykge1xuICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gJ2EnICYmIGtleVsxXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50c1trZXldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBpbml0OiBpbkJyb3dzZXIgPyBcbiAgICAgICAgZnVuY3Rpb24obGFzdFZOb2RlLCBuZXh0Vk5vZGUpIHtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLmdldCgnYTpkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuX3N1cGVyKGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyZW50RG9tID0gdGhpcy5wYXJlbnRWTm9kZSAmJiB0aGlzLnBhcmVudFZOb2RlLmRvbSB8fCB0aGlzLnBhcmVudERvbTtcbiAgICAgICAgICAgIGlmIChwYXJlbnREb20gJiYgcGFyZW50RG9tLl9yZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgbGFzdFZOb2RlID0gcGFyZW50RG9tLl9yZXNlcnZlW25leHRWTm9kZS5rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyKGxhc3RWTm9kZSwgbmV4dFZOb2RlKTtcbiAgICAgICAgfSA6IFxuICAgICAgICBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXJBcHBseShhcmd1bWVudHMpOyBcbiAgICAgICAgfSxcblxuICAgIF9tb3VudChsYXN0Vk5vZGUsIHZOb2RlKSB7XG4gICAgICAgIGxldCBpc0FwcGVhciA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcikge1xuICAgICAgICAgICAgbGV0IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLmdldCgnYTphcHBlYXInKSAmJiBcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RG9tIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnQgPSB0aGlzLnBhcmVudFZOb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAocGFyZW50LnR5cGUgJiBUeXBlcy5Db21wb25lbnRDbGFzc09ySW5zdGFuY2UpICYmXG4gICAgICAgICAgICAgICAgICAgICFwYXJlbnQuY2hpbGRyZW4uaXNSZW5kZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpc0FwcGVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgIGNvbnN0IGluaXRDbGFzc05hbWUgPSAoYywgbmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gdGhpcy5nZXQoJ2E6dHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgbGV0IGVudGVyQ2xhc3M7XG4gICAgICAgICAgICBsZXQgZW50ZXJBY3RpdmVDbGFzcztcbiAgICAgICAgICAgIGlmIChpc0FwcGVhcikge1xuICAgICAgICAgICAgICAgIGVudGVyQ2xhc3MgPSBgJHt0cmFuc2l0aW9ufS1hcHBlYXJgO1xuICAgICAgICAgICAgICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHt0cmFuc2l0aW9ufS1hcHBlYXItYWN0aXZlYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW50ZXJDbGFzcyA9IGAke3RyYW5zaXRpb259LWVudGVyYDtcbiAgICAgICAgICAgICAgICBlbnRlckFjdGl2ZUNsYXNzID0gYCR7dHJhbnNpdGlvbn0tZW50ZXItYWN0aXZlYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pc0FwcGVhciA9IGlzQXBwZWFyO1xuICAgICAgICAgICAgdGhpcy5lbnRlckNsYXNzID0gZW50ZXJDbGFzcztcbiAgICAgICAgICAgIHRoaXMuZW50ZXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2xhc3MgPSBgJHt0cmFuc2l0aW9ufS1sZWF2ZWA7XG4gICAgICAgICAgICB0aGlzLmxlYXZlQWN0aXZlQ2xhc3MgPSBgJHt0cmFuc2l0aW9ufS1sZWF2ZS1hY3RpdmVgO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ2xhc3MgPSBgJHt0cmFuc2l0aW9ufS1tb3ZlYDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJFdmVudE5hbWUgPSBpc0FwcGVhciA/ICdhOmFwcGVhcicgOiAnYTplbnRlcic7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChgXFxcXGIoJHtvbGRWYWx1ZX0oPz1cXFxcLShhcHBlYXJ8ZW50ZXJ8bGVhdmV8bW92ZSkpKWAsICdnJyksXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbignJGNoYW5nZTphOnRyYW5zaXRpb24nLCBpbml0Q2xhc3NOYW1lKTtcbiAgICAgICAgaW5pdENsYXNzTmFtZSgpO1xuXG5cbiAgICAgICAgLy8g5LiA5Liq5Yqo55S75YWD57Sg6KKr5Yig6Zmk5ZCO77yM5Lya6KKr5L+d5a2YXG4gICAgICAgIC8vIOWmguaenOWcqOWIoOmZpOeahOi/h+eoi+S4re+8jOWPiOa3u+WKoOS6hu+8jOWImeimgea4hemZpOS4iuS4gOS4quWKqOeUu+eKtuaAgVxuICAgICAgICAvLyDlsIbov5nnp43mg4XlhrXorrDlvZXkuIvmnaVcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RWTm9kZSAmJiB0aGlzLl9sYXN0Vk5vZGUgIT09IGxhc3RWTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdEluc3RhbmNlID0gdGhpcy5fbGFzdFZOb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGxhc3RJbnN0YW5jZS5fbGVhdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEluc3RhbmNlID0gbGFzdEluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSB0aGlzLnBhcmVudEluc3RhbmNlID0gdGhpcy5fZ2V0UGFyZW50QW5pbWF0ZSgpO1xuXG4gICAgICAgIHRoaXMuX2VudGVyRW5kID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdldCgnYTpjc3MnKSAmJiAhdGhpcy5nZXQoJ2E6ZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24gJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHRoaXMuZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmFuc2l0aW9uRXZlbnRzLm9mZihlbGVtZW50LCB0aGlzLl9lbnRlckVuZCk7XG4gICAgICAgICAgICB0aGlzLl9lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tcGFyZW50SW5zdGFuY2UuX2VudGVyaW5nQW1vdW50ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLmdldCgnYTptb2RlJykgPT09ICdpbi1vdXQnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5fY2hlY2tNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihgJHt0aGlzLmVudGVyRXZlbnROYW1lfUVuZGAsIGVsZW1lbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVsZW1lbnQuX3VubW91bnQgPSAobm91c2UsIHBhcmVudERvbSkgPT4ge1xuICAgICAgICAgICAgLy8g5aaC5p6c6K+l5YWD57Sg5piv5bu26L+fbW91bnTnmoTlhYPntKDvvIzliJnnm7TmjqXliKDpmaRcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxheUVudGVyKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RG9tLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSh2Tm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UuX2VudGVyaW5nQW1vdW50LS07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNOb3RBbmltYXRlID0gIXRoaXMuZ2V0KCdhOmNzcycpICYmICF0aGlzLl9oYXNKc1RyYW5zaXRpb24oKSB8fCBcbiAgICAgICAgICAgICAgICB0aGlzLmdldCgnYTpkaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy52Tm9kZSA9IHZOb2RlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnREb20gPSBwYXJlbnREb207XG4gICAgICAgICAgICBpZiAocGFyZW50SW5zdGFuY2UgJiYgIWlzTm90QW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLl9sZWF2aW5nQW1vdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlLmdldCgnYTptb2RlJykgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLnVwZGF0ZUNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLnVubW91bnRDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vdEFuaW1hdGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnREb20ucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KHZOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5a2Y5Zyo54i25Yqo55S757uE5Lu277yM5YiZ5L2/55So54i257qn6L+b6KGM566h55CGXG4gICAgICAgICAgICAvLyDnu5/kuIDlgZrliqjnlLtcbiAgICAgICAgICAgIGlmIChpc0FwcGVhciB8fCAhdGhpcy5pc1JlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RJbnN0YW5jZSAmJiB0aGlzLmxhc3RJbnN0YW5jZS5fZGVsYXlMZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbnN0YW5jZS51cGRhdGVDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLl9lbnRlcmluZ0Ftb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnIl1bm1vdW5055qE5YWD57Sg77yM5YiZ55u05o6lZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlLl9sZWF2aW5nQW1vdW50ID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UuZ2V0KCdhOm1vZGUnKSA9PT0gJ291dC1pbidcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxheUVudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLm1vdW50Q2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcHBlYXIgfHwgIXRoaXMuaXNSZW5kZXIpIHtcbiAgICAgICAgICAgIC8vIOWQpuWImeWNleS4quWFg+e0oOiHquW3seWKqOeUu1xuICAgICAgICAgICAgdGhpcy5fZW50ZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0UGFyZW50QW5pbWF0ZSgpIHtcbiAgICAgICAgLy8g5qC56IqC54K55Li6QW5pbWF0Ze+8jOS4jeWtmOWcqHBhcmVudFZOb2RlXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRWTm9kZSkgcmV0dXJuO1xuICAgICAgICAvLyB0aGlzLnBhcmVudFZOb2Rl5pivYW5pbWF0ZeeahHRhZ++8jOaJgOS7peimgeaLv3RoaXMucGFyZW50Vk5vZGUucGFyZW50Vk5vZGVcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSB0aGlzLnBhcmVudFZOb2RlLnBhcmVudFZOb2RlO1xuICAgICAgICBpZiAocGFyZW50Vk5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAocGFyZW50SW5zdGFuY2UgaW5zdGFuY2VvZiBBbmltYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudEluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgIFxuICAgIF91bm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5nZXQoJ2E6ZGlzYWJsZWQnKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBjb25zdCB2Tm9kZSA9IHRoaXMudk5vZGU7XG4gICAgICAgIGNvbnN0IHBhcmVudERvbSA9IHRoaXMucGFyZW50RG9tO1xuICAgICAgICAvLyB2Tm9kZemDveS8muiiq+a3u+WKoGtlee+8jOW9k+WPquacieS4gOS4quWtkOWFg+e0oOaXtu+8jHZOb2RlLmtleSA9PT0gdW5kZWZpbmVkXG4gICAgICAgIC8vIOi/meenjeaDheWGte+8jOaIkeS7rOS5n+W9k+aIkOaciWtleeWkhOeQhu+8jOatpOaXtmtleeS4unVuZGVmaW5lZFxuICAgICAgICBpZiAoIXBhcmVudERvbS5fcmVzZXJ2ZSkge1xuICAgICAgICAgICAgcGFyZW50RG9tLl9yZXNlcnZlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50RG9tLl9yZXNlcnZlW3ZOb2RlLmtleV0gPSB2Tm9kZTtcblxuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5fZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIFRyYW5zaXRpb25FdmVudHMub2ZmKGVsZW1lbnQsIHRoaXMuX2VudGVyRW5kKTtcbiAgICAgICAgICAgIHRoaXMuX2VudGVyRW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sZWF2ZUVuZCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoJ2E6Y3NzJykgJiYgIXRoaXMuZ2V0KCdhOmRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCB0aGlzLmxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJlZExlYXZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgICAgICAgICAgcy5wb3NpdGlvbiA9IHMudG9wID0gcy5sZWZ0ID0gcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIHBhcmVudERvbS5fcmVzZXJ2ZVt2Tm9kZS5rZXldO1xuICAgICAgICAgICAgVHJhbnNpdGlvbkV2ZW50cy5vZmYoZWxlbWVudCwgdGhpcy5fbGVhdmVFbmQpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSB0aGlzLnBhcmVudEluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tcGFyZW50SW5zdGFuY2UuX2xlYXZpbmdBbW91bnQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UuZ2V0KCdhOm1vZGUnKSA9PT0gJ291dC1pbidcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UuX2NoZWNrTW9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYTpsZWF2ZUVuZCcsIGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl91bm1vdW50Q2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RG9tLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldCgnYTpkZWxheURlc3Ryb3knKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kodk5vZGUsIG51bGwsIHBhcmVudERvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2xlYXZlKCk7XG4gICAgICAgIC8vIOWtmOWcqOS4gOenjeaDheWGte+8jOebuOWQjOeahGRvbe+8jOWQjOaXtuiiq+WtkOe7hOS7tuWSjOeItue7hOS7tueuoeeQhueahOaDheWGtVxuICAgICAgICAvLyDmiYDku6V1bm1vdW505ZCO77yM5bCG5YW2572u5Li656m65Ye95pWw77yM5Lul5YWN5YaN5qyhdW5tb3VudFxuICAgICAgICBlbGVtZW50Ll91bm1vdW50ID0gbm9vcDtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2E6bGVhdmVTdGFydCcsIGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBfYmVmb3JlVXBkYXRlKGxhc3RWTm9kZSwgdk5vZGUpIHtcbiAgICAgICAgLy8g5pu05paw5LmL5YmN77yM6L+Z6YeM55qEY2hpbGRyZW7kuI3ljIXlkKvmnKzmrKHmm7TmlrBtb3VudOi/m+adpeeahOWFg+e0oFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHJlc2VydmVkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgaXNNb3ZlID0gdGhpcy5nZXQoJ2E6bW92ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UuX2xlYXZpbmcgJiYgaXNNb3ZlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucG9zaXRpb24gPSBpbnN0YW5jZS5fZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5fZGVsYXlMZWF2ZSkge1xuICAgICAgICAgICAgICAgIHJlc2VydmVkQ2hpbGRyZW4ucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbi5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gcmVzZXJ2ZWRDaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgX2dldFBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSB8fCBzdHlsZS5XZWJraXRUcmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zdCB0cmFuc2Zvcm0gPSBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IENTU01hdHJpeCh0cmFuc2Zvcm0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcCArIG1hdHJpeC5tNDIsXG4gICAgICAgICAgICBsZWZ0OiBlbGVtZW50Lm9mZnNldExlZnQgKyBtYXRyaXgubTQxXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOWwvemHj+S/neaMgeWKqOeUu+eahOi/nui0r+aAp1xuICAgICAqL1xuICAgIF91cGRhdGUobGFzdFZOb2RlLCB2Tm9kZSwgaXNGcm9tQ2hlY2tNb2RlKSB7XG4gICAgICAgIGxldCBwYXJlbnRJbnN0YW5jZTtcbiAgICAgICAgaWYgKCF0aGlzLmdldCgnYTpkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICBwYXJlbnRJbnN0YW5jZSA9IHRoaXMucGFyZW50SW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJbnN0YW5jZS51cGRhdGVDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmm7TmlrDkuYvlkI7vvIzov5nph4znmoRjaGlsZHJlbuWMheaLrOW9k+WJjW1vdW50L3VwZGF0ZS91bm1vdW5055qE5YWD57SgXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgLy8g5LiN5a2Y5ZyoY2hpbGRyZW7vvIzliJnooajnpLrmsqHmnInlrZDliqjnlLvlhYPntKDopoHnrqHnkIbvvIznm7TmjqXov5Tlm55cbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHJldHVybjtcblxuXG4gICAgICAgIGxldCBtb3VudENoaWxkcmVuID0gdGhpcy5tb3VudENoaWxkcmVuO1xuICAgICAgICBsZXQgdW5tb3VudENoaWxkcmVuID0gdGhpcy51bm1vdW50Q2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHVwZGF0ZUNoaWxkcmVuID0gdGhpcy51cGRhdGVDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaXNNb3ZlID0gdGhpcy5nZXQoJ2E6bW92ZScpO1xuXG4gICAgICAgIC8vIOWmguaenOaYr2luLW91dOaooeW8j++8jOS9huaYr+ayoeacieWFg+e0oGVudGVy77yM5YiZ55u05o6lbGVhdmVcbiAgICAgICAgaWYgKCFpc0Zyb21DaGVja01vZGUgJiYgdGhpcy5fZW50ZXJpbmdBbW91bnQgPT09IDAgJiYgXG4gICAgICAgICAgICBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS5nZXQoJ2E6bW9kZScpID09PSAnaW4tb3V0J1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBkYXRlQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB1cGRhdGVDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX2RlbGF5TGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLl9kZWxheUxlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG5cbiAgICAgICAgLy8g6L+b6KGMbW91bnTlhYPntKDnmoTov5vlhaXliqjnlLtcbiAgICAgICAgLy8g5Zug5Li65a2Y5ZyobW92aW5n5YWD57Sg6KKrdW5tb3VudOWPiOiiq21vdW5055qE5oOF5Ya1XG4gICAgICAgIC8vIOaJgOS7peacgOWFiOWkhOeQhlxuICAgICAgICBpZiAoaXNNb3ZlKSB7XG4gICAgICAgICAgICBtb3VudENoaWxkcmVuLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOW9k+WJjeWFg+e0oOaYr+S7juS4iuS4gOS4qnVubW91bnTnmoTlhYPntKDmnaXnmoTvvIxcbiAgICAgICAgICAgICAgICAvLyDliJnopoHliJ3lp4vljJbmnIDmlrDkvY3nva7vvIzlm6DkuLpiZWZvcmVVcGRhdGXkuK1cbiAgICAgICAgICAgICAgICAvLyDkuI3ljIXmi6zlvZPliY1tb3VudOWFg+e0oOeahOS9jee9ruWIneWni+WMllxuICAgICAgICAgICAgICAgIC8vIOi/meagt+aJjeiDveS/neaMgeS9jee9rueahOi/nui0r+aAp1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5sYXN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucG9zaXRpb24gPSBpbnN0YW5jZS5fZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtb3VudENoaWxkcmVuLmZvckVhY2goaW5zdGFuY2UgPT4gaW5zdGFuY2UuX2VudGVyKCkpO1xuXG4gICAgICAgIC8vIOWFiOWwhuS5i+WJjeeahOWKqOeUu+a4heepulxuICAgICAgICAvLyDlj6rmnInml6LlnKhtb3Zl5Y+I5ZyoZW50ZXLnmoR1bm1vdW505YWD57Sg5omN5riF56m65Yqo55S7XG4gICAgICAgIC8vIOi/meenjeaDheWGteS/neaMgeS4jeS6hui/nui0r+aAp1xuICAgICAgICBpZiAoaXNNb3ZlKSB7XG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4uZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl9tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX21vdmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl9lbnRlcmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX2VudGVyRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8g5a+55LqO5pu05paw55qE5YWD57Sg77yM5aaC5p6c5q2j5ZyobW92Ze+8jOWImeWwhuS9jee9rua4heepuu+8jOS7peS+v+ehruWumuacgOe7iOS9jee9rlxuICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4uZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl9tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGluc3RhbmNlLmVsZW1lbnQuc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIHMubGVmdCA9IHMudG9wID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIOWwhuimgeWIoOmZpOeahOWFg+e0oO+8jOiuvuS4umFic29sdXRl77yM5Lul5L6/56Gu5a6a5YW25a6D5YWD57Sg5pyA57uI5L2N572uXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4uZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8g6I635Y+W5omA5pyJ5YWD57Sg55qE5paw5L2N572uXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5uZXdQb3NpdGlvbiA9IGluc3RhbmNlLl9nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIOWIhuWIq+WIpOaWreWFg+e0oOaYr+WQpumcgOimgeenu+WKqO+8jOW5tuS/neaMgeW9k+WJjeS9jee9ruS4jeWPmFxuICAgICAgICAgICAgLy8gdW5tb3VudOeahOWFg+e0oO+8jOS7juW9k+WJjeS9jee9ruebtOaOpWxlYXZl77yM5LiN6KaBbW92ZeS6hlxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuLmZvckVhY2goaW5zdGFuY2UgPT4gaW5zdGFuY2UuX2luaXRNb3ZlKHRydWUpKTtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuLmZvckVhY2goaW5zdGFuY2UgPT4gaW5zdGFuY2UuX2luaXRNb3ZlKCkpO1xuICAgICAgICAgICAgbW91bnRDaGlsZHJlbi5mb3JFYWNoKGluc3RhbmNlID0+IGluc3RhbmNlLl9pbml0TW92ZSgpKTtcblxuICAgICAgICAgICAgLy8g5a+55LqOYW5pbWF0aW9u5Yqo55S777yMZW50ZXJFbmTkuoZlbnRlcmluZ+WFg+e0oFxuICAgICAgICAgICAgLy8g6ZyA6KaBcmUtbGF5b3V077yM5p2l6Kem5Y+RbW92ZeWKqOeUu1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgLy8g5aaC5p6c5YWD57Sg6ZyA6KaB56e75Yqo77yM5YiZ6L+b6KGMbW92ZeWKqOeUu1xuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX25lZWRNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2UuX21vdmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX21vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOW3sue7j+WcqOenu+WKqOS6hu+8jOmCo+ebtOaOpeaUueWPmHRyYW5zbGF0Ze+8jOS/neaMgeWKqOeUu+i/nui0r1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuX3RyaWdnZXJNb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVubW91bnTlhYPntKDlgZpsZWF2ZeWKqOeUu1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4uZm9yRWFjaChpbnN0YW5jZSA9PiBpbnN0YW5jZS5fdW5tb3VudCgpKTtcblxuICAgICAgICB0aGlzLm1vdW50Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnVubW91bnRDaGlsZHJlbiA9IFtdO1xuICAgIH0sXG5cbiAgICBfY2hlY2tNb2RlKCkge1xuICAgICAgICBjb25zdCBtb3VudENoaWxkcmVuID0gW107XG4gICAgICAgIGNvbnN0IHVwZGF0ZUNoaWxkcmVuID0gW107XG4gICAgICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuX2RlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fZGVsYXlFbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4ucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZS5fZGVsYXlMZWF2ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9kZWxheUxlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZS5fbGVhdmluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbi5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlZm9yZVVwZGF0ZSgpO1xuICAgICAgICBtb3VudENoaWxkcmVuLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICBpbnN0YW5jZS5wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vdW50Q2hpbGRyZW4gPSBtb3VudENoaWxkcmVuO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuID0gdXBkYXRlQ2hpbGRyZW47XG4gICAgICAgIHRoaXMudW5tb3VudENoaWxkcmVuID0gdW5tb3VudENoaWxkcmVuO1xuICAgICAgICB0aGlzLmNoaWxkcmVuICA9IGNoaWxkcmVuLmNvbmNhdChtb3VudENoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKG51bGwsIG51bGwsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfaW5pdE1vdmUoaXNVbm1vdW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLm5ld1Bvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblxuICAgICAgICAvLyDlr7nkuo7mlrBtb3VudOeahOWFg+e0oO+8jOS4jei/m+ihjG1vdmXliKTmlq1cbiAgICAgICAgaWYgKCFvbGRQb3NpdGlvbikgcmV0dXJuO1xuXG4gICAgXG4gICAgICAgIGNvbnN0IGR4ID0gb2xkUG9zaXRpb24ubGVmdCAtIG5ld1Bvc2l0aW9uLmxlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gb2xkUG9zaXRpb24udG9wIC0gbmV3UG9zaXRpb24udG9wO1xuICAgICAgICBjb25zdCBvRHggPSB0aGlzLmR4O1xuICAgICAgICBjb25zdCBvRHkgPSB0aGlzLmR5O1xuXG4gICAgICAgIHRoaXMuZHggPSBkeDtcbiAgICAgICAgdGhpcy5keSA9IGR5O1xuXG4gICAgICAgIGlmIChkeCB8fCBkeSB8fCBvRHggfHwgb0R5KSB7XG4gICAgICAgICAgICAvLyDlr7nkuo5tb3Zl5Lit55qE5YWD57Sg77yM6ZyA6KaB5bCG5a6D6YeN5paw5Zue5YiwMFxuICAgICAgICAgICAgY29uc3QgcyA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgcy5sZWZ0ID0gYCR7b2xkUG9zaXRpb24ubGVmdH1weGA7XG4gICAgICAgICAgICAgICAgcy50b3AgPSBgJHtvbGRQb3NpdGlvbi50b3B9cHhgO1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOW9k+WJjeWFg+e0oOato+WcqGVudGVy77yM6ICM5LiU5pivYW5pbWF0aW9u5Yqo55S777yM5YiZ6KaBZW50ZXJFbmRcbiAgICAgICAgICAgICAgICAvLyDlkKbliJnml6Dms5Vtb3ZlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VudGVyaW5nICYmIGdldEFuaW1hdGVUeXBlKGVsZW1lbnQpICE9PSAndHJhbnNpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW50ZXJFbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZE1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHMucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgICAgIHMubGVmdCA9IGAke2R4fXB4YDtcbiAgICAgICAgICAgICAgICBzLnRvcCA9IGAke2R5fXB4YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRNb3ZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldCgnYTpkaXNhYmxlZCcpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX21vdmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCB0aGlzLm1vdmVDbGFzcyk7XG4gICAgICAgIHRoaXMuX21vdmVFbmQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgIFRyYW5zaXRpb25FdmVudHMub2ZmKGVsZW1lbnQsIHRoaXMuX21vdmVFbmQpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHRoaXMubW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBzLnBvc2l0aW9uID0gcy5sZWZ0ID0gcy50b3AgPSBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5keCA9IHRoaXMuZHkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUcmFuc2l0aW9uRXZlbnRzLm9uKGVsZW1lbnQsIHRoaXMuX21vdmVFbmQpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyTW92ZSgpO1xuICAgICAgICAgICAgLy8gbmV4dEZyYW1lKCgpID0+IHRoaXMuX3RyaWdnZXJNb3ZlKCkpO1xuICAgIH0sXG5cbiAgICBfdHJpZ2dlck1vdmUoKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7MCAtIHRoaXMuZHh9cHgsICR7MCAtIHRoaXMuZHl9cHgpYDtcbiAgICB9LFxuXG4gICAgX2VudGVyKCkge1xuICAgICAgICBpZiAodGhpcy5nZXQoJ2E6ZGlzYWJsZWQnKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbnRlcmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGVudGVyQ2xhc3MgPSB0aGlzLmVudGVyQ2xhc3M7XG4gICAgICAgIGNvbnN0IGVudGVyQWN0aXZlQ2xhc3MgPSB0aGlzLmVudGVyQWN0aXZlQ2xhc3M7XG4gICAgICAgIGNvbnN0IGlzQ3NzID0gdGhpcy5nZXQoJ2E6Y3NzJyk7XG5cbiAgICAgICAgLy8gZ2V0QW5pbWF0ZVR5cGXlsIbmt7vliqBlbnRlci1hY3RpdmUgY2xhc3NOYW1l77yM5ZyoZmlyZWZveOS4i+WwhuWvvOiHtOWKqOeUu+aPkOWJjeaJp+ihjFxuICAgICAgICAvLyDmiJHku6zlupTor6XlhYjkuo7mt7vliqBgZW50ZXJgIGNsYXNzTmFtZeWOu+iwg+eUqOivpeWHveaVsFxuICAgICAgICBsZXQgaXNUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0NzcyAmJiBnZXRBbmltYXRlVHlwZShlbGVtZW50LCBlbnRlckFjdGl2ZUNsYXNzKSAhPT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlpoLmnpzov5nkuKrlhYPntKDmmK/kuIrkuIDkuKrliKDpmaTnmoTlhYPntKDvvIzliJnku47lvZPliY3nirbmgIHlm57liLDljp/lp4vnirbmgIFcbiAgICAgICAgaWYgKHRoaXMubGFzdEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RJbnN0YW5jZS5fdW5tb3VudENhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxhc3RJbnN0YW5jZS5fbGVhdmVFbmQoKTtcblxuICAgICAgICAgICAgaWYgKGlzQ3NzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdEluc3RhbmNlLl90cmlnZ2VyZWRMZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGRDbGFzcyhlbGVtZW50LCBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5L+d5oyB6L+e6LSv77yM5re75YqgbGVhdmVBY3RpdmVDbGFzc1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCB0aGlzLmxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOS4iuS4gOS4quWFg+e0oOi/mOayoeadpeW+l+WPiuWBmuWKqOeUu++8jOWImeW9k+WBmuaWsOWFg+e0oOWkhOeQhlxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBlbnRlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDc3MpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGVudGVyQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIFRyYW5zaXRpb25FdmVudHMub24oZWxlbWVudCwgdGhpcy5fZW50ZXJFbmQpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcihgJHt0aGlzLmVudGVyRXZlbnROYW1lfVN0YXJ0YCwgZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKGlzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHRoaXMuX3RyaWdnZXJFbnRlcigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOWvueS6jmFuaW1hdGlvbuWKqOeUu++8jOWQjOatpea3u+WKoGVudGVyQWN0aXZlQ2xhc3PvvIzpgb/lhY3pl6rliqhcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbnRlcigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90cmlnZ2VyRW50ZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJlZEVudGVyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdhOmNzcycpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW50ZXJpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHRoaXMuZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCB0aGlzLmVudGVyQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHRoaXMubGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuZW50ZXJFdmVudE5hbWUsIGVsZW1lbnQsIHRoaXMuX2VudGVyRW5kKTtcbiAgICB9LFxuXG4gICAgX2xlYXZlKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICAvLyDkuLrkuobkv53mjIHliqjnlLvov57otK/vvIzmiJHku6znq4vljbPmt7vliqBsZWF2ZUFjdGl2ZUNsYXNzXG4gICAgICAgIC8vIOS9huWmguaenOW9k+WJjeWFg+e0oOi/mOayoeacieadpeW+l+WPiuWBmmVudGVy5Yqo55S777yM5bCx6KKr5Yig6ZmkXG4gICAgICAgIC8vIOWImWxlYXZlQWN0aXZlQ2xhc3PlkoxsZWF2ZUNsYXNz6YO95pS+5Yiw5LiL5LiA5bin5re75YqgXG4gICAgICAgIC8vIOWQpuWImWxlYXZlQ2xhc3PlkoxlbnRlckNsYXNz5LiA5qC35bCx5LiN5Lya5pyJ5Yqo55S75pWI5p6cXG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyZWRFbnRlciAmJiB0aGlzLmdldCgnYTpjc3MnKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgdGhpcy5sZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFuc2l0aW9uRXZlbnRzLm9uKGVsZW1lbnQsIHRoaXMuX2xlYXZlRW5kKTtcbiAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIOWmguaenGxlYXZl5Yqo55S76L+Y5rKh5b6X5Y+K5omn6KGM77yM5bCxZW50ZXLkuobvvIzmraTml7bllaXkuZ/kuI3lgZpcbiAgICAgICAgICAgIGlmICh0aGlzLl91bm1vdW50Q2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICAvLyDlrZjlnKjkuIDnp43mg4XlhrXvvIzlvZPkuIDkuKplbnRlcuWKqOeUu+WcqOWujOaIkOeahOeerOmXtO+8jFxuICAgICAgICAgICAgLy8g6L+Z5Liq5YWD57Sg6KKr5Yig6Zmk5LqG77yM55Sx5LqO5YmN6Z2i5L+d5oyB5Yqo55S755qE6L+e6LSv5oCnXG4gICAgICAgICAgICAvLyDmt7vliqDkuoZsZWF2ZUFjdGl2ZUNsYXNz77yM5YiZ5Lya5a+86Ie057uR5a6a55qEbGVhdmVFbmRcbiAgICAgICAgICAgIC8vIOeri+WNs+aJp+ihjO+8jOaJgOS7pei/memHjOaUvuWIsOS4i+S4gOW4p+adpee7keWumlxuICAgICAgICAgICAgVHJhbnNpdGlvbkV2ZW50cy5vbihlbGVtZW50LCB0aGlzLl9sZWF2ZUVuZCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyTGVhdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF90cmlnZ2VyTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJlZExlYXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2xlYXZpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdhOmNzcycpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCB0aGlzLmxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2E6bGVhdmUnLCBlbGVtZW50LCB0aGlzLl9sZWF2ZUVuZCk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3kobGFzdFZOb2RlLCBuZXh0Vk5vZGUsIHBhcmVudERvbSkge1xuICAgICAgICAvLyAxOiDkuI3lrZjlnKhwYXJlbnREb23vvIzmnInkuKTnp43mg4XlhrXvvJpcbiAgICAgICAgLy8gICAgICAxKTog54i25YWD57Sg5Lmf6KaB6KKr6ZSA5q+B77yM5q2k5pe2OiAhcGFyZW50RG9tICYmIGxhc3RWTm9kZSAmJiAhbmV4dFZOb2RlXG4gICAgICAgIC8vICAgICAgMik6IOivpeWFg+e0oOWwhuiiq+abv+aNou+8jOatpOaXtu+8miFwYXJlbnREb20gJiYgbGFzdFZOb2RlICYmIG5leHRWTm9kZVxuICAgICAgICAvLyAgICAgIOWvueS6jjEp77yM5pei54S254i25YWD57Sg6KaB6ZSA5q+B77yM6YKj5pys6Lqr5Lmf6KaB55u05o6l6ZSA5q+BXG4gICAgICAgIC8vICAgICAg5a+55LqOMinvvIzmnKzouqvlv4XpobvlvoXliqjnlLvnu5PmnZ/mlrnog73plIDmr4FcbiAgICAgICAgLy8gMjog5aaC5p6c6K+l5YWD57Sg5bey57uP5Yqo55S75a6M5oiQ77yM55u05o6l6ZSA5q+BXG4gICAgICAgIC8vIDM6IOWmguaenOebtOaOpeiwg+eUqGRlc3Ryb3nmlrnms5XvvIzliJnnm7TmjqXplIDmr4HvvIzmraTml7bvvJohbGFzdFZOb2RlICYmICFuZXh0Vk5vZGUgJiYgIXBhcmVudERvbVxuICAgICAgICAvLyA0OiDlpoLmnpzkuI3mmK/lu7bov59kZXN0cm955a2Q5YWD57Sg77yM5YiZ56uL5Y2z6ZSA5q+BXG4gICAgICAgIGlmICghdGhpcy5nZXQoJ2E6ZGVsYXlEZXN0cm95JykgfHxcbiAgICAgICAgICAgICFwYXJlbnREb20gJiYgIW5leHRWTm9kZSAmJiB0aGlzLnBhcmVudFZOb2RlLmRvbSAhPT0gdGhpcy5lbGVtZW50IHx8XG4gICAgICAgICAgICAvLyB0aGlzLmdldCgnYTpkaXNhYmxlZCcpIHx8IFxuICAgICAgICAgICAgdGhpcy5fbGVhdmluZyA9PT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLl9zdXBlcihsYXN0Vk5vZGUsIG5leHRWTm9kZSwgcGFyZW50RG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IGAgJHtjbGFzc05hbWV9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTmFtZS5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gKGAgJHtlbGVtZW50LmNsYXNzTmFtZX0gYCkuaW5kZXhPZihgICR7Y2xhc3NOYW1lfSBgKSA+IC0xO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYChefFxcXFxzKSR7Y2xhc3NOYW1lfSg/OlxcXFxzfCQpYCwgJ2cnKSwgJyQxJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIG11bHRpcGxlIHNwYWNlcyB0byBvbmVcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpOyAvLyB0cmltIHRoZSBlbmRzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCBFVkVOVF9OQU1FX01BUCA9IHtcbiAgICB0cmFuc2l0aW9uZW5kOiB7XG4gICAgICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgJ01velRyYW5zaXRpb24nOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICdPVHJhbnNpdGlvbic6ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICdtc1RyYW5zaXRpb24nOiAnTVNUcmFuc2l0aW9uRW5kJ1xuICAgIH0sXG5cbiAgICBhbmltYXRpb25lbmQ6IHtcbiAgICAgICAgJ2FuaW1hdGlvbic6ICdhbmltYXRpb25lbmQnLFxuICAgICAgICAnV2Via2l0QW5pbWF0aW9uJzogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgICAgICdNb3pBbmltYXRpb24nOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAgICAgJ09BbmltYXRpb24nOiAnb0FuaW1hdGlvbkVuZCcsXG4gICAgICAgICdtc0FuaW1hdGlvbic6ICdNU0FuaW1hdGlvbkVuZCdcbiAgICB9XG59O1xuXG5sZXQgZW5kRXZlbnRzID0gW107XG5sZXQgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG5sZXQgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gICAgbGV0IHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICAgIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gICAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gICAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNlYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbVxuICAgIC8vIGZyb20gdGhlIG1hcFxuICAgIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgICAgICBkZWxldGUgRVZFTlRfTkFNRV9NQVAuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYmFzZUV2ZW50TmFtZSBpbiBFVkVOVF9OQU1FX01BUCkge1xuICAgICAgICBsZXQgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgICAgICBmb3IgKGxldCBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuICAgICAgICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VFdmVudE5hbWUgPT09ICd0cmFuc2l0aW9uZW5kJykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcCA9IHN0eWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Qcm9wID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0ZVR5cGUoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSkgYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZVtgJHt0cmFuc2l0aW9uUHJvcH1EdXJhdGlvbmBdLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlW2Ake2FuaW1hdGlvblByb3B9RHVyYXRpb25gXS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXREdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IGdldER1cmF0aW9uKGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gICAgaWYgKGNsYXNzTmFtZSkgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uID4gYW5pbWF0aW9uRHVyYXRpb24gPyAndHJhbnNpdGlvbicgOiAnYW5pbWF0aW9uJztcbn1cblxuZnVuY3Rpb24gZ2V0RHVyYXRpb24oZHVyYXRpb25zKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZCA9PiBkLnNsaWNlKDAsIC0xKSAqIDEwMDApKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5sZXQgVHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgICBvbjogZnVuY3Rpb24obm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgQ1NTIHRyYW5zaXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkLCB0cmlnZ2VyIGFuIFwiZW5kIGFuaW1hdGlvblwiXG4gICAgICAgICAgICAvLyBldmVudCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGV2ZW50TGlzdGVuZXIsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVuZEV2ZW50KSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9mZjogZnVuY3Rpb24obm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVuZEV2ZW50KSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uZTogZnVuY3Rpb24obm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIFRyYW5zaXRpb25FdmVudHMub2ZmKG5vZGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNpdGlvbkV2ZW50cy5vbihub2RlLCBsaXN0ZW5lcik7XG4gICAgfVxufTtcblxubGV0IHJhZjtcbmV4cG9ydCBmdW5jdGlvbiBuZXh0RnJhbWUoZm4pIHtcbiAgICByYWYoKCkgPT4gcmFmKGZuKSk7XG59XG5cbmlmIChpbkJyb3dzZXIpIHtcbiAgICByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogc2V0VGltZW91dDtcblxuICAgIGRldGVjdEV2ZW50cygpO1xufVxuXG5jb25zdCBDU1NNYXRyaXggPSB0eXBlb2YgV2ViS2l0Q1NTTWF0cml4ICE9PSAndW5kZWZpbmVkJyA/IFxuICAgIFdlYktpdENTU01hdHJpeCA6IFxuICAgIGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLm00MiA9IDA7XG4gICAgICAgIHRoaXMubTQxID0gMDtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRyYW5zZm9ybS5zbGljZSgwLCB0cmFuc2Zvcm0uaW5kZXhPZignKCcpKTtcbiAgICAgICAgbGV0IHBhcnRzO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21hdHJpeDNkJykge1xuICAgICAgICAgICAgcGFydHMgPSB0cmFuc2Zvcm0uc2xpY2UoOSwgLTEpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB0aGlzLm00MSA9IHBhcnNlRmxvYXQocGFydHNbMTJdKTtcbiAgICAgICAgICAgIHRoaXMubTQyID0gcGFyc2VGbG9hdChwYXJ0c1sxM10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtYXRyaXgnKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHRyYW5zZm9ybS5zbGljZSg3LCAtMSkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHRoaXMubTQxID0gcGFyc2VGbG9hdChwYXJ0c1s0XSk7XG4gICAgICAgICAgICB0aGlzLm00MiA9IHBhcnNlRmxvYXQocGFydHNbNV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9pbnRhY3Qvc3JjL2FuaW1hdGUuanMiLCJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9hcHAudmR0JztcbmltcG9ydCBjc3MgZnJvbSAnLi9sb2FkaW5nLmNzcyc7IFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEludGFjdCB7XG4gICAgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gdGVtcGxhdGU7IH1cblxuICAgIGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlldzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBydW4oZGF0YSkge1xuICAgICAgICByZXR1cm4gKFBhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCdsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gbmV3IFBhZ2UoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNldCgndmlldycsIHBhZ2UpO1xuICAgICAgICAgICAgLy8gZm9yIGRlYnVnXG4gICAgICAgICAgICB3aW5kb3cuX19wYWdlX18gPSBwYWdlO1xuICAgICAgICAgICAgaWYgKHBhZ2UuaW5pdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2xvYWRpbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFnZS5vbmUoJyRpbml0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykuc2Nyb2xsVG9wKDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvYXBwL2luZGV4LmpzIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmosIF9WZHQsIGJsb2NrcywgJGNhbGxlZSkge1xuX1ZkdCB8fCAoX1ZkdCA9IFZkdCk7XG5vYmogfHwgKG9iaiA9IHt9KTtcbmJsb2NrcyB8fCAoYmxvY2tzID0ge30pO1xudmFyIGggPSBfVmR0Lm1pc3MuaCwgaGMgPSBfVmR0Lm1pc3MuaGMsIGh1ID0gX1ZkdC5taXNzLmh1LCB3aWRnZXRzID0gdGhpcyAmJiB0aGlzLndpZGdldHMgfHwge30sIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSB7fSxcbl9fdSA9IF9WZHQudXRpbHMsIGV4dGVuZCA9IF9fdS5leHRlbmQsIF9lID0gX191LmVycm9yLCBfY2xhc3NOYW1lID0gX191LmNsYXNzTmFtZSxcbl9fbyA9IF9fdS5PcHRpb25zLCBfZ2V0TW9kZWwgPSBfX28uZ2V0TW9kZWwsIF9zZXRNb2RlbCA9IF9fby5zZXRNb2RlbCxcbl9zZXRDaGVja2JveE1vZGVsID0gX191LnNldENoZWNrYm94TW9kZWwsIF9kZXRlY3RDaGVja2JveENoZWNrZWQgPSBfX3UuZGV0ZWN0Q2hlY2tib3hDaGVja2VkLFxuX3NldFNlbGVjdE1vZGVsID0gX191LnNldFNlbGVjdE1vZGVsLFxuc2VsZiA9IHRoaXMuZGF0YSwgJHRoaXMgPSB0aGlzLCBzY29wZSA9IG9iaiwgQW5pbWF0ZSA9IHNlbGYgJiYgc2VsZi5BbmltYXRlLCBwYXJlbnQgPSAoJGNhbGxlZSB8fCB7fSkuX3N1cGVyXG5yZXR1cm4gaCgnZGl2JywgbnVsbCwgWydcXG4gICAgJywgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3NlbGYuZ2V0KCd2aWV3JyldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCAnXFxuICAgICcsIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtzZWxmLmdldCgnbG9hZGluZycpXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSA/IGgoQW5pbWF0ZSwgeydrZXknOiAnbG9hZGluZycsICdjbGFzc05hbWUnOiAnc3Bpbm5lcicsICdhOnRyYW5zaXRpb24nOiAnbG9hZGluZycsICdjaGlsZHJlbic6IFtoKCdkaXYnLCBudWxsLCBudWxsLCAnZG91YmxlLWJvdW5jZTEnKSwgaCgnZGl2JywgbnVsbCwgbnVsbCwgJ2RvdWJsZS1ib3VuY2UyJyldLCAnX2NvbnRleHQnOiAkdGhpc30pIDogdW5kZWZpbmVkXSwgJ2FwcC13cmFwcGVyJylcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2FwcC9hcHAudmR0IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2xvYWRpbmcuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTIhLi9sb2FkaW5nLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vbG9hZGluZy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9hcHAvbG9hZGluZy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5zcGlubmVyIHtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiA1MCU7XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tdG9wOiAtMjBweDtcXG4gIG1hcmdpbi1sZWZ0OiAtMjBweDtcXG59XFxuLmRvdWJsZS1ib3VuY2UxLFxcbi5kb3VibGUtYm91bmNlMiB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZTQ0NDQ7XFxuICBvcGFjaXR5OiAwLjY7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgLXdlYmtpdC1hbmltYXRpb246IHNrLWJvdW5jZSAycyBpbmZpbml0ZSBlYXNlLWluLW91dDtcXG4gIGFuaW1hdGlvbjogc2stYm91bmNlIDJzIGluZmluaXRlIGVhc2UtaW4tb3V0O1xcbn1cXG4uZG91YmxlLWJvdW5jZTIge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IC0xcztcXG4gIGFuaW1hdGlvbi1kZWxheTogLTFzO1xcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgc2stYm91bmNlIHtcXG4gIDAlLCAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbn1cXG4ubG9hZGluZy1lbnRlcixcXG4ubG9hZGluZy1sZWF2ZSB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ubG9hZGluZy1lbnRlci1hY3RpdmUsXFxuLmxvYWRpbmctbGVhdmUtYWN0aXZlIHtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG59XFxuQC1tb3ota2V5ZnJhbWVzIHNrLWJvdW5jZSB7XFxuICAwJSwgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG59XFxuQC13ZWJraXQta2V5ZnJhbWVzIHNrLWJvdW5jZSB7XFxuICAwJSwgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG59XFxuQC1vLWtleWZyYW1lcyBzay1ib3VuY2Uge1xcbiAgMCUsIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICB9XFxufVxcbkBrZXlmcmFtZXMgc2stYm91bmNlIHtcXG4gIDAlLCAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXI/e1wiaW5jbHVkZSBjc3NcIjp0cnVlfSEuL2NvbXBvbmVudHMvYXBwL2xvYWRpbmcuY3NzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDMiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJcblxuLy9cbi8vIEdlbmVyYXRlZCBvbiBUdWUgRGVjIDE2IDIwMTQgMTI6MTM6NDcgR01UKzAxMDAgKENFVCkgYnkgQ2hhcmxpZSBSb2JiaW5zLCBQYW9sbyBGcmFnb21lbmkgJiB0aGUgQ29udHJpYnV0b3JzIChVc2luZyBDb2Rlc3VyZ2VvbikuXG4vLyBWZXJzaW9uIDEuMi42XG4vL1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuLypcbiAqIGJyb3dzZXIuanM6IEJyb3dzZXIgc3BlY2lmaWMgZnVuY3Rpb25hbGl0eSBmb3IgZGlyZWN0b3IuXG4gKlxuICogKEMpIDIwMTEsIENoYXJsaWUgUm9iYmlucywgUGFvbG8gRnJhZ29tZW5pLCAmIHRoZSBDb250cmlidXRvcnMuXG4gKiBNSVQgTElDRU5TRVxuICpcbiAqL1xuXG52YXIgZGxvYyA9IGRvY3VtZW50LmxvY2F0aW9uO1xuXG5mdW5jdGlvbiBkbG9jSGFzaEVtcHR5KCkge1xuICAvLyBOb24tSUUgYnJvd3NlcnMgcmV0dXJuICcnIHdoZW4gdGhlIGFkZHJlc3MgYmFyIHNob3dzICcjJzsgRGlyZWN0b3IncyBsb2dpY1xuICAvLyBhc3N1bWVzIGJvdGggbWVhbiBlbXB0eS5cbiAgcmV0dXJuIGRsb2MuaGFzaCA9PT0gJycgfHwgZGxvYy5oYXNoID09PSAnIyc7XG59XG5cbnZhciBsaXN0ZW5lciA9IHtcbiAgbW9kZTogJ21vZGVybicsXG4gIGhhc2g6IGRsb2MuaGFzaCxcbiAgaGlzdG9yeTogZmFsc2UsXG5cbiAgY2hlY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaCA9IGRsb2MuaGFzaDtcbiAgICBpZiAoaCAhPSB0aGlzLmhhc2gpIHtcbiAgICAgIHRoaXMuaGFzaCA9IGg7XG4gICAgICB0aGlzLm9uSGFzaENoYW5nZWQoKTtcbiAgICB9XG4gIH0sXG5cbiAgZmlyZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdtb2Rlcm4nKSB7XG4gICAgICB0aGlzLmhpc3RvcnkgPT09IHRydWUgPyB3aW5kb3cub25wb3BzdGF0ZSgpIDogd2luZG93Lm9uaGFzaGNoYW5nZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMub25IYXNoQ2hhbmdlZCgpO1xuICAgIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoZm4sIGhpc3RvcnkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcblxuICAgIGlmICghUm91dGVyLmxpc3RlbmVycykge1xuICAgICAgUm91dGVyLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2hhbmdlKG9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gUm91dGVyLmxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgUm91dGVyLmxpc3RlbmVyc1tpXShvbkNoYW5nZUV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL25vdGUgSUU4IGlzIGJlaW5nIGNvdW50ZWQgYXMgJ21vZGVybicgYmVjYXVzZSBpdCBoYXMgdGhlIGhhc2hjaGFuZ2UgZXZlbnRcbiAgICBpZiAoJ29uaGFzaGNoYW5nZScgaW4gd2luZG93ICYmIChkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IHVuZGVmaW5lZFxuICAgICAgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gNykpIHtcbiAgICAgIC8vIEF0IGxlYXN0IGZvciBub3cgSFRNTDUgaGlzdG9yeSBpcyBhdmFpbGFibGUgZm9yICdtb2Rlcm4nIGJyb3dzZXJzIG9ubHlcbiAgICAgIGlmICh0aGlzLmhpc3RvcnkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgYW4gb2xkIGJ1ZyBpbiBDaHJvbWUgdGhhdCBjYXVzZXMgb25wb3BzdGF0ZSB0byBmaXJlIGV2ZW5cbiAgICAgICAgLy8gdXBvbiBpbml0aWFsIHBhZ2UgbG9hZC4gU2luY2UgdGhlIGhhbmRsZXIgaXMgcnVuIG1hbnVhbGx5IGluIGluaXQoKSxcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBjYXVzZSBDaHJvbWUgdG8gcnVuIGl0IHR3aXNlLiBDdXJyZW50bHkgdGhlIG9ubHlcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBzZWVtcyB0byBiZSB0byBzZXQgdGhlIGhhbmRsZXIgYWZ0ZXIgdGhlIGluaXRpYWwgcGFnZSBsb2FkXG4gICAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzMDQwXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2luZG93Lm9ucG9wc3RhdGUgPSBvbmNoYW5nZTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aW5kb3cub25oYXNoY2hhbmdlID0gb25jaGFuZ2U7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGUgPSAnbW9kZXJuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gSUUgc3VwcG9ydCwgYmFzZWQgb24gYSBjb25jZXB0IGJ5IEVyaWsgQXJ2aWRzb24gLi4uXG4gICAgICAvL1xuICAgICAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBmcmFtZS5pZCA9ICdzdGF0ZS1mcmFtZSc7XG4gICAgICBmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICB0aGlzLndyaXRlRnJhbWUoJycpO1xuXG4gICAgICBpZiAoJ29ucHJvcGVydHljaGFuZ2UnIGluIGRvY3VtZW50ICYmICdhdHRhY2hFdmVudCcgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgICAgc2VsZi5jaGVjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHNlbGYuY2hlY2soKTsgfSwgNTApO1xuXG4gICAgICB0aGlzLm9uSGFzaENoYW5nZWQgPSBvbmNoYW5nZTtcbiAgICAgIHRoaXMubW9kZSA9ICdsZWdhY3knO1xuICAgIH1cblxuICAgIFJvdXRlci5saXN0ZW5lcnMucHVzaChmbik7XG5cbiAgICByZXR1cm4gdGhpcy5tb2RlO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICghUm91dGVyIHx8ICFSb3V0ZXIubGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IFJvdXRlci5saXN0ZW5lcnM7XG5cbiAgICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBzZXRIYXNoOiBmdW5jdGlvbiAocykge1xuICAgIC8vIE1vemlsbGEgYWx3YXlzIGFkZHMgYW4gZW50cnkgdG8gdGhlIGhpc3RvcnlcbiAgICBpZiAodGhpcy5tb2RlID09PSAnbGVnYWN5Jykge1xuICAgICAgdGhpcy53cml0ZUZyYW1lKHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhpc3RvcnkgPT09IHRydWUpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHMpO1xuICAgICAgLy8gRmlyZSBhbiBvbnBvcHN0YXRlIGV2ZW50IG1hbnVhbGx5IHNpbmNlIHB1c2hpbmcgZG9lcyBub3Qgb2J2aW91c2x5XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBwb3AgZXZlbnQuXG4gICAgICB0aGlzLmZpcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGxvYy5oYXNoID0gKHNbMF0gPT09ICcvJykgPyBzIDogJy8nICsgcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgd3JpdGVGcmFtZTogZnVuY3Rpb24gKHMpIHtcbiAgICAvLyBJRSBzdXBwb3J0Li4uXG4gICAgdmFyIGYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGUtZnJhbWUnKTtcbiAgICB2YXIgZCA9IGYuY29udGVudERvY3VtZW50IHx8IGYuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICBkLm9wZW4oKTtcbiAgICBkLndyaXRlKFwiPHNjcmlwdD5faGFzaCA9ICdcIiArIHMgKyBcIic7IG9ubG9hZCA9IHBhcmVudC5saXN0ZW5lci5zeW5jSGFzaDs8c2NyaXB0PlwiKTtcbiAgICBkLmNsb3NlKCk7XG4gIH0sXG5cbiAgc3luY0hhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJRSBzdXBwb3J0Li4uXG4gICAgdmFyIHMgPSB0aGlzLl9oYXNoO1xuICAgIGlmIChzICE9IGRsb2MuaGFzaCkge1xuICAgICAgZGxvYy5oYXNoID0gcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25IYXNoQ2hhbmdlZDogZnVuY3Rpb24gKCkge31cbn07XG5cbnZhciBSb3V0ZXIgPSBleHBvcnRzLlJvdXRlciA9IGZ1bmN0aW9uIChyb3V0ZXMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJvdXRlcikpIHJldHVybiBuZXcgUm91dGVyKHJvdXRlcyk7XG5cbiAgdGhpcy5wYXJhbXMgICA9IHt9O1xuICB0aGlzLnJvdXRlcyAgID0ge307XG4gIHRoaXMubWV0aG9kcyAgPSBbJ29uJywgJ29uY2UnLCAnYWZ0ZXInLCAnYmVmb3JlJ107XG4gIHRoaXMuc2NvcGUgICAgPSBbXTtcbiAgdGhpcy5fbWV0aG9kcyA9IHt9O1xuXG4gIHRoaXMuX2luc2VydCA9IHRoaXMuaW5zZXJ0O1xuICB0aGlzLmluc2VydCA9IHRoaXMuaW5zZXJ0RXg7XG5cbiAgdGhpcy5oaXN0b3J5U3VwcG9ydCA9ICh3aW5kb3cuaGlzdG9yeSAhPSBudWxsID8gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlIDogbnVsbCkgIT0gbnVsbFxuXG4gIHRoaXMuY29uZmlndXJlKCk7XG4gIHRoaXMubW91bnQocm91dGVzIHx8IHt9KTtcbn07XG5cblJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgcm91dGVUbztcbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24ob25DaGFuZ2VFdmVudCkge1xuICAgIHZhciBuZXdVUkwgPSBvbkNoYW5nZUV2ZW50ICYmIG9uQ2hhbmdlRXZlbnQubmV3VVJMIHx8IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIHZhciB1cmwgPSBzZWxmLmhpc3RvcnkgPT09IHRydWUgPyBzZWxmLmdldFBhdGgoKSA6IG5ld1VSTC5yZXBsYWNlKC8uKiMvLCAnJyk7XG4gICAgc2VsZi5kaXNwYXRjaCgnb24nLCB1cmwuY2hhckF0KDApID09PSAnLycgPyB1cmwgOiAnLycgKyB1cmwpO1xuICB9O1xuXG4gIGxpc3RlbmVyLmluaXQodGhpcy5oYW5kbGVyLCB0aGlzLmhpc3RvcnkpO1xuXG4gIGlmICh0aGlzLmhpc3RvcnkgPT09IGZhbHNlKSB7XG4gICAgaWYgKGRsb2NIYXNoRW1wdHkoKSAmJiByKSB7XG4gICAgICBkbG9jLmhhc2ggPSByO1xuICAgIH0gZWxzZSBpZiAoIWRsb2NIYXNoRW1wdHkoKSkge1xuICAgICAgc2VsZi5kaXNwYXRjaCgnb24nLCAnLycgKyBkbG9jLmhhc2gucmVwbGFjZSgvXigjXFwvfCN8XFwvKS8sICcnKSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLmNvbnZlcnRfaGFzaF9pbl9pbml0KSB7XG4gICAgICAvLyBVc2UgaGFzaCBhcyByb3V0ZVxuICAgICAgcm91dGVUbyA9IGRsb2NIYXNoRW1wdHkoKSAmJiByID8gciA6ICFkbG9jSGFzaEVtcHR5KCkgPyBkbG9jLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiBudWxsO1xuICAgICAgaWYgKHJvdXRlVG8pIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgcm91dGVUbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVXNlIGNhbm9uaWNhbCB1cmxcbiAgICAgIHJvdXRlVG8gPSB0aGlzLmdldFBhdGgoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGJ1dCBkdWUgdG8gdGhlIGNocm9tZSBidWcgaXQgd2lsbCBub3RcbiAgICAvLyB5ZXQgYWN0dWFsbHkgcm91dGUgSFRNTDUgaGlzdG9yeSBzdGF0ZSBjaGFuZ2VzLiBUaHVzLCBkZWNpZGUgaWYgc2hvdWxkIHJvdXRlLlxuICAgIGlmIChyb3V0ZVRvIHx8IHRoaXMucnVuX2luX2luaXQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuaGFuZGxlcigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5leHBsb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdiA9IHRoaXMuaGlzdG9yeSA9PT0gdHJ1ZSA/IHRoaXMuZ2V0UGF0aCgpIDogZGxvYy5oYXNoO1xuICBpZiAodi5jaGFyQXQoMSkgPT09ICcvJykgeyB2PXYuc2xpY2UoMSkgfVxuICByZXR1cm4gdi5zbGljZSgxLCB2Lmxlbmd0aCkuc3BsaXQoXCIvXCIpO1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5zZXRSb3V0ZSA9IGZ1bmN0aW9uIChpLCB2LCB2YWwpIHtcbiAgdmFyIHVybCA9IHRoaXMuZXhwbG9kZSgpO1xuXG4gIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJsW2ldID0gdjtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHVybC5zcGxpY2UoaSwgdiwgcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdXJsID0gW2ldO1xuICB9XG5cbiAgbGlzdGVuZXIuc2V0SGFzaCh1cmwuam9pbignLycpKTtcbiAgcmV0dXJuIHVybDtcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gaW5zZXJ0RXgobWV0aG9kLCBwYXRoLCByb3V0ZSwgcGFyZW50KVxuLy8gIyMjIyBAbWV0aG9kIHtzdHJpbmd9IE1ldGhvZCB0byBpbnNlcnQgdGhlIHNwZWNpZmljIGByb3V0ZWAuXG4vLyAjIyMjIEBwYXRoIHtBcnJheX0gUGFyc2VkIHBhdGggdG8gaW5zZXJ0IHRoZSBgcm91dGVgIGF0LlxuLy8gIyMjIyBAcm91dGUge0FycmF5fGZ1bmN0aW9ufSBSb3V0ZSBoYW5kbGVycyB0byBpbnNlcnQuXG4vLyAjIyMjIEBwYXJlbnQge09iamVjdH0gKipPcHRpb25hbCoqIFBhcmVudCBcInJvdXRlc1wiIHRvIGluc2VydCBpbnRvLlxuLy8gaW5zZXJ0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIG9ubHkgb2NjdXIgb25jZSBwZXIgdGhlIG1hdGNoZWQgcm91dGUuXG4vL1xuUm91dGVyLnByb3RvdHlwZS5pbnNlcnRFeCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGF0aCwgcm91dGUsIHBhcmVudCkge1xuICBpZiAobWV0aG9kID09PSBcIm9uY2VcIikge1xuICAgIG1ldGhvZCA9IFwib25cIjtcbiAgICByb3V0ZSA9IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICB2YXIgb25jZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAob25jZSkgcmV0dXJuO1xuICAgICAgICBvbmNlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJvdXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0ocm91dGUpO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbnNlcnQobWV0aG9kLCBwYXRoLCByb3V0ZSwgcGFyZW50KTtcbn07XG5cblJvdXRlci5wcm90b3R5cGUuZ2V0Um91dGUgPSBmdW5jdGlvbiAodikge1xuICB2YXIgcmV0ID0gdjtcblxuICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXQgPSB0aGlzLmV4cGxvZGUoKVt2XTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIil7XG4gICAgdmFyIGggPSB0aGlzLmV4cGxvZGUoKTtcbiAgICByZXQgPSBoLmluZGV4T2Yodik7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0ID0gdGhpcy5leHBsb2RlKCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBsaXN0ZW5lci5kZXN0cm95KHRoaXMuaGFuZGxlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgaWYgKHBhdGguc3Vic3RyKDAsIDEpICE9PSAnLycpIHtcbiAgICBwYXRoID0gJy8nICsgcGF0aDtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5mdW5jdGlvbiBfZXZlcnkoYXJyLCBpdGVyYXRvcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpdGVyYXRvcihhcnJbaV0sIGksIGFycikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9mbGF0dGVuKGFycikge1xuICB2YXIgZmxhdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBmbGF0ID0gZmxhdC5jb25jYXQoYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gZmxhdDtcbn1cblxuZnVuY3Rpb24gX2FzeW5jRXZlcnlTZXJpZXMoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cbiAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gIChmdW5jdGlvbiBpdGVyYXRlKCkge1xuICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIgfHwgZXJyID09PSBmYWxzZSkge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtaWZ5U3RyaW5nKHN0ciwgcGFyYW1zLCBtb2QpIHtcbiAgbW9kID0gc3RyO1xuICBmb3IgKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgbW9kID0gcGFyYW1zW3BhcmFtXShzdHIpO1xuICAgICAgaWYgKG1vZCAhPT0gc3RyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kID09PSBzdHIgPyBcIihbLl9hLXpBLVowLTktJSgpXSspXCIgOiBtb2Q7XG59XG5cbmZ1bmN0aW9uIHJlZ2lmeVN0cmluZyhzdHIsIHBhcmFtcykge1xuICB2YXIgbWF0Y2hlcywgbGFzdCA9IDAsIG91dCA9IFwiXCI7XG4gIHdoaWxlIChtYXRjaGVzID0gc3RyLnN1YnN0cihsYXN0KS5tYXRjaCgvW15cXHdcXGRcXC0gJUAmXSpcXCpbXlxcd1xcZFxcLSAlQCZdKi8pKSB7XG4gICAgbGFzdCA9IG1hdGNoZXMuaW5kZXggKyBtYXRjaGVzWzBdLmxlbmd0aDtcbiAgICBtYXRjaGVzWzBdID0gbWF0Y2hlc1swXS5yZXBsYWNlKC9eXFwqLywgXCIoW18uKCkhXFxcXCAlQCZhLXpBLVowLTktXSspXCIpO1xuICAgIG91dCArPSBzdHIuc3Vic3RyKDAsIG1hdGNoZXMuaW5kZXgpICsgbWF0Y2hlc1swXTtcbiAgfVxuICBzdHIgPSBvdXQgKz0gc3RyLnN1YnN0cihsYXN0KTtcbiAgdmFyIGNhcHR1cmVzID0gc3RyLm1hdGNoKC86KFteXFwvXSspL2lnKSwgY2FwdHVyZSwgbGVuZ3RoO1xuICBpZiAoY2FwdHVyZXMpIHtcbiAgICBsZW5ndGggPSBjYXB0dXJlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW2ldO1xuICAgICAgaWYgKGNhcHR1cmUuc2xpY2UoMCwgMikgPT09IFwiOjpcIikge1xuICAgICAgICBzdHIgPSBjYXB0dXJlLnNsaWNlKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoY2FwdHVyZSwgcGFyYW1pZnlTdHJpbmcoY2FwdHVyZSwgcGFyYW1zKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHRlcm1pbmF0b3Iocm91dGVzLCBkZWxpbWl0ZXIsIHN0YXJ0LCBzdG9wKSB7XG4gIHZhciBsYXN0ID0gMCwgbGVmdCA9IDAsIHJpZ2h0ID0gMCwgc3RhcnQgPSAoc3RhcnQgfHwgXCIoXCIpLnRvU3RyaW5nKCksIHN0b3AgPSAoc3RvcCB8fCBcIilcIikudG9TdHJpbmcoKSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHJvdXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHVuayA9IHJvdXRlc1tpXTtcbiAgICBpZiAoY2h1bmsuaW5kZXhPZihzdGFydCwgbGFzdCkgPiBjaHVuay5pbmRleE9mKHN0b3AsIGxhc3QpIHx8IH5jaHVuay5pbmRleE9mKHN0YXJ0LCBsYXN0KSAmJiAhfmNodW5rLmluZGV4T2Yoc3RvcCwgbGFzdCkgfHwgIX5jaHVuay5pbmRleE9mKHN0YXJ0LCBsYXN0KSAmJiB+Y2h1bmsuaW5kZXhPZihzdG9wLCBsYXN0KSkge1xuICAgICAgbGVmdCA9IGNodW5rLmluZGV4T2Yoc3RhcnQsIGxhc3QpO1xuICAgICAgcmlnaHQgPSBjaHVuay5pbmRleE9mKHN0b3AsIGxhc3QpO1xuICAgICAgaWYgKH5sZWZ0ICYmICF+cmlnaHQgfHwgIX5sZWZ0ICYmIH5yaWdodCkge1xuICAgICAgICB2YXIgdG1wID0gcm91dGVzLnNsaWNlKDAsIChpIHx8IDEpICsgMSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgICByb3V0ZXMgPSBbIHRtcCBdLmNvbmNhdChyb3V0ZXMuc2xpY2UoKGkgfHwgMSkgKyAxKSk7XG4gICAgICB9XG4gICAgICBsYXN0ID0gKHJpZ2h0ID4gbGVmdCA/IHJpZ2h0IDogbGVmdCkgKyAxO1xuICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm91dGVzO1xufVxuXG52YXIgUVVFUllfU0VQQVJBVE9SID0gL1xcPy4qLztcblxuUm91dGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX21ldGhvZHNbdGhpcy5tZXRob2RzW2ldXSA9IHRydWU7XG4gIH1cbiAgdGhpcy5yZWN1cnNlID0gb3B0aW9ucy5yZWN1cnNlIHx8IHRoaXMucmVjdXJzZSB8fCBmYWxzZTtcbiAgdGhpcy5hc3luYyA9IG9wdGlvbnMuYXN5bmMgfHwgZmFsc2U7XG4gIHRoaXMuZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvXCI7XG4gIHRoaXMuc3RyaWN0ID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0ID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IG9wdGlvbnMuc3RyaWN0O1xuICB0aGlzLm5vdGZvdW5kID0gb3B0aW9ucy5ub3Rmb3VuZDtcbiAgdGhpcy5yZXNvdXJjZSA9IG9wdGlvbnMucmVzb3VyY2U7XG4gIHRoaXMuaGlzdG9yeSA9IG9wdGlvbnMuaHRtbDVoaXN0b3J5ICYmIHRoaXMuaGlzdG9yeVN1cHBvcnQgfHwgZmFsc2U7XG4gIHRoaXMucnVuX2luX2luaXQgPSB0aGlzLmhpc3RvcnkgPT09IHRydWUgJiYgb3B0aW9ucy5ydW5faGFuZGxlcl9pbl9pbml0ICE9PSBmYWxzZTtcbiAgdGhpcy5jb252ZXJ0X2hhc2hfaW5faW5pdCA9IHRoaXMuaGlzdG9yeSA9PT0gdHJ1ZSAmJiBvcHRpb25zLmNvbnZlcnRfaGFzaF9pbl9pbml0ICE9PSBmYWxzZTtcbiAgdGhpcy5ldmVyeSA9IHtcbiAgICBhZnRlcjogb3B0aW9ucy5hZnRlciB8fCBudWxsLFxuICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgfHwgbnVsbCxcbiAgICBvbjogb3B0aW9ucy5vbiB8fCBudWxsXG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5wYXJhbSA9IGZ1bmN0aW9uKHRva2VuLCBtYXRjaGVyKSB7XG4gIGlmICh0b2tlblswXSAhPT0gXCI6XCIpIHtcbiAgICB0b2tlbiA9IFwiOlwiICsgdG9rZW47XG4gIH1cbiAgdmFyIGNvbXBpbGVkID0gbmV3IFJlZ0V4cCh0b2tlbiwgXCJnXCIpO1xuICB0aGlzLnBhcmFtc1t0b2tlbl0gPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY29tcGlsZWQsIG1hdGNoZXIuc291cmNlIHx8IG1hdGNoZXIpO1xuICB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cblJvdXRlci5wcm90b3R5cGUub24gPSBSb3V0ZXIucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCByb3V0ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghcm91dGUgJiYgdHlwZW9mIHBhdGggPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm91dGUgPSBwYXRoO1xuICAgIHBhdGggPSBtZXRob2Q7XG4gICAgbWV0aG9kID0gXCJvblwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGguZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBzZWxmLm9uKG1ldGhvZCwgcCwgcm91dGUpO1xuICAgIH0pO1xuICB9XG4gIGlmIChwYXRoLnNvdXJjZSkge1xuICAgIHBhdGggPSBwYXRoLnNvdXJjZS5yZXBsYWNlKC9cXFxcXFwvL2lnLCBcIi9cIik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobWV0aG9kKSkge1xuICAgIHJldHVybiBtZXRob2QuZm9yRWFjaChmdW5jdGlvbihtKSB7XG4gICAgICBzZWxmLm9uKG0udG9Mb3dlckNhc2UoKSwgcGF0aCwgcm91dGUpO1xuICAgIH0pO1xuICB9XG4gIHBhdGggPSBwYXRoLnNwbGl0KG5ldyBSZWdFeHAodGhpcy5kZWxpbWl0ZXIpKTtcbiAgcGF0aCA9IHRlcm1pbmF0b3IocGF0aCwgdGhpcy5kZWxpbWl0ZXIpO1xuICB0aGlzLmluc2VydChtZXRob2QsIHRoaXMuc2NvcGUuY29uY2F0KHBhdGgpLCByb3V0ZSk7XG59O1xuXG5Sb3V0ZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihwYXRoLCByb3V0ZXNGbikge1xuICB2YXIgc2VsZiA9IHRoaXMsIGxlbmd0aCA9IHRoaXMuc2NvcGUubGVuZ3RoO1xuICBpZiAocGF0aC5zb3VyY2UpIHtcbiAgICBwYXRoID0gcGF0aC5zb3VyY2UucmVwbGFjZSgvXFxcXFxcLy9pZywgXCIvXCIpO1xuICB9XG4gIHBhdGggPSBwYXRoLnNwbGl0KG5ldyBSZWdFeHAodGhpcy5kZWxpbWl0ZXIpKTtcbiAgcGF0aCA9IHRlcm1pbmF0b3IocGF0aCwgdGhpcy5kZWxpbWl0ZXIpO1xuICB0aGlzLnNjb3BlID0gdGhpcy5zY29wZS5jb25jYXQocGF0aCk7XG4gIHJvdXRlc0ZuLmNhbGwodGhpcywgdGhpcyk7XG4gIHRoaXMuc2NvcGUuc3BsaWNlKGxlbmd0aCwgcGF0aC5sZW5ndGgpO1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGF0aCwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBmbnMgPSB0aGlzLnRyYXZlcnNlKG1ldGhvZCwgcGF0aC5yZXBsYWNlKFFVRVJZX1NFUEFSQVRPUiwgXCJcIiksIHRoaXMucm91dGVzLCBcIlwiKSwgaW52b2tlZCA9IHRoaXMuX2ludm9rZWQsIGFmdGVyO1xuICB0aGlzLl9pbnZva2VkID0gdHJ1ZTtcbiAgaWYgKCFmbnMgfHwgZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMubGFzdCA9IFtdO1xuICAgIGlmICh0eXBlb2YgdGhpcy5ub3Rmb3VuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLmludm9rZShbIHRoaXMubm90Zm91bmQgXSwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMucmVjdXJzZSA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICBmbnMgPSBmbnMucmV2ZXJzZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUFuZEludm9rZSgpIHtcbiAgICBzZWxmLmxhc3QgPSBmbnMuYWZ0ZXI7XG4gICAgc2VsZi5pbnZva2Uoc2VsZi5ydW5saXN0KGZucyksIHNlbGYsIGNhbGxiYWNrKTtcbiAgfVxuICBhZnRlciA9IHRoaXMuZXZlcnkgJiYgdGhpcy5ldmVyeS5hZnRlciA/IFsgdGhpcy5ldmVyeS5hZnRlciBdLmNvbmNhdCh0aGlzLmxhc3QpIDogWyB0aGlzLmxhc3QgXTtcbiAgaWYgKGFmdGVyICYmIGFmdGVyLmxlbmd0aCA+IDAgJiYgaW52b2tlZCkge1xuICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICB0aGlzLmludm9rZShhZnRlciwgdGhpcywgdXBkYXRlQW5kSW52b2tlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnZva2UoYWZ0ZXIsIHRoaXMpO1xuICAgICAgdXBkYXRlQW5kSW52b2tlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZUFuZEludm9rZSgpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJvdXRlci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24oZm5zLCB0aGlzQXJnLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcHBseTtcbiAgaWYgKHRoaXMuYXN5bmMpIHtcbiAgICBhcHBseSA9IGZ1bmN0aW9uKGZuLCBuZXh0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICAgICAgcmV0dXJuIF9hc3luY0V2ZXJ5U2VyaWVzKGZuLCBhcHBseSwgbmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgKGZucy5jYXB0dXJlcyB8fCBbXSkuY29uY2F0KG5leHQpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9hc3luY0V2ZXJ5U2VyaWVzKGZucywgYXBwbHksIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXBwbHkgPSBmdW5jdGlvbihmbikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgICAgIHJldHVybiBfZXZlcnkoZm4sIGFwcGx5KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGZucy5jYXB0dXJlcyB8fCBbXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbiA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLnJlc291cmNlKSB7XG4gICAgICAgIHNlbGYucmVzb3VyY2VbZm5dLmFwcGx5KHRoaXNBcmcsIGZucy5jYXB0dXJlcyB8fCBbXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfZXZlcnkoZm5zLCBhcHBseSk7XG4gIH1cbn07XG5cblJvdXRlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbihtZXRob2QsIHBhdGgsIHJvdXRlcywgcmVnZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGZucyA9IFtdLCBjdXJyZW50LCBleGFjdCwgbWF0Y2gsIG5leHQsIHRoYXQ7XG4gIGZ1bmN0aW9uIGZpbHRlclJvdXRlcyhyb3V0ZXMpIHtcbiAgICBpZiAoIWZpbHRlcikge1xuICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVlcENvcHkoc291cmNlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBBcnJheS5pc0FycmF5KHNvdXJjZVtpXSkgPyBkZWVwQ29weShzb3VyY2VbaV0pIDogc291cmNlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlGaWx0ZXIoZm5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gZm5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgICAgICBhcHBseUZpbHRlcihmbnNbaV0pO1xuICAgICAgICAgIGlmIChmbnNbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWZpbHRlcihmbnNbaV0pKSB7XG4gICAgICAgICAgICBmbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um91dGVzID0gZGVlcENvcHkocm91dGVzKTtcbiAgICBuZXdSb3V0ZXMubWF0Y2hlZCA9IHJvdXRlcy5tYXRjaGVkO1xuICAgIG5ld1JvdXRlcy5jYXB0dXJlcyA9IHJvdXRlcy5jYXB0dXJlcztcbiAgICBuZXdSb3V0ZXMuYWZ0ZXIgPSByb3V0ZXMuYWZ0ZXIuZmlsdGVyKGZpbHRlcik7XG4gICAgYXBwbHlGaWx0ZXIobmV3Um91dGVzKTtcbiAgICByZXR1cm4gbmV3Um91dGVzO1xuICB9XG4gIGlmIChwYXRoID09PSB0aGlzLmRlbGltaXRlciAmJiByb3V0ZXNbbWV0aG9kXSkge1xuICAgIG5leHQgPSBbIFsgcm91dGVzLmJlZm9yZSwgcm91dGVzW21ldGhvZF0gXS5maWx0ZXIoQm9vbGVhbikgXTtcbiAgICBuZXh0LmFmdGVyID0gWyByb3V0ZXMuYWZ0ZXIgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgbmV4dC5tYXRjaGVkID0gdHJ1ZTtcbiAgICBuZXh0LmNhcHR1cmVzID0gW107XG4gICAgcmV0dXJuIGZpbHRlclJvdXRlcyhuZXh0KTtcbiAgfVxuICBmb3IgKHZhciByIGluIHJvdXRlcykge1xuICAgIGlmIChyb3V0ZXMuaGFzT3duUHJvcGVydHkocikgJiYgKCF0aGlzLl9tZXRob2RzW3JdIHx8IHRoaXMuX21ldGhvZHNbcl0gJiYgdHlwZW9mIHJvdXRlc1tyXSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShyb3V0ZXNbcl0pKSkge1xuICAgICAgY3VycmVudCA9IGV4YWN0ID0gcmVnZXhwICsgdGhpcy5kZWxpbWl0ZXIgKyByO1xuICAgICAgaWYgKCF0aGlzLnN0cmljdCkge1xuICAgICAgICBleGFjdCArPSBcIltcIiArIHRoaXMuZGVsaW1pdGVyICsgXCJdP1wiO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoXCJeXCIgKyBleGFjdCkpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaFswXSAmJiBtYXRjaFswXSA9PSBwYXRoICYmIHJvdXRlc1tyXVttZXRob2RdKSB7XG4gICAgICAgIG5leHQgPSBbIFsgcm91dGVzW3JdLmJlZm9yZSwgcm91dGVzW3JdW21ldGhvZF0gXS5maWx0ZXIoQm9vbGVhbikgXTtcbiAgICAgICAgbmV4dC5hZnRlciA9IFsgcm91dGVzW3JdLmFmdGVyIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBuZXh0Lm1hdGNoZWQgPSB0cnVlO1xuICAgICAgICBuZXh0LmNhcHR1cmVzID0gbWF0Y2guc2xpY2UoMSk7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2UgJiYgcm91dGVzID09PSB0aGlzLnJvdXRlcykge1xuICAgICAgICAgIG5leHQucHVzaChbIHJvdXRlcy5iZWZvcmUsIHJvdXRlcy5vbiBdLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgbmV4dC5hZnRlciA9IG5leHQuYWZ0ZXIuY29uY2F0KFsgcm91dGVzLmFmdGVyIF0uZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyUm91dGVzKG5leHQpO1xuICAgICAgfVxuICAgICAgbmV4dCA9IHRoaXMudHJhdmVyc2UobWV0aG9kLCBwYXRoLCByb3V0ZXNbcl0sIGN1cnJlbnQpO1xuICAgICAgaWYgKG5leHQubWF0Y2hlZCkge1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm5zID0gZm5zLmNvbmNhdChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWN1cnNlKSB7XG4gICAgICAgICAgZm5zLnB1c2goWyByb3V0ZXNbcl0uYmVmb3JlLCByb3V0ZXNbcl0ub24gXS5maWx0ZXIoQm9vbGVhbikpO1xuICAgICAgICAgIG5leHQuYWZ0ZXIgPSBuZXh0LmFmdGVyLmNvbmNhdChbIHJvdXRlc1tyXS5hZnRlciBdLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgaWYgKHJvdXRlcyA9PT0gdGhpcy5yb3V0ZXMpIHtcbiAgICAgICAgICAgIGZucy5wdXNoKFsgcm91dGVzW1wiYmVmb3JlXCJdLCByb3V0ZXNbXCJvblwiXSBdLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgICBuZXh0LmFmdGVyID0gbmV4dC5hZnRlci5jb25jYXQoWyByb3V0ZXNbXCJhZnRlclwiXSBdLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZucy5tYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgZm5zLmNhcHR1cmVzID0gbmV4dC5jYXB0dXJlcztcbiAgICAgICAgZm5zLmFmdGVyID0gbmV4dC5hZnRlcjtcbiAgICAgICAgcmV0dXJuIGZpbHRlclJvdXRlcyhmbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Sb3V0ZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGF0aCwgcm91dGUsIHBhcmVudCkge1xuICB2YXIgbWV0aG9kVHlwZSwgcGFyZW50VHlwZSwgaXNBcnJheSwgbmVzdGVkLCBwYXJ0O1xuICBwYXRoID0gcGF0aC5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBwICYmIHAubGVuZ3RoID4gMDtcbiAgfSk7XG4gIHBhcmVudCA9IHBhcmVudCB8fCB0aGlzLnJvdXRlcztcbiAgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgaWYgKC9cXDp8XFwqLy50ZXN0KHBhcnQpICYmICEvXFxcXGR8XFxcXHcvLnRlc3QocGFydCkpIHtcbiAgICBwYXJ0ID0gcmVnaWZ5U3RyaW5nKHBhcnQsIHRoaXMucGFyYW1zKTtcbiAgfVxuICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgcGFyZW50W3BhcnRdID0gcGFyZW50W3BhcnRdIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLmluc2VydChtZXRob2QsIHBhdGgsIHJvdXRlLCBwYXJlbnRbcGFydF0pO1xuICB9XG4gIGlmICghcGFydCAmJiAhcGF0aC5sZW5ndGggJiYgcGFyZW50ID09PSB0aGlzLnJvdXRlcykge1xuICAgIG1ldGhvZFR5cGUgPSB0eXBlb2YgcGFyZW50W21ldGhvZF07XG4gICAgc3dpdGNoIChtZXRob2RUeXBlKSB7XG4gICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcGFyZW50W21ldGhvZF0gPSBbIHBhcmVudFttZXRob2RdLCByb3V0ZSBdO1xuICAgICAgcmV0dXJuO1xuICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBwYXJlbnRbbWV0aG9kXS5wdXNoKHJvdXRlKTtcbiAgICAgIHJldHVybjtcbiAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcGFyZW50W21ldGhvZF0gPSByb3V0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhcmVudFR5cGUgPSB0eXBlb2YgcGFyZW50W3BhcnRdO1xuICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwYXJlbnRbcGFydF0pO1xuICBpZiAocGFyZW50W3BhcnRdICYmICFpc0FycmF5ICYmIHBhcmVudFR5cGUgPT0gXCJvYmplY3RcIikge1xuICAgIG1ldGhvZFR5cGUgPSB0eXBlb2YgcGFyZW50W3BhcnRdW21ldGhvZF07XG4gICAgc3dpdGNoIChtZXRob2RUeXBlKSB7XG4gICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcGFyZW50W3BhcnRdW21ldGhvZF0gPSBbIHBhcmVudFtwYXJ0XVttZXRob2RdLCByb3V0ZSBdO1xuICAgICAgcmV0dXJuO1xuICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBwYXJlbnRbcGFydF1bbWV0aG9kXS5wdXNoKHJvdXRlKTtcbiAgICAgIHJldHVybjtcbiAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcGFyZW50W3BhcnRdW21ldGhvZF0gPSByb3V0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VHlwZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbmVzdGVkID0ge307XG4gICAgbmVzdGVkW21ldGhvZF0gPSByb3V0ZTtcbiAgICBwYXJlbnRbcGFydF0gPSBuZXN0ZWQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm91dGUgY29udGV4dDogXCIgKyBwYXJlbnRUeXBlKTtcbn07XG5cblxuXG5Sb3V0ZXIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBsZW4gPSBtZXRob2RzLmxlbmd0aCwgaTtcbiAgZnVuY3Rpb24gZXh0ZW5kKG1ldGhvZCkge1xuICAgIHNlbGYuX21ldGhvZHNbbWV0aG9kXSA9IHRydWU7XG4gICAgc2VsZlttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXh0cmEgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gWyBtZXRob2QsIFwiXCIgXSA6IFsgbWV0aG9kIF07XG4gICAgICBzZWxmLm9uLmFwcGx5KHNlbGYsIGV4dHJhLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBleHRlbmQobWV0aG9kc1tpXSk7XG4gIH1cbn07XG5cblJvdXRlci5wcm90b3R5cGUucnVubGlzdCA9IGZ1bmN0aW9uKGZucykge1xuICB2YXIgcnVubGlzdCA9IHRoaXMuZXZlcnkgJiYgdGhpcy5ldmVyeS5iZWZvcmUgPyBbIHRoaXMuZXZlcnkuYmVmb3JlIF0uY29uY2F0KF9mbGF0dGVuKGZucykpIDogX2ZsYXR0ZW4oZm5zKTtcbiAgaWYgKHRoaXMuZXZlcnkgJiYgdGhpcy5ldmVyeS5vbikge1xuICAgIHJ1bmxpc3QucHVzaCh0aGlzLmV2ZXJ5Lm9uKTtcbiAgfVxuICBydW5saXN0LmNhcHR1cmVzID0gZm5zLmNhcHR1cmVzO1xuICBydW5saXN0LnNvdXJjZSA9IGZucy5zb3VyY2U7XG4gIHJldHVybiBydW5saXN0O1xufTtcblxuUm91dGVyLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uKHJvdXRlcywgcGF0aCkge1xuICBpZiAoIXJvdXRlcyB8fCB0eXBlb2Ygcm91dGVzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHBhdGggPSBwYXRoIHx8IFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBwYXRoID0gcGF0aC5zcGxpdChzZWxmLmRlbGltaXRlcik7XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0T3JNb3VudChyb3V0ZSwgbG9jYWwpIHtcbiAgICB2YXIgcmVuYW1lID0gcm91dGUsIHBhcnRzID0gcm91dGUuc3BsaXQoc2VsZi5kZWxpbWl0ZXIpLCByb3V0ZVR5cGUgPSB0eXBlb2Ygcm91dGVzW3JvdXRlXSwgaXNSb3V0ZSA9IHBhcnRzWzBdID09PSBcIlwiIHx8ICFzZWxmLl9tZXRob2RzW3BhcnRzWzBdXSwgZXZlbnQgPSBpc1JvdXRlID8gXCJvblwiIDogcmVuYW1lO1xuICAgIGlmIChpc1JvdXRlKSB7XG4gICAgICByZW5hbWUgPSByZW5hbWUuc2xpY2UoKHJlbmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXlwiICsgc2VsZi5kZWxpbWl0ZXIpKSB8fCBbIFwiXCIgXSlbMF0ubGVuZ3RoKTtcbiAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChpc1JvdXRlICYmIHJvdXRlVHlwZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShyb3V0ZXNbcm91dGVdKSkge1xuICAgICAgbG9jYWwgPSBsb2NhbC5jb25jYXQocGFydHMpO1xuICAgICAgc2VsZi5tb3VudChyb3V0ZXNbcm91dGVdLCBsb2NhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JvdXRlKSB7XG4gICAgICBsb2NhbCA9IGxvY2FsLmNvbmNhdChyZW5hbWUuc3BsaXQoc2VsZi5kZWxpbWl0ZXIpKTtcbiAgICAgIGxvY2FsID0gdGVybWluYXRvcihsb2NhbCwgc2VsZi5kZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBzZWxmLmluc2VydChldmVudCwgbG9jYWwsIHJvdXRlc1tyb3V0ZV0pO1xuICB9XG4gIGZvciAodmFyIHJvdXRlIGluIHJvdXRlcykge1xuICAgIGlmIChyb3V0ZXMuaGFzT3duUHJvcGVydHkocm91dGUpKSB7XG4gICAgICBpbnNlcnRPck1vdW50KHJvdXRlLCBwYXRoLnNsaWNlKDApKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG59KHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiID8gZXhwb3J0cyA6IHdpbmRvdykpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kaXJlY3Rvci9idWlsZC9kaXJlY3Rvci5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTIhLi9sYXlvdXQuc3R5bFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vbGF5b3V0LnN0eWxcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2xheW91dC5zdHlsXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Nzcy9sYXlvdXQuc3R5bFxuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCxcXG5ib2R5IHtcXG4gIG1hcmdpbjogMDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgYmFja2dyb3VuZDogI2VmZWZlZjtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuYSB7XFxuICBjb2xvcjogIzJkOGNmMDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUge1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGNvbG9yOiAjMDAwO1xcbn1cXG5oMSB7XFxuICBmb250LXNpemU6IDJlbTtcXG59XFxuaDIge1xcbiAgZm9udC1zaXplOiAxLjhlbTtcXG59XFxuaDMge1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuY29kZSB7XFxuICBjb2xvcjogI2M3MjU0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmOWYyZjQ7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBwYWRkaW5nOiAwIDVweDtcXG59XFxuYmxvY2txdW90ZSB7XFxuICBtYXJnaW46IDFlbSAwO1xcbiAgcGFkZGluZzogMXB4IDJlbTtcXG4gIGJhY2tncm91bmQ6ICNmOGY4Zjg7XFxuICBib3JkZXItcmFkaXVzOiAwIDNweCAzcHggMDtcXG4gIGJvcmRlci1sZWZ0OiAycHggc29saWQgI2ZlNDQ0NDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuYmxvY2txdW90ZTpiZWZvcmUge1xcbiAgY29udGVudDogJyEnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIG1hcmdpbi10b3A6IC0xMHB4O1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBib3JkZXItcmFkaXVzOiAxMDAlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZDogI2ZlNDQ0NDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICBsZWZ0OiAtMTFweDtcXG59XFxuI3BhZ2UsXFxuLmFwcC13cmFwcGVyLFxcbi5tYWluLXdyYXBwZXIge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG4uaGVhZGVyLXdyYXBwZXIge1xcbiAgaGVpZ2h0OiA4MHB4O1xcbiAgbGluZS1oZWlnaHQ6IDgwcHg7XFxuICBib3gtc2hhZG93OiAwIDJweCA1cHggcmdiYSgwLDAsMCwwLjA4KTtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB3aWR0aDogMTAwJTtcXG4gIHRvcDogMDtcXG4gIHotaW5kZXg6IDk5OTtcXG59XFxuLmhlYWRlci13cmFwcGVyIGhlYWRlciB7XFxuICB3aWR0aDogMTA4MHB4O1xcbiAgbWFyZ2luOiAwIGF1dG87XFxufVxcbi5oZWFkZXItd3JhcHBlciAubG9nbyB7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICBjb2xvcjogIzMzMztcXG4gIG1hcmdpbi1sZWZ0OiAyMHB4O1xcbn1cXG4uaGVhZGVyLXdyYXBwZXIgbmF2IHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmhlYWRlci13cmFwcGVyIG5hdiBhIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBhZGRpbmc6IDAgMjBweDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uaGVhZGVyLXdyYXBwZXIgbmF2IGEuYWN0aXZlIHtcXG4gIGNvbG9yOiAjZmU0NDQ0O1xcbn1cXG4uaGVhZGVyLXdyYXBwZXIgLmJvcmRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDA7XFxuICBib3JkZXItYm90dG9tOiAycHggc29saWQgI2ZlNDQ0NDtcXG59XFxuLnRyYW5zaXRpb24ge1xcbiAgdHJhbnNpdGlvbjogYWxsIDM1MG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjEsIDEpO1xcbn1cXG4uYmx1ZSB7XFxuICBjb2xvcjogIzA5ZDtcXG59XFxuLnJlZCB7XFxuICBjb2xvcjogI2QwNDtcXG59XFxuLnllbGxvdyB7XFxuICBjb2xvcjogI2ZmYzQwMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyP3tcImluY2x1ZGUgY3NzXCI6dHJ1ZX0hLi9jc3MvbGF5b3V0LnN0eWxcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMyJdLCJzb3VyY2VSb290IjoiIn0=