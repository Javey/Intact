webpackJsonp([1],Array(35).concat([
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _document = __webpack_require__(126);

var _document2 = _interopRequireDefault(_document);

var _document3 = __webpack_require__(127);

var _document4 = _interopRequireDefault(_document3);

var _throttle = __webpack_require__(129);

var _throttle2 = _interopRequireDefault(_throttle);

var _shuffle = __webpack_require__(135);

var _shuffle2 = _interopRequireDefault(_shuffle);

var _debounce = __webpack_require__(120);

var _debounce2 = _interopRequireDefault(_debounce);

var _utils = __webpack_require__(57);

var _layout = __webpack_require__(119);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// for debug
window.Intact = Intact;
window._ = { throttle: _throttle2.default, shuffle: _shuffle2.default, debounce: _debounce2.default };
window.$ = $;

var _class = function (_Layout) {
    _inherits(_class, _Layout);

    function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _Layout.apply(this, arguments));
    }

    _class.prototype._init = function _init() {
        var _this2 = this;

        return fetch('./docs/' + this.get('title') + '.md').then(function (response) {
            return response.text();
        }).then(function (md) {
            _this2.set('content', _utils.marked.render(md));
        });
    };

    _class.prototype._mount = function _mount() {
        _Layout.prototype._mount.call(this);
        var codes = this.element.querySelectorAll('pre code');
        codes.forEach(function (item) {
            _utils.highlight.highlightBlock(item);
        });
        var catalogs = [];
        catalogs.active = 'active1';
        this.element.querySelectorAll('h1').forEach(function (item) {
            var catalog = { title: item.innerText };
            var nextSibling = item.nextSibling;
            while (nextSibling) {
                var tagName = (nextSibling.tagName || '').toLowerCase();
                if (tagName === 'h1') break;
                if (tagName === 'h2') {
                    if (!catalog.subs) {
                        catalog.subs = [];
                        catalog.subs.active = 'active2';
                    }
                    catalog.subs.push({
                        title: nextSibling.innerText
                    });
                }
                nextSibling = nextSibling.nextSibling;
            }
            catalogs.push(catalog);
        });
        this.set('subCatalogs', catalogs);

        this.evalScript();
        this.onScroll();
    };

    _class.prototype.evalScript = function evalScript() {
        var $examples = $(this.element).find('.example');
        var template = void 0;
        for (var i = 0; i < $examples.length; i++) {
            var $example = $examples.eq(i);
            var code = $example.text();
            if ($example.hasClass('auto')) {
                var _C = void 0;
                if ($example.hasClass('language-html')) {
                    template = Intact.Vdt.compile(code);
                    _C = Intact.extend({
                        template: template
                    });
                } else if ($example.hasClass('javascript')) {
                    _C = eval(code);
                }
                var $container = $('<div class="output"></div>');
                $example.parent().after($container);
                Intact.mount(_C, $container[0]);
            } else if ($example.hasClass('manual')) {
                var $button = $('<button>点击运行</button>');
                var $p = $('<p></p>').append($button);
                $example.parent().after($p);
                $button.on('click', function (code) {
                    return function () {
                        eval(code);
                    };
                }(code));
            } else if ($example.hasClass('language-html')) {
                template = Intact.Vdt.compile(code);
            } else if ($example.hasClass('javascript')) {
                eval(code);
            } else if ($example.hasClass('language-css')) {
                $example.parent().after('<style>' + code + '</style>');
            }
        }

        // 执行script标签
        var $scripts = $(this.element).find('script');
        for (var _i = 0; _i < $scripts.length; _i++) {
            var $script = $scripts.eq(_i);
            var _code = $script.text();
            eval(_code);
        }
    };

    _class.prototype.onScroll = function onScroll() {
        var _this3 = this;

        var $wrapper = $(this.element).find('.content-wrapper');
        var $article = $(this.element).find('article');
        var $h1s = $article.find('h1');
        var $h2s = $article.find('h2');
        var $aside = $(this.element).find('aside');
        var $border = $aside.find('.aside-border');
        var $window = $(window);
        $window.off('scroll');
        $window.on('scroll.fix', function () {
            var scrollTop = $(window).scrollTop();
            $wrapper[scrollTop >= 15 ? 'addClass' : 'removeClass']('fixed');
        });
        $window.on('scroll.active', (0, _throttle2.default)(function () {
            var scrollTop = $(window).scrollTop();

            function findActive($hs) {
                var minTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                for (var i = $hs.length - 1; i >= 0; i--) {
                    var $h = $hs.eq(i);
                    var top = $h.position().top;
                    if (top > minTop && scrollTop >= top - 60) {
                        return {
                            text: $h.text(),
                            top: top
                        };
                    }
                }
                return { text: '', top: 0 };
            }

            var active1 = findActive($h1s);
            var active2 = findActive($h2s, active1.top);

            _this3.set({
                active2: active2.text,
                active1: active1.text
            });

            $activeA = $aside.find('.active').last().children('a');
            if ($activeA.length) {
                var height = $activeA.height();
                var top = $activeA.position().top;
                $border.css({ height: height, top: top });
            }
        }, 50));
        $window.trigger('scroll');
    };

    _class.prototype.scrollTo = function scrollTo(text, type) {
        var _this4 = this;

        var $article = $(this.element).find('article');
        var $hs = $article.find(type === 'active1' ? 'h1' : 'h2');

        for (var i = 0; i < $hs.length; i++) {
            var $h = $hs.eq(i);
            if ($h.text() === text) {
                var top = $h.position().top;
                $(window).off('scroll.active');
                $('html, body').animate({
                    scrollTop: top - 60
                }, {
                    complete: function complete() {
                        _this4.onScroll();
                    }
                });
                break;
            }
        }
    };

    _class.prototype._destroy = function _destroy() {
        $(window).off('scroll');
    };

    _createClass(_class, [{
        key: 'template',
        get: function get() {
            return _document2.default;
        }
    }]);

    return _class;
}(_layout2.default);

exports.default = _class;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(16)))

/***/ }),
/* 36 */,
/* 37 */,
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(45);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(39);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(46);
exports.lib.ucmicro = __webpack_require__(65);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 40 */
/***/ (function(module, exports) {



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 41 */
/***/ (function(module, exports) {



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(122),
    getRawTag = __webpack_require__(133),
    objectToString = __webpack_require__(134);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {



/*eslint quotes:0*/
module.exports = __webpack_require__(60);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {



module.exports.encode = __webpack_require__(61);
module.exports.decode = __webpack_require__(62);
module.exports.format = __webpack_require__(63);
module.exports.parse = __webpack_require__(64);

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 50 */
/***/ (function(module, exports) {



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 51 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 52 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 53 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(121);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (obj, _Vdt, blocks) {
    if (false) {
        var __this = this;
        module.hot.dispose(function (data) {
            data.vdt = __this;
            data.isParent = __this.data !== obj;
        });
    }

    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        scope = obj,
        Animate = self && self.Animate,
        parent = self && self._parentTemplate;
    var nav = [{
        title: '教程',
        href: 'document'
    }, {
        title: 'API',
        href: 'api'
    }];
    return h('div', null, [h('div', null, h('header', null, (_blocks.header = function (parent) {
        return [h('a', { 'href': '#/' }, 'Intact', 'logo'), h('nav', null, [_Vdt.utils.map(function () {
            try {
                return [nav][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), function (value, key) {
            return h('a', { 'href': function () {
                    try {
                        return ['#/' + value.href][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, function () {
                try {
                    return [value.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this), _className(function () {
                try {
                    return [{
                        active: value.href === scope.navIndex
                    }][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)));
        }, this), h('div', null, null, 'border')])];
    }) && (__blocks.header = function (parent) {
        var self = this;
        return blocks.header ? blocks.header.call(this, function () {
            return _blocks.header.call(self, parent);
        }) : _blocks.header.call(this, parent);
    }) && __blocks.header.call(this)), 'header-wrapper'), h('div', null, (_blocks.content = function (parent) {
        return null;
    }) && (__blocks.content = function (parent) {
        var self = this;
        return blocks.content ? blocks.content.call(this, function () {
            return _blocks.content.call(self, parent);
        }) : _blocks.content.call(this, parent);
    }) && __blocks.content.call(this), 'content-wrapper')], _className(function () {
        try {
            return ['main-wrapper ' + (scope.className || '')][0];
        } catch (e) {
            _e(e);
        }
    }.call(this)));
};
if (false) {
    module.hot.accept();
    var vdt = module.hot.data && module.hot.data.vdt;
    if (vdt) {
        if (!module.hot.data.isParent) {
            vdt.template = module.exports;
        }
        vdt.update();
    }
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.marked = exports.highlight = undefined;

var _markdownIt = __webpack_require__(58);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _markdownItDecorate = __webpack_require__(113);

var _markdownItDecorate2 = _interopRequireDefault(_markdownItDecorate);

var _highlight = __webpack_require__(114);

var _highlight2 = _interopRequireDefault(_highlight);

var _javascript = __webpack_require__(115);

var _javascript2 = _interopRequireDefault(_javascript);

var _css = __webpack_require__(116);

var _css2 = _interopRequireDefault(_css);

var _xml = __webpack_require__(117);

var _xml2 = _interopRequireDefault(_xml);

var _bash = __webpack_require__(118);

var _bash2 = _interopRequireDefault(_bash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_highlight2.default.registerLanguage('bash', _bash2.default);
_highlight2.default.registerLanguage('css', _css2.default);
_highlight2.default.registerLanguage('javascript', _javascript2.default);
_highlight2.default.registerLanguage('xml', _xml2.default);

window.highlight = _highlight2.default;

var marked = (0, _markdownIt2.default)({
    html: true,
    breaks: false
}).use(_markdownItDecorate2.default);
// 去掉段落softbreak
marked.renderer.rules.softbreak = function () {
    return '';
};

exports.highlight = _highlight2.default;
exports.marked = marked;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = __webpack_require__(59);

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {



var utils = __webpack_require__(38);
var helpers = __webpack_require__(67);
var Renderer = __webpack_require__(71);
var ParserCore = __webpack_require__(72);
var ParserBlock = __webpack_require__(80);
var ParserInline = __webpack_require__(94);
var LinkifyIt = __webpack_require__(107);
var mdurl = __webpack_require__(46);
var punycode = __webpack_require__(109);

var config = {
  'default': __webpack_require__(110),
  zero: __webpack_require__(111),
  commonmark: __webpack_require__(112)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 61 */
/***/ (function(module, exports) {



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 62 */
/***/ (function(module, exports) {



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 63 */
/***/ (function(module, exports) {



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 64 */
/***/ (function(module, exports) {



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {



exports.Any = __webpack_require__(47);
exports.Cc = __webpack_require__(48);
exports.Cf = __webpack_require__(66);
exports.P = __webpack_require__(39);
exports.Z = __webpack_require__(49);

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {



exports.parseLinkLabel = __webpack_require__(68);
exports.parseLinkDestination = __webpack_require__(69);
exports.parseLinkTitle = __webpack_require__(70);

/***/ }),
/* 68 */
/***/ (function(module, exports) {



module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;
var unescapeAll = __webpack_require__(38).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {



var unescapeAll = __webpack_require__(38).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {



var assign = __webpack_require__(38).assign;
var unescapeAll = __webpack_require__(38).unescapeAll;
var escapeHtml = __webpack_require__(38).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

var _rules = [['normalize', __webpack_require__(73)], ['block', __webpack_require__(74)], ['inline', __webpack_require__(75)], ['linkify', __webpack_require__(76)], ['replacements', __webpack_require__(77)], ['smartquotes', __webpack_require__(78)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(79);

module.exports = Core;

/***/ }),
/* 73 */
/***/ (function(module, exports) {



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 74 */
/***/ (function(module, exports) {



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 75 */
/***/ (function(module, exports) {



module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {



var arrayReplaceAt = __webpack_require__(38).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 77 */
/***/ (function(module, exports) {



// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {



var isWhiteSpace = __webpack_require__(38).isWhiteSpace;
var isPunctChar = __webpack_require__(38).isPunctChar;
var isMdAsciiPunct = __webpack_require__(38).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(81), ['paragraph', 'reference']], ['code', __webpack_require__(82)], ['fence', __webpack_require__(83), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(84), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(85), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(86), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(87)], ['heading', __webpack_require__(88), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(89)], ['html_block', __webpack_require__(90), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(92)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(93);

module.exports = ParserBlock;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 82 */
/***/ (function(module, exports) {



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 83 */
/***/ (function(module, exports) {



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false;

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !wasOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 89 */
/***/ (function(module, exports) {



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {



var block_names = __webpack_require__(91);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(50).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 91 */
/***/ (function(module, exports) {



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 92 */
/***/ (function(module, exports) {



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);
var isSpace = __webpack_require__(38).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(95)], ['newline', __webpack_require__(96)], ['escape', __webpack_require__(97)], ['backticks', __webpack_require__(98)], ['strikethrough', __webpack_require__(51).tokenize], ['emphasis', __webpack_require__(52).tokenize], ['link', __webpack_require__(99)], ['image', __webpack_require__(100)], ['autolink', __webpack_require__(101)], ['html_inline', __webpack_require__(102)], ['entity', __webpack_require__(103)]];

var _rules2 = [['balance_pairs', __webpack_require__(104)], ['strikethrough', __webpack_require__(51).postProcess], ['emphasis', __webpack_require__(52).postProcess], ['text_collapse', __webpack_require__(105)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(106);

module.exports = ParserInline;

/***/ }),
/* 95 */
/***/ (function(module, exports) {



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 98 */
/***/ (function(module, exports) {



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {



/*eslint max-len:0*/
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {



var HTML_TAG_RE = __webpack_require__(50).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {



var entities = __webpack_require__(45);
var has = __webpack_require__(38).has;
var isValidEntityCode = __webpack_require__(38).isValidEntityCode;
var fromCodePoint = __webpack_require__(38).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 104 */
/***/ (function(module, exports) {



module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 105 */
/***/ (function(module, exports) {



module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);
var isWhiteSpace = __webpack_require__(38).isWhiteSpace;
var isPunctChar = __webpack_require__(38).isPunctChar;
var isMdAsciiPunct = __webpack_require__(38).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(108)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(47).source;
  re.src_Cc = __webpack_require__(48).source;
  re.src_Z = __webpack_require__(49).source;
  re.src_P = __webpack_require__(39).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(53)) == 'object' && __webpack_require__(53)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module), __webpack_require__(54)))

/***/ }),
/* 110 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 113 */
/***/ (function(module, exports) {


/* eslint-disable no-cond-assign */

var tagExpr = /^<!-- ?\{(?:([a-z0-9]+)(\^[0-9]*)?: ?)?(.*)\} ?-->\n?$/;

module.exports = function attributes(md) {
  md.core.ruler.push('curly_attributes', curlyAttrs);
};

/*
 * List of tag -> token type mappings. Eg, `<li>` is `list_item_open`.
 */

var opening = {
  li: ['list_item'],
  ul: ['bullet_list'],
  p: ['paragraph'],
  ol: ['ordered_list'],
  blockquote: ['blockquote'],
  h1: ['heading'],
  h2: ['heading'],
  h3: ['heading'],
  h4: ['heading'],
  h5: ['heading'],
  h6: ['heading'],
  a: ['link'],
  code: ['code_inline', 'code_block', 'fence']
};

var selfClosing = {
  hr: true,
  image: true

  /**
   * ...
   */

};function curlyAttrs(state) {
  var tokens = state.tokens;
  var omissions = [];
  var parent, m;
  var stack = { len: 0, contents: [], types: {} };

  tokens.forEach(function (token, i) {
    // Save breadcrumbs so html_block will pick it up
    if (isOpener(token.type) || selfClosing[token.type]) {
      spush(stack, token);
    }

    // "# Hello\n<!--{.classname}-->"
    // ...sequence of [heading_open, inline, heading_close, html_block]
    if (token.type === 'html_block') {
      m = token.content.match(tagExpr);
      if (!m) return;

      parent = findParent(stack, m[1], m[2]);
      if (parent && applyToToken(parent, m[3])) {
        omissions.unshift(i);
      }
    }

    // "# Hello <!--{.classname} -->"
    // { type: 'inline', children: { ..., '<!--{...}-->' } }
    if (token.type === 'inline') {
      curlyInline(token.children, stack);
    }
  });

  // Remove <!--...--> html_block tokens
  omissions.forEach(function (idx) {
    return tokens.splice(idx, 1);
  });
}

/**
 * Internal: checks in a token type is a block opener
 */

function isOpener(type) {
  return type.match(/_(open|start)$/) || type === 'fence' || type === 'code_block';
}

/**
 * Internal: Run through inline and stuff
 */

function curlyInline(children, stack) {
  var lastText, m, parent;

  // Keep a list of sub-tokens to be removed
  var omissions = [];

  children.forEach(function (child, i) {
    if (isOpener(child.type) || selfClosing[child.type] || child.type === 'code_inline') {
      spush(stack, child);
    }

    // Decorate tags are found
    if (m = child.content.match(tagExpr)) {
      var tag = m[1];
      var depth = m[2];
      var attrs = m[3];

      // Remove the comment, then remove the extra space
      parent = findParent(stack, tag, depth);
      if (parent && applyToToken(parent, attrs)) {
        omissions.unshift(i);
        if (lastText) trimRight(lastText, 'content');
      }
    }

    if (child.type === 'text') lastText = child;
  });

  // Remove them in a separate step so we don't
  omissions.forEach(function (idx) {
    children.splice(idx, 1);
  });
}

/**
 * Private: given a list of tokens `list` and `lastParent`, find the one that
 * matches `tag`.
 */

function findParent(stack, tag, depth) {
  if (!tag) return stack.last;

  if (depth === '^') {
    depth = 1;
  } else if (typeof depth === 'string') {
    /* '^2' */
    depth = +depth.substr(1);
  } else {
    depth = 0;
  }

  var targets = opening[tag.toLowerCase()] || [tag.toLowerCase()];

  var target = targets.filter(function (target) {
    return stack.types[target];
  });

  var list = stack.types[target];
  if (!list) return; // Can't find tag `tag`

  return list[list.length - 1 - depth];
}

/**
 * Private: trim the right
 */

function trimRight(obj, attr) {
  obj[attr] = obj[attr].replace(/\s*$/, '');
}

/**
 * Private: apply tag to token
 *
 *     applyToToken(token, '.classname')
 */

function applyToToken(token, attrs) {
  var m;
  var todo = [];

  while (attrs.length > 0) {
    if (m = attrs.match(/^\s*\.([a-zA-Z0-9\-_]+)/)) {
      todo.push(['class', m[1], { append: true }]);
      shift();
    } else if (m = attrs.match(/^\s*#([a-zA-Z0-9\-_]+)/)) {
      todo.push(['id', m[1]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)="([^"]*)"/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)='([^']*)'/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)=([^ ]*)/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)/)) {
      todo.push([m[1], '']);
      shift();
    } else if (m = attrs.match(/^\s+/)) {
      shift();
    } else {
      return;
    }
  }

  todo.forEach(function (args) {
    setAttr.apply(this, [token].concat(args));
  });
  return true;

  function shift() {
    attrs = attrs.substr(m[0].length);
  }
}

/**
 * Private: sets an attribute `attr` to `value` in a token. If `options.append`
 * is true, append to the old value instead of overwriting it.
 */

function setAttr(token, attr, value, options) {
  var idx = token.attrIndex(attr);

  if (idx === -1) {
    token.attrPush([attr, value]);
  } else if (options && options.append) {
    token.attrs[idx][1] = token.attrs[idx][1] + ' ' + value;
  } else {
    token.attrs[idx][1] = value;
  }
}

/**
 * Private: pushes a token to the stack
 */

function spush(stack, token) {
  var type = token.type.replace(/_(open|start)$/, '');
  if (!stack.types[type]) {
    stack.types[type] = [];
  }
  stack.types[type].push(token);
  stack.last = token;
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function (factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if (true) {
    factory(exports);
  } else if (globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return globalObject.hljs;
      });
    }
  }
})(function (hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent) {
    // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent) {
      result[key] = parent[key];
    }objects.forEach(function (obj) {
      for (key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:
       if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;
       ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace('"', '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function expand_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function (variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];
  }

  function compileLanguage(language) {

    function reStr(re) {
      return re && re.source || re;
    }

    function langRe(value, global) {
      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }

    function compileMode(mode, parent) {
      if (mode.compiled) return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function flatten(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function (kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') {
          // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin) mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null) mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {
        return expand_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function (c) {
        compileMode(c, mode);
      });

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = mode.contains.map(function (c) {
        return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function exec() /*s*/{
          return null;
        } };
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:
   - relevance (int)
  - value (an HTML string with highlighting markup)
   */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan = '<span class="' + classPrefix,
          closeSpan = leaveOpen ? '' : spanEndTag;

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords) return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += top.subLanguage != null ? processSubLanguage() : processKeywords();
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className ? buildSpan(mode.className, '', true) : '';
      top = Object.create(mode, { parent: { value: top } });
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '',
        current;
    for (current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match,
          count,
          index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match) break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:
   - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)
   */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:
   - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers
   */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {
      if (options.useBR && match === '\n') {
        return '<br>';
      } else if (options.tabReplace) {
        return p1.replace(/\t/g, options.tabReplace);
      }
      return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language)) return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function (alias) {
        aliases[alias] = name;
      });
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
      className: 'comment',
      begin: begin, end: end,
      contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [hljs.BACKSLASH_ESCAPE, {
      begin: /\[/, end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
});

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' +
    // ECMAScript 6 modules import
    'import from as',

    literal: 'true false null undefined NaN Infinity',
    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'
  };
  var EXPRESSIONS;
  var NUMBER = {
    className: 'number',
    variants: [{ begin: '\\b(0[bB][01]+)' }, { begin: '\\b(0[oO][0-7]+)' }, { begin: hljs.C_NUMBER_RE }],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: [] // defined later
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];
  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);

  return {
    aliases: ['js', 'jsx'],
    keywords: KEYWORDS,
    contains: [{
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, {
      className: 'meta',
      begin: /^#!/, end: /$/
    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, { // object attr container
      begin: /[{,]\s*/, relevance: 0,
      contains: [{
        begin: IDENT_RE + '\\s*:', returnBegin: true,
        relevance: 0,
        contains: [{ className: 'attr', begin: IDENT_RE, relevance: 0 }]
      }]
    }, { // "value" container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
      keywords: 'return throw case',
      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {
        className: 'function',
        begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
        end: '\\s*=>',
        contains: [{
          className: 'params',
          variants: [{
            begin: IDENT_RE
          }, {
            begin: /\(\s*\)/
          }, {
            begin: /\(/, end: /\)/,
            excludeBegin: true, excludeEnd: true,
            keywords: KEYWORDS,
            contains: PARAMS_CONTAINS
          }]
        }]
      }, { // E4X / JSX
        begin: /</, end: /(\/\w+|\w+\/)>/,
        subLanguage: 'xml',
        contains: [{ begin: /<\w+\s*\/>/, skip: true }, {
          begin: /<\w+/, end: /(\/\w+|\w+\/)>/, skip: true,
          contains: [{ begin: /<\w+\s*\/>/, skip: true }, 'self']
        }]
      }],
      relevance: 0
    }, {
      className: 'function',
      beginKeywords: 'function', end: /\{/, excludeEnd: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }), {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        contains: PARAMS_CONTAINS
      }],
      illegal: /\[|%/
    }, {
      begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
    }, hljs.METHOD_GUARD, { // ES6 class
      className: 'class',
      beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
      illegal: /[:"\[\]]/,
      contains: [{ beginKeywords: 'extends' }, hljs.UNDERSCORE_TITLE_MODE]
    }, {
      beginKeywords: 'constructor', end: /\{/, excludeEnd: true
    }],
    illegal: /#(?!!)/
  };
};

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /[A-Z\_\.\-]+\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [{
      className: 'attribute',
      begin: /\S/, end: ':', excludeEnd: true,
      starts: {
        endsWithParent: true, excludeEnd: true,
        contains: [{
          begin: /[\w-]+\(/, returnBegin: true,
          contains: [{
            className: 'built_in',
            begin: /[\w-]+/
          }, {
            begin: /\(/, end: /\)/,
            contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
          }]
        }, hljs.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, hljs.C_BLOCK_COMMENT_MODE, {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        }, {
          className: 'meta', begin: '!important'
        }]
      }
    }]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [hljs.C_BLOCK_COMMENT_MODE, {
      className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
    }, {
      className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
    }, {
      className: 'selector-attr',
      begin: /\[/, end: /\]/,
      illegal: '$'
    }, {
      className: 'selector-pseudo',
      begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
    }, {
      begin: '@(font-face|page)',
      lexemes: '[a-z-]+',
      keywords: 'font-face page'
    }, {
      begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
      // because it doesn’t let it to be parsed as
      // a rule set but instead drops parser into
      // the default mode which is how it should be.
      illegal: /:/, // break on Less variables @var: ...
      contains: [{
        className: 'keyword',
        begin: /\w+/
      }, {
        begin: /\s/, endsWithParent: true, excludeEnd: true,
        relevance: 0,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, hljs.CSS_NUMBER_MODE]
      }]
    }, {
      className: 'selector-tag', begin: IDENT_RE,
      relevance: 0
    }, {
      begin: '{', end: '}',
      illegal: /\S/,
      contains: [hljs.C_BLOCK_COMMENT_MODE, RULE]
    }]
  };
};

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [{
      className: 'attr',
      begin: XML_IDENT_RE,
      relevance: 0
    }, {
      begin: /=\s*/,
      relevance: 0,
      contains: [{
        className: 'string',
        endsParent: true,
        variants: [{ begin: /"/, end: /"/ }, { begin: /'/, end: /'/ }, { begin: /[^\s"'=<>`]+/ }]
      }]
    }]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
    case_insensitive: true,
    contains: [{
      className: 'meta',
      begin: '<!DOCTYPE', end: '>',
      relevance: 10,
      contains: [{ begin: '\\[', end: '\\]' }]
    }, hljs.COMMENT('<!--', '-->', {
      relevance: 10
    }), {
      begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
      relevance: 10
    }, {
      begin: /<\?(php)?/, end: /\?>/,
      subLanguage: 'php',
      contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
    }, {
      className: 'tag',
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending braket. The '$' is needed for the lexeme to be recognized
      by hljs.subMode() that tests lexemes outside the stream.
      */
      begin: '<style(?=\\s|>|$)', end: '>',
      keywords: { name: 'style' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '</style>', returnEnd: true,
        subLanguage: ['css', 'xml']
      }
    }, {
      className: 'tag',
      // See the comment in the <style tag about the lookahead pattern
      begin: '<script(?=\\s|>|$)', end: '>',
      keywords: { name: 'script' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '\<\/script\>', returnEnd: true,
        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
      }
    }, {
      className: 'meta',
      variants: [{ begin: /<\?xml/, end: /\?>/, relevance: 10 }, { begin: /<\?\w+/, end: /\?>/ }]
    }, {
      className: 'tag',
      begin: '</?', end: '/?>',
      contains: [{
        className: 'name', begin: /[^\/><\s]+/, relevance: 0
      }, TAG_INTERNALS]
    }]
  };
};

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var VAR = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d#@][\w\d_]*/ }, { begin: /\$\{(.*?)}/ }]
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: /"/, end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, {
      className: 'variable',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  var APOS_STRING = {
    className: 'string',
    begin: /'/, end: /'/
  };

  return {
    aliases: ['sh', 'zsh'],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: 'if then else elif fi for while in do done case esac function',
      literal: 'true false',
      built_in:
      // Shell built-ins
      // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' + 'trap umask unset ' +
      // Bash built-ins
      'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' + 'read readarray source type typeset ulimit unalias ' +
      // Shell modifiers
      'set shopt ' +
      // Zsh built-ins
      'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' + 'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' + 'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' + 'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' + 'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' + 'zpty zregexparse zsocket zstyle ztcp',
      _: '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster
    },
    contains: [{
      className: 'meta',
      begin: /^#![^\n]+sh\s*$/,
      relevance: 10
    }, {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, hljs.HASH_COMMENT_MODE, QUOTE_STRING, APOS_STRING, VAR]
  };
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _class = function (_Intact) {
    _inherits(_class, _Intact);

    function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _class.prototype._mount = function _mount() {
        this.$border = $(this.element).find('.border');
        this._updateBorder();
    };

    _class.prototype._updateBorder = function _updateBorder() {
        var $nav = $(this.element).find('.active');
        var width = 0;
        var left = 0;
        if ($nav.length) {
            left = $nav.position().left;
            width = $nav.outerWidth();
        }
        this.$border.addClass('transition');
        this.$border.css({ width: width, left: left });
    };

    return _class;
}(Intact);

exports.default = _class;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(16)))

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(42),
    now = __webpack_require__(130),
    toNumber = __webpack_require__(131);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(55);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom = __webpack_require__(138);

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
    var index = -1,
        length = array.length,
        lastIndex = length - 1;

    size = size === undefined ? length : size;
    while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
    }
    array.length = size;
    return array;
}

module.exports = shuffleSelf;

/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 125 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (obj, _Vdt, blocks) {
    if (false) {
        var __this = this;
        module.hot.dispose(function (data) {
            data.vdt = __this;
            data.isParent = __this.data !== obj;
        });
    }

    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        scope = obj,
        Animate = self && self.Animate,
        parent = self && self._parentTemplate;
    var layout = __webpack_require__(56);

    var catalogs = [{
        title: '基础',
        subCatalogs: [{
            title: '开始',
            href: 'start'
        }, {
            title: 'Intact实例',
            href: 'instance'
        }, {
            title: '组件生命周期',
            href: 'lifecycle'
        }, {
            title: '模板语法',
            href: 'syntax'
        }, {
            title: '事件处理',
            href: 'event'
        }, {
            title: '表单处理',
            href: 'form'
        }, {
            title: '组件',
            href: 'component'
        }, {
            title: '组件继承',
            href: 'extend'
        }]
    }, {
        title: '进阶',
        subCatalogs: [{
            title: '动画',
            href: 'animation'
        }, {
            title: '模板template',
            href: 'template'
        }, {
            title: '路由',
            href: 'router'
        }, {
            title: 'webpack实践',
            href: 'project'
        }, {
            title: '服务器端渲染',
            href: 'ssr'
        }]
    }];
    var currentNav = {};

    var Subs = function Subs(attr) {
        return function () {
            try {
                return [attr.subs][0];
            } catch (e) {
                _e(e);
            }
        }.call(this) ? h('ul', null, _Vdt.utils.map(function () {
            try {
                return [attr.subs][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), function (value, key) {
            return h('li', null, [h('a', { 'ev-click': function () {
                    try {
                        return [self.scrollTo.bind(self, value.title, attr.subs.active)][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, function () {
                try {
                    return [value.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)), h(Subs, { 'subs': function () {
                    try {
                        return [value.subs][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) })], _className(function () {
                try {
                    return [{
                        active: self.get(attr.subs.active) === value.title
                    }][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)));
        }, this), 'sub-catalogs') : undefined;
    };
    return function (blocks) {
        var _blocks = {},
            __blocks = extend({}, blocks),
            _obj = { 'navIndex': 'document', 'className': 'document-page' } || {};
        if (_obj.hasOwnProperty("arguments")) {
            extend(_obj, _obj.arguments === true ? obj : _obj.arguments);delete _obj.arguments;
        }
        return layout.call(this, _obj, _Vdt, (_blocks.content = function (parent) {
            return [h('aside', null, h('div', null, [_Vdt.utils.map(function () {
                try {
                    return [catalogs][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this), function (value, key) {
                return h('div', null, [h('h5', null, function () {
                    try {
                        return [value.title][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this)), h('ul', null, _Vdt.utils.map(function () {
                    try {
                        return [value.subCatalogs][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this), function (value, key) {
                    return h('li', null, ['\n                            ', function () {
                        try {
                            return [function () {
                                if (value.href === self.get('title')) {
                                    currentNav = value;
                                }
                            }()][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this), '\n                            ', h('a', { 'href': function () {
                            try {
                                return ['#/document/' + value.href][0];
                            } catch (e) {
                                _e(e);
                            }
                        }.call(this) }, function () {
                        try {
                            return [value.title][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this)), function () {
                        try {
                            return [value.href === self.get('title')][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this) ? h(Subs, { 'subs': function () {
                            try {
                                return [self.get('subCatalogs')][0];
                            } catch (e) {
                                _e(e);
                            }
                        }.call(this) }) : undefined], _className(function () {
                        try {
                            return [{
                                active: value.href === self.get('title')
                            }][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this)));
                }, this))], 'catalog-section');
            }, this), h('div', null, null, 'aside-border transition')], 'aside-wrapper')), h('article', null, [h('div', null, [h('div', null, function () {
                try {
                    return [currentNav.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this), 'title'), h('div', null, ['\n                    如果你发现文档有问题，请帮忙在\n                    ', h('a', { 'target': '_blank', 'href': function () {
                    try {
                        return ['https://github.com/Javey/javey.github.io/blob/master/intact/docs/' + self.get('title') + '.md'][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, 'github'), '\n                    上修正该文档\n                '], 'edit-link')], 'article-head'), h('div', { 'innerHTML': function () {
                    try {
                        return [self.get('content')][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) })])];
        }) && (__blocks.content = function (parent) {
            var self = this;
            return blocks.content ? blocks.content.call(this, function () {
                return _blocks.content.call(self, parent);
            }) : _blocks.content.call(this, parent);
        }) && __blocks);
    }.call(this, blocks);
};
if (false) {
    module.hot.accept();
    var vdt = module.hot.data && module.hot.data.vdt;
    if (vdt) {
        if (!module.hot.data.isParent) {
            vdt.template = module.exports;
        }
        vdt.update();
    }
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(128);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(9)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, ".hljs {\n  display: block;\n  overflow-x: auto;\n  color: #525252;\n  padding: 15px;\n  -webkit-text-size-adjust: none;\n  margin: 0;\n}\n.hljs-doctype {\n  color: #999;\n}\n.hljs-tag {\n  color: #3e76f6;\n}\n.hljs-attribute {\n  color: #e96900;\n}\n.hljs-value {\n  color: #42b983;\n}\n.hljs-keyword {\n  color: #e96900;\n}\n.hljs-string {\n  color: #42b983;\n}\n.hljs-comment {\n  color: #b3b3b3;\n}\n.hljs-operator .hljs-comment {\n  color: #525252;\n}\n.hljs-regexp {\n  color: #af7dff;\n}\n.hljs-built_in {\n  color: #2db7f5;\n}\n.css .hljs-class {\n  color: #e96900;\n}\n.css .hljs-number,\n.javascript .hljs-number {\n  color: #fc1e70;\n}\n.css .hljs-attribute {\n  color: #af7dff;\n}\n.css .hljs-important {\n  color: #d04;\n}\n.actionscript .hljs-literal,\n.javascript .hljs-literal {\n  color: #fc1e70;\n}\npre {\n  padding: 0;\n  margin: 0;\n}\ncode {\n  display: inline-block;\n  background: #f7f7f7;\n  font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;\n  margin: 3px;\n  padding: 1px 5px;\n  border-radius: 3px;\n  color: #666;\n  border: 1px solid #eee;\n  line-height: 20px;\n}\n.document-page {\n  padding-top: 95px;\n  box-sizing: border-box;\n}\n.document-page .content-wrapper.fixed {\n  margin-bottom: 0;\n}\n.document-page .content-wrapper.fixed aside {\n  position: fixed;\n  top: 80px;\n  background: #fff;\n  height: calc(100% - 80px);\n  overflow: auto;\n  box-sizing: border-box;\n}\n.document-page .content-wrapper.fixed article {\n  margin-left: 200px;\n}\n.document-page .content-wrapper {\n  width: 1080px;\n  display: flex;\n  background: #fff;\n  margin: 0 auto;\n  border-radius: 5px;\n  box-shadow: 0 1px 1px rgba(0,0,0,0.08);\n  min-height: calc(100% - 15px);\n}\n.document-page .content-wrapper aside {\n  width: 200px;\n  border-right: 1px solid #eee;\n}\n.document-page .content-wrapper .aside-wrapper {\n  position: relative;\n}\n.document-page .content-wrapper .aside-wrapper h5 {\n  font-size: 16px;\n  margin: 25px 0 15px 20px;\n  color: #999;\n}\n.document-page .content-wrapper .aside-wrapper ul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.document-page .content-wrapper .aside-wrapper a {\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  padding-left: 25px;\n  color: #333;\n}\n.document-page .content-wrapper .aside-wrapper a:hover {\n  background: #f3f3f3;\n}\n.document-page .content-wrapper .aside-wrapper .active > a {\n  color: #fe4444;\n}\n.document-page .content-wrapper .aside-wrapper .sub-catalogs {\n  margin-left: 10px;\n  font-size: 12px;\n}\n.document-page .content-wrapper .aside-wrapper .aside-border {\n  border-right: 2px solid #fe4444;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.document-page .content-wrapper article {\n  flex: 1;\n  padding: 10px 20px;\n  overflow: auto;\n}\n.document-page .content-wrapper .article-head .title {\n  padding: 10px 0;\n  font-size: 2.2em;\n  color: #000;\n  display: inline-block;\n}\n.document-page .content-wrapper .article-head .edit-link {\n  display: inline-block;\n  margin-left: 20px;\n  color: #999;\n  font-style: italic;\n}\n.document-page .content-wrapper article h1 {\n  padding: 10px 0;\n  border-bottom: 1px solid #eee;\n  margin: 20px 0;\n}\n.document-page .content-wrapper article h2,\n.document-page .content-wrapper article h3 {\n  padding: 10px 0;\n  margin: 15px 0;\n}\n.document-page .content-wrapper article p {\n  line-height: 25px;\n}\n.document-page .content-wrapper article .output {\n  padding: 20px;\n  border: 1px solid #eee;\n  margin: 20px 0;\n}\n", ""]);

// exports


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(120),
    isObject = __webpack_require__(42);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(55);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(42),
    isSymbol = __webpack_require__(132);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(43),
    isObjectLike = __webpack_require__(44);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(122);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var arrayShuffle = __webpack_require__(136),
    baseShuffle = __webpack_require__(139),
    isArray = __webpack_require__(124);

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  var func = isArray(collection) ? arrayShuffle : baseShuffle;
  return func(collection);
}

module.exports = shuffle;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray = __webpack_require__(137),
    shuffleSelf = __webpack_require__(123);

/**
 * A specialized version of `_.shuffle` for arrays.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function arrayShuffle(array) {
  return shuffleSelf(copyArray(array));
}

module.exports = arrayShuffle;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

/***/ }),
/* 138 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var shuffleSelf = __webpack_require__(123),
    values = __webpack_require__(140);

/**
 * The base implementation of `_.shuffle`.
 *
 * @private
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function baseShuffle(collection) {
  return shuffleSelf(values(collection));
}

module.exports = baseShuffle;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(141),
    keys = __webpack_require__(143);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(142);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(144),
    baseKeys = __webpack_require__(155),
    isArrayLike = __webpack_require__(159);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(145),
    isArguments = __webpack_require__(146),
    isArray = __webpack_require__(124),
    isBuffer = __webpack_require__(148),
    isIndex = __webpack_require__(150),
    isTypedArray = __webpack_require__(151);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(147),
    isObjectLike = __webpack_require__(44);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(43),
    isObjectLike = __webpack_require__(44);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(55),
    stubFalse = __webpack_require__(149);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(152),
    baseUnary = __webpack_require__(153),
    nodeUtil = __webpack_require__(154);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(43),
    isLength = __webpack_require__(125),
    isObjectLike = __webpack_require__(44);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(121);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(156),
    nativeKeys = __webpack_require__(157);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(158);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(160),
    isLength = __webpack_require__(125);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(43),
    isObject = __webpack_require__(42);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9kb2N1bWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2xheW91dC52ZHQiLCJ3ZWJwYWNrOi8vLy4vbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZHVybC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQtZGVjb3JhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9jc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaC5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaHVmZmxlU2VsZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC52ZHQiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQuc3R5bD80ZGFjIiwid2VicGFjazovLy8uL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWwiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJJbnRhY3QiLCJfIiwidGhyb3R0bGUiLCJzaHVmZmxlIiwiZGVib3VuY2UiLCIkIiwiX2luaXQiLCJmZXRjaCIsImdldCIsInRoZW4iLCJyZXNwb25zZSIsInRleHQiLCJzZXQiLCJyZW5kZXIiLCJtZCIsIl9tb3VudCIsImNvZGVzIiwiZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaGlnaGxpZ2h0QmxvY2siLCJpdGVtIiwiY2F0YWxvZ3MiLCJhY3RpdmUiLCJjYXRhbG9nIiwidGl0bGUiLCJpbm5lclRleHQiLCJuZXh0U2libGluZyIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsInN1YnMiLCJwdXNoIiwiZXZhbFNjcmlwdCIsIm9uU2Nyb2xsIiwiJGV4YW1wbGVzIiwiZmluZCIsInRlbXBsYXRlIiwiaSIsImxlbmd0aCIsIiRleGFtcGxlIiwiZXEiLCJjb2RlIiwiaGFzQ2xhc3MiLCJfQyIsIlZkdCIsImNvbXBpbGUiLCJleHRlbmQiLCJldmFsIiwiJGNvbnRhaW5lciIsInBhcmVudCIsImFmdGVyIiwibW91bnQiLCIkYnV0dG9uIiwiJHAiLCJhcHBlbmQiLCJvbiIsIiRzY3JpcHRzIiwiJHNjcmlwdCIsIiR3cmFwcGVyIiwiJGFydGljbGUiLCIkaDFzIiwiJGgycyIsIiRhc2lkZSIsIiRib3JkZXIiLCIkd2luZG93Iiwib2ZmIiwic2Nyb2xsVG9wIiwiZmluZEFjdGl2ZSIsIiRocyIsIm1pblRvcCIsIiRoIiwidG9wIiwicG9zaXRpb24iLCJhY3RpdmUxIiwiYWN0aXZlMiIsIiRhY3RpdmVBIiwibGFzdCIsImNoaWxkcmVuIiwiaGVpZ2h0IiwiY3NzIiwidHJpZ2dlciIsInNjcm9sbFRvIiwidHlwZSIsImFuaW1hdGUiLCJjb21wbGV0ZSIsIl9kZXN0cm95IiwiX2NsYXNzIiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNTdHJpbmciLCJfaGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsIm9iamVjdCIsImtleSIsImFzc2lnbiIsInNvdXJjZXMiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwic291cmNlIiwiVHlwZUVycm9yIiwia2V5cyIsImFycmF5UmVwbGFjZUF0Iiwic3JjIiwicG9zIiwibmV3RWxlbWVudHMiLCJjb25jYXQiLCJpc1ZhbGlkRW50aXR5Q29kZSIsImMiLCJmcm9tQ29kZVBvaW50Iiwic3Vycm9nYXRlMSIsInN1cnJvZ2F0ZTIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTkVTQ0FQRV9NRF9SRSIsIkVOVElUWV9SRSIsIlVORVNDQVBFX0FMTF9SRSIsIlJlZ0V4cCIsIkRJR0lUQUxfRU5USVRZX1RFU1RfUkUiLCJlbnRpdGllcyIsInJlcXVpcmUiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsIm1hdGNoIiwibmFtZSIsImNoYXJDb2RlQXQiLCJ0ZXN0IiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwic3RyIiwiaW5kZXhPZiIsInJlcGxhY2UiLCJ1bmVzY2FwZUFsbCIsImVzY2FwZWQiLCJlbnRpdHkiLCJIVE1MX0VTQ0FQRV9URVNUX1JFIiwiSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSIsIkhUTUxfUkVQTEFDRU1FTlRTIiwicmVwbGFjZVVuc2FmZUNoYXIiLCJjaCIsImVzY2FwZUh0bWwiLCJSRUdFWFBfRVNDQVBFX1JFIiwiZXNjYXBlUkUiLCJpc1NwYWNlIiwiaXNXaGl0ZVNwYWNlIiwiVU5JQ09ERV9QVU5DVF9SRSIsImlzUHVuY3RDaGFyIiwiaXNNZEFzY2lpUHVuY3QiLCJub3JtYWxpemVSZWZlcmVuY2UiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJleHBvcnRzIiwibGliIiwibWR1cmwiLCJ1Y21pY3JvIiwibW9kdWxlIiwiUnVsZXIiLCJfX3J1bGVzX18iLCJfX2NhY2hlX18iLCJfX2ZpbmRfXyIsIl9fY29tcGlsZV9fIiwic2VsZiIsImNoYWlucyIsInJ1bGUiLCJlbmFibGVkIiwiYWx0IiwiYWx0TmFtZSIsImNoYWluIiwiZm4iLCJhdCIsIm9wdGlvbnMiLCJpbmRleCIsIm9wdCIsIkVycm9yIiwiYmVmb3JlIiwiYmVmb3JlTmFtZSIsInJ1bGVOYW1lIiwic3BsaWNlIiwiYWZ0ZXJOYW1lIiwiZW5hYmxlIiwibGlzdCIsImlnbm9yZUludmFsaWQiLCJpc0FycmF5IiwicmVzdWx0IiwiaWR4IiwiZW5hYmxlT25seSIsImRpc2FibGUiLCJnZXRSdWxlcyIsImNoYWluTmFtZSIsIlRva2VuIiwidGFnIiwibmVzdGluZyIsImF0dHJzIiwibWFwIiwibGV2ZWwiLCJjb250ZW50IiwibWFya3VwIiwiaW5mbyIsIm1ldGEiLCJibG9jayIsImhpZGRlbiIsImF0dHJJbmRleCIsImxlbiIsImF0dHJQdXNoIiwiYXR0ckRhdGEiLCJhdHRyU2V0IiwidmFsdWUiLCJhdHRyR2V0IiwiYXR0ckpvaW4iLCJpc09iamVjdCIsIlN5bWJvbCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJ1bmRlZmluZWQiLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwiZW5jb2RlIiwiZGVjb2RlIiwiZm9ybWF0IiwicGFyc2UiLCJhdHRyX25hbWUiLCJ1bnF1b3RlZCIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwiYXR0cl92YWx1ZSIsImF0dHJpYnV0ZSIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwiY29tbWVudCIsInByb2Nlc3NpbmciLCJkZWNsYXJhdGlvbiIsImNkYXRhIiwiSFRNTF9UQUdfUkUiLCJIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIiwidG9rZW5pemUiLCJzdHJpa2V0aHJvdWdoIiwic3RhdGUiLCJzaWxlbnQiLCJzY2FubmVkIiwidG9rZW4iLCJzdGFydCIsIm1hcmtlciIsInNjYW5EZWxpbXMiLCJkZWxpbWl0ZXJzIiwianVtcCIsInRva2VucyIsImVuZCIsIm9wZW4iLCJjYW5fb3BlbiIsImNsb3NlIiwiY2FuX2Nsb3NlIiwicG9zdFByb2Nlc3MiLCJqIiwic3RhcnREZWxpbSIsImVuZERlbGltIiwibG9uZU1hcmtlcnMiLCJtYXgiLCJwb3AiLCJlbXBoYXNpcyIsImlzU3Ryb25nIiwiZyIsIkZ1bmN0aW9uIiwiZSIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJfVmR0IiwiYmxvY2tzIiwiX190aGlzIiwiaG90IiwiZGlzcG9zZSIsImRhdGEiLCJ2ZHQiLCJpc1BhcmVudCIsImgiLCJtaXNzIiwiaGMiLCJodSIsIndpZGdldHMiLCJfYmxvY2tzIiwiX19ibG9ja3MiLCJfX3UiLCJ1dGlscyIsIl9lIiwiZXJyb3IiLCJfY2xhc3NOYW1lIiwiY2xhc3NOYW1lIiwiX19vIiwiT3B0aW9ucyIsIl9nZXRNb2RlbCIsImdldE1vZGVsIiwiX3NldE1vZGVsIiwic2V0TW9kZWwiLCJfc2V0Q2hlY2tib3hNb2RlbCIsInNldENoZWNrYm94TW9kZWwiLCJfZGV0ZWN0Q2hlY2tib3hDaGVja2VkIiwiZGV0ZWN0Q2hlY2tib3hDaGVja2VkIiwiX3NldFNlbGVjdE1vZGVsIiwic2V0U2VsZWN0TW9kZWwiLCJzY29wZSIsIkFuaW1hdGUiLCJfcGFyZW50VGVtcGxhdGUiLCJuYXYiLCJocmVmIiwiaGVhZGVyIiwibmF2SW5kZXgiLCJhY2NlcHQiLCJ1cGRhdGUiLCJyZWdpc3Rlckxhbmd1YWdlIiwiaGlnaGxpZ2h0IiwibWFya2VkIiwiaHRtbCIsImJyZWFrcyIsInVzZSIsInJlbmRlcmVyIiwicnVsZXMiLCJzb2Z0YnJlYWsiLCJoZWxwZXJzIiwiUmVuZGVyZXIiLCJQYXJzZXJDb3JlIiwiUGFyc2VyQmxvY2siLCJQYXJzZXJJbmxpbmUiLCJMaW5raWZ5SXQiLCJwdW55Y29kZSIsImNvbmZpZyIsInplcm8iLCJjb21tb25tYXJrIiwiQkFEX1BST1RPX1JFIiwiR09PRF9EQVRBX1JFIiwidmFsaWRhdGVMaW5rIiwidXJsIiwiUkVDT0RFX0hPU1ROQU1FX0ZPUiIsIm5vcm1hbGl6ZUxpbmsiLCJwYXJzZWQiLCJob3N0bmFtZSIsInByb3RvY29sIiwidG9BU0NJSSIsImVyIiwibm9ybWFsaXplTGlua1RleHQiLCJ0b1VuaWNvZGUiLCJNYXJrZG93bkl0IiwicHJlc2V0TmFtZSIsImlubGluZSIsImNvcmUiLCJsaW5raWZ5IiwiY29uZmlndXJlIiwicHJlc2V0cyIsImNvbXBvbmVudHMiLCJydWxlciIsInJ1bGVzMiIsInJ1bGVyMiIsIm1pc3NlZCIsImZpbHRlciIsInBsdWdpbiIsImFyZ3MiLCJhcHBseSIsImVudiIsIlN0YXRlIiwicHJvY2VzcyIsInBhcnNlSW5saW5lIiwiaW5saW5lTW9kZSIsInJlbmRlcklubGluZSIsImVuY29kZUNhY2hlIiwiZ2V0RW5jb2RlQ2FjaGUiLCJleGNsdWRlIiwiY2FjaGUiLCJzdHJpbmciLCJrZWVwRXNjYXBlZCIsImwiLCJuZXh0Q29kZSIsImRlZmF1bHRDaGFycyIsImVuY29kZVVSSUNvbXBvbmVudCIsImNvbXBvbmVudENoYXJzIiwiZGVjb2RlQ2FjaGUiLCJnZXREZWNvZGVDYWNoZSIsInNlcSIsImIxIiwiYjIiLCJiMyIsImI0IiwiY2hyIiwic2xhc2hlcyIsImF1dGgiLCJwb3J0IiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiVXJsIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJ1cmxQYXJzZSIsInNsYXNoZXNEZW5vdGVIb3N0IiwidSIsImxvd2VyUHJvdG8iLCJoZWMiLCJyZXN0Iiwic3BsaXQiLCJzaW1wbGVQYXRoIiwiZXhlYyIsInByb3RvIiwic3Vic3RyIiwiaG9zdEVuZCIsImF0U2lnbiIsImxhc3RJbmRleE9mIiwiaG9zdCIsInBhcnNlSG9zdCIsImlwdjZIb3N0bmFtZSIsImhvc3RwYXJ0cyIsInBhcnQiLCJuZXdwYXJ0IiwiayIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsImpvaW4iLCJxbSIsIkFueSIsIkNjIiwiQ2YiLCJQIiwiWiIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsImRpc2FibGVOZXN0ZWQiLCJmb3VuZCIsInByZXZQb3MiLCJsYWJlbEVuZCIsInBvc01heCIsIm9sZFBvcyIsInNraXBUb2tlbiIsImxpbmVzIiwib2siLCJkZWZhdWx0X3J1bGVzIiwiY29kZV9pbmxpbmUiLCJzbGYiLCJyZW5kZXJBdHRycyIsImNvZGVfYmxvY2siLCJmZW5jZSIsImxhbmdOYW1lIiwiaGlnaGxpZ2h0ZWQiLCJ0bXBBdHRycyIsInRtcFRva2VuIiwibGFuZ1ByZWZpeCIsImltYWdlIiwicmVuZGVySW5saW5lQXNUZXh0IiwicmVuZGVyVG9rZW4iLCJoYXJkYnJlYWsiLCJ4aHRtbE91dCIsImh0bWxfYmxvY2siLCJodG1sX2lubGluZSIsIm5leHRUb2tlbiIsIm5lZWRMZiIsIl9ydWxlcyIsIkNvcmUiLCJORVdMSU5FU19SRSIsIk5VTExfUkUiLCJ0b2siLCJpc0xpbmtPcGVuIiwiaXNMaW5rQ2xvc2UiLCJjdXJyZW50VG9rZW4iLCJub2RlcyIsImxuIiwibGFzdFBvcyIsImh0bWxMaW5rTGV2ZWwiLCJmdWxsVXJsIiwidXJsVGV4dCIsImJsb2NrVG9rZW5zIiwibGlua3MiLCJwcmV0ZXN0Iiwic2NoZW1hIiwibGFzdEluZGV4IiwiUkFSRV9SRSIsIlNDT1BFRF9BQkJSX1RFU1RfUkUiLCJTQ09QRURfQUJCUl9SRSIsIlNDT1BFRF9BQkJSIiwiciIsInAiLCJ0bSIsInJlcGxhY2VGbiIsInJlcGxhY2Vfc2NvcGVkIiwiaW5saW5lVG9rZW5zIiwiaW5zaWRlX2F1dG9saW5rIiwicmVwbGFjZV9yYXJlIiwiYmxrSWR4IiwidHlwb2dyYXBoZXIiLCJRVU9URV9URVNUX1JFIiwiUVVPVEVfUkUiLCJBUE9TVFJPUEhFIiwicmVwbGFjZUF0IiwicHJvY2Vzc19pbmxpbmVzIiwidCIsInRoaXNMZXZlbCIsImxhc3RDaGFyIiwibmV4dENoYXIiLCJpc0xhc3RQdW5jdENoYXIiLCJpc05leHRQdW5jdENoYXIiLCJpc0xhc3RXaGl0ZVNwYWNlIiwiaXNOZXh0V2hpdGVTcGFjZSIsImNhbk9wZW4iLCJjYW5DbG9zZSIsImlzU2luZ2xlIiwic3RhY2siLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJxdW90ZXMiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJsaW5lIiwiaGFzRW1wdHlMaW5lcyIsIm1heE5lc3RpbmciLCJza2lwRW1wdHlMaW5lcyIsInNDb3VudCIsImJsa0luZGVudCIsInRpZ2h0IiwiaXNFbXB0eSIsIm91dFRva2VucyIsImxpbmVNYXgiLCJnZXRMaW5lIiwiYk1hcmtzIiwiZU1hcmtzIiwiZXNjYXBlZFNwbGl0IiwiZXNjYXBlcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJzdWJzdHJpbmciLCJ0YWJsZSIsImxpbmVUZXh0IiwibmV4dExpbmUiLCJjb2x1bW5zIiwiY29sdW1uQ291bnQiLCJhbGlnbnMiLCJ0YWJsZUxpbmVzIiwidGJvZHlMaW5lcyIsInRTaGlmdCIsImdldExpbmVzIiwicGFyYW1zIiwibWVtIiwiaGF2ZUVuZE1hcmtlciIsInNraXBDaGFycyIsInNraXBTcGFjZXMiLCJibG9ja3F1b3RlIiwiYWRqdXN0VGFiIiwiaW5pdGlhbCIsImxhc3RMaW5lRW1wdHkiLCJvZmZzZXQiLCJvbGRCTWFya3MiLCJvbGRCU0NvdW50Iiwib2xkSW5kZW50Iiwib2xkUGFyZW50VHlwZSIsIm9sZFNDb3VudCIsIm9sZFRTaGlmdCIsInNwYWNlQWZ0ZXJNYXJrZXIiLCJ0ZXJtaW5hdGUiLCJ0ZXJtaW5hdG9yUnVsZXMiLCJ3YXNPdXRkZW50ZWQiLCJvbGRMaW5lTWF4IiwiYnNDb3VudCIsInBhcmVudFR5cGUiLCJociIsImNudCIsInNraXBCdWxsZXRMaXN0TWFya2VyIiwic2tpcE9yZGVyZWRMaXN0TWFya2VyIiwibWFya1RpZ2h0UGFyYWdyYXBocyIsImNvbnRlbnRTdGFydCIsImluZGVudCIsImluZGVudEFmdGVyTWFya2VyIiwiaXNPcmRlcmVkIiwiaXRlbUxpbmVzIiwibGlzdExpbmVzIiwibGlzdFRva0lkeCIsIm1hcmtlckNoYXJDb2RlIiwibWFya2VyVmFsdWUiLCJvbGRMSW5kZW50Iiwib2xkVGlnaHQiLCJwb3NBZnRlck1hcmtlciIsInByZXZFbXB0eUVuZCIsImlzVGVybWluYXRpbmdQYXJhZ3JhcGgiLCJOdW1iZXIiLCJNYXRoIiwibWluIiwicmVmZXJlbmNlIiwiX2VuZExpbmUiLCJkZXN0RW5kUG9zIiwiZGVzdEVuZExpbmVObyIsImxhYmVsIiwicmVzIiwicmVmZXJlbmNlcyIsImhlYWRpbmciLCJ0bXAiLCJza2lwU3BhY2VzQmFjayIsInNraXBDaGFyc0JhY2siLCJsaGVhZGluZyIsImJsb2NrX25hbWVzIiwiSFRNTF9TRVFVRU5DRVMiLCJwYXJhZ3JhcGgiLCJTdGF0ZUJsb2NrIiwicyIsImluZGVudF9mb3VuZCIsImRkSW5kZW50IiwiZnJvbSIsImJlZ2luIiwia2VlcExhc3RMRiIsImxpbmVJbmRlbnQiLCJmaXJzdCIsInF1ZXVlIiwibGluZVN0YXJ0IiwiX3J1bGVzMiIsInBlbmRpbmciLCJwdXNoUGVuZGluZyIsImlzVGVybWluYXRvckNoYXIiLCJuZXdsaW5lIiwicG1heCIsIkVTQ0FQRUQiLCJlc2NhcGUiLCJiYWNrdGljayIsIm1hdGNoU3RhcnQiLCJtYXRjaEVuZCIsImxpbmsiLCJsYWJlbFN0YXJ0IiwicmVmIiwicGFyc2VSZWZlcmVuY2UiLCJFTUFJTF9SRSIsIkFVVE9MSU5LX1JFIiwiYXV0b2xpbmsiLCJ0YWlsIiwibGlua01hdGNoIiwiZW1haWxNYXRjaCIsImlzTGV0dGVyIiwibGMiLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJsaW5rX3BhaXJzIiwibGFzdERlbGltIiwiY3VyckRlbGltIiwib2RkX21hdGNoIiwidGV4dF9jb2xsYXBzZSIsImN1cnIiLCJTdGF0ZUlubGluZSIsInBlbmRpbmdMZXZlbCIsImNhblNwbGl0V29yZCIsImNvdW50IiwibGVmdF9mbGFua2luZyIsInJpZ2h0X2ZsYW5raW5nIiwiaXNSZWdFeHAiLCJpc0Z1bmN0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJmdXp6eUxpbmsiLCJmdXp6eUVtYWlsIiwiZnV6enlJUCIsImlzT3B0aW9uc09iaiIsInJlZHVjZSIsImFjYyIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJyZSIsImh0dHAiLCJzcmNfYXV0aCIsInNyY19ob3N0X3BvcnRfc3RyaWN0Iiwic3JjX3BhdGgiLCJub19odHRwIiwic3JjX2RvbWFpbiIsInNyY19kb21haW5fcm9vdCIsInNyY19wb3J0Iiwic3JjX2hvc3RfdGVybWluYXRvciIsIm1haWx0byIsInNyY19lbWFpbF9uYW1lIiwic3JjX2hvc3Rfc3RyaWN0IiwidGxkc18yY2hfc3JjX3JlIiwidGxkc19kZWZhdWx0IiwicmVzZXRTY2FuQ2FjaGUiLCJfX2luZGV4X18iLCJfX3RleHRfY2FjaGVfXyIsImNyZWF0ZVZhbGlkYXRvciIsImNyZWF0ZU5vcm1hbGl6ZXIiLCJub3JtYWxpemUiLCJfX29wdHNfXyIsInRsZHMiLCJfX3RsZHNfXyIsIm9uQ29tcGlsZSIsIl9fdGxkc19yZXBsYWNlZF9fIiwic3JjX3huIiwic3JjX3RsZHMiLCJ1bnRwbCIsInRwbCIsImVtYWlsX2Z1enp5IiwidHBsX2VtYWlsX2Z1enp5IiwibGlua19mdXp6eSIsInRwbF9saW5rX2Z1enp5IiwibGlua19ub19pcF9mdXp6eSIsInRwbF9saW5rX25vX2lwX2Z1enp5IiwiaG9zdF9mdXp6eV90ZXN0IiwidHBsX2hvc3RfZnV6enlfdGVzdCIsImFsaWFzZXMiLCJfX2NvbXBpbGVkX18iLCJzY2hlbWFFcnJvciIsInZhbCIsIl9fc2NoZW1hc19fIiwiY29tcGlsZWQiLCJhbGlhcyIsInNsaXN0Iiwic2NoZW1hX3Rlc3QiLCJzcmNfWlBDYyIsInNjaGVtYV9zZWFyY2giLCJNYXRjaCIsInNoaWZ0IiwiX19sYXN0X2luZGV4X18iLCJfX3NjaGVtYV9fIiwicmF3IiwiY3JlYXRlTWF0Y2giLCJzY2hlbWFzIiwiYWRkIiwiZGVmaW5pdGlvbiIsIm0iLCJtbCIsIm1lIiwibmV4dCIsInRsZF9wb3MiLCJhdF9wb3MiLCJ0ZXN0U2NoZW1hQXQiLCJrZWVwT2xkIiwic29ydCIsImVsIiwiYXJyIiwicmV2ZXJzZSIsIm9wdHMiLCJzcmNfQW55Iiwic3JjX0NjIiwic3JjX1oiLCJzcmNfUCIsInNyY19aQ2MiLCJ0ZXh0X3NlcGFyYXRvcnMiLCJzcmNfcHNldWRvX2xldHRlciIsInNyY19pcDQiLCJzcmNfaG9zdCIsInRwbF9ob3N0X2Z1enp5IiwidHBsX2hvc3Rfbm9faXBfZnV6enkiLCJ0cGxfaG9zdF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0IiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJnbG9iYWwiLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJmbG9vciIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIlJhbmdlRXJyb3IiLCJhcnJheSIsIm1hcERvbWFpbiIsInBhcnRzIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJvdXQiLCJuIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInciLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwiZGVmaW5lIiwidGFnRXhwciIsImF0dHJpYnV0ZXMiLCJjdXJseUF0dHJzIiwib3BlbmluZyIsImxpIiwidWwiLCJvbCIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImEiLCJzZWxmQ2xvc2luZyIsIm9taXNzaW9ucyIsImNvbnRlbnRzIiwidHlwZXMiLCJpc09wZW5lciIsInNwdXNoIiwiZmluZFBhcmVudCIsImFwcGx5VG9Ub2tlbiIsImN1cmx5SW5saW5lIiwibGFzdFRleHQiLCJjaGlsZCIsImRlcHRoIiwidHJpbVJpZ2h0IiwidGFyZ2V0cyIsInRhcmdldCIsImF0dHIiLCJ0b2RvIiwic2V0QXR0ciIsImZhY3RvcnkiLCJnbG9iYWxPYmplY3QiLCJobGpzIiwiYW1kIiwiQXJyYXlQcm90byIsIm9iamVjdEtleXMiLCJsYW5ndWFnZXMiLCJub0hpZ2hsaWdodFJlIiwibGFuZ3VhZ2VQcmVmaXhSZSIsImZpeE1hcmt1cFJlIiwic3BhbkVuZFRhZyIsImNsYXNzUHJlZml4IiwidGFiUmVwbGFjZSIsInVzZUJSIiwibm9kZSIsIm5vZGVOYW1lIiwidGVzdFJlIiwibGV4ZW1lIiwiaXNOb3RIaWdobGlnaHRlZCIsImxhbmd1YWdlIiwiYmxvY2tMYW5ndWFnZSIsImNsYXNzZXMiLCJwYXJlbnROb2RlIiwiZ2V0TGFuZ3VhZ2UiLCJpbmhlcml0Iiwib2JqZWN0cyIsIm5vZGVTdHJlYW0iLCJfbm9kZVN0cmVhbSIsImZpcnN0Q2hpbGQiLCJub2RlVmFsdWUiLCJldmVudCIsIm1lcmdlU3RyZWFtcyIsIm9yaWdpbmFsIiwicHJvY2Vzc2VkIiwibm9kZVN0YWNrIiwic2VsZWN0U3RyZWFtIiwiYXR0cl9zdHIiLCJzdHJlYW0iLCJleHBhbmRfbW9kZSIsIm1vZGUiLCJ2YXJpYW50cyIsImNhY2hlZF92YXJpYW50cyIsInZhcmlhbnQiLCJlbmRzV2l0aFBhcmVudCIsImNvbXBpbGVMYW5ndWFnZSIsInJlU3RyIiwibGFuZ1JlIiwiY2FzZV9pbnNlbnNpdGl2ZSIsImNvbXBpbGVNb2RlIiwia2V5d29yZHMiLCJiZWdpbktleXdvcmRzIiwiY29tcGlsZWRfa2V5d29yZHMiLCJmbGF0dGVuIiwia3ciLCJwYWlyIiwibGV4ZW1lc1JlIiwibGV4ZW1lcyIsImJlZ2luUmUiLCJlbmRSZSIsInRlcm1pbmF0b3JfZW5kIiwiaWxsZWdhbCIsImlsbGVnYWxSZSIsInJlbGV2YW5jZSIsImNvbnRhaW5zIiwic3RhcnRzIiwidGVybWluYXRvcnMiLCJCb29sZWFuIiwiaWdub3JlX2lsbGVnYWxzIiwiY29udGludWF0aW9uIiwic3ViTW9kZSIsImVuZE9mTW9kZSIsImVuZHNQYXJlbnQiLCJpc0lsbGVnYWwiLCJrZXl3b3JkTWF0Y2giLCJtYXRjaF9zdHIiLCJidWlsZFNwYW4iLCJjbGFzc25hbWUiLCJpbnNpZGVTcGFuIiwibGVhdmVPcGVuIiwibm9QcmVmaXgiLCJvcGVuU3BhbiIsImNsb3NlU3BhbiIsInByb2Nlc3NLZXl3b3JkcyIsImtleXdvcmRfbWF0Y2giLCJsYXN0X2luZGV4IiwibW9kZV9idWZmZXIiLCJwcm9jZXNzU3ViTGFuZ3VhZ2UiLCJleHBsaWNpdCIsInN1Ykxhbmd1YWdlIiwiY29udGludWF0aW9ucyIsImhpZ2hsaWdodEF1dG8iLCJwcm9jZXNzQnVmZmVyIiwic3RhcnROZXdNb2RlIiwiY3JlYXRlIiwicHJvY2Vzc0xleGVtZSIsImJ1ZmZlciIsIm5ld19tb2RlIiwic2tpcCIsImV4Y2x1ZGVCZWdpbiIsInJldHVybkJlZ2luIiwiZW5kX21vZGUiLCJvcmlnaW4iLCJyZXR1cm5FbmQiLCJleGNsdWRlRW5kIiwiY3VycmVudCIsIm1lc3NhZ2UiLCJsYW5ndWFnZVN1YnNldCIsInNlY29uZF9iZXN0IiwiZml4TWFya3VwIiwicDEiLCJidWlsZENsYXNzTmFtZSIsInByZXZDbGFzc05hbWUiLCJjdXJyZW50TGFuZyIsInJlc3VsdExhbmciLCJvcmlnaW5hbFN0cmVhbSIsInJlc3VsdE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidXNlcl9vcHRpb25zIiwiaW5pdEhpZ2hsaWdodGluZyIsImNhbGxlZCIsImluaXRIaWdobGlnaHRpbmdPbkxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwibGFuZyIsImxpc3RMYW5ndWFnZXMiLCJJREVOVF9SRSIsIlVOREVSU0NPUkVfSURFTlRfUkUiLCJOVU1CRVJfUkUiLCJDX05VTUJFUl9SRSIsIkJJTkFSWV9OVU1CRVJfUkUiLCJSRV9TVEFSVEVSU19SRSIsIkJBQ0tTTEFTSF9FU0NBUEUiLCJBUE9TX1NUUklOR19NT0RFIiwiUVVPVEVfU1RSSU5HX01PREUiLCJQSFJBU0FMX1dPUkRTX01PREUiLCJDT01NRU5UIiwiaW5oZXJpdHMiLCJDX0xJTkVfQ09NTUVOVF9NT0RFIiwiQ19CTE9DS19DT01NRU5UX01PREUiLCJIQVNIX0NPTU1FTlRfTU9ERSIsIk5VTUJFUl9NT0RFIiwiQ19OVU1CRVJfTU9ERSIsIkJJTkFSWV9OVU1CRVJfTU9ERSIsIkNTU19OVU1CRVJfTU9ERSIsIlJFR0VYUF9NT0RFIiwiVElUTEVfTU9ERSIsIlVOREVSU0NPUkVfVElUTEVfTU9ERSIsIk1FVEhPRF9HVUFSRCIsIktFWVdPUkRTIiwia2V5d29yZCIsImxpdGVyYWwiLCJidWlsdF9pbiIsIkVYUFJFU1NJT05TIiwiTlVNQkVSIiwiU1VCU1QiLCJURU1QTEFURV9TVFJJTkciLCJQQVJBTVNfQ09OVEFJTlMiLCJSVUxFIiwiWE1MX0lERU5UX1JFIiwiVEFHX0lOVEVSTkFMUyIsIlZBUiIsIlFVT1RFX1NUUklORyIsIkFQT1NfU1RSSU5HIiwiX3VwZGF0ZUJvcmRlciIsIiRuYXYiLCJ3aWR0aCIsImxlZnQiLCJvdXRlcldpZHRoIiwiYWRkQ2xhc3MiLCJub3ciLCJ0b051bWJlciIsIkZVTkNfRVJST1JfVEVYVCIsIm5hdGl2ZU1heCIsIm5hdGl2ZU1pbiIsImZ1bmMiLCJ3YWl0IiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwidHJhaWxpbmciLCJpbnZva2VGdW5jIiwidGltZSIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInNldFRpbWVvdXQiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwic2hvdWxkSW52b2tlIiwidHJhaWxpbmdFZGdlIiwiY2FuY2VsIiwiY2xlYXJUaW1lb3V0IiwiZmx1c2giLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiYmFzZVJhbmRvbSIsInNodWZmbGVTZWxmIiwic2l6ZSIsInJhbmQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNMZW5ndGgiLCJsYXlvdXQiLCJzdWJDYXRhbG9ncyIsImN1cnJlbnROYXYiLCJTdWJzIiwiYmluZCIsIl9vYmoiLCJEYXRlIiwiaXNTeW1ib2wiLCJOQU4iLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsIm90aGVyIiwidmFsdWVPZiIsImlzQmluYXJ5Iiwic3ltYm9sVGFnIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJhcnJheVNodWZmbGUiLCJiYXNlU2h1ZmZsZSIsImNvbGxlY3Rpb24iLCJjb3B5QXJyYXkiLCJuYXRpdmVGbG9vciIsIm5hdGl2ZVJhbmRvbSIsInJhbmRvbSIsImxvd2VyIiwidXBwZXIiLCJ2YWx1ZXMiLCJiYXNlVmFsdWVzIiwiYXJyYXlNYXAiLCJwcm9wcyIsIml0ZXJhdGVlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzIiwiaXNBcnJheUxpa2UiLCJiYXNlVGltZXMiLCJpc0FyZ3VtZW50cyIsImlzQnVmZmVyIiwiaXNJbmRleCIsImlzVHlwZWRBcnJheSIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImJhc2VJc0FyZ3VtZW50cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiYXJnc1RhZyIsInN0dWJGYWxzZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsInJlSXNVaW50IiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZVByb2Nlc3MiLCJiaW5kaW5nIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsImFyZyIsImFzeW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTtBQUNBQSxPQUFPQyxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBRCxPQUFPRSxDQUFQLEdBQVcsRUFBQ0MsNEJBQUQsRUFBV0MsMEJBQVgsRUFBb0JDLDRCQUFwQixFQUFYO0FBQ0FMLE9BQU9NLENBQVAsR0FBV0EsQ0FBWDs7Ozs7Ozs7Ozs7cUJBS0lDLEssb0JBQVE7QUFBQTs7QUFDSixlQUFPQyxrQkFBZ0IsS0FBS0MsR0FBTCxDQUFTLE9BQVQsQ0FBaEIsVUFBd0NDLElBQXhDLENBQTZDLG9CQUFZO0FBQzVELG1CQUFPQyxTQUFTQyxJQUFULEVBQVA7QUFDSCxTQUZNLEVBRUpGLElBRkksQ0FFQyxj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QUFTODhCLFdBQVQsQ0FBcUJ6M0IsS0FBckIsRUFBNEI7QUFDMUIsU0FBT0EsU0FBUyxJQUFULElBQWlCazFCLFNBQVNsMUIsTUFBTTNLLE1BQWYsQ0FBakIsSUFBMkMsQ0FBQ3NuQixXQUFXM2MsS0FBWCxDQUFuRDtBQUNEOztBQUVEbkQsT0FBT0osT0FBUCxHQUFpQmc3QixXQUFqQixDOzs7Ozs7QUNoQ0EsSUFBSTcyQixhQUFhLG1CQUFBakcsQ0FBUSxFQUFSLENBQWpCO0FBQUEsSUFDSXdGLFdBQVcsbUJBQUF4RixDQUFRLEVBQVIsQ0FEZjs7QUFHQTtBQUNBLElBQUl1Z0MsV0FBVyx3QkFBZjtBQUFBLElBQ0k3QixVQUFVLG1CQURkO0FBQUEsSUFFSThCLFNBQVMsNEJBRmI7QUFBQSxJQUdJQyxXQUFXLGdCQUhmOztBQUtBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxTQUFTemUsVUFBVCxDQUFvQjNjLEtBQXBCLEVBQTJCO0FBQ3pCLFFBQUksQ0FBQ0csU0FBU0gsS0FBVCxDQUFMLEVBQXNCO0FBQ3BCLGVBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFFBQUloQixNQUFNNEIsV0FBV1osS0FBWCxDQUFWO0FBQ0EsV0FBT2hCLE9BQU9xNkIsT0FBUCxJQUFrQnI2QixPQUFPbThCLE1BQXpCLElBQW1DbjhCLE9BQU9rOEIsUUFBMUMsSUFBc0RsOEIsT0FBT284QixRQUFwRTtBQUNEOztBQUVEditCLE9BQU9KLE9BQVAsR0FBaUJrZ0IsVUFBakIsQyIsImZpbGUiOiJzdGF0aWMvY2h1bmsvZTI4MGY5MjJjYjQ5MDU3NTdiNzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9kb2N1bWVudC52ZHQnO1xuaW1wb3J0IGNzcyBmcm9tICcuL2RvY3VtZW50LnN0eWwnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc2h1ZmZsZSBmcm9tICdsb2Rhc2gvc2h1ZmZsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbi8vIGZvciBkZWJ1Z1xud2luZG93LkludGFjdCA9IEludGFjdDtcbndpbmRvdy5fID0ge3Rocm90dGxlLCBzaHVmZmxlLCBkZWJvdW5jZX07XG53aW5kb3cuJCA9ICQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZTsgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaChgLi9kb2NzLyR7dGhpcy5nZXQoJ3RpdGxlJyl9Lm1kYCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KS50aGVuKG1kID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCdjb250ZW50JywgbWFya2VkLnJlbmRlcihtZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfbW91bnQoKSB7XG4gICAgICAgIHN1cGVyLl9tb3VudCgpO1xuICAgICAgICBjb25zdCBjb2RlcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICBjb2Rlcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaGlnaGxpZ2h0LmhpZ2hsaWdodEJsb2NrKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2F0YWxvZ3MgPSBbXTtcbiAgICAgICAgY2F0YWxvZ3MuYWN0aXZlID0gJ2FjdGl2ZTEnO1xuICAgICAgICB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgY2F0YWxvZyA9IHt0aXRsZTogaXRlbS5pbm5lclRleHR9O1xuICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gaXRlbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSAobmV4dFNpYmxpbmcudGFnTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2gxJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdoMicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXRhbG9nLnN1YnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGFsb2cuc3VicyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0YWxvZy5zdWJzLmFjdGl2ZSA9ICdhY3RpdmUyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRhbG9nLnN1YnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbmV4dFNpYmxpbmcuaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0YWxvZ3MucHVzaChjYXRhbG9nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0KCdzdWJDYXRhbG9ncycsIGNhdGFsb2dzKTtcblxuICAgICAgICB0aGlzLmV2YWxTY3JpcHQoKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCgpO1xuICAgIH1cblxuICAgIGV2YWxTY3JpcHQoKSB7XG4gICAgICAgIGNvbnN0ICRleGFtcGxlcyA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuZXhhbXBsZScpO1xuICAgICAgICBsZXQgdGVtcGxhdGU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgJGV4YW1wbGUgPSAkZXhhbXBsZXMuZXEoaSk7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICRleGFtcGxlLnRleHQoKTtcbiAgICAgICAgICAgIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnYXV0bycpKSB7XG4gICAgICAgICAgICAgICAgbGV0IF9DO1xuICAgICAgICAgICAgICAgIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbGFuZ3VhZ2UtaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gSW50YWN0LlZkdC5jb21waWxlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBfQyA9IEludGFjdC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2phdmFzY3JpcHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBfQyA9IGV2YWwoY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCAkY29udGFpbmVyID0gJCgnPGRpdiBjbGFzcz1cIm91dHB1dFwiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICRleGFtcGxlLnBhcmVudCgpLmFmdGVyKCRjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIEludGFjdC5tb3VudChfQywgJGNvbnRhaW5lclswXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdtYW51YWwnKSkge1xuICAgICAgICAgICAgICAgIGxldCAkYnV0dG9uID0gJCgnPGJ1dHRvbj7ngrnlh7vov5DooYw8L2J1dHRvbj4nKTtcbiAgICAgICAgICAgICAgICBsZXQgJHAgPSAkKCc8cD48L3A+JykuYXBwZW5kKCRidXR0b24pO1xuICAgICAgICAgICAgICAgICRleGFtcGxlLnBhcmVudCgpLmFmdGVyKCRwKTtcbiAgICAgICAgICAgICAgICAkYnV0dG9uLm9uKCdjbGljaycsICgoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KShjb2RlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdsYW5ndWFnZS1odG1sJykpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IEludGFjdC5WZHQuY29tcGlsZShjb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2phdmFzY3JpcHQnKSkge1xuICAgICAgICAgICAgICAgIGV2YWwoY29kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdsYW5ndWFnZS1jc3MnKSkge1xuICAgICAgICAgICAgICAgICRleGFtcGxlLnBhcmVudCgpLmFmdGVyKGA8c3R5bGU+JHtjb2RlfTwvc3R5bGU+YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmiafooYxzY3JpcHTmoIfnrb5cbiAgICAgICAgY29uc3QgJHNjcmlwdHMgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnc2NyaXB0Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCAkc2NyaXB0ID0gJHNjcmlwdHMuZXEoaSk7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICRzY3JpcHQudGV4dCgpO1xuICAgICAgICAgICAgZXZhbChjb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICBjb25zdCAkd3JhcHBlciA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuY29udGVudC13cmFwcGVyJyk7XG4gICAgICAgIGNvbnN0ICRhcnRpY2xlID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJ2FydGljbGUnKTtcbiAgICAgICAgY29uc3QgJGgxcyA9ICRhcnRpY2xlLmZpbmQoJ2gxJyk7XG4gICAgICAgIGNvbnN0ICRoMnMgPSAkYXJ0aWNsZS5maW5kKCdoMicpO1xuICAgICAgICBjb25zdCAkYXNpZGUgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnYXNpZGUnKTtcbiAgICAgICAgY29uc3QgJGJvcmRlciA9ICRhc2lkZS5maW5kKCcuYXNpZGUtYm9yZGVyJyk7XG4gICAgICAgIGNvbnN0ICR3aW5kb3cgPSAkKHdpbmRvdyk7XG4gICAgICAgICR3aW5kb3cub2ZmKCdzY3JvbGwnKTtcbiAgICAgICAgJHdpbmRvdy5vbignc2Nyb2xsLmZpeCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICR3cmFwcGVyW3Njcm9sbFRvcCA+PSAxNSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnZml4ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgICR3aW5kb3cub24oJ3Njcm9sbC5hY3RpdmUnLCB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRBY3RpdmUoJGhzLCBtaW5Ub3AgPSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9ICRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJGggPSAkaHMuZXEoaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSAkaC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCAmJiBzY3JvbGxUb3AgPj0gdG9wIC0gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJGgudGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7dGV4dDogJycsIHRvcDogMH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZTEgPSBmaW5kQWN0aXZlKCRoMXMpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlMiA9IGZpbmRBY3RpdmUoJGgycywgYWN0aXZlMS50b3ApO1xuXG4gICAgICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgICAgICAgYWN0aXZlMjogYWN0aXZlMi50ZXh0LFxuICAgICAgICAgICAgICAgIGFjdGl2ZTE6IGFjdGl2ZTEudGV4dCBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkYWN0aXZlQSA9ICRhc2lkZS5maW5kKCcuYWN0aXZlJykubGFzdCgpLmNoaWxkcmVuKCdhJyk7XG4gICAgICAgICAgICBpZiAoJGFjdGl2ZUEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9ICRhY3RpdmVBLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSAkYWN0aXZlQS5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAkYm9yZGVyLmNzcyh7aGVpZ2h0OiBoZWlnaHQsIHRvcDogdG9wfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDUwKSk7XG4gICAgICAgICR3aW5kb3cudHJpZ2dlcignc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgc2Nyb2xsVG8odGV4dCwgdHlwZSkge1xuICAgICAgICBjb25zdCAkYXJ0aWNsZSA9ICQodGhpcy5lbGVtZW50KS5maW5kKCdhcnRpY2xlJyk7XG4gICAgICAgIGNvbnN0ICRocyA9ICRhcnRpY2xlLmZpbmQodHlwZSA9PT0gJ2FjdGl2ZTEnID8gJ2gxJyA6ICdoMicpO1xuICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0ICRoID0gJGhzLmVxKGkpO1xuICAgICAgICAgICAgaWYgKCRoLnRleHQoKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSAkaC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHRvcCAtIDYwXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsJyk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFnZXMvZG9jdW1lbnQvaW5kZXguanMiLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn0qL1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUFsbChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgIGlmIChlc2NhcGVkKSB7IHJldHVybiBlc2NhcGVkOyB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgJ1xcXFwkJicpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OlxuICAgIGNhc2UgMHgyMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICBpZiAoY29kZSA+PSAweDIwMDAgJiYgY29kZSA8PSAweDIwMEEpIHsgcmV0dXJuIHRydWU7IH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG52YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxuZnVuY3Rpb24gaXNQdW5jdENoYXIoY2gpIHtcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG59XG5cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDI3LyogJyAqLzpcbiAgICBjYXNlIDB4MjgvKiAoICovOlxuICAgIGNhc2UgMHgyOS8qICkgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyQy8qICwgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4MkUvKiAuICovOlxuICAgIGNhc2UgMHgyRi8qIC8gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHgzRi8qID8gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0MvKiB8ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVwbGVyIHRvIHVuaWZ5IFtyZWZlcmVuY2UgbGFiZWxzXS5cbi8vXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5leHBvcnRzLmxpYiAgICAgICAgICAgICAgICAgPSB7fTtcbmV4cG9ydHMubGliLm1kdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcbmV4cG9ydHMuaGFzICAgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcbmV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgICA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICAgID0gZnJvbUNvZGVQb2ludDtcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlSHRtbCAgICAgICAgICA9IGVzY2FwZUh0bWw7XG5leHBvcnRzLmFycmF5UmVwbGFjZUF0ICAgICAgPSBhcnJheVJlcGxhY2VBdDtcbmV4cG9ydHMuaXNTcGFjZSAgICAgICAgICAgICA9IGlzU3BhY2U7XG5leHBvcnRzLmlzV2hpdGVTcGFjZSAgICAgICAgPSBpc1doaXRlU3BhY2U7XG5leHBvcnRzLmlzTWRBc2NpaVB1bmN0ICAgICAgPSBpc01kQXNjaWlQdW5jdDtcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xuZXhwb3J0cy5lc2NhcGVSRSAgICAgICAgICAgID0gZXNjYXBlUkU7XG5leHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSAgPSBub3JtYWxpemVSZWZlcmVuY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDRcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwiLyoqXG4gKiBjbGFzcyBSdWxlclxuICpcbiAqIEhlbHBlciBjbGFzcywgdXNlZCBieSBbW01hcmtkb3duSXQjY29yZV1dLCBbW01hcmtkb3duSXQjYmxvY2tdXSBhbmRcbiAqIFtbTWFya2Rvd25JdCNpbmxpbmVdXSB0byBtYW5hZ2Ugc2VxdWVuY2VzIG9mIGZ1bmN0aW9ucyAocnVsZXMpOlxuICpcbiAqIC0ga2VlcCBydWxlcyBpbiBkZWZpbmVkIG9yZGVyXG4gKiAtIGFzc2lnbiB0aGUgbmFtZSB0byBlYWNoIHJ1bGVcbiAqIC0gZW5hYmxlL2Rpc2FibGUgcnVsZXNcbiAqIC0gYWRkL3JlcGxhY2UgcnVsZXNcbiAqIC0gYWxsb3cgYXNzaWduIHJ1bGVzIHRvIGFkZGl0aW9uYWwgbmFtZWQgY2hhaW5zIChpbiB0aGUgc2FtZSlcbiAqIC0gY2FjaGVpbmcgbGlzdHMgb2YgYWN0aXZlIHJ1bGVzXG4gKlxuICogWW91IHdpbGwgbm90IG5lZWQgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkgdW50aWwgd3JpdGUgcGx1Z2lucy4gRm9yIHNpbXBsZVxuICogcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSwgW1tNYXJrZG93bkl0LmVuYWJsZV1dIGFuZFxuICogW1tNYXJrZG93bkl0LnVzZV1dLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogbmV3IFJ1bGVyKClcbiAqKi9cbmZ1bmN0aW9uIFJ1bGVyKCkge1xuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XG4gIC8vXG4gIC8vIHtcbiAgLy8gICBuYW1lOiBYWFgsXG4gIC8vICAgZW5hYmxlZDogQm9vbGVhbixcbiAgLy8gICBmbjogRnVuY3Rpb24oKSxcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF1cbiAgLy8gfVxuICAvL1xuICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xuXG4gIC8vIENhY2hlZCBydWxlIGNoYWlucy5cbiAgLy9cbiAgLy8gRmlyc3QgbGV2ZWwgLSBjaGFpbiBuYW1lLCAnJyBmb3IgZGVmYXVsdC5cbiAgLy8gU2Vjb25kIGxldmVsIC0gZGlnaW5hbCBhbmNob3IgZm9yIGZhc3QgZmlsdGVyaW5nIGJ5IGNoYXJjb2Rlcy5cbiAgLy9cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIG1ldGhvZHMsIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseVxuXG5cbi8vIEZpbmQgcnVsZSBpbmRleCBieSBuYW1lXG4vL1xuUnVsZXIucHJvdG90eXBlLl9fZmluZF9fID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcnVsZXNfXy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLl9fcnVsZXNfX1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vLyBCdWlsZCBydWxlcyBsb29rdXAgY2FjaGVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19jb21waWxlX18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNoYWlucyA9IFsgJycgXTtcblxuICAvLyBjb2xsZWN0IHVuaXF1ZSBuYW1lc1xuICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBydWxlLmFsdC5mb3JFYWNoKGZ1bmN0aW9uIChhbHROYW1lKSB7XG4gICAgICBpZiAoY2hhaW5zLmluZGV4T2YoYWx0TmFtZSkgPCAwKSB7XG4gICAgICAgIGNoYWlucy5wdXNoKGFsdE5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBzZWxmLl9fY2FjaGVfXyA9IHt9O1xuXG4gIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXSA9IFtdO1xuICAgIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoY2hhaW4gJiYgcnVsZS5hbHQuaW5kZXhPZihjaGFpbikgPCAwKSB7IHJldHVybjsgfVxuXG4gICAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0ucHVzaChydWxlLmZuKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYXQobmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgbmFtZSB0byByZXBsYWNlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBuZXcgcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogbmV3IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUmVwbGFjZSBydWxlIGJ5IG5hbWUgd2l0aCBuZXcgZnVuY3Rpb24gJiBvcHRpb25zLiBUaHJvd3MgZXJyb3IgaWYgbmFtZSBub3RcbiAqIGZvdW5kLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogUmVwbGFjZSBleGlzdGluZyB0eXBvcmdhcGhlciByZXBsYWNlbWVudCBydWxlIHdpdGggbmV3IG9uZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5hdCgncmVwbGFjZW1lbnRzJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgbmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uZm4gPSBmbjtcbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmFsdCA9IG9wdC5hbHQgfHwgW107XG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5iZWZvcmUoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBiZWZvcmVOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGJlZm9yZSB0aGlzIG9uZS5cbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYmVmb3JlIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmFmdGVyXV0sIFtbUnVsZXIucHVzaF1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZSgncGFyYWdyYXBoJywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIChiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hZnRlcihhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYWZ0ZXJOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBhZnRlciBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuaW5saW5lLnJ1bGVyLmFmdGVyKCd0ZXh0JywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmFmdGVyID0gZnVuY3Rpb24gKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYWZ0ZXJOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGFmdGVyTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogUnVsZXIucHVzaChydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUHVzaCBuZXcgcnVsZSB0byB0aGUgZW5kIG9mIGNoYWluLiBTZWUgYWxzb1xuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5hZnRlcl1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmNvcmUucnVsZXIucHVzaCgnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGVuYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZiAoaWdub3JlSW52YWxpZCkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZW5hYmxlT25seShsaXN0IFssIGlnbm9yZUludmFsaWRdKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlICh3aGl0ZWxpc3QpLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMsIGFuZCBkaXNhYmxlIGV2ZXJ5dGhpbmcgZWxzZS4gSWYgYW55IHJ1bGUgbmFtZVxuICogbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZU9ubHkgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkgeyBydWxlLmVuYWJsZWQgPSBmYWxzZTsgfSk7XG5cbiAgdGhpcy5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZCk7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZGlzYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIERpc2FibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cbiAqIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZW5hYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBkaXNhYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZ2V0UnVsZXMoY2hhaW5OYW1lKSAtPiBBcnJheVxuICpcbiAqIFJldHVybiBhcnJheSBvZiBhY3RpdmUgZnVuY3Rpb25zIChydWxlcykgZm9yIGdpdmVuIGNoYWluIG5hbWUuIEl0IGFuYWx5emVzXG4gKiBydWxlcyBjb25maWd1cmF0aW9uLCBjb21waWxlcyBjYWNoZXMgaWYgbm90IGV4aXN0cyBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogRGVmYXVsdCBjaGFpbiBuYW1lIGlzIGAnJ2AgKGVtcHR5IHN0cmluZykuIEl0IGNhbid0IGJlIHNraXBwZWQuIFRoYXQnc1xuICogZG9uZSBpbnRlbnRpb25hbGx5LCB0byBrZWVwIHNpZ25hdHVyZSBtb25vbW9ycGhpYyBmb3IgaGlnaCBzcGVlZC5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uIChjaGFpbk5hbWUpIHtcbiAgaWYgKHRoaXMuX19jYWNoZV9fID09PSBudWxsKSB7XG4gICAgdGhpcy5fX2NvbXBpbGVfXygpO1xuICB9XG5cbiAgLy8gQ2hhaW4gY2FuIGJlIGVtcHR5LCBpZiBydWxlcyBkaXNhYmxlZC4gQnV0IHdlIHN0aWxsIGhhdmUgdG8gcmV0dXJuIEFycmF5LlxuICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUnVsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwiLy8gVG9rZW4gY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogY2xhc3MgVG9rZW5cbiAqKi9cblxuLyoqXG4gKiBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICpcbiAqIENyZWF0ZSBuZXcgdG9rZW4gYW5kIGZpbGwgcGFzc2VkIHByb3BlcnRpZXMuXG4gKiovXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgLyoqXG4gICAqIFRva2VuI3R5cGUgLT4gU3RyaW5nXG4gICAqXG4gICAqIFR5cGUgb2YgdGhlIHRva2VuIChzdHJpbmcsIGUuZy4gXCJwYXJhZ3JhcGhfb3BlblwiKVxuICAgKiovXG4gIHRoaXMudHlwZSAgICAgPSB0eXBlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiN0YWcgLT4gU3RyaW5nXG4gICAqXG4gICAqIGh0bWwgdGFnIG5hbWUsIGUuZy4gXCJwXCJcbiAgICoqL1xuICB0aGlzLnRhZyAgICAgID0gdGFnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNhdHRycyAtPiBBcnJheVxuICAgKlxuICAgKiBIdG1sIGF0dHJpYnV0ZXMuIEZvcm1hdDogYFsgWyBuYW1lMSwgdmFsdWUxIF0sIFsgbmFtZTIsIHZhbHVlMiBdIF1gXG4gICAqKi9cbiAgdGhpcy5hdHRycyAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcCAtPiBBcnJheVxuICAgKlxuICAgKiBTb3VyY2UgbWFwIGluZm8uIEZvcm1hdDogYFsgbGluZV9iZWdpbiwgbGluZV9lbmQgXWBcbiAgICoqL1xuICB0aGlzLm1hcCAgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbmVzdGluZyAtPiBOdW1iZXJcbiAgICpcbiAgICogTGV2ZWwgY2hhbmdlIChudW1iZXIgaW4gey0xLCAwLCAxfSBzZXQpLCB3aGVyZTpcbiAgICpcbiAgICogLSAgYDFgIG1lYW5zIHRoZSB0YWcgaXMgb3BlbmluZ1xuICAgKiAtICBgMGAgbWVhbnMgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmdcbiAgICogLSBgLTFgIG1lYW5zIHRoZSB0YWcgaXMgY2xvc2luZ1xuICAgKiovXG4gIHRoaXMubmVzdGluZyAgPSBuZXN0aW5nO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcbiAgICpcbiAgICogbmVzdGluZyBsZXZlbCwgdGhlIHNhbWUgYXMgYHN0YXRlLmxldmVsYFxuICAgKiovXG4gIHRoaXMubGV2ZWwgICAgPSAwO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjaGlsZHJlbiAtPiBBcnJheVxuICAgKlxuICAgKiBBbiBhcnJheSBvZiBjaGlsZCBub2RlcyAoaW5saW5lIGFuZCBpbWcgdG9rZW5zKVxuICAgKiovXG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjb250ZW50IC0+IFN0cmluZ1xuICAgKlxuICAgKiBJbiBhIGNhc2Ugb2Ygc2VsZi1jbG9zaW5nIHRhZyAoY29kZSwgaHRtbCwgZmVuY2UsIGV0Yy4pLFxuICAgKiBpdCBoYXMgY29udGVudHMgb2YgdGhpcyB0YWcuXG4gICAqKi9cbiAgdGhpcy5jb250ZW50ICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXJrdXAgLT4gU3RyaW5nXG4gICAqXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5tYXJrdXAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNpbmZvIC0+IFN0cmluZ1xuICAgKlxuICAgKiBmZW5jZSBpbmZvc3RyaW5nXG4gICAqKi9cbiAgdGhpcy5pbmZvICAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxuICAgKlxuICAgKiBBIHBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBkYXRhXG4gICAqKi9cbiAgdGhpcy5tZXRhICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2Jsb2NrIC0+IEJvb2xlYW5cbiAgICpcbiAgICogVHJ1ZSBmb3IgYmxvY2stbGV2ZWwgdG9rZW5zLCBmYWxzZSBmb3IgaW5saW5lIHRva2Vucy5cbiAgICogVXNlZCBpbiByZW5kZXJlciB0byBjYWxjdWxhdGUgbGluZSBicmVha3NcbiAgICoqL1xuICB0aGlzLmJsb2NrICAgID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRva2VuI2hpZGRlbiAtPiBCb29sZWFuXG4gICAqXG4gICAqIElmIGl0J3MgdHJ1ZSwgaWdub3JlIHRoaXMgZWxlbWVudCB3aGVuIHJlbmRlcmluZy4gVXNlZCBmb3IgdGlnaHQgbGlzdHNcbiAgICogdG8gaGlkZSBwYXJhZ3JhcGhzLlxuICAgKiovXG4gIHRoaXMuaGlkZGVuICAgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFRva2VuLmF0dHJJbmRleChuYW1lKSAtPiBOdW1iZXJcbiAqXG4gKiBTZWFyY2ggYXR0cmlidXRlIGluZGV4IGJ5IG5hbWUuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckluZGV4ID0gZnVuY3Rpb24gYXR0ckluZGV4KG5hbWUpIHtcbiAgdmFyIGF0dHJzLCBpLCBsZW47XG5cbiAgaWYgKCF0aGlzLmF0dHJzKSB7IHJldHVybiAtMTsgfVxuXG4gIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSA9PT0gbmFtZSkgeyByZXR1cm4gaTsgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyUHVzaChhdHRyRGF0YSlcbiAqXG4gKiBBZGQgYFsgbmFtZSwgdmFsdWUgXWAgYXR0cmlidXRlIHRvIGxpc3QuIEluaXQgYXR0cnMgaWYgbmVjZXNzYXJ5XG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clB1c2ggPSBmdW5jdGlvbiBhdHRyUHVzaChhdHRyRGF0YSkge1xuICBpZiAodGhpcy5hdHRycykge1xuICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRycyA9IFsgYXR0ckRhdGEgXTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJTZXQobmFtZSwgdmFsdWUpXG4gKlxuICogU2V0IGBuYW1lYCBhdHRyaWJ1dGUgdG8gYHZhbHVlYC4gT3ZlcnJpZGUgb2xkIHZhbHVlIGlmIGV4aXN0cy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyU2V0ID0gZnVuY3Rpb24gYXR0clNldChuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksXG4gICAgICBhdHRyRGF0YSA9IFsgbmFtZSwgdmFsdWUgXTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJEYXRhO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckdldChuYW1lKVxuICpcbiAqIEdldCB0aGUgdmFsdWUgb2YgYXR0cmlidXRlIGBuYW1lYCwgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyR2V0ID0gZnVuY3Rpb24gYXR0ckdldChuYW1lKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgdmFsdWUgPSBudWxsO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckpvaW4obmFtZSwgdmFsdWUpXG4gKlxuICogSm9pbiB2YWx1ZSB0byBleGlzdGluZyBhdHRyaWJ1dGUgdmlhIHNwYWNlLiBPciBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBpZiBub3RcbiAqIGV4aXN0cy4gVXNlZnVsIHRvIG9wZXJhdGUgd2l0aCB0b2tlbiBjbGFzc2VzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJKb2luID0gZnVuY3Rpb24gYXR0ckpvaW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChbIG5hbWUsIHZhbHVlIF0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XVsxXSA9IHRoaXMuYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIi8vIEhUTUw1IGVudGl0aWVzIG1hcDogeyBuYW1lIC0+IHV0ZjE2c3RyaW5nIH1cbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IHF1b3RlczowKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWR1cmwvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwiLy8gfn5zdHJpa2UgdGhyb3VnaH5+XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sIGxlbiwgY2gsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgdHJ1ZSk7XG4gIGxlbiA9IHNjYW5uZWQubGVuZ3RoO1xuICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBpZiAobGVuIDwgMikgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobGVuICUgMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBjaDtcbiAgICBsZW4tLTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBjaCArIGNoO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAganVtcDogICBpLFxuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcbiAgICAgIGxldmVsOiAgc3RhdGUubGV2ZWwsXG4gICAgICBlbmQ6ICAgIC0xLFxuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlKSB7XG4gIHZhciBpLCBqLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBsb25lTWFya2VycyA9IFtdLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSAnc19vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSAnc19jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS5jb250ZW50ID09PSAnficpIHtcblxuICAgICAgbG9uZU1hcmtlcnMucHVzaChlbmREZWxpbS50b2tlbiAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGEgbWFya2VyIHNlcXVlbmNlIGhhcyBhbiBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGl0J3Mgc3BsaXR0ZWRcbiAgLy8gbGlrZSB0aGlzOiBgfn5+fn5gIC0+IGB+YCArIGB+fmAgKyBgfn5gLCBsZWF2aW5nIG9uZSBtYXJrZXIgYXQgdGhlXG4gIC8vIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgLy9cbiAgLy8gU28sIHdlIGhhdmUgdG8gbW92ZSBhbGwgdGhvc2UgbWFya2VycyBhZnRlciBzdWJzZXF1ZW50IHNfY2xvc2UgdGFncy5cbiAgLy9cbiAgd2hpbGUgKGxvbmVNYXJrZXJzLmxlbmd0aCkge1xuICAgIGkgPSBsb25lTWFya2Vycy5wb3AoKTtcbiAgICBqID0gaSArIDE7XG5cbiAgICB3aGlsZSAoaiA8IHN0YXRlLnRva2Vucy5sZW5ndGggJiYgc3RhdGUudG9rZW5zW2pdLnR5cGUgPT09ICdzX2Nsb3NlJykge1xuICAgICAgaisrO1xuICAgIH1cblxuICAgIGotLTtcblxuICAgIGlmIChpICE9PSBqKSB7XG4gICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tqXTtcbiAgICAgIHN0YXRlLnRva2Vuc1tqXSA9IHN0YXRlLnRva2Vuc1tpXTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXSA9IHRva2VuO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEFuIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGJlZm9yZSB0aGlzIG9uZSB0aGF0J3MgZXF1aXZhbGVudCB0b1xuICAgICAgLy8gY3VycmVudCBvbmUuIEluIHBsYWluIEVuZ2xpc2g6IGlmIHRoaXMgZGVsaW1pdGVyIGRvZXMgbm90IG9wZW5cbiAgICAgIC8vIGFuIGVtcGhhc2lzLCBuZWl0aGVyIGRvIHByZXZpb3VzIGBqdW1wYCBjaGFyYWN0ZXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFVzZWQgdG8gc2tpcCBzZXF1ZW5jZXMgbGlrZSBcIioqKioqXCIgaW4gb25lIHN0ZXAsIGZvciAxc3QgYXN0ZXJpc2tcbiAgICAgIC8vIHZhbHVlIHdpbGwgYmUgMCwgZm9yIDJuZCBpdCdzIDEgYW5kIHNvIG9uLlxuICAgICAgLy9cbiAgICAgIGp1bXA6ICAgaSxcblxuICAgICAgLy8gQSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gdGhpcyBkZWxpbWl0ZXIgY29ycmVzcG9uZHMgdG8uXG4gICAgICAvL1xuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcblxuICAgICAgLy8gVG9rZW4gbGV2ZWwuXG4gICAgICAvL1xuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcblxuICAgICAgLy8gSWYgdGhpcyBkZWxpbWl0ZXIgaXMgbWF0Y2hlZCBhcyBhIHZhbGlkIG9wZW5lciwgYGVuZGAgd2lsbCBiZVxuICAgICAgLy8gZXF1YWwgdG8gaXRzIHBvc2l0aW9uLCBvdGhlcndpc2UgaXQncyBgLTFgLlxuICAgICAgLy9cbiAgICAgIGVuZDogICAgLTEsXG5cbiAgICAgIC8vIEJvb2xlYW4gZmxhZ3MgdGhhdCBkZXRlcm1pbmUgaWYgdGhpcyBkZWxpbWl0ZXIgY291bGQgb3BlbiBvciBjbG9zZVxuICAgICAgLy8gYW4gZW1waGFzaXMuXG4gICAgICAvL1xuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSkge1xuICB2YXIgaSxcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgY2gsXG4gICAgICBpc1N0cm9uZyxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4NUYvKiBfICovICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDJBLyogKiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBvbmx5IG9wZW5pbmcgbWFya2Vyc1xuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICAvLyBJZiB0aGUgbmV4dCBkZWxpbWl0ZXIgaGFzIHRoZSBzYW1lIG1hcmtlciBhbmQgaXMgYWRqYWNlbnQgdG8gdGhpcyBvbmUsXG4gICAgLy8gbWVyZ2UgdGhvc2UgaW50byBvbmUgc3Ryb25nIGRlbGltaXRlci5cbiAgICAvL1xuICAgIC8vIGA8ZW0+PGVtPndoYXRldmVyPC9lbT48L2VtPmAgLT4gYDxzdHJvbmc+d2hhdGV2ZXI8L3N0cm9uZz5gXG4gICAgLy9cbiAgICBpc1N0cm9uZyA9IGkgKyAxIDwgbWF4ICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5lbmQgPT09IHN0YXJ0RGVsaW0uZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gKyAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kIC0gMV0udG9rZW4gPT09IGVuZERlbGltLnRva2VuIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlcjtcblxuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydERlbGltLm1hcmtlcik7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfb3BlbicgOiAnZW1fb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX2Nsb3NlJyA6ICdlbV9jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKGlzU3Ryb25nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpICsgMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kIC0gMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MpIHtcbmlmIChtb2R1bGUuaG90KSB7XG4gICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgZGF0YS52ZHQgPSBfX3RoaXM7XG4gICAgICAgIGRhdGEuaXNQYXJlbnQgPSBfX3RoaXMuZGF0YSAhPT0gb2JqO1xuICAgIH0pXG59XG5cbl9WZHQgfHwgKF9WZHQgPSBWZHQpO1xub2JqIHx8IChvYmogPSB7fSk7XG5ibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbnZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG5fX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsXG5fX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG5fc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbl9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbnNlbGYgPSB0aGlzLmRhdGEsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9IHNlbGYgJiYgc2VsZi5fcGFyZW50VGVtcGxhdGVcbmNvbnN0IG5hdiA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAn5pWZ56iLJyxcbiAgICAgICAgaHJlZjogJ2RvY3VtZW50J1xuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0FQSScsXG4gICAgICAgIGhyZWY6ICdhcGknXG4gICAgfSxcbiAgICAvLyB7XG4gICAgICAgIC8vIHRpdGxlOiAn56S65L6LJyxcbiAgICAgICAgLy8gaHJlZjogJ2V4YW1wbGVzJ1xuICAgIC8vIH1cbl1cbnJldHVybiBoKCdkaXYnLCBudWxsLCBbaCgnZGl2JywgbnVsbCwgaCgnaGVhZGVyJywgbnVsbCwgKF9ibG9ja3MuaGVhZGVyID0gZnVuY3Rpb24ocGFyZW50KSB7cmV0dXJuIFtoKCdhJywgeydocmVmJzogJyMvJ30sICdJbnRhY3QnLCAnbG9nbycpLCBoKCduYXYnLCBudWxsLCBbX1ZkdC51dGlscy5tYXAoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW25hdl1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbnJldHVybiBoKCdhJywgeydocmVmJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW2AjLyR7dmFsdWUuaHJlZn1gXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKX0sIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt2YWx1ZS50aXRsZV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdmFsdWUuaHJlZiA9PT0gc2NvcGUubmF2SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykpKTtcbn0sIHRoaXMpLCBoKCdkaXYnLCBudWxsLCBudWxsLCAnYm9yZGVyJyldKV07fSkgJiYgKF9fYmxvY2tzLmhlYWRlciA9IGZ1bmN0aW9uKHBhcmVudCkge1xudmFyIHNlbGYgPSB0aGlzO1xucmV0dXJuIGJsb2Nrcy5oZWFkZXIgPyBibG9ja3MuaGVhZGVyLmNhbGwodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gX2Jsb2Nrcy5oZWFkZXIuY2FsbChzZWxmLCBwYXJlbnQpO1xufSkgOiBfYmxvY2tzLmhlYWRlci5jYWxsKHRoaXMsIHBhcmVudCk7XG59KSAmJiBfX2Jsb2Nrcy5oZWFkZXIuY2FsbCh0aGlzKSksICdoZWFkZXItd3JhcHBlcicpLCBoKCdkaXYnLCBudWxsLCAoX2Jsb2Nrcy5jb250ZW50ID0gZnVuY3Rpb24ocGFyZW50KSB7cmV0dXJuIG51bGw7fSkgJiYgKF9fYmxvY2tzLmNvbnRlbnQgPSBmdW5jdGlvbihwYXJlbnQpIHtcbnZhciBzZWxmID0gdGhpcztcbnJldHVybiBibG9ja3MuY29udGVudCA/IGJsb2Nrcy5jb250ZW50LmNhbGwodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gX2Jsb2Nrcy5jb250ZW50LmNhbGwoc2VsZiwgcGFyZW50KTtcbn0pIDogX2Jsb2Nrcy5jb250ZW50LmNhbGwodGhpcywgcGFyZW50KTtcbn0pICYmIF9fYmxvY2tzLmNvbnRlbnQuY2FsbCh0aGlzKSwgJ2NvbnRlbnQtd3JhcHBlcicpXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiBbJ21haW4td3JhcHBlciAnICsgKHNjb3BlLmNsYXNzTmFtZSB8fCAnJyldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpKSlcbn1cbmlmIChtb2R1bGUuaG90KSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKTtcbiAgICB2YXIgdmR0ID0gbW9kdWxlLmhvdC5kYXRhICYmIG1vZHVsZS5ob3QuZGF0YS52ZHRcbiAgICBpZiAodmR0KSB7XG4gICAgICAgIGlmICghbW9kdWxlLmhvdC5kYXRhLmlzUGFyZW50KSB7XG4gICAgICAgICAgICB2ZHQudGVtcGxhdGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICB2ZHQudXBkYXRlKCk7XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL2xheW91dC52ZHQiLCJpbXBvcnQgTWFya2Rvd25JdCBmcm9tICdtYXJrZG93bi1pdCc7XG5pbXBvcnQgTWFya2Rvd25JdERlY29yYXRlIGZyb20gJ21hcmtkb3duLWl0LWRlY29yYXRlJztcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQnO1xuaW1wb3J0IGxKYXZhc2NyaXB0IGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQnO1xuaW1wb3J0IGxDc3MgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzJztcbmltcG9ydCBsWG1sIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbCc7XG5pbXBvcnQgbEJhc2ggZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaCc7XG5cbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdiYXNoJywgbEJhc2gpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2NzcycsIGxDc3MpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmFzY3JpcHQnLCBsSmF2YXNjcmlwdCk7XG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgneG1sJywgbFhtbCk7XG5cbndpbmRvdy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbmNvbnN0IG1hcmtlZCA9IE1hcmtkb3duSXQoe1xuICAgIGh0bWw6IHRydWUsXG4gICAgYnJlYWtzOiBmYWxzZSBcbn0pLnVzZShNYXJrZG93bkl0RGVjb3JhdGUpO1xuLy8g5Y675o6J5q616JC9c29mdGJyZWFrXG5tYXJrZWQucmVuZGVyZXIucnVsZXMuc29mdGJyZWFrID0gKCkgPT4gJyc7XG5cbmV4cG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvaW5kZXguanMiLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJBYWN1dGVcIjpcIsOBXCIsXCJhYWN1dGVcIjpcIsOhXCIsXCJBYnJldmVcIjpcIsSCXCIsXCJhYnJldmVcIjpcIsSDXCIsXCJhY1wiOlwi4oi+XCIsXCJhY2RcIjpcIuKIv1wiLFwiYWNFXCI6XCLiiL7Ms1wiLFwiQWNpcmNcIjpcIsOCXCIsXCJhY2lyY1wiOlwiw6JcIixcImFjdXRlXCI6XCLCtFwiLFwiQWN5XCI6XCLQkFwiLFwiYWN5XCI6XCLQsFwiLFwiQUVsaWdcIjpcIsOGXCIsXCJhZWxpZ1wiOlwiw6ZcIixcImFmXCI6XCLigaFcIixcIkFmclwiOlwi8J2UhFwiLFwiYWZyXCI6XCLwnZSeXCIsXCJBZ3JhdmVcIjpcIsOAXCIsXCJhZ3JhdmVcIjpcIsOgXCIsXCJhbGVmc3ltXCI6XCLihLVcIixcImFsZXBoXCI6XCLihLVcIixcIkFscGhhXCI6XCLOkVwiLFwiYWxwaGFcIjpcIs6xXCIsXCJBbWFjclwiOlwixIBcIixcImFtYWNyXCI6XCLEgVwiLFwiYW1hbGdcIjpcIuKov1wiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcImFuZGFuZFwiOlwi4qmVXCIsXCJBbmRcIjpcIuKpk1wiLFwiYW5kXCI6XCLiiKdcIixcImFuZGRcIjpcIuKpnFwiLFwiYW5kc2xvcGVcIjpcIuKpmFwiLFwiYW5kdlwiOlwi4qmaXCIsXCJhbmdcIjpcIuKIoFwiLFwiYW5nZVwiOlwi4qakXCIsXCJhbmdsZVwiOlwi4oigXCIsXCJhbmdtc2RhYVwiOlwi4qaoXCIsXCJhbmdtc2RhYlwiOlwi4qapXCIsXCJhbmdtc2RhY1wiOlwi4qaqXCIsXCJhbmdtc2RhZFwiOlwi4qarXCIsXCJhbmdtc2RhZVwiOlwi4qasXCIsXCJhbmdtc2RhZlwiOlwi4qatXCIsXCJhbmdtc2RhZ1wiOlwi4qauXCIsXCJhbmdtc2RhaFwiOlwi4qavXCIsXCJhbmdtc2RcIjpcIuKIoVwiLFwiYW5ncnRcIjpcIuKIn1wiLFwiYW5ncnR2YlwiOlwi4oq+XCIsXCJhbmdydHZiZFwiOlwi4qadXCIsXCJhbmdzcGhcIjpcIuKIolwiLFwiYW5nc3RcIjpcIsOFXCIsXCJhbmd6YXJyXCI6XCLijbxcIixcIkFvZ29uXCI6XCLEhFwiLFwiYW9nb25cIjpcIsSFXCIsXCJBb3BmXCI6XCLwnZS4XCIsXCJhb3BmXCI6XCLwnZWSXCIsXCJhcGFjaXJcIjpcIuKpr1wiLFwiYXBcIjpcIuKJiFwiLFwiYXBFXCI6XCLiqbBcIixcImFwZVwiOlwi4omKXCIsXCJhcGlkXCI6XCLiiYtcIixcImFwb3NcIjpcIidcIixcIkFwcGx5RnVuY3Rpb25cIjpcIuKBoVwiLFwiYXBwcm94XCI6XCLiiYhcIixcImFwcHJveGVxXCI6XCLiiYpcIixcIkFyaW5nXCI6XCLDhVwiLFwiYXJpbmdcIjpcIsOlXCIsXCJBc2NyXCI6XCLwnZKcXCIsXCJhc2NyXCI6XCLwnZK2XCIsXCJBc3NpZ25cIjpcIuKJlFwiLFwiYXN0XCI6XCIqXCIsXCJhc3ltcFwiOlwi4omIXCIsXCJhc3ltcGVxXCI6XCLiiY1cIixcIkF0aWxkZVwiOlwiw4NcIixcImF0aWxkZVwiOlwiw6NcIixcIkF1bWxcIjpcIsOEXCIsXCJhdW1sXCI6XCLDpFwiLFwiYXdjb25pbnRcIjpcIuKIs1wiLFwiYXdpbnRcIjpcIuKokVwiLFwiYmFja2NvbmdcIjpcIuKJjFwiLFwiYmFja2Vwc2lsb25cIjpcIs+2XCIsXCJiYWNrcHJpbWVcIjpcIuKAtVwiLFwiYmFja3NpbVwiOlwi4oi9XCIsXCJiYWNrc2ltZXFcIjpcIuKLjVwiLFwiQmFja3NsYXNoXCI6XCLiiJZcIixcIkJhcnZcIjpcIuKrp1wiLFwiYmFydmVlXCI6XCLiir1cIixcImJhcndlZFwiOlwi4oyFXCIsXCJCYXJ3ZWRcIjpcIuKMhlwiLFwiYmFyd2VkZ2VcIjpcIuKMhVwiLFwiYmJya1wiOlwi4o61XCIsXCJiYnJrdGJya1wiOlwi4o62XCIsXCJiY29uZ1wiOlwi4omMXCIsXCJCY3lcIjpcItCRXCIsXCJiY3lcIjpcItCxXCIsXCJiZHF1b1wiOlwi4oCeXCIsXCJiZWNhdXNcIjpcIuKItVwiLFwiYmVjYXVzZVwiOlwi4oi1XCIsXCJCZWNhdXNlXCI6XCLiiLVcIixcImJlbXB0eXZcIjpcIuKmsFwiLFwiYmVwc2lcIjpcIs+2XCIsXCJiZXJub3VcIjpcIuKErFwiLFwiQmVybm91bGxpc1wiOlwi4oSsXCIsXCJCZXRhXCI6XCLOklwiLFwiYmV0YVwiOlwizrJcIixcImJldGhcIjpcIuKEtlwiLFwiYmV0d2VlblwiOlwi4omsXCIsXCJCZnJcIjpcIvCdlIVcIixcImJmclwiOlwi8J2Un1wiLFwiYmlnY2FwXCI6XCLii4JcIixcImJpZ2NpcmNcIjpcIuKXr1wiLFwiYmlnY3VwXCI6XCLii4NcIixcImJpZ29kb3RcIjpcIuKogFwiLFwiYmlnb3BsdXNcIjpcIuKogVwiLFwiYmlnb3RpbWVzXCI6XCLiqIJcIixcImJpZ3NxY3VwXCI6XCLiqIZcIixcImJpZ3N0YXJcIjpcIuKYhVwiLFwiYmlndHJpYW5nbGVkb3duXCI6XCLilr1cIixcImJpZ3RyaWFuZ2xldXBcIjpcIuKWs1wiLFwiYmlndXBsdXNcIjpcIuKohFwiLFwiYmlndmVlXCI6XCLii4FcIixcImJpZ3dlZGdlXCI6XCLii4BcIixcImJrYXJvd1wiOlwi4qSNXCIsXCJibGFja2xvemVuZ2VcIjpcIuKnq1wiLFwiYmxhY2tzcXVhcmVcIjpcIuKWqlwiLFwiYmxhY2t0cmlhbmdsZVwiOlwi4pa0XCIsXCJibGFja3RyaWFuZ2xlZG93blwiOlwi4pa+XCIsXCJibGFja3RyaWFuZ2xlbGVmdFwiOlwi4peCXCIsXCJibGFja3RyaWFuZ2xlcmlnaHRcIjpcIuKWuFwiLFwiYmxhbmtcIjpcIuKQo1wiLFwiYmxrMTJcIjpcIuKWklwiLFwiYmxrMTRcIjpcIuKWkVwiLFwiYmxrMzRcIjpcIuKWk1wiLFwiYmxvY2tcIjpcIuKWiFwiLFwiYm5lXCI6XCI94oOlXCIsXCJibmVxdWl2XCI6XCLiiaHig6VcIixcImJOb3RcIjpcIuKrrVwiLFwiYm5vdFwiOlwi4oyQXCIsXCJCb3BmXCI6XCLwnZS5XCIsXCJib3BmXCI6XCLwnZWTXCIsXCJib3RcIjpcIuKKpVwiLFwiYm90dG9tXCI6XCLiiqVcIixcImJvd3RpZVwiOlwi4ouIXCIsXCJib3hib3hcIjpcIuKniVwiLFwiYm94ZGxcIjpcIuKUkFwiLFwiYm94ZExcIjpcIuKVlVwiLFwiYm94RGxcIjpcIuKVllwiLFwiYm94RExcIjpcIuKVl1wiLFwiYm94ZHJcIjpcIuKUjFwiLFwiYm94ZFJcIjpcIuKVklwiLFwiYm94RHJcIjpcIuKVk1wiLFwiYm94RFJcIjpcIuKVlFwiLFwiYm94aFwiOlwi4pSAXCIsXCJib3hIXCI6XCLilZBcIixcImJveGhkXCI6XCLilKxcIixcImJveEhkXCI6XCLilaRcIixcImJveGhEXCI6XCLilaVcIixcImJveEhEXCI6XCLilaZcIixcImJveGh1XCI6XCLilLRcIixcImJveEh1XCI6XCLiladcIixcImJveGhVXCI6XCLilahcIixcImJveEhVXCI6XCLilalcIixcImJveG1pbnVzXCI6XCLiip9cIixcImJveHBsdXNcIjpcIuKKnlwiLFwiYm94dGltZXNcIjpcIuKKoFwiLFwiYm94dWxcIjpcIuKUmFwiLFwiYm94dUxcIjpcIuKVm1wiLFwiYm94VWxcIjpcIuKVnFwiLFwiYm94VUxcIjpcIuKVnVwiLFwiYm94dXJcIjpcIuKUlFwiLFwiYm94dVJcIjpcIuKVmFwiLFwiYm94VXJcIjpcIuKVmVwiLFwiYm94VVJcIjpcIuKVmlwiLFwiYm94dlwiOlwi4pSCXCIsXCJib3hWXCI6XCLilZFcIixcImJveHZoXCI6XCLilLxcIixcImJveHZIXCI6XCLilapcIixcImJveFZoXCI6XCLilatcIixcImJveFZIXCI6XCLilaxcIixcImJveHZsXCI6XCLilKRcIixcImJveHZMXCI6XCLilaFcIixcImJveFZsXCI6XCLilaJcIixcImJveFZMXCI6XCLilaNcIixcImJveHZyXCI6XCLilJxcIixcImJveHZSXCI6XCLilZ5cIixcImJveFZyXCI6XCLilZ9cIixcImJveFZSXCI6XCLilaBcIixcImJwcmltZVwiOlwi4oC1XCIsXCJicmV2ZVwiOlwiy5hcIixcIkJyZXZlXCI6XCLLmFwiLFwiYnJ2YmFyXCI6XCLCplwiLFwiYnNjclwiOlwi8J2St1wiLFwiQnNjclwiOlwi4oSsXCIsXCJic2VtaVwiOlwi4oGPXCIsXCJic2ltXCI6XCLiiL1cIixcImJzaW1lXCI6XCLii41cIixcImJzb2xiXCI6XCLip4VcIixcImJzb2xcIjpcIlxcXFxcIixcImJzb2xoc3ViXCI6XCLin4hcIixcImJ1bGxcIjpcIuKAolwiLFwiYnVsbGV0XCI6XCLigKJcIixcImJ1bXBcIjpcIuKJjlwiLFwiYnVtcEVcIjpcIuKqrlwiLFwiYnVtcGVcIjpcIuKJj1wiLFwiQnVtcGVxXCI6XCLiiY5cIixcImJ1bXBlcVwiOlwi4omPXCIsXCJDYWN1dGVcIjpcIsSGXCIsXCJjYWN1dGVcIjpcIsSHXCIsXCJjYXBhbmRcIjpcIuKphFwiLFwiY2FwYnJjdXBcIjpcIuKpiVwiLFwiY2FwY2FwXCI6XCLiqYtcIixcImNhcFwiOlwi4oipXCIsXCJDYXBcIjpcIuKLklwiLFwiY2FwY3VwXCI6XCLiqYdcIixcImNhcGRvdFwiOlwi4qmAXCIsXCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOlwi4oWFXCIsXCJjYXBzXCI6XCLiiKnvuIBcIixcImNhcmV0XCI6XCLigYFcIixcImNhcm9uXCI6XCLLh1wiLFwiQ2F5bGV5c1wiOlwi4oStXCIsXCJjY2Fwc1wiOlwi4qmNXCIsXCJDY2Fyb25cIjpcIsSMXCIsXCJjY2Fyb25cIjpcIsSNXCIsXCJDY2VkaWxcIjpcIsOHXCIsXCJjY2VkaWxcIjpcIsOnXCIsXCJDY2lyY1wiOlwixIhcIixcImNjaXJjXCI6XCLEiVwiLFwiQ2NvbmludFwiOlwi4oiwXCIsXCJjY3Vwc1wiOlwi4qmMXCIsXCJjY3Vwc3NtXCI6XCLiqZBcIixcIkNkb3RcIjpcIsSKXCIsXCJjZG90XCI6XCLEi1wiLFwiY2VkaWxcIjpcIsK4XCIsXCJDZWRpbGxhXCI6XCLCuFwiLFwiY2VtcHR5dlwiOlwi4qayXCIsXCJjZW50XCI6XCLColwiLFwiY2VudGVyZG90XCI6XCLCt1wiLFwiQ2VudGVyRG90XCI6XCLCt1wiLFwiY2ZyXCI6XCLwnZSgXCIsXCJDZnJcIjpcIuKErVwiLFwiQ0hjeVwiOlwi0KdcIixcImNoY3lcIjpcItGHXCIsXCJjaGVja1wiOlwi4pyTXCIsXCJjaGVja21hcmtcIjpcIuKck1wiLFwiQ2hpXCI6XCLOp1wiLFwiY2hpXCI6XCLPh1wiLFwiY2lyY1wiOlwiy4ZcIixcImNpcmNlcVwiOlwi4omXXCIsXCJjaXJjbGVhcnJvd2xlZnRcIjpcIuKGulwiLFwiY2lyY2xlYXJyb3dyaWdodFwiOlwi4oa7XCIsXCJjaXJjbGVkYXN0XCI6XCLiiptcIixcImNpcmNsZWRjaXJjXCI6XCLiippcIixcImNpcmNsZWRkYXNoXCI6XCLiip1cIixcIkNpcmNsZURvdFwiOlwi4oqZXCIsXCJjaXJjbGVkUlwiOlwiwq5cIixcImNpcmNsZWRTXCI6XCLik4hcIixcIkNpcmNsZU1pbnVzXCI6XCLiipZcIixcIkNpcmNsZVBsdXNcIjpcIuKKlVwiLFwiQ2lyY2xlVGltZXNcIjpcIuKKl1wiLFwiY2lyXCI6XCLil4tcIixcImNpckVcIjpcIuKng1wiLFwiY2lyZVwiOlwi4omXXCIsXCJjaXJmbmludFwiOlwi4qiQXCIsXCJjaXJtaWRcIjpcIuKrr1wiLFwiY2lyc2NpclwiOlwi4qeCXCIsXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIslwiLFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCLigJ1cIixcIkNsb3NlQ3VybHlRdW90ZVwiOlwi4oCZXCIsXCJjbHVic1wiOlwi4pmjXCIsXCJjbHVic3VpdFwiOlwi4pmjXCIsXCJjb2xvblwiOlwiOlwiLFwiQ29sb25cIjpcIuKIt1wiLFwiQ29sb25lXCI6XCLiqbRcIixcImNvbG9uZVwiOlwi4omUXCIsXCJjb2xvbmVxXCI6XCLiiZRcIixcImNvbW1hXCI6XCIsXCIsXCJjb21tYXRcIjpcIkBcIixcImNvbXBcIjpcIuKIgVwiLFwiY29tcGZuXCI6XCLiiJhcIixcImNvbXBsZW1lbnRcIjpcIuKIgVwiLFwiY29tcGxleGVzXCI6XCLihIJcIixcImNvbmdcIjpcIuKJhVwiLFwiY29uZ2RvdFwiOlwi4qmtXCIsXCJDb25ncnVlbnRcIjpcIuKJoVwiLFwiY29uaW50XCI6XCLiiK5cIixcIkNvbmludFwiOlwi4oivXCIsXCJDb250b3VySW50ZWdyYWxcIjpcIuKIrlwiLFwiY29wZlwiOlwi8J2VlFwiLFwiQ29wZlwiOlwi4oSCXCIsXCJjb3Byb2RcIjpcIuKIkFwiLFwiQ29wcm9kdWN0XCI6XCLiiJBcIixcImNvcHlcIjpcIsKpXCIsXCJDT1BZXCI6XCLCqVwiLFwiY29weXNyXCI6XCLihJdcIixcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIs1wiLFwiY3JhcnJcIjpcIuKGtVwiLFwiY3Jvc3NcIjpcIuKcl1wiLFwiQ3Jvc3NcIjpcIuKor1wiLFwiQ3NjclwiOlwi8J2SnlwiLFwiY3NjclwiOlwi8J2SuFwiLFwiY3N1YlwiOlwi4quPXCIsXCJjc3ViZVwiOlwi4quRXCIsXCJjc3VwXCI6XCLiq5BcIixcImNzdXBlXCI6XCLiq5JcIixcImN0ZG90XCI6XCLii69cIixcImN1ZGFycmxcIjpcIuKkuFwiLFwiY3VkYXJyclwiOlwi4qS1XCIsXCJjdWVwclwiOlwi4oueXCIsXCJjdWVzY1wiOlwi4oufXCIsXCJjdWxhcnJcIjpcIuKGtlwiLFwiY3VsYXJycFwiOlwi4qS9XCIsXCJjdXBicmNhcFwiOlwi4qmIXCIsXCJjdXBjYXBcIjpcIuKphlwiLFwiQ3VwQ2FwXCI6XCLiiY1cIixcImN1cFwiOlwi4oiqXCIsXCJDdXBcIjpcIuKLk1wiLFwiY3VwY3VwXCI6XCLiqYpcIixcImN1cGRvdFwiOlwi4oqNXCIsXCJjdXBvclwiOlwi4qmFXCIsXCJjdXBzXCI6XCLiiKrvuIBcIixcImN1cmFyclwiOlwi4oa3XCIsXCJjdXJhcnJtXCI6XCLipLxcIixcImN1cmx5ZXFwcmVjXCI6XCLii55cIixcImN1cmx5ZXFzdWNjXCI6XCLii59cIixcImN1cmx5dmVlXCI6XCLii45cIixcImN1cmx5d2VkZ2VcIjpcIuKLj1wiLFwiY3VycmVuXCI6XCLCpFwiLFwiY3VydmVhcnJvd2xlZnRcIjpcIuKGtlwiLFwiY3VydmVhcnJvd3JpZ2h0XCI6XCLihrdcIixcImN1dmVlXCI6XCLii45cIixcImN1d2VkXCI6XCLii49cIixcImN3Y29uaW50XCI6XCLiiLJcIixcImN3aW50XCI6XCLiiLFcIixcImN5bGN0eVwiOlwi4oytXCIsXCJkYWdnZXJcIjpcIuKAoFwiLFwiRGFnZ2VyXCI6XCLigKFcIixcImRhbGV0aFwiOlwi4oS4XCIsXCJkYXJyXCI6XCLihpNcIixcIkRhcnJcIjpcIuKGoVwiLFwiZEFyclwiOlwi4oeTXCIsXCJkYXNoXCI6XCLigJBcIixcIkRhc2h2XCI6XCLiq6RcIixcImRhc2h2XCI6XCLiiqNcIixcImRia2Fyb3dcIjpcIuKkj1wiLFwiZGJsYWNcIjpcIsudXCIsXCJEY2Fyb25cIjpcIsSOXCIsXCJkY2Fyb25cIjpcIsSPXCIsXCJEY3lcIjpcItCUXCIsXCJkY3lcIjpcItC0XCIsXCJkZGFnZ2VyXCI6XCLigKFcIixcImRkYXJyXCI6XCLih4pcIixcIkREXCI6XCLihYVcIixcImRkXCI6XCLihYZcIixcIkREb3RyYWhkXCI6XCLipJFcIixcImRkb3RzZXFcIjpcIuKpt1wiLFwiZGVnXCI6XCLCsFwiLFwiRGVsXCI6XCLiiIdcIixcIkRlbHRhXCI6XCLOlFwiLFwiZGVsdGFcIjpcIs60XCIsXCJkZW1wdHl2XCI6XCLiprFcIixcImRmaXNodFwiOlwi4qW/XCIsXCJEZnJcIjpcIvCdlIdcIixcImRmclwiOlwi8J2UoVwiLFwiZEhhclwiOlwi4qWlXCIsXCJkaGFybFwiOlwi4oeDXCIsXCJkaGFyclwiOlwi4oeCXCIsXCJEaWFjcml0aWNhbEFjdXRlXCI6XCLCtFwiLFwiRGlhY3JpdGljYWxEb3RcIjpcIsuZXCIsXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6XCLLnVwiLFwiRGlhY3JpdGljYWxHcmF2ZVwiOlwiYFwiLFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiy5xcIixcImRpYW1cIjpcIuKLhFwiLFwiZGlhbW9uZFwiOlwi4ouEXCIsXCJEaWFtb25kXCI6XCLii4RcIixcImRpYW1vbmRzdWl0XCI6XCLimaZcIixcImRpYW1zXCI6XCLimaZcIixcImRpZVwiOlwiwqhcIixcIkRpZmZlcmVudGlhbERcIjpcIuKFhlwiLFwiZGlnYW1tYVwiOlwiz51cIixcImRpc2luXCI6XCLii7JcIixcImRpdlwiOlwiw7dcIixcImRpdmlkZVwiOlwiw7dcIixcImRpdmlkZW9udGltZXNcIjpcIuKLh1wiLFwiZGl2b254XCI6XCLii4dcIixcIkRKY3lcIjpcItCCXCIsXCJkamN5XCI6XCLRklwiLFwiZGxjb3JuXCI6XCLijJ5cIixcImRsY3JvcFwiOlwi4oyNXCIsXCJkb2xsYXJcIjpcIiRcIixcIkRvcGZcIjpcIvCdlLtcIixcImRvcGZcIjpcIvCdlZVcIixcIkRvdFwiOlwiwqhcIixcImRvdFwiOlwiy5lcIixcIkRvdERvdFwiOlwi4oOcXCIsXCJkb3RlcVwiOlwi4omQXCIsXCJkb3RlcWRvdFwiOlwi4omRXCIsXCJEb3RFcXVhbFwiOlwi4omQXCIsXCJkb3RtaW51c1wiOlwi4oi4XCIsXCJkb3RwbHVzXCI6XCLiiJRcIixcImRvdHNxdWFyZVwiOlwi4oqhXCIsXCJkb3VibGViYXJ3ZWRnZVwiOlwi4oyGXCIsXCJEb3VibGVDb250b3VySW50ZWdyYWxcIjpcIuKIr1wiLFwiRG91YmxlRG90XCI6XCLCqFwiLFwiRG91YmxlRG93bkFycm93XCI6XCLih5NcIixcIkRvdWJsZUxlZnRBcnJvd1wiOlwi4oeQXCIsXCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOlwi4oeUXCIsXCJEb3VibGVMZWZ0VGVlXCI6XCLiq6RcIixcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjpcIuKfuFwiLFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7pcIixcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCLin7lcIixcIkRvdWJsZVJpZ2h0QXJyb3dcIjpcIuKHklwiLFwiRG91YmxlUmlnaHRUZWVcIjpcIuKKqFwiLFwiRG91YmxlVXBBcnJvd1wiOlwi4oeRXCIsXCJEb3VibGVVcERvd25BcnJvd1wiOlwi4oeVXCIsXCJEb3VibGVWZXJ0aWNhbEJhclwiOlwi4oilXCIsXCJEb3duQXJyb3dCYXJcIjpcIuKkk1wiLFwiZG93bmFycm93XCI6XCLihpNcIixcIkRvd25BcnJvd1wiOlwi4oaTXCIsXCJEb3duYXJyb3dcIjpcIuKHk1wiLFwiRG93bkFycm93VXBBcnJvd1wiOlwi4oe1XCIsXCJEb3duQnJldmVcIjpcIsyRXCIsXCJkb3duZG93bmFycm93c1wiOlwi4oeKXCIsXCJkb3duaGFycG9vbmxlZnRcIjpcIuKHg1wiLFwiZG93bmhhcnBvb25yaWdodFwiOlwi4oeCXCIsXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCLipZBcIixcIkRvd25MZWZ0VGVlVmVjdG9yXCI6XCLipZ5cIixcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCLipZZcIixcIkRvd25MZWZ0VmVjdG9yXCI6XCLihr1cIixcIkRvd25SaWdodFRlZVZlY3RvclwiOlwi4qWfXCIsXCJEb3duUmlnaHRWZWN0b3JCYXJcIjpcIuKll1wiLFwiRG93blJpZ2h0VmVjdG9yXCI6XCLih4FcIixcIkRvd25UZWVBcnJvd1wiOlwi4oanXCIsXCJEb3duVGVlXCI6XCLiiqRcIixcImRyYmthcm93XCI6XCLipJBcIixcImRyY29yblwiOlwi4oyfXCIsXCJkcmNyb3BcIjpcIuKMjFwiLFwiRHNjclwiOlwi8J2Sn1wiLFwiZHNjclwiOlwi8J2SuVwiLFwiRFNjeVwiOlwi0IVcIixcImRzY3lcIjpcItGVXCIsXCJkc29sXCI6XCLip7ZcIixcIkRzdHJva1wiOlwixJBcIixcImRzdHJva1wiOlwixJFcIixcImR0ZG90XCI6XCLii7FcIixcImR0cmlcIjpcIuKWv1wiLFwiZHRyaWZcIjpcIuKWvlwiLFwiZHVhcnJcIjpcIuKHtVwiLFwiZHVoYXJcIjpcIuKlr1wiLFwiZHdhbmdsZVwiOlwi4qamXCIsXCJEWmN5XCI6XCLQj1wiLFwiZHpjeVwiOlwi0Z9cIixcImR6aWdyYXJyXCI6XCLin79cIixcIkVhY3V0ZVwiOlwiw4lcIixcImVhY3V0ZVwiOlwiw6lcIixcImVhc3RlclwiOlwi4qmuXCIsXCJFY2Fyb25cIjpcIsSaXCIsXCJlY2Fyb25cIjpcIsSbXCIsXCJFY2lyY1wiOlwiw4pcIixcImVjaXJjXCI6XCLDqlwiLFwiZWNpclwiOlwi4omWXCIsXCJlY29sb25cIjpcIuKJlVwiLFwiRWN5XCI6XCLQrVwiLFwiZWN5XCI6XCLRjVwiLFwiZUREb3RcIjpcIuKpt1wiLFwiRWRvdFwiOlwixJZcIixcImVkb3RcIjpcIsSXXCIsXCJlRG90XCI6XCLiiZFcIixcImVlXCI6XCLihYdcIixcImVmRG90XCI6XCLiiZJcIixcIkVmclwiOlwi8J2UiFwiLFwiZWZyXCI6XCLwnZSiXCIsXCJlZ1wiOlwi4qqaXCIsXCJFZ3JhdmVcIjpcIsOIXCIsXCJlZ3JhdmVcIjpcIsOoXCIsXCJlZ3NcIjpcIuKqllwiLFwiZWdzZG90XCI6XCLiqphcIixcImVsXCI6XCLiqplcIixcIkVsZW1lbnRcIjpcIuKIiFwiLFwiZWxpbnRlcnNcIjpcIuKPp1wiLFwiZWxsXCI6XCLihJNcIixcImVsc1wiOlwi4qqVXCIsXCJlbHNkb3RcIjpcIuKql1wiLFwiRW1hY3JcIjpcIsSSXCIsXCJlbWFjclwiOlwixJNcIixcImVtcHR5XCI6XCLiiIVcIixcImVtcHR5c2V0XCI6XCLiiIVcIixcIkVtcHR5U21hbGxTcXVhcmVcIjpcIuKXu1wiLFwiZW1wdHl2XCI6XCLiiIVcIixcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6XCLilqtcIixcImVtc3AxM1wiOlwi4oCEXCIsXCJlbXNwMTRcIjpcIuKAhVwiLFwiZW1zcFwiOlwi4oCDXCIsXCJFTkdcIjpcIsWKXCIsXCJlbmdcIjpcIsWLXCIsXCJlbnNwXCI6XCLigIJcIixcIkVvZ29uXCI6XCLEmFwiLFwiZW9nb25cIjpcIsSZXCIsXCJFb3BmXCI6XCLwnZS8XCIsXCJlb3BmXCI6XCLwnZWWXCIsXCJlcGFyXCI6XCLii5VcIixcImVwYXJzbFwiOlwi4qejXCIsXCJlcGx1c1wiOlwi4qmxXCIsXCJlcHNpXCI6XCLOtVwiLFwiRXBzaWxvblwiOlwizpVcIixcImVwc2lsb25cIjpcIs61XCIsXCJlcHNpdlwiOlwiz7VcIixcImVxY2lyY1wiOlwi4omWXCIsXCJlcWNvbG9uXCI6XCLiiZVcIixcImVxc2ltXCI6XCLiiYJcIixcImVxc2xhbnRndHJcIjpcIuKqllwiLFwiZXFzbGFudGxlc3NcIjpcIuKqlVwiLFwiRXF1YWxcIjpcIuKptVwiLFwiZXF1YWxzXCI6XCI9XCIsXCJFcXVhbFRpbGRlXCI6XCLiiYJcIixcImVxdWVzdFwiOlwi4omfXCIsXCJFcXVpbGlicml1bVwiOlwi4oeMXCIsXCJlcXVpdlwiOlwi4omhXCIsXCJlcXVpdkREXCI6XCLiqbhcIixcImVxdnBhcnNsXCI6XCLip6VcIixcImVyYXJyXCI6XCLipbFcIixcImVyRG90XCI6XCLiiZNcIixcImVzY3JcIjpcIuKEr1wiLFwiRXNjclwiOlwi4oSwXCIsXCJlc2RvdFwiOlwi4omQXCIsXCJFc2ltXCI6XCLiqbNcIixcImVzaW1cIjpcIuKJglwiLFwiRXRhXCI6XCLOl1wiLFwiZXRhXCI6XCLOt1wiLFwiRVRIXCI6XCLDkFwiLFwiZXRoXCI6XCLDsFwiLFwiRXVtbFwiOlwiw4tcIixcImV1bWxcIjpcIsOrXCIsXCJldXJvXCI6XCLigqxcIixcImV4Y2xcIjpcIiFcIixcImV4aXN0XCI6XCLiiINcIixcIkV4aXN0c1wiOlwi4oiDXCIsXCJleHBlY3RhdGlvblwiOlwi4oSwXCIsXCJleHBvbmVudGlhbGVcIjpcIuKFh1wiLFwiRXhwb25lbnRpYWxFXCI6XCLihYdcIixcImZhbGxpbmdkb3RzZXFcIjpcIuKJklwiLFwiRmN5XCI6XCLQpFwiLFwiZmN5XCI6XCLRhFwiLFwiZmVtYWxlXCI6XCLimYBcIixcImZmaWxpZ1wiOlwi76yDXCIsXCJmZmxpZ1wiOlwi76yAXCIsXCJmZmxsaWdcIjpcIu+shFwiLFwiRmZyXCI6XCLwnZSJXCIsXCJmZnJcIjpcIvCdlKNcIixcImZpbGlnXCI6XCLvrIFcIixcIkZpbGxlZFNtYWxsU3F1YXJlXCI6XCLil7xcIixcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOlwi4paqXCIsXCJmamxpZ1wiOlwiZmpcIixcImZsYXRcIjpcIuKZrVwiLFwiZmxsaWdcIjpcIu+sglwiLFwiZmx0bnNcIjpcIuKWsVwiLFwiZm5vZlwiOlwixpJcIixcIkZvcGZcIjpcIvCdlL1cIixcImZvcGZcIjpcIvCdlZdcIixcImZvcmFsbFwiOlwi4oiAXCIsXCJGb3JBbGxcIjpcIuKIgFwiLFwiZm9ya1wiOlwi4ouUXCIsXCJmb3JrdlwiOlwi4quZXCIsXCJGb3VyaWVydHJmXCI6XCLihLFcIixcImZwYXJ0aW50XCI6XCLiqI1cIixcImZyYWMxMlwiOlwiwr1cIixcImZyYWMxM1wiOlwi4oWTXCIsXCJmcmFjMTRcIjpcIsK8XCIsXCJmcmFjMTVcIjpcIuKFlVwiLFwiZnJhYzE2XCI6XCLihZlcIixcImZyYWMxOFwiOlwi4oWbXCIsXCJmcmFjMjNcIjpcIuKFlFwiLFwiZnJhYzI1XCI6XCLihZZcIixcImZyYWMzNFwiOlwiwr5cIixcImZyYWMzNVwiOlwi4oWXXCIsXCJmcmFjMzhcIjpcIuKFnFwiLFwiZnJhYzQ1XCI6XCLihZhcIixcImZyYWM1NlwiOlwi4oWaXCIsXCJmcmFjNThcIjpcIuKFnVwiLFwiZnJhYzc4XCI6XCLihZ5cIixcImZyYXNsXCI6XCLigYRcIixcImZyb3duXCI6XCLijKJcIixcImZzY3JcIjpcIvCdkrtcIixcIkZzY3JcIjpcIuKEsVwiLFwiZ2FjdXRlXCI6XCLHtVwiLFwiR2FtbWFcIjpcIs6TXCIsXCJnYW1tYVwiOlwizrNcIixcIkdhbW1hZFwiOlwiz5xcIixcImdhbW1hZFwiOlwiz51cIixcImdhcFwiOlwi4qqGXCIsXCJHYnJldmVcIjpcIsSeXCIsXCJnYnJldmVcIjpcIsSfXCIsXCJHY2VkaWxcIjpcIsSiXCIsXCJHY2lyY1wiOlwixJxcIixcImdjaXJjXCI6XCLEnVwiLFwiR2N5XCI6XCLQk1wiLFwiZ2N5XCI6XCLQs1wiLFwiR2RvdFwiOlwixKBcIixcImdkb3RcIjpcIsShXCIsXCJnZVwiOlwi4omlXCIsXCJnRVwiOlwi4omnXCIsXCJnRWxcIjpcIuKqjFwiLFwiZ2VsXCI6XCLii5tcIixcImdlcVwiOlwi4omlXCIsXCJnZXFxXCI6XCLiiadcIixcImdlcXNsYW50XCI6XCLiqb5cIixcImdlc2NjXCI6XCLiqqlcIixcImdlc1wiOlwi4qm+XCIsXCJnZXNkb3RcIjpcIuKqgFwiLFwiZ2VzZG90b1wiOlwi4qqCXCIsXCJnZXNkb3RvbFwiOlwi4qqEXCIsXCJnZXNsXCI6XCLii5vvuIBcIixcImdlc2xlc1wiOlwi4qqUXCIsXCJHZnJcIjpcIvCdlIpcIixcImdmclwiOlwi8J2UpFwiLFwiZ2dcIjpcIuKJq1wiLFwiR2dcIjpcIuKLmVwiLFwiZ2dnXCI6XCLii5lcIixcImdpbWVsXCI6XCLihLdcIixcIkdKY3lcIjpcItCDXCIsXCJnamN5XCI6XCLRk1wiLFwiZ2xhXCI6XCLiqqVcIixcImdsXCI6XCLiibdcIixcImdsRVwiOlwi4qqSXCIsXCJnbGpcIjpcIuKqpFwiLFwiZ25hcFwiOlwi4qqKXCIsXCJnbmFwcHJveFwiOlwi4qqKXCIsXCJnbmVcIjpcIuKqiFwiLFwiZ25FXCI6XCLiialcIixcImduZXFcIjpcIuKqiFwiLFwiZ25lcXFcIjpcIuKJqVwiLFwiZ25zaW1cIjpcIuKLp1wiLFwiR29wZlwiOlwi8J2UvlwiLFwiZ29wZlwiOlwi8J2VmFwiLFwiZ3JhdmVcIjpcImBcIixcIkdyZWF0ZXJFcXVhbFwiOlwi4omlXCIsXCJHcmVhdGVyRXF1YWxMZXNzXCI6XCLii5tcIixcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp1wiLFwiR3JlYXRlckdyZWF0ZXJcIjpcIuKqolwiLFwiR3JlYXRlckxlc3NcIjpcIuKJt1wiLFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvlwiLFwiR3JlYXRlclRpbGRlXCI6XCLiibNcIixcIkdzY3JcIjpcIvCdkqJcIixcImdzY3JcIjpcIuKEilwiLFwiZ3NpbVwiOlwi4omzXCIsXCJnc2ltZVwiOlwi4qqOXCIsXCJnc2ltbFwiOlwi4qqQXCIsXCJndGNjXCI6XCLiqqdcIixcImd0Y2lyXCI6XCLiqbpcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiR3RcIjpcIuKJq1wiLFwiZ3Rkb3RcIjpcIuKLl1wiLFwiZ3RsUGFyXCI6XCLippVcIixcImd0cXVlc3RcIjpcIuKpvFwiLFwiZ3RyYXBwcm94XCI6XCLiqoZcIixcImd0cmFyclwiOlwi4qW4XCIsXCJndHJkb3RcIjpcIuKLl1wiLFwiZ3RyZXFsZXNzXCI6XCLii5tcIixcImd0cmVxcWxlc3NcIjpcIuKqjFwiLFwiZ3RybGVzc1wiOlwi4om3XCIsXCJndHJzaW1cIjpcIuKJs1wiLFwiZ3ZlcnRuZXFxXCI6XCLiianvuIBcIixcImd2bkVcIjpcIuKJqe+4gFwiLFwiSGFjZWtcIjpcIsuHXCIsXCJoYWlyc3BcIjpcIuKAilwiLFwiaGFsZlwiOlwiwr1cIixcImhhbWlsdFwiOlwi4oSLXCIsXCJIQVJEY3lcIjpcItCqXCIsXCJoYXJkY3lcIjpcItGKXCIsXCJoYXJyY2lyXCI6XCLipYhcIixcImhhcnJcIjpcIuKGlFwiLFwiaEFyclwiOlwi4oeUXCIsXCJoYXJyd1wiOlwi4oatXCIsXCJIYXRcIjpcIl5cIixcImhiYXJcIjpcIuKEj1wiLFwiSGNpcmNcIjpcIsSkXCIsXCJoY2lyY1wiOlwixKVcIixcImhlYXJ0c1wiOlwi4pmlXCIsXCJoZWFydHN1aXRcIjpcIuKZpVwiLFwiaGVsbGlwXCI6XCLigKZcIixcImhlcmNvblwiOlwi4oq5XCIsXCJoZnJcIjpcIvCdlKVcIixcIkhmclwiOlwi4oSMXCIsXCJIaWxiZXJ0U3BhY2VcIjpcIuKEi1wiLFwiaGtzZWFyb3dcIjpcIuKkpVwiLFwiaGtzd2Fyb3dcIjpcIuKkplwiLFwiaG9hcnJcIjpcIuKHv1wiLFwiaG9tdGh0XCI6XCLiiLtcIixcImhvb2tsZWZ0YXJyb3dcIjpcIuKGqVwiLFwiaG9va3JpZ2h0YXJyb3dcIjpcIuKGqlwiLFwiaG9wZlwiOlwi8J2VmVwiLFwiSG9wZlwiOlwi4oSNXCIsXCJob3JiYXJcIjpcIuKAlVwiLFwiSG9yaXpvbnRhbExpbmVcIjpcIuKUgFwiLFwiaHNjclwiOlwi8J2SvVwiLFwiSHNjclwiOlwi4oSLXCIsXCJoc2xhc2hcIjpcIuKEj1wiLFwiSHN0cm9rXCI6XCLEplwiLFwiaHN0cm9rXCI6XCLEp1wiLFwiSHVtcERvd25IdW1wXCI6XCLiiY5cIixcIkh1bXBFcXVhbFwiOlwi4omPXCIsXCJoeWJ1bGxcIjpcIuKBg1wiLFwiaHlwaGVuXCI6XCLigJBcIixcIklhY3V0ZVwiOlwiw41cIixcImlhY3V0ZVwiOlwiw61cIixcImljXCI6XCLigaNcIixcIkljaXJjXCI6XCLDjlwiLFwiaWNpcmNcIjpcIsOuXCIsXCJJY3lcIjpcItCYXCIsXCJpY3lcIjpcItC4XCIsXCJJZG90XCI6XCLEsFwiLFwiSUVjeVwiOlwi0JVcIixcImllY3lcIjpcItC1XCIsXCJpZXhjbFwiOlwiwqFcIixcImlmZlwiOlwi4oeUXCIsXCJpZnJcIjpcIvCdlKZcIixcIklmclwiOlwi4oSRXCIsXCJJZ3JhdmVcIjpcIsOMXCIsXCJpZ3JhdmVcIjpcIsOsXCIsXCJpaVwiOlwi4oWIXCIsXCJpaWlpbnRcIjpcIuKojFwiLFwiaWlpbnRcIjpcIuKIrVwiLFwiaWluZmluXCI6XCLip5xcIixcImlpb3RhXCI6XCLihKlcIixcIklKbGlnXCI6XCLEslwiLFwiaWpsaWdcIjpcIsSzXCIsXCJJbWFjclwiOlwixKpcIixcImltYWNyXCI6XCLEq1wiLFwiaW1hZ2VcIjpcIuKEkVwiLFwiSW1hZ2luYXJ5SVwiOlwi4oWIXCIsXCJpbWFnbGluZVwiOlwi4oSQXCIsXCJpbWFncGFydFwiOlwi4oSRXCIsXCJpbWF0aFwiOlwixLFcIixcIkltXCI6XCLihJFcIixcImltb2ZcIjpcIuKKt1wiLFwiaW1wZWRcIjpcIsa1XCIsXCJJbXBsaWVzXCI6XCLih5JcIixcImluY2FyZVwiOlwi4oSFXCIsXCJpblwiOlwi4oiIXCIsXCJpbmZpblwiOlwi4oieXCIsXCJpbmZpbnRpZVwiOlwi4qedXCIsXCJpbm9kb3RcIjpcIsSxXCIsXCJpbnRjYWxcIjpcIuKKulwiLFwiaW50XCI6XCLiiKtcIixcIkludFwiOlwi4oisXCIsXCJpbnRlZ2Vyc1wiOlwi4oSkXCIsXCJJbnRlZ3JhbFwiOlwi4oirXCIsXCJpbnRlcmNhbFwiOlwi4oq6XCIsXCJJbnRlcnNlY3Rpb25cIjpcIuKLglwiLFwiaW50bGFyaGtcIjpcIuKol1wiLFwiaW50cHJvZFwiOlwi4qi8XCIsXCJJbnZpc2libGVDb21tYVwiOlwi4oGjXCIsXCJJbnZpc2libGVUaW1lc1wiOlwi4oGiXCIsXCJJT2N5XCI6XCLQgVwiLFwiaW9jeVwiOlwi0ZFcIixcIklvZ29uXCI6XCLErlwiLFwiaW9nb25cIjpcIsSvXCIsXCJJb3BmXCI6XCLwnZWAXCIsXCJpb3BmXCI6XCLwnZWaXCIsXCJJb3RhXCI6XCLOmVwiLFwiaW90YVwiOlwizrlcIixcImlwcm9kXCI6XCLiqLxcIixcImlxdWVzdFwiOlwiwr9cIixcImlzY3JcIjpcIvCdkr5cIixcIklzY3JcIjpcIuKEkFwiLFwiaXNpblwiOlwi4oiIXCIsXCJpc2luZG90XCI6XCLii7VcIixcImlzaW5FXCI6XCLii7lcIixcImlzaW5zXCI6XCLii7RcIixcImlzaW5zdlwiOlwi4ouzXCIsXCJpc2ludlwiOlwi4oiIXCIsXCJpdFwiOlwi4oGiXCIsXCJJdGlsZGVcIjpcIsSoXCIsXCJpdGlsZGVcIjpcIsSpXCIsXCJJdWtjeVwiOlwi0IZcIixcIml1a2N5XCI6XCLRllwiLFwiSXVtbFwiOlwiw49cIixcIml1bWxcIjpcIsOvXCIsXCJKY2lyY1wiOlwixLRcIixcImpjaXJjXCI6XCLEtVwiLFwiSmN5XCI6XCLQmVwiLFwiamN5XCI6XCLQuVwiLFwiSmZyXCI6XCLwnZSNXCIsXCJqZnJcIjpcIvCdlKdcIixcImptYXRoXCI6XCLIt1wiLFwiSm9wZlwiOlwi8J2VgVwiLFwiam9wZlwiOlwi8J2Vm1wiLFwiSnNjclwiOlwi8J2SpVwiLFwianNjclwiOlwi8J2Sv1wiLFwiSnNlcmN5XCI6XCLQiFwiLFwianNlcmN5XCI6XCLRmFwiLFwiSnVrY3lcIjpcItCEXCIsXCJqdWtjeVwiOlwi0ZRcIixcIkthcHBhXCI6XCLOmlwiLFwia2FwcGFcIjpcIs66XCIsXCJrYXBwYXZcIjpcIs+wXCIsXCJLY2VkaWxcIjpcIsS2XCIsXCJrY2VkaWxcIjpcIsS3XCIsXCJLY3lcIjpcItCaXCIsXCJrY3lcIjpcItC6XCIsXCJLZnJcIjpcIvCdlI5cIixcImtmclwiOlwi8J2UqFwiLFwia2dyZWVuXCI6XCLEuFwiLFwiS0hjeVwiOlwi0KVcIixcImtoY3lcIjpcItGFXCIsXCJLSmN5XCI6XCLQjFwiLFwia2pjeVwiOlwi0ZxcIixcIktvcGZcIjpcIvCdlYJcIixcImtvcGZcIjpcIvCdlZxcIixcIktzY3JcIjpcIvCdkqZcIixcImtzY3JcIjpcIvCdk4BcIixcImxBYXJyXCI6XCLih5pcIixcIkxhY3V0ZVwiOlwixLlcIixcImxhY3V0ZVwiOlwixLpcIixcImxhZW1wdHl2XCI6XCLiprRcIixcImxhZ3JhblwiOlwi4oSSXCIsXCJMYW1iZGFcIjpcIs6bXCIsXCJsYW1iZGFcIjpcIs67XCIsXCJsYW5nXCI6XCLin6hcIixcIkxhbmdcIjpcIuKfqlwiLFwibGFuZ2RcIjpcIuKmkVwiLFwibGFuZ2xlXCI6XCLin6hcIixcImxhcFwiOlwi4qqFXCIsXCJMYXBsYWNldHJmXCI6XCLihJJcIixcImxhcXVvXCI6XCLCq1wiLFwibGFycmJcIjpcIuKHpFwiLFwibGFycmJmc1wiOlwi4qSfXCIsXCJsYXJyXCI6XCLihpBcIixcIkxhcnJcIjpcIuKGnlwiLFwibEFyclwiOlwi4oeQXCIsXCJsYXJyZnNcIjpcIuKknVwiLFwibGFycmhrXCI6XCLihqlcIixcImxhcnJscFwiOlwi4oarXCIsXCJsYXJycGxcIjpcIuKkuVwiLFwibGFycnNpbVwiOlwi4qWzXCIsXCJsYXJydGxcIjpcIuKGolwiLFwibGF0YWlsXCI6XCLipJlcIixcImxBdGFpbFwiOlwi4qSbXCIsXCJsYXRcIjpcIuKqq1wiLFwibGF0ZVwiOlwi4qqtXCIsXCJsYXRlc1wiOlwi4qqt77iAXCIsXCJsYmFyclwiOlwi4qSMXCIsXCJsQmFyclwiOlwi4qSOXCIsXCJsYmJya1wiOlwi4p2yXCIsXCJsYnJhY2VcIjpcIntcIixcImxicmFja1wiOlwiW1wiLFwibGJya2VcIjpcIuKmi1wiLFwibGJya3NsZFwiOlwi4qaPXCIsXCJsYnJrc2x1XCI6XCLipo1cIixcIkxjYXJvblwiOlwixL1cIixcImxjYXJvblwiOlwixL5cIixcIkxjZWRpbFwiOlwixLtcIixcImxjZWRpbFwiOlwixLxcIixcImxjZWlsXCI6XCLijIhcIixcImxjdWJcIjpcIntcIixcIkxjeVwiOlwi0JtcIixcImxjeVwiOlwi0LtcIixcImxkY2FcIjpcIuKktlwiLFwibGRxdW9cIjpcIuKAnFwiLFwibGRxdW9yXCI6XCLigJ5cIixcImxkcmRoYXJcIjpcIuKlp1wiLFwibGRydXNoYXJcIjpcIuKli1wiLFwibGRzaFwiOlwi4oayXCIsXCJsZVwiOlwi4omkXCIsXCJsRVwiOlwi4ommXCIsXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCLin6hcIixcIkxlZnRBcnJvd0JhclwiOlwi4oekXCIsXCJsZWZ0YXJyb3dcIjpcIuKGkFwiLFwiTGVmdEFycm93XCI6XCLihpBcIixcIkxlZnRhcnJvd1wiOlwi4oeQXCIsXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCLih4ZcIixcImxlZnRhcnJvd3RhaWxcIjpcIuKGolwiLFwiTGVmdENlaWxpbmdcIjpcIuKMiFwiLFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIuKfplwiLFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIuKloVwiLFwiTGVmdERvd25WZWN0b3JCYXJcIjpcIuKlmVwiLFwiTGVmdERvd25WZWN0b3JcIjpcIuKHg1wiLFwiTGVmdEZsb29yXCI6XCLijIpcIixcImxlZnRoYXJwb29uZG93blwiOlwi4oa9XCIsXCJsZWZ0aGFycG9vbnVwXCI6XCLihrxcIixcImxlZnRsZWZ0YXJyb3dzXCI6XCLih4dcIixcImxlZnRyaWdodGFycm93XCI6XCLihpRcIixcIkxlZnRSaWdodEFycm93XCI6XCLihpRcIixcIkxlZnRyaWdodGFycm93XCI6XCLih5RcIixcImxlZnRyaWdodGFycm93c1wiOlwi4oeGXCIsXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwi4oeLXCIsXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCLihq1cIixcIkxlZnRSaWdodFZlY3RvclwiOlwi4qWOXCIsXCJMZWZ0VGVlQXJyb3dcIjpcIuKGpFwiLFwiTGVmdFRlZVwiOlwi4oqjXCIsXCJMZWZ0VGVlVmVjdG9yXCI6XCLipZpcIixcImxlZnR0aHJlZXRpbWVzXCI6XCLii4tcIixcIkxlZnRUcmlhbmdsZUJhclwiOlwi4qePXCIsXCJMZWZ0VHJpYW5nbGVcIjpcIuKKslwiLFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKKtFwiLFwiTGVmdFVwRG93blZlY3RvclwiOlwi4qWRXCIsXCJMZWZ0VXBUZWVWZWN0b3JcIjpcIuKloFwiLFwiTGVmdFVwVmVjdG9yQmFyXCI6XCLipZhcIixcIkxlZnRVcFZlY3RvclwiOlwi4oa/XCIsXCJMZWZ0VmVjdG9yQmFyXCI6XCLipZJcIixcIkxlZnRWZWN0b3JcIjpcIuKGvFwiLFwibEVnXCI6XCLiqotcIixcImxlZ1wiOlwi4ouaXCIsXCJsZXFcIjpcIuKJpFwiLFwibGVxcVwiOlwi4ommXCIsXCJsZXFzbGFudFwiOlwi4qm9XCIsXCJsZXNjY1wiOlwi4qqoXCIsXCJsZXNcIjpcIuKpvVwiLFwibGVzZG90XCI6XCLiqb9cIixcImxlc2RvdG9cIjpcIuKqgVwiLFwibGVzZG90b3JcIjpcIuKqg1wiLFwibGVzZ1wiOlwi4oua77iAXCIsXCJsZXNnZXNcIjpcIuKqk1wiLFwibGVzc2FwcHJveFwiOlwi4qqFXCIsXCJsZXNzZG90XCI6XCLii5ZcIixcImxlc3NlcWd0clwiOlwi4ouaXCIsXCJsZXNzZXFxZ3RyXCI6XCLiqotcIixcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIuKLmlwiLFwiTGVzc0Z1bGxFcXVhbFwiOlwi4ommXCIsXCJMZXNzR3JlYXRlclwiOlwi4om2XCIsXCJsZXNzZ3RyXCI6XCLiibZcIixcIkxlc3NMZXNzXCI6XCLiqqFcIixcImxlc3NzaW1cIjpcIuKJslwiLFwiTGVzc1NsYW50RXF1YWxcIjpcIuKpvVwiLFwiTGVzc1RpbGRlXCI6XCLiibJcIixcImxmaXNodFwiOlwi4qW8XCIsXCJsZmxvb3JcIjpcIuKMilwiLFwiTGZyXCI6XCLwnZSPXCIsXCJsZnJcIjpcIvCdlKlcIixcImxnXCI6XCLiibZcIixcImxnRVwiOlwi4qqRXCIsXCJsSGFyXCI6XCLipaJcIixcImxoYXJkXCI6XCLihr1cIixcImxoYXJ1XCI6XCLihrxcIixcImxoYXJ1bFwiOlwi4qWqXCIsXCJsaGJsa1wiOlwi4paEXCIsXCJMSmN5XCI6XCLQiVwiLFwibGpjeVwiOlwi0ZlcIixcImxsYXJyXCI6XCLih4dcIixcImxsXCI6XCLiiapcIixcIkxsXCI6XCLii5hcIixcImxsY29ybmVyXCI6XCLijJ5cIixcIkxsZWZ0YXJyb3dcIjpcIuKHmlwiLFwibGxoYXJkXCI6XCLipatcIixcImxsdHJpXCI6XCLil7pcIixcIkxtaWRvdFwiOlwixL9cIixcImxtaWRvdFwiOlwixYBcIixcImxtb3VzdGFjaGVcIjpcIuKOsFwiLFwibG1vdXN0XCI6XCLijrBcIixcImxuYXBcIjpcIuKqiVwiLFwibG5hcHByb3hcIjpcIuKqiVwiLFwibG5lXCI6XCLiqodcIixcImxuRVwiOlwi4omoXCIsXCJsbmVxXCI6XCLiqodcIixcImxuZXFxXCI6XCLiiahcIixcImxuc2ltXCI6XCLii6ZcIixcImxvYW5nXCI6XCLin6xcIixcImxvYXJyXCI6XCLih71cIixcImxvYnJrXCI6XCLin6ZcIixcImxvbmdsZWZ0YXJyb3dcIjpcIuKftVwiLFwiTG9uZ0xlZnRBcnJvd1wiOlwi4p+1XCIsXCJMb25nbGVmdGFycm93XCI6XCLin7hcIixcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+3XCIsXCJMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKft1wiLFwiTG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7pcIixcImxvbmdtYXBzdG9cIjpcIuKfvFwiLFwibG9uZ3JpZ2h0YXJyb3dcIjpcIuKftlwiLFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIuKftlwiLFwiTG9uZ3JpZ2h0YXJyb3dcIjpcIuKfuVwiLFwibG9vcGFycm93bGVmdFwiOlwi4oarXCIsXCJsb29wYXJyb3dyaWdodFwiOlwi4oasXCIsXCJsb3BhclwiOlwi4qaFXCIsXCJMb3BmXCI6XCLwnZWDXCIsXCJsb3BmXCI6XCLwnZWdXCIsXCJsb3BsdXNcIjpcIuKorVwiLFwibG90aW1lc1wiOlwi4qi0XCIsXCJsb3dhc3RcIjpcIuKIl1wiLFwibG93YmFyXCI6XCJfXCIsXCJMb3dlckxlZnRBcnJvd1wiOlwi4oaZXCIsXCJMb3dlclJpZ2h0QXJyb3dcIjpcIuKGmFwiLFwibG96XCI6XCLil4pcIixcImxvemVuZ2VcIjpcIuKXilwiLFwibG96ZlwiOlwi4qerXCIsXCJscGFyXCI6XCIoXCIsXCJscGFybHRcIjpcIuKmk1wiLFwibHJhcnJcIjpcIuKHhlwiLFwibHJjb3JuZXJcIjpcIuKMn1wiLFwibHJoYXJcIjpcIuKHi1wiLFwibHJoYXJkXCI6XCLipa1cIixcImxybVwiOlwi4oCOXCIsXCJscnRyaVwiOlwi4oq/XCIsXCJsc2FxdW9cIjpcIuKAuVwiLFwibHNjclwiOlwi8J2TgVwiLFwiTHNjclwiOlwi4oSSXCIsXCJsc2hcIjpcIuKGsFwiLFwiTHNoXCI6XCLihrBcIixcImxzaW1cIjpcIuKJslwiLFwibHNpbWVcIjpcIuKqjVwiLFwibHNpbWdcIjpcIuKqj1wiLFwibHNxYlwiOlwiW1wiLFwibHNxdW9cIjpcIuKAmFwiLFwibHNxdW9yXCI6XCLigJpcIixcIkxzdHJva1wiOlwixYFcIixcImxzdHJva1wiOlwixYJcIixcImx0Y2NcIjpcIuKqplwiLFwibHRjaXJcIjpcIuKpuVwiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJMdFwiOlwi4omqXCIsXCJsdGRvdFwiOlwi4ouWXCIsXCJsdGhyZWVcIjpcIuKLi1wiLFwibHRpbWVzXCI6XCLii4lcIixcImx0bGFyclwiOlwi4qW2XCIsXCJsdHF1ZXN0XCI6XCLiqbtcIixcImx0cmlcIjpcIuKXg1wiLFwibHRyaWVcIjpcIuKKtFwiLFwibHRyaWZcIjpcIuKXglwiLFwibHRyUGFyXCI6XCLippZcIixcImx1cmRzaGFyXCI6XCLipYpcIixcImx1cnVoYXJcIjpcIuKlplwiLFwibHZlcnRuZXFxXCI6XCLiiajvuIBcIixcImx2bkVcIjpcIuKJqO+4gFwiLFwibWFjclwiOlwiwq9cIixcIm1hbGVcIjpcIuKZglwiLFwibWFsdFwiOlwi4pygXCIsXCJtYWx0ZXNlXCI6XCLinKBcIixcIk1hcFwiOlwi4qSFXCIsXCJtYXBcIjpcIuKGplwiLFwibWFwc3RvXCI6XCLihqZcIixcIm1hcHN0b2Rvd25cIjpcIuKGp1wiLFwibWFwc3RvbGVmdFwiOlwi4oakXCIsXCJtYXBzdG91cFwiOlwi4oalXCIsXCJtYXJrZXJcIjpcIuKWrlwiLFwibWNvbW1hXCI6XCLiqKlcIixcIk1jeVwiOlwi0JxcIixcIm1jeVwiOlwi0LxcIixcIm1kYXNoXCI6XCLigJRcIixcIm1ERG90XCI6XCLiiLpcIixcIm1lYXN1cmVkYW5nbGVcIjpcIuKIoVwiLFwiTWVkaXVtU3BhY2VcIjpcIuKBn1wiLFwiTWVsbGludHJmXCI6XCLihLNcIixcIk1mclwiOlwi8J2UkFwiLFwibWZyXCI6XCLwnZSqXCIsXCJtaG9cIjpcIuKEp1wiLFwibWljcm9cIjpcIsK1XCIsXCJtaWRhc3RcIjpcIipcIixcIm1pZGNpclwiOlwi4quwXCIsXCJtaWRcIjpcIuKIo1wiLFwibWlkZG90XCI6XCLCt1wiLFwibWludXNiXCI6XCLiip9cIixcIm1pbnVzXCI6XCLiiJJcIixcIm1pbnVzZFwiOlwi4oi4XCIsXCJtaW51c2R1XCI6XCLiqKpcIixcIk1pbnVzUGx1c1wiOlwi4oiTXCIsXCJtbGNwXCI6XCLiq5tcIixcIm1sZHJcIjpcIuKAplwiLFwibW5wbHVzXCI6XCLiiJNcIixcIm1vZGVsc1wiOlwi4oqnXCIsXCJNb3BmXCI6XCLwnZWEXCIsXCJtb3BmXCI6XCLwnZWeXCIsXCJtcFwiOlwi4oiTXCIsXCJtc2NyXCI6XCLwnZOCXCIsXCJNc2NyXCI6XCLihLNcIixcIm1zdHBvc1wiOlwi4oi+XCIsXCJNdVwiOlwizpxcIixcIm11XCI6XCLOvFwiLFwibXVsdGltYXBcIjpcIuKKuFwiLFwibXVtYXBcIjpcIuKKuFwiLFwibmFibGFcIjpcIuKIh1wiLFwiTmFjdXRlXCI6XCLFg1wiLFwibmFjdXRlXCI6XCLFhFwiLFwibmFuZ1wiOlwi4oig4oOSXCIsXCJuYXBcIjpcIuKJiVwiLFwibmFwRVwiOlwi4qmwzLhcIixcIm5hcGlkXCI6XCLiiYvMuFwiLFwibmFwb3NcIjpcIsWJXCIsXCJuYXBwcm94XCI6XCLiiYlcIixcIm5hdHVyYWxcIjpcIuKZrlwiLFwibmF0dXJhbHNcIjpcIuKElVwiLFwibmF0dXJcIjpcIuKZrlwiLFwibmJzcFwiOlwiwqBcIixcIm5idW1wXCI6XCLiiY7MuFwiLFwibmJ1bXBlXCI6XCLiiY/MuFwiLFwibmNhcFwiOlwi4qmDXCIsXCJOY2Fyb25cIjpcIsWHXCIsXCJuY2Fyb25cIjpcIsWIXCIsXCJOY2VkaWxcIjpcIsWFXCIsXCJuY2VkaWxcIjpcIsWGXCIsXCJuY29uZ1wiOlwi4omHXCIsXCJuY29uZ2RvdFwiOlwi4qmtzLhcIixcIm5jdXBcIjpcIuKpglwiLFwiTmN5XCI6XCLQnVwiLFwibmN5XCI6XCLQvVwiLFwibmRhc2hcIjpcIuKAk1wiLFwibmVhcmhrXCI6XCLipKRcIixcIm5lYXJyXCI6XCLihpdcIixcIm5lQXJyXCI6XCLih5dcIixcIm5lYXJyb3dcIjpcIuKGl1wiLFwibmVcIjpcIuKJoFwiLFwibmVkb3RcIjpcIuKJkMy4XCIsXCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjpcIuKAi1wiLFwibmVxdWl2XCI6XCLiiaJcIixcIm5lc2VhclwiOlwi4qSoXCIsXCJuZXNpbVwiOlwi4omCzLhcIixcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiiatcIixcIk5lc3RlZExlc3NMZXNzXCI6XCLiiapcIixcIk5ld0xpbmVcIjpcIlxcblwiLFwibmV4aXN0XCI6XCLiiIRcIixcIm5leGlzdHNcIjpcIuKIhFwiLFwiTmZyXCI6XCLwnZSRXCIsXCJuZnJcIjpcIvCdlKtcIixcIm5nRVwiOlwi4omnzLhcIixcIm5nZVwiOlwi4omxXCIsXCJuZ2VxXCI6XCLiibFcIixcIm5nZXFxXCI6XCLiiafMuFwiLFwibmdlcXNsYW50XCI6XCLiqb7MuFwiLFwibmdlc1wiOlwi4qm+zLhcIixcIm5HZ1wiOlwi4ouZzLhcIixcIm5nc2ltXCI6XCLiibVcIixcIm5HdFwiOlwi4omr4oOSXCIsXCJuZ3RcIjpcIuKJr1wiLFwibmd0clwiOlwi4omvXCIsXCJuR3R2XCI6XCLiiavMuFwiLFwibmhhcnJcIjpcIuKGrlwiLFwibmhBcnJcIjpcIuKHjlwiLFwibmhwYXJcIjpcIuKrslwiLFwibmlcIjpcIuKIi1wiLFwibmlzXCI6XCLii7xcIixcIm5pc2RcIjpcIuKLulwiLFwibml2XCI6XCLiiItcIixcIk5KY3lcIjpcItCKXCIsXCJuamN5XCI6XCLRmlwiLFwibmxhcnJcIjpcIuKGmlwiLFwibmxBcnJcIjpcIuKHjVwiLFwibmxkclwiOlwi4oClXCIsXCJubEVcIjpcIuKJpsy4XCIsXCJubGVcIjpcIuKJsFwiLFwibmxlZnRhcnJvd1wiOlwi4oaaXCIsXCJuTGVmdGFycm93XCI6XCLih41cIixcIm5sZWZ0cmlnaHRhcnJvd1wiOlwi4oauXCIsXCJuTGVmdHJpZ2h0YXJyb3dcIjpcIuKHjlwiLFwibmxlcVwiOlwi4omwXCIsXCJubGVxcVwiOlwi4ommzLhcIixcIm5sZXFzbGFudFwiOlwi4qm9zLhcIixcIm5sZXNcIjpcIuKpvcy4XCIsXCJubGVzc1wiOlwi4omuXCIsXCJuTGxcIjpcIuKLmMy4XCIsXCJubHNpbVwiOlwi4om0XCIsXCJuTHRcIjpcIuKJquKDklwiLFwibmx0XCI6XCLiia5cIixcIm5sdHJpXCI6XCLii6pcIixcIm5sdHJpZVwiOlwi4ousXCIsXCJuTHR2XCI6XCLiiarMuFwiLFwibm1pZFwiOlwi4oikXCIsXCJOb0JyZWFrXCI6XCLigaBcIixcIk5vbkJyZWFraW5nU3BhY2VcIjpcIsKgXCIsXCJub3BmXCI6XCLwnZWfXCIsXCJOb3BmXCI6XCLihJVcIixcIk5vdFwiOlwi4qusXCIsXCJub3RcIjpcIsKsXCIsXCJOb3RDb25ncnVlbnRcIjpcIuKJolwiLFwiTm90Q3VwQ2FwXCI6XCLiia1cIixcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKZcIixcIk5vdEVsZW1lbnRcIjpcIuKIiVwiLFwiTm90RXF1YWxcIjpcIuKJoFwiLFwiTm90RXF1YWxUaWxkZVwiOlwi4omCzLhcIixcIk5vdEV4aXN0c1wiOlwi4oiEXCIsXCJOb3RHcmVhdGVyXCI6XCLiia9cIixcIk5vdEdyZWF0ZXJFcXVhbFwiOlwi4omxXCIsXCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiafMuFwiLFwiTm90R3JlYXRlckdyZWF0ZXJcIjpcIuKJq8y4XCIsXCJOb3RHcmVhdGVyTGVzc1wiOlwi4om5XCIsXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+zLhcIixcIk5vdEdyZWF0ZXJUaWxkZVwiOlwi4om1XCIsXCJOb3RIdW1wRG93bkh1bXBcIjpcIuKJjsy4XCIsXCJOb3RIdW1wRXF1YWxcIjpcIuKJj8y4XCIsXCJub3RpblwiOlwi4oiJXCIsXCJub3RpbmRvdFwiOlwi4ou1zLhcIixcIm5vdGluRVwiOlwi4ou5zLhcIixcIm5vdGludmFcIjpcIuKIiVwiLFwibm90aW52YlwiOlwi4ou3XCIsXCJub3RpbnZjXCI6XCLii7ZcIixcIk5vdExlZnRUcmlhbmdsZUJhclwiOlwi4qePzLhcIixcIk5vdExlZnRUcmlhbmdsZVwiOlwi4ouqXCIsXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4ousXCIsXCJOb3RMZXNzXCI6XCLiia5cIixcIk5vdExlc3NFcXVhbFwiOlwi4omwXCIsXCJOb3RMZXNzR3JlYXRlclwiOlwi4om4XCIsXCJOb3RMZXNzTGVzc1wiOlwi4omqzLhcIixcIk5vdExlc3NTbGFudEVxdWFsXCI6XCLiqb3MuFwiLFwiTm90TGVzc1RpbGRlXCI6XCLiibRcIixcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiqqLMuFwiLFwiTm90TmVzdGVkTGVzc0xlc3NcIjpcIuKqocy4XCIsXCJub3RuaVwiOlwi4oiMXCIsXCJub3RuaXZhXCI6XCLiiIxcIixcIm5vdG5pdmJcIjpcIuKLvlwiLFwibm90bml2Y1wiOlwi4ou9XCIsXCJOb3RQcmVjZWRlc1wiOlwi4oqAXCIsXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCLiqq/MuFwiLFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6XCLii6BcIixcIk5vdFJldmVyc2VFbGVtZW50XCI6XCLiiIxcIixcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkMy4XCIsXCJOb3RSaWdodFRyaWFuZ2xlXCI6XCLii6tcIixcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4outXCIsXCJOb3RTcXVhcmVTdWJzZXRcIjpcIuKKj8y4XCIsXCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4ouiXCIsXCJOb3RTcXVhcmVTdXBlcnNldFwiOlwi4oqQzLhcIixcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKLo1wiLFwiTm90U3Vic2V0XCI6XCLiioLig5JcIixcIk5vdFN1YnNldEVxdWFsXCI6XCLiiohcIixcIk5vdFN1Y2NlZWRzXCI6XCLiioFcIixcIk5vdFN1Y2NlZWRzRXF1YWxcIjpcIuKqsMy4XCIsXCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKLoVwiLFwiTm90U3VjY2VlZHNUaWxkZVwiOlwi4om/zLhcIixcIk5vdFN1cGVyc2V0XCI6XCLiioPig5JcIixcIk5vdFN1cGVyc2V0RXF1YWxcIjpcIuKKiVwiLFwiTm90VGlsZGVcIjpcIuKJgVwiLFwiTm90VGlsZGVFcXVhbFwiOlwi4omEXCIsXCJOb3RUaWxkZUZ1bGxFcXVhbFwiOlwi4omHXCIsXCJOb3RUaWxkZVRpbGRlXCI6XCLiiYlcIixcIk5vdFZlcnRpY2FsQmFyXCI6XCLiiKRcIixcIm5wYXJhbGxlbFwiOlwi4oimXCIsXCJucGFyXCI6XCLiiKZcIixcIm5wYXJzbFwiOlwi4qu94oOlXCIsXCJucGFydFwiOlwi4oiCzLhcIixcIm5wb2xpbnRcIjpcIuKolFwiLFwibnByXCI6XCLiioBcIixcIm5wcmN1ZVwiOlwi4ougXCIsXCJucHJlY1wiOlwi4oqAXCIsXCJucHJlY2VxXCI6XCLiqq/MuFwiLFwibnByZVwiOlwi4qqvzLhcIixcIm5yYXJyY1wiOlwi4qSzzLhcIixcIm5yYXJyXCI6XCLihptcIixcIm5yQXJyXCI6XCLih49cIixcIm5yYXJyd1wiOlwi4oadzLhcIixcIm5yaWdodGFycm93XCI6XCLihptcIixcIm5SaWdodGFycm93XCI6XCLih49cIixcIm5ydHJpXCI6XCLii6tcIixcIm5ydHJpZVwiOlwi4outXCIsXCJuc2NcIjpcIuKKgVwiLFwibnNjY3VlXCI6XCLii6FcIixcIm5zY2VcIjpcIuKqsMy4XCIsXCJOc2NyXCI6XCLwnZKpXCIsXCJuc2NyXCI6XCLwnZODXCIsXCJuc2hvcnRtaWRcIjpcIuKIpFwiLFwibnNob3J0cGFyYWxsZWxcIjpcIuKIplwiLFwibnNpbVwiOlwi4omBXCIsXCJuc2ltZVwiOlwi4omEXCIsXCJuc2ltZXFcIjpcIuKJhFwiLFwibnNtaWRcIjpcIuKIpFwiLFwibnNwYXJcIjpcIuKIplwiLFwibnNxc3ViZVwiOlwi4ouiXCIsXCJuc3FzdXBlXCI6XCLii6NcIixcIm5zdWJcIjpcIuKKhFwiLFwibnN1YkVcIjpcIuKrhcy4XCIsXCJuc3ViZVwiOlwi4oqIXCIsXCJuc3Vic2V0XCI6XCLiioLig5JcIixcIm5zdWJzZXRlcVwiOlwi4oqIXCIsXCJuc3Vic2V0ZXFxXCI6XCLiq4XMuFwiLFwibnN1Y2NcIjpcIuKKgVwiLFwibnN1Y2NlcVwiOlwi4qqwzLhcIixcIm5zdXBcIjpcIuKKhVwiLFwibnN1cEVcIjpcIuKrhsy4XCIsXCJuc3VwZVwiOlwi4oqJXCIsXCJuc3Vwc2V0XCI6XCLiioPig5JcIixcIm5zdXBzZXRlcVwiOlwi4oqJXCIsXCJuc3Vwc2V0ZXFxXCI6XCLiq4bMuFwiLFwibnRnbFwiOlwi4om5XCIsXCJOdGlsZGVcIjpcIsORXCIsXCJudGlsZGVcIjpcIsOxXCIsXCJudGxnXCI6XCLiibhcIixcIm50cmlhbmdsZWxlZnRcIjpcIuKLqlwiLFwibnRyaWFuZ2xlbGVmdGVxXCI6XCLii6xcIixcIm50cmlhbmdsZXJpZ2h0XCI6XCLii6tcIixcIm50cmlhbmdsZXJpZ2h0ZXFcIjpcIuKLrVwiLFwiTnVcIjpcIs6dXCIsXCJudVwiOlwizr1cIixcIm51bVwiOlwiI1wiLFwibnVtZXJvXCI6XCLihJZcIixcIm51bXNwXCI6XCLigIdcIixcIm52YXBcIjpcIuKJjeKDklwiLFwibnZkYXNoXCI6XCLiiqxcIixcIm52RGFzaFwiOlwi4oqtXCIsXCJuVmRhc2hcIjpcIuKKrlwiLFwiblZEYXNoXCI6XCLiiq9cIixcIm52Z2VcIjpcIuKJpeKDklwiLFwibnZndFwiOlwiPuKDklwiLFwibnZIYXJyXCI6XCLipIRcIixcIm52aW5maW5cIjpcIuKnnlwiLFwibnZsQXJyXCI6XCLipIJcIixcIm52bGVcIjpcIuKJpOKDklwiLFwibnZsdFwiOlwiPOKDklwiLFwibnZsdHJpZVwiOlwi4oq04oOSXCIsXCJudnJBcnJcIjpcIuKkg1wiLFwibnZydHJpZVwiOlwi4oq14oOSXCIsXCJudnNpbVwiOlwi4oi84oOSXCIsXCJud2FyaGtcIjpcIuKko1wiLFwibndhcnJcIjpcIuKGllwiLFwibndBcnJcIjpcIuKHllwiLFwibndhcnJvd1wiOlwi4oaWXCIsXCJud25lYXJcIjpcIuKkp1wiLFwiT2FjdXRlXCI6XCLDk1wiLFwib2FjdXRlXCI6XCLDs1wiLFwib2FzdFwiOlwi4oqbXCIsXCJPY2lyY1wiOlwiw5RcIixcIm9jaXJjXCI6XCLDtFwiLFwib2NpclwiOlwi4oqaXCIsXCJPY3lcIjpcItCeXCIsXCJvY3lcIjpcItC+XCIsXCJvZGFzaFwiOlwi4oqdXCIsXCJPZGJsYWNcIjpcIsWQXCIsXCJvZGJsYWNcIjpcIsWRXCIsXCJvZGl2XCI6XCLiqLhcIixcIm9kb3RcIjpcIuKKmVwiLFwib2Rzb2xkXCI6XCLiprxcIixcIk9FbGlnXCI6XCLFklwiLFwib2VsaWdcIjpcIsWTXCIsXCJvZmNpclwiOlwi4qa/XCIsXCJPZnJcIjpcIvCdlJJcIixcIm9mclwiOlwi8J2UrFwiLFwib2dvblwiOlwiy5tcIixcIk9ncmF2ZVwiOlwiw5JcIixcIm9ncmF2ZVwiOlwiw7JcIixcIm9ndFwiOlwi4qeBXCIsXCJvaGJhclwiOlwi4qa1XCIsXCJvaG1cIjpcIs6pXCIsXCJvaW50XCI6XCLiiK5cIixcIm9sYXJyXCI6XCLihrpcIixcIm9sY2lyXCI6XCLipr5cIixcIm9sY3Jvc3NcIjpcIuKmu1wiLFwib2xpbmVcIjpcIuKAvlwiLFwib2x0XCI6XCLip4BcIixcIk9tYWNyXCI6XCLFjFwiLFwib21hY3JcIjpcIsWNXCIsXCJPbWVnYVwiOlwizqlcIixcIm9tZWdhXCI6XCLPiVwiLFwiT21pY3JvblwiOlwizp9cIixcIm9taWNyb25cIjpcIs6/XCIsXCJvbWlkXCI6XCLiprZcIixcIm9taW51c1wiOlwi4oqWXCIsXCJPb3BmXCI6XCLwnZWGXCIsXCJvb3BmXCI6XCLwnZWgXCIsXCJvcGFyXCI6XCLiprdcIixcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6XCLigJxcIixcIk9wZW5DdXJseVF1b3RlXCI6XCLigJhcIixcIm9wZXJwXCI6XCLiprlcIixcIm9wbHVzXCI6XCLiipVcIixcIm9yYXJyXCI6XCLihrtcIixcIk9yXCI6XCLiqZRcIixcIm9yXCI6XCLiiKhcIixcIm9yZFwiOlwi4qmdXCIsXCJvcmRlclwiOlwi4oS0XCIsXCJvcmRlcm9mXCI6XCLihLRcIixcIm9yZGZcIjpcIsKqXCIsXCJvcmRtXCI6XCLCulwiLFwib3JpZ29mXCI6XCLiirZcIixcIm9yb3JcIjpcIuKpllwiLFwib3JzbG9wZVwiOlwi4qmXXCIsXCJvcnZcIjpcIuKpm1wiLFwib1NcIjpcIuKTiFwiLFwiT3NjclwiOlwi8J2SqlwiLFwib3NjclwiOlwi4oS0XCIsXCJPc2xhc2hcIjpcIsOYXCIsXCJvc2xhc2hcIjpcIsO4XCIsXCJvc29sXCI6XCLiiphcIixcIk90aWxkZVwiOlwiw5VcIixcIm90aWxkZVwiOlwiw7VcIixcIm90aW1lc2FzXCI6XCLiqLZcIixcIk90aW1lc1wiOlwi4qi3XCIsXCJvdGltZXNcIjpcIuKKl1wiLFwiT3VtbFwiOlwiw5ZcIixcIm91bWxcIjpcIsO2XCIsXCJvdmJhclwiOlwi4oy9XCIsXCJPdmVyQmFyXCI6XCLigL5cIixcIk92ZXJCcmFjZVwiOlwi4o+eXCIsXCJPdmVyQnJhY2tldFwiOlwi4o60XCIsXCJPdmVyUGFyZW50aGVzaXNcIjpcIuKPnFwiLFwicGFyYVwiOlwiwrZcIixcInBhcmFsbGVsXCI6XCLiiKVcIixcInBhclwiOlwi4oilXCIsXCJwYXJzaW1cIjpcIuKrs1wiLFwicGFyc2xcIjpcIuKrvVwiLFwicGFydFwiOlwi4oiCXCIsXCJQYXJ0aWFsRFwiOlwi4oiCXCIsXCJQY3lcIjpcItCfXCIsXCJwY3lcIjpcItC/XCIsXCJwZXJjbnRcIjpcIiVcIixcInBlcmlvZFwiOlwiLlwiLFwicGVybWlsXCI6XCLigLBcIixcInBlcnBcIjpcIuKKpVwiLFwicGVydGVua1wiOlwi4oCxXCIsXCJQZnJcIjpcIvCdlJNcIixcInBmclwiOlwi8J2UrVwiLFwiUGhpXCI6XCLOplwiLFwicGhpXCI6XCLPhlwiLFwicGhpdlwiOlwiz5VcIixcInBobW1hdFwiOlwi4oSzXCIsXCJwaG9uZVwiOlwi4piOXCIsXCJQaVwiOlwizqBcIixcInBpXCI6XCLPgFwiLFwicGl0Y2hmb3JrXCI6XCLii5RcIixcInBpdlwiOlwiz5ZcIixcInBsYW5ja1wiOlwi4oSPXCIsXCJwbGFuY2toXCI6XCLihI5cIixcInBsYW5rdlwiOlwi4oSPXCIsXCJwbHVzYWNpclwiOlwi4qijXCIsXCJwbHVzYlwiOlwi4oqeXCIsXCJwbHVzY2lyXCI6XCLiqKJcIixcInBsdXNcIjpcIitcIixcInBsdXNkb1wiOlwi4oiUXCIsXCJwbHVzZHVcIjpcIuKopVwiLFwicGx1c2VcIjpcIuKpslwiLFwiUGx1c01pbnVzXCI6XCLCsVwiLFwicGx1c21uXCI6XCLCsVwiLFwicGx1c3NpbVwiOlwi4qimXCIsXCJwbHVzdHdvXCI6XCLiqKdcIixcInBtXCI6XCLCsVwiLFwiUG9pbmNhcmVwbGFuZVwiOlwi4oSMXCIsXCJwb2ludGludFwiOlwi4qiVXCIsXCJwb3BmXCI6XCLwnZWhXCIsXCJQb3BmXCI6XCLihJlcIixcInBvdW5kXCI6XCLCo1wiLFwicHJhcFwiOlwi4qq3XCIsXCJQclwiOlwi4qq7XCIsXCJwclwiOlwi4om6XCIsXCJwcmN1ZVwiOlwi4om8XCIsXCJwcmVjYXBwcm94XCI6XCLiqrdcIixcInByZWNcIjpcIuKJulwiLFwicHJlY2N1cmx5ZXFcIjpcIuKJvFwiLFwiUHJlY2VkZXNcIjpcIuKJulwiLFwiUHJlY2VkZXNFcXVhbFwiOlwi4qqvXCIsXCJQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKJvFwiLFwiUHJlY2VkZXNUaWxkZVwiOlwi4om+XCIsXCJwcmVjZXFcIjpcIuKqr1wiLFwicHJlY25hcHByb3hcIjpcIuKquVwiLFwicHJlY25lcXFcIjpcIuKqtVwiLFwicHJlY25zaW1cIjpcIuKLqFwiLFwicHJlXCI6XCLiqq9cIixcInByRVwiOlwi4qqzXCIsXCJwcmVjc2ltXCI6XCLiib5cIixcInByaW1lXCI6XCLigLJcIixcIlByaW1lXCI6XCLigLNcIixcInByaW1lc1wiOlwi4oSZXCIsXCJwcm5hcFwiOlwi4qq5XCIsXCJwcm5FXCI6XCLiqrVcIixcInBybnNpbVwiOlwi4ouoXCIsXCJwcm9kXCI6XCLiiI9cIixcIlByb2R1Y3RcIjpcIuKIj1wiLFwicHJvZmFsYXJcIjpcIuKMrlwiLFwicHJvZmxpbmVcIjpcIuKMklwiLFwicHJvZnN1cmZcIjpcIuKMk1wiLFwicHJvcFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uYWxcIjpcIuKInVwiLFwiUHJvcG9ydGlvblwiOlwi4oi3XCIsXCJwcm9wdG9cIjpcIuKInVwiLFwicHJzaW1cIjpcIuKJvlwiLFwicHJ1cmVsXCI6XCLiirBcIixcIlBzY3JcIjpcIvCdkqtcIixcInBzY3JcIjpcIvCdk4VcIixcIlBzaVwiOlwizqhcIixcInBzaVwiOlwiz4hcIixcInB1bmNzcFwiOlwi4oCIXCIsXCJRZnJcIjpcIvCdlJRcIixcInFmclwiOlwi8J2UrlwiLFwicWludFwiOlwi4qiMXCIsXCJxb3BmXCI6XCLwnZWiXCIsXCJRb3BmXCI6XCLihJpcIixcInFwcmltZVwiOlwi4oGXXCIsXCJRc2NyXCI6XCLwnZKsXCIsXCJxc2NyXCI6XCLwnZOGXCIsXCJxdWF0ZXJuaW9uc1wiOlwi4oSNXCIsXCJxdWF0aW50XCI6XCLiqJZcIixcInF1ZXN0XCI6XCI/XCIsXCJxdWVzdGVxXCI6XCLiiZ9cIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJBYXJyXCI6XCLih5tcIixcInJhY2VcIjpcIuKIvcyxXCIsXCJSYWN1dGVcIjpcIsWUXCIsXCJyYWN1dGVcIjpcIsWVXCIsXCJyYWRpY1wiOlwi4oiaXCIsXCJyYWVtcHR5dlwiOlwi4qazXCIsXCJyYW5nXCI6XCLin6lcIixcIlJhbmdcIjpcIuKfq1wiLFwicmFuZ2RcIjpcIuKmklwiLFwicmFuZ2VcIjpcIuKmpVwiLFwicmFuZ2xlXCI6XCLin6lcIixcInJhcXVvXCI6XCLCu1wiLFwicmFycmFwXCI6XCLipbVcIixcInJhcnJiXCI6XCLih6VcIixcInJhcnJiZnNcIjpcIuKkoFwiLFwicmFycmNcIjpcIuKks1wiLFwicmFyclwiOlwi4oaSXCIsXCJSYXJyXCI6XCLihqBcIixcInJBcnJcIjpcIuKHklwiLFwicmFycmZzXCI6XCLipJ5cIixcInJhcnJoa1wiOlwi4oaqXCIsXCJyYXJybHBcIjpcIuKGrFwiLFwicmFycnBsXCI6XCLipYVcIixcInJhcnJzaW1cIjpcIuKltFwiLFwiUmFycnRsXCI6XCLipJZcIixcInJhcnJ0bFwiOlwi4oajXCIsXCJyYXJyd1wiOlwi4oadXCIsXCJyYXRhaWxcIjpcIuKkmlwiLFwickF0YWlsXCI6XCLipJxcIixcInJhdGlvXCI6XCLiiLZcIixcInJhdGlvbmFsc1wiOlwi4oSaXCIsXCJyYmFyclwiOlwi4qSNXCIsXCJyQmFyclwiOlwi4qSPXCIsXCJSQmFyclwiOlwi4qSQXCIsXCJyYmJya1wiOlwi4p2zXCIsXCJyYnJhY2VcIjpcIn1cIixcInJicmFja1wiOlwiXVwiLFwicmJya2VcIjpcIuKmjFwiLFwicmJya3NsZFwiOlwi4qaOXCIsXCJyYnJrc2x1XCI6XCLippBcIixcIlJjYXJvblwiOlwixZhcIixcInJjYXJvblwiOlwixZlcIixcIlJjZWRpbFwiOlwixZZcIixcInJjZWRpbFwiOlwixZdcIixcInJjZWlsXCI6XCLijIlcIixcInJjdWJcIjpcIn1cIixcIlJjeVwiOlwi0KBcIixcInJjeVwiOlwi0YBcIixcInJkY2FcIjpcIuKkt1wiLFwicmRsZGhhclwiOlwi4qWpXCIsXCJyZHF1b1wiOlwi4oCdXCIsXCJyZHF1b3JcIjpcIuKAnVwiLFwicmRzaFwiOlwi4oazXCIsXCJyZWFsXCI6XCLihJxcIixcInJlYWxpbmVcIjpcIuKEm1wiLFwicmVhbHBhcnRcIjpcIuKEnFwiLFwicmVhbHNcIjpcIuKEnVwiLFwiUmVcIjpcIuKEnFwiLFwicmVjdFwiOlwi4patXCIsXCJyZWdcIjpcIsKuXCIsXCJSRUdcIjpcIsKuXCIsXCJSZXZlcnNlRWxlbWVudFwiOlwi4oiLXCIsXCJSZXZlcnNlRXF1aWxpYnJpdW1cIjpcIuKHi1wiLFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjpcIuKlr1wiLFwicmZpc2h0XCI6XCLipb1cIixcInJmbG9vclwiOlwi4oyLXCIsXCJyZnJcIjpcIvCdlK9cIixcIlJmclwiOlwi4oScXCIsXCJySGFyXCI6XCLipaRcIixcInJoYXJkXCI6XCLih4FcIixcInJoYXJ1XCI6XCLih4BcIixcInJoYXJ1bFwiOlwi4qWsXCIsXCJSaG9cIjpcIs6hXCIsXCJyaG9cIjpcIs+BXCIsXCJyaG92XCI6XCLPsVwiLFwiUmlnaHRBbmdsZUJyYWNrZXRcIjpcIuKfqVwiLFwiUmlnaHRBcnJvd0JhclwiOlwi4oelXCIsXCJyaWdodGFycm93XCI6XCLihpJcIixcIlJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiUmlnaHRhcnJvd1wiOlwi4oeSXCIsXCJSaWdodEFycm93TGVmdEFycm93XCI6XCLih4RcIixcInJpZ2h0YXJyb3d0YWlsXCI6XCLihqNcIixcIlJpZ2h0Q2VpbGluZ1wiOlwi4oyJXCIsXCJSaWdodERvdWJsZUJyYWNrZXRcIjpcIuKfp1wiLFwiUmlnaHREb3duVGVlVmVjdG9yXCI6XCLipZ1cIixcIlJpZ2h0RG93blZlY3RvckJhclwiOlwi4qWVXCIsXCJSaWdodERvd25WZWN0b3JcIjpcIuKHglwiLFwiUmlnaHRGbG9vclwiOlwi4oyLXCIsXCJyaWdodGhhcnBvb25kb3duXCI6XCLih4FcIixcInJpZ2h0aGFycG9vbnVwXCI6XCLih4BcIixcInJpZ2h0bGVmdGFycm93c1wiOlwi4oeEXCIsXCJyaWdodGxlZnRoYXJwb29uc1wiOlwi4oeMXCIsXCJyaWdodHJpZ2h0YXJyb3dzXCI6XCLih4lcIixcInJpZ2h0c3F1aWdhcnJvd1wiOlwi4oadXCIsXCJSaWdodFRlZUFycm93XCI6XCLihqZcIixcIlJpZ2h0VGVlXCI6XCLiiqJcIixcIlJpZ2h0VGVlVmVjdG9yXCI6XCLipZtcIixcInJpZ2h0dGhyZWV0aW1lc1wiOlwi4ouMXCIsXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5BcIixcIlJpZ2h0VHJpYW5nbGVcIjpcIuKKs1wiLFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLiirVcIixcIlJpZ2h0VXBEb3duVmVjdG9yXCI6XCLipY9cIixcIlJpZ2h0VXBUZWVWZWN0b3JcIjpcIuKlnFwiLFwiUmlnaHRVcFZlY3RvckJhclwiOlwi4qWUXCIsXCJSaWdodFVwVmVjdG9yXCI6XCLihr5cIixcIlJpZ2h0VmVjdG9yQmFyXCI6XCLipZNcIixcIlJpZ2h0VmVjdG9yXCI6XCLih4BcIixcInJpbmdcIjpcIsuaXCIsXCJyaXNpbmdkb3RzZXFcIjpcIuKJk1wiLFwicmxhcnJcIjpcIuKHhFwiLFwicmxoYXJcIjpcIuKHjFwiLFwicmxtXCI6XCLigI9cIixcInJtb3VzdGFjaGVcIjpcIuKOsVwiLFwicm1vdXN0XCI6XCLijrFcIixcInJubWlkXCI6XCLiq65cIixcInJvYW5nXCI6XCLin61cIixcInJvYXJyXCI6XCLih75cIixcInJvYnJrXCI6XCLin6dcIixcInJvcGFyXCI6XCLipoZcIixcInJvcGZcIjpcIvCdlaNcIixcIlJvcGZcIjpcIuKEnVwiLFwicm9wbHVzXCI6XCLiqK5cIixcInJvdGltZXNcIjpcIuKotVwiLFwiUm91bmRJbXBsaWVzXCI6XCLipbBcIixcInJwYXJcIjpcIilcIixcInJwYXJndFwiOlwi4qaUXCIsXCJycHBvbGludFwiOlwi4qiSXCIsXCJycmFyclwiOlwi4oeJXCIsXCJScmlnaHRhcnJvd1wiOlwi4oebXCIsXCJyc2FxdW9cIjpcIuKAulwiLFwicnNjclwiOlwi8J2Th1wiLFwiUnNjclwiOlwi4oSbXCIsXCJyc2hcIjpcIuKGsVwiLFwiUnNoXCI6XCLihrFcIixcInJzcWJcIjpcIl1cIixcInJzcXVvXCI6XCLigJlcIixcInJzcXVvclwiOlwi4oCZXCIsXCJydGhyZWVcIjpcIuKLjFwiLFwicnRpbWVzXCI6XCLii4pcIixcInJ0cmlcIjpcIuKWuVwiLFwicnRyaWVcIjpcIuKKtVwiLFwicnRyaWZcIjpcIuKWuFwiLFwicnRyaWx0cmlcIjpcIuKnjlwiLFwiUnVsZURlbGF5ZWRcIjpcIuKntFwiLFwicnVsdWhhclwiOlwi4qWoXCIsXCJyeFwiOlwi4oSeXCIsXCJTYWN1dGVcIjpcIsWaXCIsXCJzYWN1dGVcIjpcIsWbXCIsXCJzYnF1b1wiOlwi4oCaXCIsXCJzY2FwXCI6XCLiqrhcIixcIlNjYXJvblwiOlwixaBcIixcInNjYXJvblwiOlwixaFcIixcIlNjXCI6XCLiqrxcIixcInNjXCI6XCLiibtcIixcInNjY3VlXCI6XCLiib1cIixcInNjZVwiOlwi4qqwXCIsXCJzY0VcIjpcIuKqtFwiLFwiU2NlZGlsXCI6XCLFnlwiLFwic2NlZGlsXCI6XCLFn1wiLFwiU2NpcmNcIjpcIsWcXCIsXCJzY2lyY1wiOlwixZ1cIixcInNjbmFwXCI6XCLiqrpcIixcInNjbkVcIjpcIuKqtlwiLFwic2Nuc2ltXCI6XCLii6lcIixcInNjcG9saW50XCI6XCLiqJNcIixcInNjc2ltXCI6XCLiib9cIixcIlNjeVwiOlwi0KFcIixcInNjeVwiOlwi0YFcIixcInNkb3RiXCI6XCLiiqFcIixcInNkb3RcIjpcIuKLhVwiLFwic2RvdGVcIjpcIuKpplwiLFwic2VhcmhrXCI6XCLipKVcIixcInNlYXJyXCI6XCLihphcIixcInNlQXJyXCI6XCLih5hcIixcInNlYXJyb3dcIjpcIuKGmFwiLFwic2VjdFwiOlwiwqdcIixcInNlbWlcIjpcIjtcIixcInNlc3dhclwiOlwi4qSpXCIsXCJzZXRtaW51c1wiOlwi4oiWXCIsXCJzZXRtblwiOlwi4oiWXCIsXCJzZXh0XCI6XCLinLZcIixcIlNmclwiOlwi8J2UllwiLFwic2ZyXCI6XCLwnZSwXCIsXCJzZnJvd25cIjpcIuKMolwiLFwic2hhcnBcIjpcIuKZr1wiLFwiU0hDSGN5XCI6XCLQqVwiLFwic2hjaGN5XCI6XCLRiVwiLFwiU0hjeVwiOlwi0KhcIixcInNoY3lcIjpcItGIXCIsXCJTaG9ydERvd25BcnJvd1wiOlwi4oaTXCIsXCJTaG9ydExlZnRBcnJvd1wiOlwi4oaQXCIsXCJzaG9ydG1pZFwiOlwi4oijXCIsXCJzaG9ydHBhcmFsbGVsXCI6XCLiiKVcIixcIlNob3J0UmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJTaG9ydFVwQXJyb3dcIjpcIuKGkVwiLFwic2h5XCI6XCLCrVwiLFwiU2lnbWFcIjpcIs6jXCIsXCJzaWdtYVwiOlwiz4NcIixcInNpZ21hZlwiOlwiz4JcIixcInNpZ21hdlwiOlwiz4JcIixcInNpbVwiOlwi4oi8XCIsXCJzaW1kb3RcIjpcIuKpqlwiLFwic2ltZVwiOlwi4omDXCIsXCJzaW1lcVwiOlwi4omDXCIsXCJzaW1nXCI6XCLiqp5cIixcInNpbWdFXCI6XCLiqqBcIixcInNpbWxcIjpcIuKqnVwiLFwic2ltbEVcIjpcIuKqn1wiLFwic2ltbmVcIjpcIuKJhlwiLFwic2ltcGx1c1wiOlwi4qikXCIsXCJzaW1yYXJyXCI6XCLipbJcIixcInNsYXJyXCI6XCLihpBcIixcIlNtYWxsQ2lyY2xlXCI6XCLiiJhcIixcInNtYWxsc2V0bWludXNcIjpcIuKIllwiLFwic21hc2hwXCI6XCLiqLNcIixcInNtZXBhcnNsXCI6XCLip6RcIixcInNtaWRcIjpcIuKIo1wiLFwic21pbGVcIjpcIuKMo1wiLFwic210XCI6XCLiqqpcIixcInNtdGVcIjpcIuKqrFwiLFwic210ZXNcIjpcIuKqrO+4gFwiLFwiU09GVGN5XCI6XCLQrFwiLFwic29mdGN5XCI6XCLRjFwiLFwic29sYmFyXCI6XCLijL9cIixcInNvbGJcIjpcIuKnhFwiLFwic29sXCI6XCIvXCIsXCJTb3BmXCI6XCLwnZWKXCIsXCJzb3BmXCI6XCLwnZWkXCIsXCJzcGFkZXNcIjpcIuKZoFwiLFwic3BhZGVzdWl0XCI6XCLimaBcIixcInNwYXJcIjpcIuKIpVwiLFwic3FjYXBcIjpcIuKKk1wiLFwic3FjYXBzXCI6XCLiipPvuIBcIixcInNxY3VwXCI6XCLiipRcIixcInNxY3Vwc1wiOlwi4oqU77iAXCIsXCJTcXJ0XCI6XCLiiJpcIixcInNxc3ViXCI6XCLiio9cIixcInNxc3ViZVwiOlwi4oqRXCIsXCJzcXN1YnNldFwiOlwi4oqPXCIsXCJzcXN1YnNldGVxXCI6XCLiipFcIixcInNxc3VwXCI6XCLiipBcIixcInNxc3VwZVwiOlwi4oqSXCIsXCJzcXN1cHNldFwiOlwi4oqQXCIsXCJzcXN1cHNldGVxXCI6XCLiipJcIixcInNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlSW50ZXJzZWN0aW9uXCI6XCLiipNcIixcIlNxdWFyZVN1YnNldFwiOlwi4oqPXCIsXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4oqRXCIsXCJTcXVhcmVTdXBlcnNldFwiOlwi4oqQXCIsXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLiipJcIixcIlNxdWFyZVVuaW9uXCI6XCLiipRcIixcInNxdWFyZlwiOlwi4paqXCIsXCJzcXVcIjpcIuKWoVwiLFwic3F1ZlwiOlwi4paqXCIsXCJzcmFyclwiOlwi4oaSXCIsXCJTc2NyXCI6XCLwnZKuXCIsXCJzc2NyXCI6XCLwnZOIXCIsXCJzc2V0bW5cIjpcIuKIllwiLFwic3NtaWxlXCI6XCLijKNcIixcInNzdGFyZlwiOlwi4ouGXCIsXCJTdGFyXCI6XCLii4ZcIixcInN0YXJcIjpcIuKYhlwiLFwic3RhcmZcIjpcIuKYhVwiLFwic3RyYWlnaHRlcHNpbG9uXCI6XCLPtVwiLFwic3RyYWlnaHRwaGlcIjpcIs+VXCIsXCJzdHJuc1wiOlwiwq9cIixcInN1YlwiOlwi4oqCXCIsXCJTdWJcIjpcIuKLkFwiLFwic3ViZG90XCI6XCLiqr1cIixcInN1YkVcIjpcIuKrhVwiLFwic3ViZVwiOlwi4oqGXCIsXCJzdWJlZG90XCI6XCLiq4NcIixcInN1Ym11bHRcIjpcIuKrgVwiLFwic3VibkVcIjpcIuKri1wiLFwic3VibmVcIjpcIuKKilwiLFwic3VicGx1c1wiOlwi4qq/XCIsXCJzdWJyYXJyXCI6XCLipblcIixcInN1YnNldFwiOlwi4oqCXCIsXCJTdWJzZXRcIjpcIuKLkFwiLFwic3Vic2V0ZXFcIjpcIuKKhlwiLFwic3Vic2V0ZXFxXCI6XCLiq4VcIixcIlN1YnNldEVxdWFsXCI6XCLiioZcIixcInN1YnNldG5lcVwiOlwi4oqKXCIsXCJzdWJzZXRuZXFxXCI6XCLiq4tcIixcInN1YnNpbVwiOlwi4quHXCIsXCJzdWJzdWJcIjpcIuKrlVwiLFwic3Vic3VwXCI6XCLiq5NcIixcInN1Y2NhcHByb3hcIjpcIuKquFwiLFwic3VjY1wiOlwi4om7XCIsXCJzdWNjY3VybHllcVwiOlwi4om9XCIsXCJTdWNjZWVkc1wiOlwi4om7XCIsXCJTdWNjZWVkc0VxdWFsXCI6XCLiqrBcIixcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4om9XCIsXCJTdWNjZWVkc1RpbGRlXCI6XCLiib9cIixcInN1Y2NlcVwiOlwi4qqwXCIsXCJzdWNjbmFwcHJveFwiOlwi4qq6XCIsXCJzdWNjbmVxcVwiOlwi4qq2XCIsXCJzdWNjbnNpbVwiOlwi4oupXCIsXCJzdWNjc2ltXCI6XCLiib9cIixcIlN1Y2hUaGF0XCI6XCLiiItcIixcInN1bVwiOlwi4oiRXCIsXCJTdW1cIjpcIuKIkVwiLFwic3VuZ1wiOlwi4pmqXCIsXCJzdXAxXCI6XCLCuVwiLFwic3VwMlwiOlwiwrJcIixcInN1cDNcIjpcIsKzXCIsXCJzdXBcIjpcIuKKg1wiLFwiU3VwXCI6XCLii5FcIixcInN1cGRvdFwiOlwi4qq+XCIsXCJzdXBkc3ViXCI6XCLiq5hcIixcInN1cEVcIjpcIuKrhlwiLFwic3VwZVwiOlwi4oqHXCIsXCJzdXBlZG90XCI6XCLiq4RcIixcIlN1cGVyc2V0XCI6XCLiioNcIixcIlN1cGVyc2V0RXF1YWxcIjpcIuKKh1wiLFwic3VwaHNvbFwiOlwi4p+JXCIsXCJzdXBoc3ViXCI6XCLiq5dcIixcInN1cGxhcnJcIjpcIuKlu1wiLFwic3VwbXVsdFwiOlwi4quCXCIsXCJzdXBuRVwiOlwi4quMXCIsXCJzdXBuZVwiOlwi4oqLXCIsXCJzdXBwbHVzXCI6XCLiq4BcIixcInN1cHNldFwiOlwi4oqDXCIsXCJTdXBzZXRcIjpcIuKLkVwiLFwic3Vwc2V0ZXFcIjpcIuKKh1wiLFwic3Vwc2V0ZXFxXCI6XCLiq4ZcIixcInN1cHNldG5lcVwiOlwi4oqLXCIsXCJzdXBzZXRuZXFxXCI6XCLiq4xcIixcInN1cHNpbVwiOlwi4quIXCIsXCJzdXBzdWJcIjpcIuKrlFwiLFwic3Vwc3VwXCI6XCLiq5ZcIixcInN3YXJoa1wiOlwi4qSmXCIsXCJzd2FyclwiOlwi4oaZXCIsXCJzd0FyclwiOlwi4oeZXCIsXCJzd2Fycm93XCI6XCLihplcIixcInN3bndhclwiOlwi4qSqXCIsXCJzemxpZ1wiOlwiw59cIixcIlRhYlwiOlwiXFx0XCIsXCJ0YXJnZXRcIjpcIuKMllwiLFwiVGF1XCI6XCLOpFwiLFwidGF1XCI6XCLPhFwiLFwidGJya1wiOlwi4o60XCIsXCJUY2Fyb25cIjpcIsWkXCIsXCJ0Y2Fyb25cIjpcIsWlXCIsXCJUY2VkaWxcIjpcIsWiXCIsXCJ0Y2VkaWxcIjpcIsWjXCIsXCJUY3lcIjpcItCiXCIsXCJ0Y3lcIjpcItGCXCIsXCJ0ZG90XCI6XCLig5tcIixcInRlbHJlY1wiOlwi4oyVXCIsXCJUZnJcIjpcIvCdlJdcIixcInRmclwiOlwi8J2UsVwiLFwidGhlcmU0XCI6XCLiiLRcIixcInRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGVyZWZvcmVcIjpcIuKItFwiLFwiVGhldGFcIjpcIs6YXCIsXCJ0aGV0YVwiOlwizrhcIixcInRoZXRhc3ltXCI6XCLPkVwiLFwidGhldGF2XCI6XCLPkVwiLFwidGhpY2thcHByb3hcIjpcIuKJiFwiLFwidGhpY2tzaW1cIjpcIuKIvFwiLFwiVGhpY2tTcGFjZVwiOlwi4oGf4oCKXCIsXCJUaGluU3BhY2VcIjpcIuKAiVwiLFwidGhpbnNwXCI6XCLigIlcIixcInRoa2FwXCI6XCLiiYhcIixcInRoa3NpbVwiOlwi4oi8XCIsXCJUSE9STlwiOlwiw55cIixcInRob3JuXCI6XCLDvlwiLFwidGlsZGVcIjpcIsucXCIsXCJUaWxkZVwiOlwi4oi8XCIsXCJUaWxkZUVxdWFsXCI6XCLiiYNcIixcIlRpbGRlRnVsbEVxdWFsXCI6XCLiiYVcIixcIlRpbGRlVGlsZGVcIjpcIuKJiFwiLFwidGltZXNiYXJcIjpcIuKosVwiLFwidGltZXNiXCI6XCLiiqBcIixcInRpbWVzXCI6XCLDl1wiLFwidGltZXNkXCI6XCLiqLBcIixcInRpbnRcIjpcIuKIrVwiLFwidG9lYVwiOlwi4qSoXCIsXCJ0b3Bib3RcIjpcIuKMtlwiLFwidG9wY2lyXCI6XCLiq7FcIixcInRvcFwiOlwi4oqkXCIsXCJUb3BmXCI6XCLwnZWLXCIsXCJ0b3BmXCI6XCLwnZWlXCIsXCJ0b3Bmb3JrXCI6XCLiq5pcIixcInRvc2FcIjpcIuKkqVwiLFwidHByaW1lXCI6XCLigLRcIixcInRyYWRlXCI6XCLihKJcIixcIlRSQURFXCI6XCLihKJcIixcInRyaWFuZ2xlXCI6XCLilrVcIixcInRyaWFuZ2xlZG93blwiOlwi4pa/XCIsXCJ0cmlhbmdsZWxlZnRcIjpcIuKXg1wiLFwidHJpYW5nbGVsZWZ0ZXFcIjpcIuKKtFwiLFwidHJpYW5nbGVxXCI6XCLiiZxcIixcInRyaWFuZ2xlcmlnaHRcIjpcIuKWuVwiLFwidHJpYW5nbGVyaWdodGVxXCI6XCLiirVcIixcInRyaWRvdFwiOlwi4pesXCIsXCJ0cmllXCI6XCLiiZxcIixcInRyaW1pbnVzXCI6XCLiqLpcIixcIlRyaXBsZURvdFwiOlwi4oObXCIsXCJ0cmlwbHVzXCI6XCLiqLlcIixcInRyaXNiXCI6XCLip41cIixcInRyaXRpbWVcIjpcIuKou1wiLFwidHJwZXppdW1cIjpcIuKPolwiLFwiVHNjclwiOlwi8J2Sr1wiLFwidHNjclwiOlwi8J2TiVwiLFwiVFNjeVwiOlwi0KZcIixcInRzY3lcIjpcItGGXCIsXCJUU0hjeVwiOlwi0ItcIixcInRzaGN5XCI6XCLRm1wiLFwiVHN0cm9rXCI6XCLFplwiLFwidHN0cm9rXCI6XCLFp1wiLFwidHdpeHRcIjpcIuKJrFwiLFwidHdvaGVhZGxlZnRhcnJvd1wiOlwi4oaeXCIsXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwi4oagXCIsXCJVYWN1dGVcIjpcIsOaXCIsXCJ1YWN1dGVcIjpcIsO6XCIsXCJ1YXJyXCI6XCLihpFcIixcIlVhcnJcIjpcIuKGn1wiLFwidUFyclwiOlwi4oeRXCIsXCJVYXJyb2NpclwiOlwi4qWJXCIsXCJVYnJjeVwiOlwi0I5cIixcInVicmN5XCI6XCLRnlwiLFwiVWJyZXZlXCI6XCLFrFwiLFwidWJyZXZlXCI6XCLFrVwiLFwiVWNpcmNcIjpcIsObXCIsXCJ1Y2lyY1wiOlwiw7tcIixcIlVjeVwiOlwi0KNcIixcInVjeVwiOlwi0YNcIixcInVkYXJyXCI6XCLih4VcIixcIlVkYmxhY1wiOlwixbBcIixcInVkYmxhY1wiOlwixbFcIixcInVkaGFyXCI6XCLipa5cIixcInVmaXNodFwiOlwi4qW+XCIsXCJVZnJcIjpcIvCdlJhcIixcInVmclwiOlwi8J2UslwiLFwiVWdyYXZlXCI6XCLDmVwiLFwidWdyYXZlXCI6XCLDuVwiLFwidUhhclwiOlwi4qWjXCIsXCJ1aGFybFwiOlwi4oa/XCIsXCJ1aGFyclwiOlwi4oa+XCIsXCJ1aGJsa1wiOlwi4paAXCIsXCJ1bGNvcm5cIjpcIuKMnFwiLFwidWxjb3JuZXJcIjpcIuKMnFwiLFwidWxjcm9wXCI6XCLijI9cIixcInVsdHJpXCI6XCLil7hcIixcIlVtYWNyXCI6XCLFqlwiLFwidW1hY3JcIjpcIsWrXCIsXCJ1bWxcIjpcIsKoXCIsXCJVbmRlckJhclwiOlwiX1wiLFwiVW5kZXJCcmFjZVwiOlwi4o+fXCIsXCJVbmRlckJyYWNrZXRcIjpcIuKOtVwiLFwiVW5kZXJQYXJlbnRoZXNpc1wiOlwi4o+dXCIsXCJVbmlvblwiOlwi4ouDXCIsXCJVbmlvblBsdXNcIjpcIuKKjlwiLFwiVW9nb25cIjpcIsWyXCIsXCJ1b2dvblwiOlwixbNcIixcIlVvcGZcIjpcIvCdlYxcIixcInVvcGZcIjpcIvCdlaZcIixcIlVwQXJyb3dCYXJcIjpcIuKkklwiLFwidXBhcnJvd1wiOlwi4oaRXCIsXCJVcEFycm93XCI6XCLihpFcIixcIlVwYXJyb3dcIjpcIuKHkVwiLFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwi4oeFXCIsXCJ1cGRvd25hcnJvd1wiOlwi4oaVXCIsXCJVcERvd25BcnJvd1wiOlwi4oaVXCIsXCJVcGRvd25hcnJvd1wiOlwi4oeVXCIsXCJVcEVxdWlsaWJyaXVtXCI6XCLipa5cIixcInVwaGFycG9vbmxlZnRcIjpcIuKGv1wiLFwidXBoYXJwb29ucmlnaHRcIjpcIuKGvlwiLFwidXBsdXNcIjpcIuKKjlwiLFwiVXBwZXJMZWZ0QXJyb3dcIjpcIuKGllwiLFwiVXBwZXJSaWdodEFycm93XCI6XCLihpdcIixcInVwc2lcIjpcIs+FXCIsXCJVcHNpXCI6XCLPklwiLFwidXBzaWhcIjpcIs+SXCIsXCJVcHNpbG9uXCI6XCLOpVwiLFwidXBzaWxvblwiOlwiz4VcIixcIlVwVGVlQXJyb3dcIjpcIuKGpVwiLFwiVXBUZWVcIjpcIuKKpVwiLFwidXB1cGFycm93c1wiOlwi4oeIXCIsXCJ1cmNvcm5cIjpcIuKMnVwiLFwidXJjb3JuZXJcIjpcIuKMnVwiLFwidXJjcm9wXCI6XCLijI5cIixcIlVyaW5nXCI6XCLFrlwiLFwidXJpbmdcIjpcIsWvXCIsXCJ1cnRyaVwiOlwi4pe5XCIsXCJVc2NyXCI6XCLwnZKwXCIsXCJ1c2NyXCI6XCLwnZOKXCIsXCJ1dGRvdFwiOlwi4ouwXCIsXCJVdGlsZGVcIjpcIsWoXCIsXCJ1dGlsZGVcIjpcIsWpXCIsXCJ1dHJpXCI6XCLilrVcIixcInV0cmlmXCI6XCLilrRcIixcInV1YXJyXCI6XCLih4hcIixcIlV1bWxcIjpcIsOcXCIsXCJ1dW1sXCI6XCLDvFwiLFwidXdhbmdsZVwiOlwi4qanXCIsXCJ2YW5ncnRcIjpcIuKmnFwiLFwidmFyZXBzaWxvblwiOlwiz7VcIixcInZhcmthcHBhXCI6XCLPsFwiLFwidmFybm90aGluZ1wiOlwi4oiFXCIsXCJ2YXJwaGlcIjpcIs+VXCIsXCJ2YXJwaVwiOlwiz5ZcIixcInZhcnByb3B0b1wiOlwi4oidXCIsXCJ2YXJyXCI6XCLihpVcIixcInZBcnJcIjpcIuKHlVwiLFwidmFycmhvXCI6XCLPsVwiLFwidmFyc2lnbWFcIjpcIs+CXCIsXCJ2YXJzdWJzZXRuZXFcIjpcIuKKiu+4gFwiLFwidmFyc3Vic2V0bmVxcVwiOlwi4quL77iAXCIsXCJ2YXJzdXBzZXRuZXFcIjpcIuKKi++4gFwiLFwidmFyc3Vwc2V0bmVxcVwiOlwi4quM77iAXCIsXCJ2YXJ0aGV0YVwiOlwiz5FcIixcInZhcnRyaWFuZ2xlbGVmdFwiOlwi4oqyXCIsXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCLiirNcIixcInZCYXJcIjpcIuKrqFwiLFwiVmJhclwiOlwi4qurXCIsXCJ2QmFydlwiOlwi4qupXCIsXCJWY3lcIjpcItCSXCIsXCJ2Y3lcIjpcItCyXCIsXCJ2ZGFzaFwiOlwi4oqiXCIsXCJ2RGFzaFwiOlwi4oqoXCIsXCJWZGFzaFwiOlwi4oqpXCIsXCJWRGFzaFwiOlwi4oqrXCIsXCJWZGFzaGxcIjpcIuKrplwiLFwidmVlYmFyXCI6XCLiirtcIixcInZlZVwiOlwi4oioXCIsXCJWZWVcIjpcIuKLgVwiLFwidmVlZXFcIjpcIuKJmlwiLFwidmVsbGlwXCI6XCLii65cIixcInZlcmJhclwiOlwifFwiLFwiVmVyYmFyXCI6XCLigJZcIixcInZlcnRcIjpcInxcIixcIlZlcnRcIjpcIuKAllwiLFwiVmVydGljYWxCYXJcIjpcIuKIo1wiLFwiVmVydGljYWxMaW5lXCI6XCJ8XCIsXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwi4p2YXCIsXCJWZXJ0aWNhbFRpbGRlXCI6XCLiiYBcIixcIlZlcnlUaGluU3BhY2VcIjpcIuKAilwiLFwiVmZyXCI6XCLwnZSZXCIsXCJ2ZnJcIjpcIvCdlLNcIixcInZsdHJpXCI6XCLiirJcIixcInZuc3ViXCI6XCLiioLig5JcIixcInZuc3VwXCI6XCLiioPig5JcIixcIlZvcGZcIjpcIvCdlY1cIixcInZvcGZcIjpcIvCdladcIixcInZwcm9wXCI6XCLiiJ1cIixcInZydHJpXCI6XCLiirNcIixcIlZzY3JcIjpcIvCdkrFcIixcInZzY3JcIjpcIvCdk4tcIixcInZzdWJuRVwiOlwi4quL77iAXCIsXCJ2c3VibmVcIjpcIuKKiu+4gFwiLFwidnN1cG5FXCI6XCLiq4zvuIBcIixcInZzdXBuZVwiOlwi4oqL77iAXCIsXCJWdmRhc2hcIjpcIuKKqlwiLFwidnppZ3phZ1wiOlwi4qaaXCIsXCJXY2lyY1wiOlwixbRcIixcIndjaXJjXCI6XCLFtVwiLFwid2VkYmFyXCI6XCLiqZ9cIixcIndlZGdlXCI6XCLiiKdcIixcIldlZGdlXCI6XCLii4BcIixcIndlZGdlcVwiOlwi4omZXCIsXCJ3ZWllcnBcIjpcIuKEmFwiLFwiV2ZyXCI6XCLwnZSaXCIsXCJ3ZnJcIjpcIvCdlLRcIixcIldvcGZcIjpcIvCdlY5cIixcIndvcGZcIjpcIvCdlahcIixcIndwXCI6XCLihJhcIixcIndyXCI6XCLiiYBcIixcIndyZWF0aFwiOlwi4omAXCIsXCJXc2NyXCI6XCLwnZKyXCIsXCJ3c2NyXCI6XCLwnZOMXCIsXCJ4Y2FwXCI6XCLii4JcIixcInhjaXJjXCI6XCLil69cIixcInhjdXBcIjpcIuKLg1wiLFwieGR0cmlcIjpcIuKWvVwiLFwiWGZyXCI6XCLwnZSbXCIsXCJ4ZnJcIjpcIvCdlLVcIixcInhoYXJyXCI6XCLin7dcIixcInhoQXJyXCI6XCLin7pcIixcIlhpXCI6XCLOnlwiLFwieGlcIjpcIs6+XCIsXCJ4bGFyclwiOlwi4p+1XCIsXCJ4bEFyclwiOlwi4p+4XCIsXCJ4bWFwXCI6XCLin7xcIixcInhuaXNcIjpcIuKLu1wiLFwieG9kb3RcIjpcIuKogFwiLFwiWG9wZlwiOlwi8J2Vj1wiLFwieG9wZlwiOlwi8J2VqVwiLFwieG9wbHVzXCI6XCLiqIFcIixcInhvdGltZVwiOlwi4qiCXCIsXCJ4cmFyclwiOlwi4p+2XCIsXCJ4ckFyclwiOlwi4p+5XCIsXCJYc2NyXCI6XCLwnZKzXCIsXCJ4c2NyXCI6XCLwnZONXCIsXCJ4c3FjdXBcIjpcIuKohlwiLFwieHVwbHVzXCI6XCLiqIRcIixcInh1dHJpXCI6XCLilrNcIixcInh2ZWVcIjpcIuKLgVwiLFwieHdlZGdlXCI6XCLii4BcIixcIllhY3V0ZVwiOlwiw51cIixcInlhY3V0ZVwiOlwiw71cIixcIllBY3lcIjpcItCvXCIsXCJ5YWN5XCI6XCLRj1wiLFwiWWNpcmNcIjpcIsW2XCIsXCJ5Y2lyY1wiOlwixbdcIixcIlljeVwiOlwi0KtcIixcInljeVwiOlwi0YtcIixcInllblwiOlwiwqVcIixcIllmclwiOlwi8J2UnFwiLFwieWZyXCI6XCLwnZS2XCIsXCJZSWN5XCI6XCLQh1wiLFwieWljeVwiOlwi0ZdcIixcIllvcGZcIjpcIvCdlZBcIixcInlvcGZcIjpcIvCdlapcIixcIllzY3JcIjpcIvCdkrRcIixcInlzY3JcIjpcIvCdk45cIixcIllVY3lcIjpcItCuXCIsXCJ5dWN5XCI6XCLRjlwiLFwieXVtbFwiOlwiw79cIixcIll1bWxcIjpcIsW4XCIsXCJaYWN1dGVcIjpcIsW5XCIsXCJ6YWN1dGVcIjpcIsW6XCIsXCJaY2Fyb25cIjpcIsW9XCIsXCJ6Y2Fyb25cIjpcIsW+XCIsXCJaY3lcIjpcItCXXCIsXCJ6Y3lcIjpcItC3XCIsXCJaZG90XCI6XCLFu1wiLFwiemRvdFwiOlwixbxcIixcInplZXRyZlwiOlwi4oSoXCIsXCJaZXJvV2lkdGhTcGFjZVwiOlwi4oCLXCIsXCJaZXRhXCI6XCLOllwiLFwiemV0YVwiOlwizrZcIixcInpmclwiOlwi8J2Ut1wiLFwiWmZyXCI6XCLihKhcIixcIlpIY3lcIjpcItCWXCIsXCJ6aGN5XCI6XCLQtlwiLFwiemlncmFyclwiOlwi4oedXCIsXCJ6b3BmXCI6XCLwnZWrXCIsXCJab3BmXCI6XCLihKRcIixcIlpzY3JcIjpcIvCdkrVcIixcInpzY3JcIjpcIvCdk49cIixcInp3alwiOlwi4oCNXCIsXCJ6d25qXCI6XCLigIxcIn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9lbmNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgY2FjaGUucHVzaChjaCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIERlY29kZSBwZXJjZW50LWVuY29kZWQgc3RyaW5nLlxuLy9cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgdmFyIGNhY2hlO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xuICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBiMSA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMSwgaSArIDMpLCAxNik7XG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEUwKSA9PT0gMHhDMCAmJiAoaSArIDMgPCBsKSkge1xuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGMCkgPT09IDB4RTAgJiYgKGkgKyA2IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxMikgJiAweEYwMDApIHwgKChiMiA8PCA2KSAmIDB4RkMwKSB8IChiMyAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODAwIHx8IChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxOCkgJiAweDFDMDAwMCkgfCAoKGIyIDw8IDEyKSAmIDB4M0YwMDApIHwgKChiMyA8PCA2KSAmIDB4RkMwKSB8IChiNCAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKGNociA+PiAxMCksIDB4REMwMCArIChjaHIgJiAweDNGRikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJ1xcdWZmZmQnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5cbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XG5kZWNvZGUuY29tcG9uZW50Q2hhcnMgPSAnJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9kZWNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdCh1cmwpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHJlc3VsdCArPSB1cmwucHJvdG9jb2wgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2xhc2hlcyA/ICcvLycgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyAnQCcgOiAnJztcblxuICBpZiAodXJsLmhvc3RuYW1lICYmIHVybC5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgLy8gaXB2NiBhZGRyZXNzXG4gICAgcmVzdWx0ICs9ICdbJyArIHVybC5ob3N0bmFtZSArICddJztcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5wYXRobmFtZSB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zZWFyY2ggfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuaGFzaCB8fCAnJztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9mb3JtYXQuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9wYXJzZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5BbnkgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jyk7XG5leHBvcnRzLkNjICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DYy9yZWdleCcpO1xuZXhwb3J0cy5DZiAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2YvcmVnZXgnKTtcbmV4cG9ydHMuUCAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1AvcmVnZXgnKTtcbmV4cG9ydHMuWiAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1ovcmVnZXgnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRcXHVEQ0JEfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcbid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnRzLnBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2xhYmVsJyk7XG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG5leHBvcnRzLnBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX3RpdGxlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCIvLyBQYXJzZSBsaW5rIGxhYmVsXG4vL1xuLy8gdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIChcIltcIikgYWxyZWFkeSBtYXRjaGVzO1xuLy8gcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbFxuLy9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQsIGRpc2FibGVOZXN0ZWQpIHtcbiAgdmFyIGxldmVsLCBmb3VuZCwgbWFya2VyLCBwcmV2UG9zLFxuICAgICAgbGFiZWxFbmQgPSAtMSxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcztcblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gIGxldmVsID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKTtcbiAgICBpZiAobWFya2VyID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2UG9zID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgaWYgKHByZXZQb3MgPT09IHN0YXRlLnBvcyAtIDEpIHtcbiAgICAgICAgLy8gaW5jcmVhc2UgbGV2ZWwgaWYgd2UgZmluZCB0ZXh0IGBbYCwgd2hpY2ggaXMgbm90IGEgcGFydCBvZiBhbnkgdG9rZW5cbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH0gZWxzZSBpZiAoZGlzYWJsZU5lc3RlZCkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHtcbiAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvcztcblxuICByZXR1cm4gbGFiZWxFbmQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1NwYWNlICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsIGxldmVsLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8gfHwgaXNTcGFjZShjb2RlKSkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBhc2NpaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDB4MjAgfHwgY29kZSA9PT0gMHg3RikgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgaWYgKGxldmVsID4gMSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwiLy8gUGFyc2UgbGluayB0aXRsZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsXG4gICAgICBtYXJrZXIsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBtYXJrZXIgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4MjIgLyogXCIgKi8gJiYgbWFya2VyICE9PSAweDI3IC8qICcgKi8gJiYgbWFya2VyICE9PSAweDI4IC8qICggKi8pIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHBvcysrO1xuXG4gIC8vIGlmIG9wZW5pbmcgbWFya2VyIGlzIFwiKFwiLCBzd2l0Y2ggaXQgdG8gY2xvc2luZyBtYXJrZXIgXCIpXCJcbiAgaWYgKG1hcmtlciA9PT0gMHgyOCkgeyBtYXJrZXIgPSAweDI5OyB9XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xudmFyIGVzY2FwZUh0bWwgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuZXNjYXBlSHRtbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+Jztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXG4gICAgICBpbmZvID0gdG9rZW4uaW5mbyA/IHVuZXNjYXBlQWxsKHRva2VuLmluZm8pLnRyaW0oKSA6ICcnLFxuICAgICAgbGFuZ05hbWUgPSAnJyxcbiAgICAgIGhpZ2hsaWdodGVkLCBpLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBsYW5nTmFtZSA9IGluZm8uc3BsaXQoL1xccysvZylbMF07XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtb2RpZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuY2xvbmUoKSBmb3IgdG9rZW4gYW5kIHNpbXBsaWZ5IHRoaXMgcGFydCwgYnV0XG4gIC8vIG5vdyB3ZSBwcmVmZXIgdG8ga2VlcCB0aGluZ3MgbG9jYWwuXG4gIGlmIChpbmZvKSB7XG4gICAgaSAgICAgICAgPSB0b2tlbi5hdHRySW5kZXgoJ2NsYXNzJyk7XG4gICAgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdG1wQXR0cnMucHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBBdHRyc1tpXVsxXSArPSAnICcgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH07XG5cbiAgICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyAnPidcbiAgICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuXG4gIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG5cbiAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5kZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5kZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcblxuICAvKipcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XG4gICAqXG4gICAqIENvbnRhaW5zIHJlbmRlciBydWxlcyBmb3IgdG9rZW5zLiBDYW4gYmUgdXBkYXRlZCBhbmQgZXh0ZW5kZWQuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPC9iPic7IH07XG4gICAqXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlZCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XG4gICAqICAgLy8gLi4uXG4gICAqICAgcmV0dXJuIHJlbmRlcmVkSFRNTDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcylcbiAgICogZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlcyA9IGFzc2lnbih7fSwgZGVmYXVsdF9ydWxlcyk7XG59XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJBdHRycyh0b2tlbikgLT4gU3RyaW5nXG4gKlxuICogUmVuZGVyIHRva2VuIGF0dHJpYnV0ZXMgdG8gc3RyaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcbiAgdmFyIGksIGwsIHJlc3VsdDtcblxuICBpZiAoIXRva2VuLmF0dHJzKSB7IHJldHVybiAnJzsgfVxuXG4gIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbi5hdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyAnICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVswXSkgKyAnPVwiJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMV0pICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvZiB0b2tlbnNcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICpcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXG4gKiBpbiBbW1JlbmRlcmVyI3J1bGVzXV0uXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICB2YXIgbmV4dFRva2VuLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBuZWVkTGYgPSBmYWxzZSxcbiAgICAgIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gVGlnaHQgbGlzdCBwYXJhZ3JhcGhzXG4gIGlmICh0b2tlbi5oaWRkZW4pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBJbnNlcnQgYSBuZXdsaW5lIGJldHdlZW4gaGlkZGVuIHBhcmFncmFwaCBhbmQgc3Vic2VxdWVudCBvcGVuaW5nXG4gIC8vIGJsb2NrLWxldmVsIHRhZy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGhlcmUgd2Ugc2hvdWxkIGluc2VydCBhIG5ld2xpbmUgYmVmb3JlIGJsb2NrcXVvdGU6XG4gIC8vICAtIGFcbiAgLy8gICAgPlxuICAvL1xuICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBBZGQgdG9rZW4gbmFtZSwgZS5nLiBgPGltZ2BcbiAgcmVzdWx0ICs9ICh0b2tlbi5uZXN0aW5nID09PSAtMSA/ICc8LycgOiAnPCcpICsgdG9rZW4udGFnO1xuXG4gIC8vIEVuY29kZSBhdHRyaWJ1dGVzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiYFxuICByZXN1bHQgKz0gdGhpcy5yZW5kZXJBdHRycyh0b2tlbik7XG5cbiAgLy8gQWRkIGEgc2xhc2ggZm9yIHNlbGYtY2xvc2luZyB0YWdzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiIC9gXG4gIGlmICh0b2tlbi5uZXN0aW5nID09PSAwICYmIG9wdGlvbnMueGh0bWxPdXQpIHtcbiAgICByZXN1bHQgKz0gJyAvJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xuICBpZiAodG9rZW4uYmxvY2spIHtcbiAgICBuZWVkTGYgPSB0cnVlO1xuXG4gICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgIGlmIChpZHggKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XG5cbiAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAnaW5saW5lJyB8fCBuZXh0VG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gQmxvY2stbGV2ZWwgdGFnIGNvbnRhaW5pbmcgYW4gaW5saW5lIHRhZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLm5lc3RpbmcgPT09IC0xICYmIG5leHRUb2tlbi50YWcgPT09IHRva2VuLnRhZykge1xuICAgICAgICAgIC8vIE9wZW5pbmcgdGFnICsgY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgdHlwZS4gRS5nLiBgPGxpPjwvbGk+YC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ICs9IG5lZWRMZiA/ICc+XFxuJyA6ICc+JztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZSh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGhlIHNhbWUgYXMgW1tSZW5kZXJlci5yZW5kZXJdXSwgYnV0IGZvciBzaW5nbGUgdG9rZW4gb2YgYGlubGluZWAgdHlwZS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFNwZWNpYWwga2x1ZGdlIGZvciBpbWFnZSBgYWx0YCBhdHRyaWJ1dGVzIHRvIGNvbmZvcm0gQ29tbW9uTWFyayBzcGVjLlxuICogRG9uJ3QgdHJ5IHRvIHVzZSBpdCEgU3BlYyByZXF1aXJlcyB0byBzaG93IGBhbHRgIGNvbnRlbnQgd2l0aCBzdHJpcHBlZCBtYXJrdXAsXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmVBc1RleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzdWx0ICs9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXIodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcbiAqIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgaSwgbGVuLCB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3Rva2Vuc1tpXS50eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIENvcmVcbiAqXG4gKiBUb3AtbGV2ZWwgcnVsZXMgZXhlY3V0b3IuIEdsdWVzIGJsb2NrL2lubGluZSBwYXJzZXJzIGFuZCBkb2VzIGludGVybWVkaWF0ZVxuICogdHJhbnNmb3JtYXRpb25zLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnbm9ybWFsaXplJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbm9ybWFsaXplJykgICAgICBdLFxuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXG4gIFsgJ2lubGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2lubGluZScpICAgICAgICAgXSxcbiAgWyAnbGlua2lmeScsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbGlua2lmeScpICAgICAgICBdLFxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXG4gIFsgJ3NtYXJ0cXVvdGVzJywgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzJykgICAgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBDb3JlKClcbiAqKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG4gIC8qKlxuICAgKiBDb3JlI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGNvcmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ29yZS5wcm9jZXNzKHN0YXRlKVxuICpcbiAqIEV4ZWN1dGVzIGNvcmUgY2hhaW4gcnVsZXMuXG4gKiovXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBydWxlcztcblxuICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cbkNvcmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19jb3JlL3N0YXRlX2NvcmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV0/fFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcdTAwMDAvZztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgc3RyO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsICdcXHVGRkZEJyk7XG5cbiAgc3RhdGUuc3JjID0gc3RyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuICB2YXIgdG9rZW47XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyAwLCAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XG5cbiAgLy8gUGFyc2UgaW5saW5lc1xuICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRvayA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UodG9rLmNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRvay5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCIvLyBTaW1wbGUgdHlwb2dyYXBoeWMgcmVwbGFjZW1lbnRzXG4vL1xuLy8gKGMpIChDKSDihpIgwqlcbi8vICh0bSkgKFRNKSDihpIg4oSiXG4vLyAocikgKFIpIOKGkiDCrlxuLy8gKy0g4oaSIMKxXG4vLyAocCkgKFApIC0+IMKnXG4vLyAuLi4g4oaSIOKApiAoYWxzbyA/Li4uLiDihpIgPy4uLCAhLi4uLiDihpIgIS4uKVxuLy8gPz8/Pz8/Pz8g4oaSID8/PywgISEhISEg4oaSICEhISwgYCwsYCDihpIgYCxgXG4vLyAtLSDihpIgJm5kYXNoOywgLS0tIOKGkiAmbWRhc2g7XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOlxuLy8gLSBmcmFjdGlvbmFscyAxLzIsIDEvNCwgMy80IC0+IMK9LCDCvCwgwr5cbi8vIC0gbWlsdGlwbGljYXRpb24gMiB4IDQgLT4gMiDDlyA0XG5cbnZhciBSQVJFX1JFID0gL1xcKy18XFwuXFwufFxcP1xcP1xcP1xcP3whISEhfCwsfC0tLztcblxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXG4vLyBvciByb290IGNoZWNrIHdpbGwgZmFpbCBldmVyeSBzZWNvbmQgdGltZVxudmFyIFNDT1BFRF9BQkJSX1RFU1RfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pO1xuXG52YXIgU0NPUEVEX0FCQlJfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pZztcbnZhciBTQ09QRURfQUJCUiA9IHtcbiAgYzogJ8KpJyxcbiAgcjogJ8KuJyxcbiAgcDogJ8KnJyxcbiAgdG06ICfihKInXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlRm4obWF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2Vfc2NvcGVkKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgICAgICAgICAgICAvLyAuLiwgLi4uLCAuLi4uLi4uIC0+IOKAplxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbPyFdKXs0LH0vZywgJyQxJDEkMScpLnJlcGxhY2UoLyx7Mix9L2csICcsJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW4tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKFxcc3wkKS9tZywgJyQxXFx1MjAxMyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG52YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG52YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbnZhciBBUE9TVFJPUEhFID0gJ1xcdTIwMTknOyAvKiDigJkgKi9cblxuXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfaW5saW5lcyh0b2tlbnMsIHN0YXRlKSB7XG4gIHZhciBpLCB0b2tlbiwgdGV4dCwgdCwgcG9zLCBtYXgsIHRoaXNMZXZlbCwgaXRlbSwgbGFzdENoYXIsIG5leHRDaGFyLFxuICAgICAgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsXG4gICAgICBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIHN0YWNrLCBvcGVuUXVvdGUsIGNsb3NlUXVvdGU7XG5cbiAgc3RhY2sgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICB0aGlzTGV2ZWwgPSB0b2tlbnNbaV0ubGV2ZWw7XG5cbiAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgIHBvcyA9IDA7XG4gICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgIE9VVEVSOlxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIHQgPSBRVU9URV9SRS5leGVjKHRleHQpO1xuICAgICAgaWYgKCF0KSB7IGJyZWFrOyB9XG5cbiAgICAgIGNhbk9wZW4gPSBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBwb3MgPSB0LmluZGV4ICsgMTtcbiAgICAgIGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKTtcblxuICAgICAgLy8gRmluZCBwcmV2aW91cyBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIGxhc3RDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHQuaW5kZXggLSAxID49IDApIHtcbiAgICAgICAgbGFzdENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQodC5pbmRleCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIG5leHRDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gICAgICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICAgICAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gMHgyMiAvKiBcIiAqLyAmJiB0WzBdID09PSAnXCInKSB7XG4gICAgICAgIGlmIChsYXN0Q2hhciA+PSAweDMwIC8qIDAgKi8gJiYgbGFzdENoYXIgPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiAxXCJcIiAtIGNvdW50IGZpcnN0IHF1b3RlIGFzIGFuIGluY2hcbiAgICAgICAgICBjYW5DbG9zZSA9IGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xuICAgICAgICAvLyB0cmVhdCB0aGlzIGFzIHRoZSBtaWRkbGUgb2YgdGhlIHdvcmRcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdodG1sX2Jsb2NrJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9odG1sX2Jsb2NrJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCIvLyBHRk0gdGFibGUsIG5vbi1zdGFuZGFyZFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5ibGtJbmRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgcmV0dXJuIHN0YXRlLnNyYy5zdWJzdHIocG9zLCBtYXggLSBwb3MpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkU3BsaXQoc3RyKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBtYXggPSBzdHIubGVuZ3RoLFxuICAgICAgY2gsXG4gICAgICBlc2NhcGVzID0gMCxcbiAgICAgIGxhc3RQb3MgPSAwLFxuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlLFxuICAgICAgbGFzdEJhY2tUaWNrID0gMDtcblxuICBjaCAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBpZiAoY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgICBpZiAoYmFja1RpY2tlZCkge1xuICAgICAgICAvLyBtYWtlIFxcYCBjbG9zZSBjb2RlIHNlcXVlbmNlLCBidXQgbm90IG9wZW4gaXQ7XG4gICAgICAgIC8vIHRoZSByZWFzb24gaXM6IGBcXGAgaXMgY29ycmVjdCBjb2RlIGJsb2NrXG4gICAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVzICUgMiA9PT0gMCkge1xuICAgICAgICBiYWNrVGlja2VkID0gdHJ1ZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N2MvKiB8ICovICYmIChlc2NhcGVzICUgMiA9PT0gMCkgJiYgIWJhY2tUaWNrZWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICBsYXN0UG9zID0gcG9zICsgMTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4NWMvKiBcXCAqLykge1xuICAgICAgZXNjYXBlcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlc2NhcGVzID0gMDtcbiAgICB9XG5cbiAgICBwb3MrKztcblxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiB1bi1jbG9zZWQgYmFja3RpY2ssIGdvIGJhY2sgdG8ganVzdCBhZnRlclxuICAgIC8vIHRoZSBsYXN0IGJhY2t0aWNrLCBidXQgYXMgaWYgaXQgd2FzIGEgbm9ybWFsIGNoYXJhY3RlclxuICAgIGlmIChwb3MgPT09IG1heCAmJiBiYWNrVGlja2VkKSB7XG4gICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICBwb3MgPSBsYXN0QmFja1RpY2sgKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgfVxuXG4gIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsaW5lVGV4dCwgcG9zLCBpLCBuZXh0TGluZSwgY29sdW1ucywgY29sdW1uQ291bnQsIHRva2VuLFxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xuXG4gIC8vIHNob3VsZCBoYXZlIGF0IGxlYXN0IHR3byBsaW5lc1xuICBpZiAoc3RhcnRMaW5lICsgMiA+IGVuZExpbmUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnLCAnLScsICc6JyxcbiAgLy8gYW5kIG5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgYnV0IHNwYWNlcztcbiAgLy8gYmFzaWNhbGx5LCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC9eWy06fF1bLTp8XFxzXSokLyByZWdleHBcblxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgaWYgKHBvcyA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkbid0IGJlIHNtYWxsZXIgdGhhbiB0aGF0ICh0aGUgcmVzdCBvZiB0aGUgcm93cyBjYW4pXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA+IGFsaWducy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgfVxuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfY2xvc2UnLCAndGgnLCAtMSk7XG4gIH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfY2xvc2UnLCAndGhlYWQnLCAtMSk7XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGJvZHlfb3BlbicsICd0Ym9keScsIDEpO1xuICB0b2tlbi5tYXAgPSB0Ym9keUxpbmVzID0gWyBzdGFydExpbmUgKyAyLCAwIF07XG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKCk7XG4gICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKTtcbiAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgICAgfVxuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogJyc7XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX2Nsb3NlJywgJ3RkJywgLTEpO1xuICAgIH1cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB9XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGJvZHlfY2xvc2UnLCAndGJvZHknLCAtMSk7XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGFibGVfY2xvc2UnLCAndGFibGUnLCAtMSk7XG5cbiAgdGFibGVMaW5lc1sxXSA9IHRib2R5TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwiLy8gQ29kZSBibG9jayAoNCBzcGFjZXMgcGFkZGVkKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIG5leHRMaW5lLCBsYXN0LCB0b2tlbjtcblxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPCA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3QgPSBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBsYXN0ID0gbmV4dExpbmU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbGFzdDtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9ibG9jaycsICdjb2RlJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIGxhc3QsIDQgKyBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCIvLyBmZW5jZXMgKGBgYCBsYW5nLCB+fn4gbGFuZylcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLCB0b2tlbiwgbWFya3VwLFxuICAgICAgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDYwIC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgbWVtID0gcG9zO1xuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIGxlbiA9IHBvcyAtIG1lbTtcblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrdXAgPSBzdGF0ZS5zcmMuc2xpY2UobWVtLCBwb3MpO1xuICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGFkanVzdFRhYixcbiAgICAgIGNoLFxuICAgICAgaSxcbiAgICAgIGluaXRpYWwsXG4gICAgICBsLFxuICAgICAgbGFzdExpbmVFbXB0eSxcbiAgICAgIGxpbmVzLFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRCTWFya3MsXG4gICAgICBvbGRCU0NvdW50LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIHdhc091dGRlbnRlZCxcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgIHBvcysrO1xuICAgIGluaXRpYWwrKztcbiAgICBvZmZzZXQrKztcbiAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgaWYgKChzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICBwb3MrKztcbiAgICAgIGluaXRpYWwrKztcbiAgICAgIG9mZnNldCsrO1xuICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgfVxuXG4gIG9sZEJNYXJrcyA9IFsgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIG9sZEJTQ291bnQgPSBbIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICBvbGRTQ291bnQgPSBbIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICBvbGRUU2hpZnQgPSBbIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdibG9ja3F1b3RlJztcbiAgd2FzT3V0ZGVudGVkID0gZmFsc2U7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZzpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vICAgICAgLSAtIC1cbiAgLy8gICAgIGBgYFxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBvdXRkZW50ZWQsIGkuZS4gaXQncyBpbnNpZGUgbGlzdCBpdGVtIGFuZCBpbmRlbnRlZFxuICAgIC8vIGxlc3MgdGhhbiBzYWlkIGxpc3QgaXRlbTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIDEuIGFueXRoaW5nXG4gICAgLy8gICAgPiBjdXJyZW50IGJsb2NrcXVvdGVcbiAgICAvLyAyLiBjaGVja2luZyB0aGlzIGxpbmVcbiAgICAvLyBgYGBcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgd2FzT3V0ZGVudGVkID0gdHJ1ZTtcblxuICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgLy8gQ2FzZSAxOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGlzIGxpbmUgaXMgZW1wdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLyAmJiAhd2FzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuXG4gICAgICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgICAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAvLyBRdWlyayB0byBlbmZvcmNlIFwiaGFyZCB0ZXJtaW5hdGlvbiBtb2RlXCIgZm9yIHBhcmFncmFwaHM7XG4gICAgICAvLyBub3JtYWxseSBpZiB5b3UgY2FsbCBgdG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpYCxcbiAgICAgIC8vIHBhcmFncmFwaHMgd2lsbCBsb29rIGJlbG93IG5leHRMaW5lIGZvciBwYXJhZ3JhcGggY29udGludWF0aW9uLFxuICAgICAgLy8gYnV0IGlmIGJsb2NrcXVvdGUgaXMgdGVybWluYXRlZCBieSBhbm90aGVyIHRhZywgdGhleSBzaG91bGRuJ3RcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBuZXh0TGluZTtcblxuICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0ZS5ibGtJbmRlbnQgd2FzIG5vbi16ZXJvLCB3ZSBub3cgc2V0IGl0IHRvIHplcm8sXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGFsbCBvZmZzZXRzIHRvIGFwcGVhciBhc1xuICAgICAgICAvLyBpZiBpbmRlbnQgd2Fzbid0IGNoYW5nZWRcbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIi8vIEhvcml6b250YWwgcnVsZVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBjbnQsIGNoLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgLy8gQ2hlY2sgaHIgbWFya2VyXG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4NUYvKiBfICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbWFya2VycyBjYW4gYmUgbWl4ZWQgd2l0aCBzcGFjZXMsIGJ1dCB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3QgMyBvZiB0aGVtXG5cbiAgY250ID0gMTtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgIGlmIChjaCAhPT0gbWFya2VyICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoY2ggPT09IG1hcmtlcikgeyBjbnQrKzsgfVxuICB9XG5cbiAgaWYgKGNudCA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hyJywgJ2hyJywgMCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLm1hcmt1cCA9IEFycmF5KGNudCArIDEpLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkTEluZGVudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4ICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIHRoaXMgY2FzZVxuICAgICAgLy8gKGxpc3QgaXRlbSBpcyBlbXB0eSwgbGlzdCB0ZXJtaW5hdGVzIGJlZm9yZSBcImZvb1wiKTpcbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICAvLyAgIC1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgZm9vXG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgc3RhdGUubGluZSA9IE1hdGgubWluKHN0YXRlLmxpbmUgKyAyLCBlbmRMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZExJbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvL1xuICAgIC8vIFRyeSB0byBjaGVjayBpZiBsaXN0IGlzIHRlcm1pbmF0ZWQgb3IgY29udGludWVkLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIGxpc3QgaGFzIGFub3RoZXIgdHlwZVxuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VyQ2hhckNvZGUgIT09IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIEZpbmFsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3RfY2xvc2UnLCAndWwnLCAtMSk7XG4gIH1cbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWZlcmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBkZXN0RW5kUG9zLFxuICAgICAgZGVzdEVuZExpbmVObyxcbiAgICAgIGVuZExpbmUsXG4gICAgICBocmVmLFxuICAgICAgaSxcbiAgICAgIGwsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIHJlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdGl0bGUsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbXBsZSBjaGVjayB0byBxdWlja2x5IGludGVycnVwdCBzY2FuIG9uIFtsaW5rXSh1cmwpIGF0IHRoZSBzdGFydCBvZiBsaW5lLlxuICAvLyBDYW4gYmUgdXNlZnVsIG9uIHByYWN0aWNlOiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzU0XG4gIHdoaWxlICgrK3BvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVEIC8qIF0gKi8gJiZcbiAgICAgICAgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgaWYgKHBvcyArIDEgPT09IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdyZWZlcmVuY2UnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdyZWZlcmVuY2UnO1xuXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgc3RyID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuICBtYXggPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAocG9zID0gMTsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGFiZWxFbmQgPSBwb3M7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBBIC8qIFxcbiAqLykge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDIC8qIFxcICovKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcbiAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgIF5eXl5eXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KTtcbiAgaWYgKCFyZXMub2spIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHJlcy5wb3M7XG4gIGxpbmVzICs9IHJlcy5saW5lcztcblxuICAvLyBzYXZlIGN1cnNvciBzdGF0ZSwgd2UgY291bGQgcmVxdWlyZSB0byByb2xsYmFjayBsYXRlclxuICBkZXN0RW5kUG9zID0gcG9zO1xuICBkZXN0RW5kTGluZU5vID0gbGluZXM7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgc3RhcnQgPSBwb3M7XG4gIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgdGl0bGUgPSByZXMuc3RyO1xuICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgbGluZXMgKz0gcmVzLmxpbmVzO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gJyc7XG4gICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gIH1cblxuICAvLyBza2lwIHRyYWlsaW5nIHNwYWNlcyB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRpdGxlLFxuICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgdmFsaWQgcmVmZXJlbmNlIGlmIHdlIHJvbGwgYmFja1xuICAgICAgdGl0bGUgPSAnJztcbiAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIuc2xpY2UoMSwgbGFiZWxFbmQpKTtcbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIENvbW1vbk1hcmsgMC4yMCBkaXNhbGxvd3MgZW1wdHkgbGFiZWxzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUmVmZXJlbmNlIGNhbiBub3QgdGVybWluYXRlIGFueXRoaW5nLiBUaGlzIGNoZWNrIGlzIGZvciBzYWZldHkgb25seS5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgaWYqL1xuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGU6IHRpdGxlLCBocmVmOiBocmVmIH07XG4gIH1cblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgbGluZXMgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmICFpc1NwYWNlKGNoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIExldCdzIGN1dCB0YWlscyBsaWtlICcgICAgIyMjICAnIGZyb20gdGhlIGVuZCBvZiBzdHJpbmdcblxuICBtYXggPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgsIHBvcyk7XG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCIvLyBsaGVhZGluZyAoLS0tLCA9PT0pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIHBvcywgbWF4LCBsZXZlbCwgbWFya2VyLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7IC8vIHVzZSBwYXJhZ3JhcGggdG8gbWF0Y2ggdGVybWluYXRvclJ1bGVzXG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vXG4gICAgLy8gQ2hlY2sgZm9yIHVuZGVybGluZSBpbiBzZXRleHQgaGVhZGVyXG4gICAgLy9cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4MkQvKiAtICovIHx8IG1hcmtlciA9PT0gMHgzRC8qID0gKi8pIHtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgICAgICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAgICAgICBsZXZlbCA9IChtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKCFsZXZlbCkge1xuICAgIC8vIERpZG4ndCBmaW5kIHZhbGlkIHVuZGVybGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgLSAxIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuLy8gQW4gYXJyYXkgb2Ygb3BlbmluZyBhbmQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHNlcXVlbmNlcyBmb3IgaHRtbCB0YWdzLFxuLy8gbGFzdCBhcmd1bWVudCBkZWZpbmVzIHdoZXRoZXIgaXQgY2FuIHRlcm1pbmF0ZSBhIHBhcmFncmFwaCBvciBub3Rcbi8vXG52YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gIFsgL148KHNjcmlwdHxwcmV8c3R5bGUpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlKT4vaSwgdHJ1ZSBdLFxuICBbIC9ePCEtLS8sICAgICAgICAvLS0+LywgICB0cnVlIF0sXG4gIFsgL148XFw/LywgICAgICAgICAvXFw/Pi8sICAgdHJ1ZSBdLFxuICBbIC9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlIF0sXG4gIFsgL148IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cCgnXjwvPygnICsgYmxvY2tfbmFtZXMuam9pbignfCcpICsgJykoPz0oXFxcXHN8Lz8+fCQpKScsICdpJyksIC9eJC8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlIF1cbl07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgaSwgbmV4dExpbmUsIHRva2VuLCBsaW5lVGV4dCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gdHJ1ZSBpZiB0aGlzIHNlcXVlbmNlIGNhbiBiZSBhIHRlcm1pbmF0b3IsIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBIVE1MX1NFUVVFTkNFU1tpXVsyXTtcbiAgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBJZiB3ZSBhcmUgaGVyZSAtIHdlIGRldGVjdGVkIEhUTUwgYmxvY2suXG4gIC8vIExldCdzIHJvbGwgZG93biB0aWxsIGJsb2NrIGVuZC5cbiAgaWYgKCFIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKzsgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgbmV4dExpbmUgXTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwiLy8gTGlzdCBvZiB2YWxpZCBodG1sIGJsb2NrcyBuYW1lcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xuLy8gaHR0cDovL2pnbS5naXRodWIuaW8vQ29tbW9uTWFyay9zcGVjLmh0bWwjaHRtbC1ibG9ja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jhc2UnLFxuICAnYmFzZWZvbnQnLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2NhcHRpb24nLFxuICAnY2VudGVyJyxcbiAgJ2NvbCcsXG4gICdjb2xncm91cCcsXG4gICdkZCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RpYWxvZycsXG4gICdkaXInLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2ZyYW1lJyxcbiAgJ2ZyYW1lc2V0JyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hyJyxcbiAgJ2h0bWwnLFxuICAnaWZyYW1lJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdsaW5rJyxcbiAgJ21haW4nLFxuICAnbWVudScsXG4gICdtZW51aXRlbScsXG4gICdtZXRhJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdwcmUnLFxuICAnc2VjdGlvbicsXG4gICdzb3VyY2UnLFxuICAndGl0bGUnLFxuICAnc3VtbWFyeScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aXRsZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd1bCdcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIi8vIFBhcmFncmFwaFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3RhdGUsIHN0YXJ0TGluZS8qLCBlbmRMaW5lKi8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyksXG4gICAgICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnO1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9vcGVuJywgJ3AnLCAxKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwiLy8gUGFyc2VyIHN0YXRlIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBTdGF0ZUJsb2NrKHNyYywgbWQsIGVudiwgdG9rZW5zKSB7XG4gIHZhciBjaCwgcywgc3RhcnQsIHBvcywgbGVuLCBpbmRlbnQsIG9mZnNldCwgaW5kZW50X2ZvdW5kO1xuXG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG4gIHRoaXMubWQgICAgID0gbWQ7XG5cbiAgdGhpcy5lbnYgPSBlbnY7XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXG4gIHRoaXMuYk1hcmtzID0gW107ICAvLyBsaW5lIGJlZ2luIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy5lTWFya3MgPSBbXTsgIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIG9mZnNldHMgb2YgdGhlIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJzICh0YWJzIG5vdCBleHBhbmRlZClcbiAgdGhpcy5zQ291bnQgPSBbXTsgIC8vIGluZGVudHMgZm9yIGVhY2ggbGluZSAodGFicyBleHBhbmRlZClcblxuICAvLyBBbiBhbW91bnQgb2YgdmlydHVhbCBzcGFjZXMgKHRhYnMgZXhwYW5kZWQpIGJldHdlZW4gYmVnaW5uaW5nXG4gIC8vIG9mIGVhY2ggbGluZSAoYk1hcmtzKSBhbmQgcmVhbCBiZWdpbm5pbmcgb2YgdGhhdCBsaW5lLlxuICAvL1xuICAvLyBJdCBleGlzdHMgb25seSBhcyBhIGhhY2sgYmVjYXVzZSBibG9ja3F1b3RlcyBvdmVycmlkZSBiTWFya3NcbiAgLy8gbG9zaW5nIGluZm9ybWF0aW9uIGluIHRoZSBwcm9jZXNzLlxuICAvL1xuICAvLyBJdCdzIHVzZWQgb25seSB3aGVuIGV4cGFuZGluZyB0YWJzLCB5b3UgY2FuIHRoaW5rIGFib3V0IGl0IGFzXG4gIC8vIGFuIGluaXRpYWwgdGFiIGxlbmd0aCwgZS5nLiBic0NvdW50PTIxIGFwcGxpZWQgdG8gc3RyaW5nIGBcXHQxMjNgXG4gIC8vIG1lYW5zIGZpcnN0IHRhYiBzaG91bGQgYmUgZXhwYW5kZWQgdG8gNC0yMSU0ID09PSAzIHNwYWNlcy5cbiAgLy9cbiAgdGhpcy5ic0NvdW50ID0gW107XG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHdlIGFyZSBpbiBsaXN0KVxuICB0aGlzLmxpbmUgICAgICAgPSAwOyAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxuICB0aGlzLnRpZ2h0ICAgICAgPSBmYWxzZTsgIC8vIGxvb3NlL3RpZ2h0IG1vZGUgZm9yIGxpc3RzXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICAvLyBjYW4gYmUgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdyb290JywgJ3BhcmFncmFwaCcgb3IgJ3JlZmVyZW5jZSdcbiAgLy8gdXNlZCBpbiBsaXN0cyB0byBkZXRlcm1pbmUgaWYgdGhleSBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGhcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnO1xuXG4gIHRoaXMubGV2ZWwgPSAwO1xuXG4gIC8vIHJlbmRlcmVyXG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgLy8gQ3JlYXRlIGNhY2hlc1xuICAvLyBHZW5lcmF0ZSBtYXJrZXJzLlxuICBzID0gdGhpcy5zcmM7XG4gIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSBvZmZzZXQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgIGNoID0gcy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGluZGVudCsrO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBIHx8IHBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgaWYgKGNoICE9PSAweDBBKSB7IHBvcysrOyB9XG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goaW5kZW50KTtcbiAgICAgIHRoaXMuc0NvdW50LnB1c2gob2Zmc2V0KTtcbiAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggZmFrZSBlbnRyeSB0byBzaW1wbGlmeSBjYWNoZSBib3VuZHMgY2hlY2tzXG4gIHRoaXMuYk1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy50U2hpZnQucHVzaCgwKTtcbiAgdGhpcy5zQ291bnQucHVzaCgwKTtcbiAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgdGhpcy5saW5lTWF4ID0gdGhpcy5iTWFya3MubGVuZ3RoIC0gMTsgLy8gZG9uJ3QgY291bnQgbGFzdCBmYWtlIGxpbmVcbn1cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdG9rZW4uYmxvY2sgPSB0cnVlO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlcklubGluZVxuICpcbiAqIFRva2VuaXplcyBwYXJhZ3JhcGggY29udGVudC5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQYXJzZXIgcnVsZXNcblxudmFyIF9ydWxlcyA9IFtcbiAgWyAndGV4dCcsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dCcpIF0sXG4gIFsgJ25ld2xpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL25ld2xpbmUnKSBdLFxuICBbICdlc2NhcGUnLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lc2NhcGUnKSBdLFxuICBbICdiYWNrdGlja3MnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWNrdGlja3MnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykudG9rZW5pemUgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS50b2tlbml6ZSBdLFxuICBbICdsaW5rJywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9saW5rJykgXSxcbiAgWyAnaW1hZ2UnLCAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaW1hZ2UnKSBdLFxuICBbICdhdXRvbGluaycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9hdXRvbGluaycpIF0sXG4gIFsgJ2h0bWxfaW5saW5lJywgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lJykgXSxcbiAgWyAnZW50aXR5JywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW50aXR5JykgXVxuXTtcblxudmFyIF9ydWxlczIgPSBbXG4gIFsgJ2JhbGFuY2VfcGFpcnMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykucG9zdFByb2Nlc3MgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS5wb3N0UHJvY2VzcyBdLFxuICBbICd0ZXh0X2NvbGxhcHNlJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJJbmxpbmUoKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VySW5saW5lKCkge1xuICB2YXIgaTtcblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGlubGluZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyMiAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIFNlY29uZCBydWxlciB1c2VkIGZvciBwb3N0LXByb2Nlc3NpbmdcbiAgICogKGUuZy4gaW4gZW1waGFzaXMtbGlrZSBydWxlcykuXG4gICAqKi9cbiAgdGhpcy5ydWxlcjIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzMi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIyLnB1c2goX3J1bGVzMltpXVswXSwgX3J1bGVzMltpXVsxXSk7XG4gIH1cbn1cblxuXG4vLyBTa2lwIHNpbmdsZSB0b2tlbiBieSBydW5uaW5nIGFsbCBydWxlcyBpbiB2YWxpZGF0aW9uIG1vZGU7XG4vLyByZXR1cm5zIGB0cnVlYCBpZiBhbnkgcnVsZSByZXBvcnRlZCBzdWNjZXNzXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5za2lwVG9rZW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLCBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZyxcbiAgICAgIGNhY2hlID0gc3RhdGUuY2FjaGU7XG5cblxuICBpZiAodHlwZW9mIGNhY2hlW3Bvc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUucG9zID0gY2FjaGVbcG9zXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBJbmNyZW1lbnQgc3RhdGUubGV2ZWwgYW5kIGRlY3JlbWVudCBpdCBsYXRlciB0byBsaW1pdCByZWN1cnNpb24uXG4gICAgICAvLyBJdCdzIGhhcm1sZXNzIHRvIGRvIGhlcmUsIGJlY2F1c2Ugbm8gdG9rZW5zIGFyZSBjcmVhdGVkLiBCdXQgaWRlYWxseSxcbiAgICAgIC8vIHdlJ2QgbmVlZCBhIHNlcGFyYXRlIHByaXZhdGUgc3RhdGUgdmFyaWFibGUgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgIC8vXG4gICAgICBzdGF0ZS5sZXZlbCsrO1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5sZXZlbC0tO1xuXG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9vIG11Y2ggbmVzdGluZywganVzdCBza2lwIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBjYXVzZSBsaW5rcyB0byBiZWhhdmUgaW5jb3JyZWN0bHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlLFxuICAgIC8vICAgICAgIHdoZW4gYW4gYW1vdW50IG9mIGBbYCBpcyBleGFjdGx5IGVxdWFsIHRvIGBtYXhOZXN0aW5nICsgMWA6XG4gICAgLy9cbiAgICAvLyAgICAgICBbW1tbW1tbW1tbW1tbW1tbW1tbW1tmb29dKClcbiAgICAvL1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdvcmthcm91bmQgd2hlbiBDTSBzdGFuZGFyZCB3aWxsIGFsbG93IG5lc3RlZCBsaW5rc1xuICAgIC8vICAgICAgICh3ZSBjYW4gcmVwbGFjZSBpdCBieSBwcmV2ZW50aW5nIGxpbmtzIGZyb20gYmVpbmcgcGFyc2VkIGluXG4gICAgLy8gICAgICAgdmFsaWRhdGlvbiBtb2RlKVxuICAgIC8vXG4gICAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4O1xuICB9XG5cbiAgaWYgKCFvaykgeyBzdGF0ZS5wb3MrKzsgfVxuICBjYWNoZVtwb3NdID0gc3RhdGUucG9zO1xufTtcblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgZW5kID0gc3RhdGUucG9zTWF4LFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgZW5kKSB7XG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5wb3NgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2spIHtcbiAgICAgIGlmIChzdGF0ZS5wb3MgPj0gZW5kKSB7IGJyZWFrOyB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1tzdGF0ZS5wb3MrK107XG4gIH1cblxuICBpZiAoc3RhdGUucGVuZGluZykge1xuICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJJbmxpbmUucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggaW5saW5lIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBpLCBydWxlcywgbGVuO1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzdHIsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyMi5nZXRSdWxlcygnJyk7XG4gIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VySW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXdsaW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBtYXggPSBzdGF0ZS5wZW5kaW5nLmxlbmd0aCAtIDE7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyAnICBcXG4nIC0+IGhhcmRicmVha1xuICAvLyBMb29rdXAgaW4gcGVuZGluZyBjaGFycyBpcyBiYWQgcHJhY3RpY2UhIERvbid0IGNvcHkgdG8gb3RoZXIgcnVsZXMhXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcbiAgLy8gY29udmVydGlvbiB0byBmbGF0IG1vZGUuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMHgyMCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwiLy8gUHJvY2VzcyBlc2NhcGVkIGNoYXJzIGFuZCBoYXJkYnJlYWtzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG52YXIgRVNDQVBFRCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxuXG4nXFxcXCFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi0nXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHsgRVNDQVBFRFtjaC5jaGFyQ29kZUF0KDApXSA9IDE7IH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qy8qIFxcICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcysrO1xuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggPCAyNTYgJiYgRVNDQVBFRFtjaF0gIT09IDApIHtcbiAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107IH1cbiAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgICAvLyBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZXMgZnJvbSBuZXh0IGxpbmVcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICdcXFxcJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hcmtlcjtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjsgfVxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcywgdHJ1ZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBtaWdodCBoYXZlIGZvdW5kIGEgdmFsaWQgc2hvcnRjdXQgbGluaywgZGlzYWJsZSByZWZlcmVuY2UgcGFyc2luZ1xuICAgIHBhcnNlUmVmZXJlbmNlID0gZmFsc2U7XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCIvLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgY29udGVudCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVmLFxuICAgICAgcmVzLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UoXG4gICAgICBjb250ZW50LFxuICAgICAgc3RhdGUubWQsXG4gICAgICBzdGF0ZS5lbnYsXG4gICAgICB0b2tlbnMgPSBbXVxuICAgICk7XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xuICAgIHRva2VuLmF0dHJzICAgID0gYXR0cnMgPSBbIFsgJ3NyYycsIGhyZWYgXSwgWyAnYWx0JywgJycgXSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gdG9rZW5zO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKEFVVE9MSU5LX1JFLnRlc3QodGFpbCkpIHtcbiAgICBsaW5rTWF0Y2ggPSB0YWlsLm1hdGNoKEFVVE9MSU5LX1JFKTtcblxuICAgIHVybCA9IGxpbmtNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFTUFJTF9SRS50ZXN0KHRhaWwpKSB7XG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCIvLyBQcm9jZXNzIGh0bWwgZW50aXR5IC0gJiMxMjM7LCAmI3hBRjssICZxdW90OywgLi4uXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0aWVzICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL2VudGl0aWVzJyk7XG52YXIgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5oYXM7XG52YXIgaXNWYWxpZEVudGl0eUNvZGUgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1ZhbGlkRW50aXR5Q29kZTtcbnZhciBmcm9tQ29kZVBvaW50ICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmZyb21Db2RlUG9pbnQ7XG5cblxudmFyIERJR0lUQUxfUkUgPSAvXiYjKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKTsvaTtcbnZhciBOQU1FRF9SRSAgID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBjb2RlLCBtYXRjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjYvKiAmICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAxIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMyAvKiAjICovKSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgY29kZSA9IG1hdGNoWzFdWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gaXNWYWxpZEVudGl0eUNvZGUoY29kZSkgPyBmcm9tQ29kZVBvaW50KGNvZGUpIDogZnJvbUNvZGVQb2ludCgweEZGRkQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKE5BTUVEX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoaGFzKGVudGl0aWVzLCBtYXRjaFsxXSkpIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IGVudGl0aWVzW21hdGNoWzFdXTsgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICcmJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsYXN0RGVsaW0sIGN1cnJEZWxpbSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgbGFzdERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmICghbGFzdERlbGltLmNsb3NlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBqID0gaSAtIGxhc3REZWxpbS5qdW1wIC0gMTtcblxuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIGN1cnJEZWxpbSA9IGRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChjdXJyRGVsaW0ub3BlbiAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5tYXJrZXIgPT09IGxhc3REZWxpbS5tYXJrZXIgJiZcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kIDwgMCAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5sZXZlbCA9PT0gbGFzdERlbGltLmxldmVsKSB7XG5cbiAgICAgICAgLy8gdHlwZW9mcyBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBwbHVnaW5zXG4gICAgICAgIHZhciBvZGRfbWF0Y2ggPSAoY3VyckRlbGltLmNsb3NlIHx8IGxhc3REZWxpbS5vcGVuKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJEZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdERlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyRGVsaW0ubGVuZ3RoICsgbGFzdERlbGltLmxlbmd0aCkgJSAzID09PSAwO1xuXG4gICAgICAgIGlmICghb2RkX21hdGNoKSB7XG4gICAgICAgICAgbGFzdERlbGltLmp1bXAgPSBpIC0gajtcbiAgICAgICAgICBsYXN0RGVsaW0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgID0gaTtcbiAgICAgICAgICBjdXJyRGVsaW0uanVtcCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiAtPSBjdXJyRGVsaW0uanVtcCArIDE7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgaW50byBvbmUsIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRfY29sbGFwc2Uoc3RhdGUpIHtcbiAgdmFyIGN1cnIsIGxhc3QsXG4gICAgICBsZXZlbCA9IDAsXG4gICAgICB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBtYXggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGZvciAoY3VyciA9IGxhc3QgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICAvLyByZS1jYWxjdWxhdGUgbGV2ZWxzXG4gICAgbGV2ZWwgKz0gdG9rZW5zW2N1cnJdLm5lc3Rpbmc7XG4gICAgdG9rZW5zW2N1cnJdLmxldmVsID0gbGV2ZWw7XG5cbiAgICBpZiAodG9rZW5zW2N1cnJdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBjdXJyICsgMSA8IG1heCAmJlxuICAgICAgICB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuXG4gICAgICAvLyBjb2xsYXBzZSB0d28gYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyICE9PSBsYXN0KSB7IHRva2Vuc1tsYXN0XSA9IHRva2Vuc1tjdXJyXTsgfVxuXG4gICAgICBsYXN0Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICB0b2tlbnMubGVuZ3RoID0gbGFzdDtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG5cbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG5cbiAgdGhpcy5jYWNoZSA9IHt9OyAgICAgICAgLy8gU3RvcmVzIHsgc3RhcnQ6IGVuZCB9IHBhaXJzLiBVc2VmdWwgZm9yIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cblxuICB0aGlzLmRlbGltaXRlcnMgPSBbXTsgICAvLyBFbXBoYXNpcy1saWtlIGRlbGltaXRlcnNcbn1cblxuXG4vLyBGbHVzaCBwZW5kaW5nIHRleHRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbigndGV4dCcsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHRoaXMucGVuZGluZztcbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vLyBJZiBwZW5kaW5nIHRleHQgZXhpc3RzIC0gZmx1c2ggaXQgYXMgdGV4dCB0b2tlblxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xuICB9XG5cbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgICAgICAgPSBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57MiwzfVthLXpBLVowLTklL118JyArIC8vIGdpdGh1YiBoYXMgLi4uIGluIGNvbW1pdCByYW5nZSBsaW5rcy4gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgLy8gYWxsb3cgYCwsLGAgaW4gcGF0aHNcbiAgICAgICAgICAnXFxcXCEoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdKS58JyArXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XSkuJyArXG4gICAgICAgICcpKycgK1xuICAgICAgJ3xcXFxcLycgK1xuICAgICcpPyc7XG5cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10rJztcblxuICByZS5zcmNfeG4gPVxuXG4gICAgJ3huLS1bYS16MC05XFxcXC1dezEsNTl9JztcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19kb21haW4gPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAgICd8JyArXG4gICAgICAvLyBkb24ndCBhbGxvdyBgLS1gIGluIGRvbWFpbiBuYW1lcywgYmVjYXVzZTpcbiAgICAgIC8vIC0gdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBtYXJrZG93biAmbWRhc2g7IC8gJm5kYXNoO1xuICAgICAgLy8gLSBub2JvZHkgdXNlIHRob3NlIGFueXdheVxuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotKD8hLSl8JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICcpJztcblxuICByZS5zcmNfaG9zdCA9XG5cbiAgICAnKD86JyArXG4gICAgLy8gRG9uJ3QgbmVlZCBJUCBjaGVjaywgYmVjYXVzZSBkaWdpdHMgYXJlIGFscmVhZHkgYWxsb3dlZCBpbiBub3JtYWwgZG9tYWluIG5hbWVzXG4gICAgLy8gICBzcmNfaXA0ICtcbiAgICAvLyAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikqJyArIHJlLnNyY19kb21haW4vKl9yb290Ki8gKyAnKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9mdXp6eSA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfaXA0ICtcbiAgICAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgPVxuXG4gICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknO1xuXG4gIHJlLnNyY19ob3N0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcnVsZXNcblxuICAvLyBSdWRlIHRlc3QgZnV6enkgbGlua3MgYnkgaG9zdCwgZm9yIHF1aWNrIGRlbnlcbiAgcmUudHBsX2hvc3RfZnV6enlfdGVzdCA9XG5cbiAgICAnbG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OicgKyByZS5zcmNfWlBDYyArICd8PnwkKSknO1xuXG4gIHJlLnRwbF9lbWFpbF9mdXp6eSA9XG5cbiAgICAgICcoXnwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcXFxcKHwnICsgcmUuc3JjX1pDYyArICcpKCcgKyByZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCArICcpJztcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZXR1cm4gcmU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIi8vIG1hcmtkb3duLWl0IGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAxMDAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCIvLyBcIlplcm9cIiBwcmVzZXQsIHdpdGggbm90aGluZyBlbmFibGVkLiBVc2VmdWwgZm9yIG1hbnVhbCBjb25maWd1cmluZyBvZiBzaW1wbGVcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanMiLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIid1c2Ugc3RyaWN0J1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxudmFyIHRhZ0V4cHIgPSAvXjwhLS0gP1xceyg/OihbYS16MC05XSspKFxcXlswLTldKik/OiA/KT8oLiopXFx9ID8tLT5cXG4/JC9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzIChtZCkge1xuICBtZC5jb3JlLnJ1bGVyLnB1c2goJ2N1cmx5X2F0dHJpYnV0ZXMnLCBjdXJseUF0dHJzKVxufVxuXG4vKlxuICogTGlzdCBvZiB0YWcgLT4gdG9rZW4gdHlwZSBtYXBwaW5ncy4gRWcsIGA8bGk+YCBpcyBgbGlzdF9pdGVtX29wZW5gLlxuICovXG5cbnZhciBvcGVuaW5nID0ge1xuICBsaTogWydsaXN0X2l0ZW0nXSxcbiAgdWw6IFsnYnVsbGV0X2xpc3QnXSxcbiAgcDogWydwYXJhZ3JhcGgnXSxcbiAgb2w6IFsnb3JkZXJlZF9saXN0J10sXG4gIGJsb2NrcXVvdGU6IFsnYmxvY2txdW90ZSddLFxuICBoMTogWydoZWFkaW5nJ10sXG4gIGgyOiBbJ2hlYWRpbmcnXSxcbiAgaDM6IFsnaGVhZGluZyddLFxuICBoNDogWydoZWFkaW5nJ10sXG4gIGg1OiBbJ2hlYWRpbmcnXSxcbiAgaDY6IFsnaGVhZGluZyddLFxuICBhOiBbJ2xpbmsnXSxcbiAgY29kZTogWydjb2RlX2lubGluZScsICdjb2RlX2Jsb2NrJywgJ2ZlbmNlJ11cbn1cblxudmFyIHNlbGZDbG9zaW5nID0ge1xuICBocjogdHJ1ZSxcbiAgaW1hZ2U6IHRydWVcbn1cblxuLyoqXG4gKiAuLi5cbiAqL1xuXG5mdW5jdGlvbiBjdXJseUF0dHJzIChzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zXG4gIHZhciBvbWlzc2lvbnMgPSBbXVxuICB2YXIgcGFyZW50LCBtXG4gIHZhciBzdGFjayA9IHsgbGVuOiAwLCBjb250ZW50czogW10sIHR5cGVzOiB7fSB9XG5cbiAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuLCBpKSB7XG4gICAgLy8gU2F2ZSBicmVhZGNydW1icyBzbyBodG1sX2Jsb2NrIHdpbGwgcGljayBpdCB1cFxuICAgIGlmIChpc09wZW5lcih0b2tlbi50eXBlKSB8fCBzZWxmQ2xvc2luZ1t0b2tlbi50eXBlXSkge1xuICAgICAgc3B1c2goc3RhY2ssIHRva2VuKVxuICAgIH1cblxuICAgIC8vIFwiIyBIZWxsb1xcbjwhLS17LmNsYXNzbmFtZX0tLT5cIlxuICAgIC8vIC4uLnNlcXVlbmNlIG9mIFtoZWFkaW5nX29wZW4sIGlubGluZSwgaGVhZGluZ19jbG9zZSwgaHRtbF9ibG9ja11cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2h0bWxfYmxvY2snKSB7XG4gICAgICBtID0gdG9rZW4uY29udGVudC5tYXRjaCh0YWdFeHByKVxuICAgICAgaWYgKCFtKSByZXR1cm5cblxuICAgICAgcGFyZW50ID0gZmluZFBhcmVudChzdGFjaywgbVsxXSwgbVsyXSlcbiAgICAgIGlmIChwYXJlbnQgJiYgYXBwbHlUb1Rva2VuKHBhcmVudCwgbVszXSkpIHtcbiAgICAgICAgb21pc3Npb25zLnVuc2hpZnQoaSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBcIiMgSGVsbG8gPCEtLXsuY2xhc3NuYW1lfSAtLT5cIlxuICAgIC8vIHsgdHlwZTogJ2lubGluZScsIGNoaWxkcmVuOiB7IC4uLiwgJzwhLS17Li4ufS0tPicgfSB9XG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBjdXJseUlubGluZSh0b2tlbi5jaGlsZHJlbiwgc3RhY2spXG4gICAgfVxuICB9KVxuXG4gIC8vIFJlbW92ZSA8IS0tLi4uLS0+IGh0bWxfYmxvY2sgdG9rZW5zXG4gIG9taXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIHRva2Vucy5zcGxpY2UoaWR4LCAxKSB9KVxufVxuXG4vKipcbiAqIEludGVybmFsOiBjaGVja3MgaW4gYSB0b2tlbiB0eXBlIGlzIGEgYmxvY2sgb3BlbmVyXG4gKi9cblxuZnVuY3Rpb24gaXNPcGVuZXIgKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUubWF0Y2goL18ob3BlbnxzdGFydCkkLykgfHxcbiAgICB0eXBlID09PSAnZmVuY2UnIHx8IHR5cGUgPT09ICdjb2RlX2Jsb2NrJ1xufVxuXG4vKipcbiAqIEludGVybmFsOiBSdW4gdGhyb3VnaCBpbmxpbmUgYW5kIHN0dWZmXG4gKi9cblxuZnVuY3Rpb24gY3VybHlJbmxpbmUgKGNoaWxkcmVuLCBzdGFjaykge1xuICB2YXIgbGFzdFRleHQsIG0sIHBhcmVudFxuXG4gIC8vIEtlZXAgYSBsaXN0IG9mIHN1Yi10b2tlbnMgdG8gYmUgcmVtb3ZlZFxuICB2YXIgb21pc3Npb25zID0gW11cblxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgIGlmIChpc09wZW5lcihjaGlsZC50eXBlKSB8fFxuICAgICAgc2VsZkNsb3NpbmdbY2hpbGQudHlwZV0gfHxcbiAgICAgIGNoaWxkLnR5cGUgPT09ICdjb2RlX2lubGluZScpIHtcbiAgICAgIHNwdXNoKHN0YWNrLCBjaGlsZClcbiAgICB9XG5cbiAgICAvLyBEZWNvcmF0ZSB0YWdzIGFyZSBmb3VuZFxuICAgIGlmIChtID0gY2hpbGQuY29udGVudC5tYXRjaCh0YWdFeHByKSkge1xuICAgICAgdmFyIHRhZyA9IG1bMV1cbiAgICAgIHZhciBkZXB0aCA9IG1bMl1cbiAgICAgIHZhciBhdHRycyA9IG1bM11cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBjb21tZW50LCB0aGVuIHJlbW92ZSB0aGUgZXh0cmEgc3BhY2VcbiAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnQoc3RhY2ssIHRhZywgZGVwdGgpXG4gICAgICBpZiAocGFyZW50ICYmIGFwcGx5VG9Ub2tlbihwYXJlbnQsIGF0dHJzKSkge1xuICAgICAgICBvbWlzc2lvbnMudW5zaGlmdChpKVxuICAgICAgICBpZiAobGFzdFRleHQpIHRyaW1SaWdodChsYXN0VGV4dCwgJ2NvbnRlbnQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZC50eXBlID09PSAndGV4dCcpIGxhc3RUZXh0ID0gY2hpbGRcbiAgfSlcblxuICAvLyBSZW1vdmUgdGhlbSBpbiBhIHNlcGFyYXRlIHN0ZXAgc28gd2UgZG9uJ3RcbiAgb21pc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpXG4gIH0pXG59XG5cbi8qKlxuICogUHJpdmF0ZTogZ2l2ZW4gYSBsaXN0IG9mIHRva2VucyBgbGlzdGAgYW5kIGBsYXN0UGFyZW50YCwgZmluZCB0aGUgb25lIHRoYXRcbiAqIG1hdGNoZXMgYHRhZ2AuXG4gKi9cblxuZnVuY3Rpb24gZmluZFBhcmVudCAoc3RhY2ssIHRhZywgZGVwdGgpIHtcbiAgaWYgKCF0YWcpIHJldHVybiBzdGFjay5sYXN0XG5cbiAgaWYgKGRlcHRoID09PSAnXicpIHtcbiAgICBkZXB0aCA9IDFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVwdGggPT09ICdzdHJpbmcnKSB7IC8qICdeMicgKi9cbiAgICBkZXB0aCA9ICtkZXB0aC5zdWJzdHIoMSlcbiAgfSBlbHNlIHtcbiAgICBkZXB0aCA9IDBcbiAgfVxuXG4gIHZhciB0YXJnZXRzID0gb3BlbmluZ1t0YWcudG9Mb3dlckNhc2UoKV0gfHwgW3RhZy50b0xvd2VyQ2FzZSgpXVxuXG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHN0YWNrLnR5cGVzW3RhcmdldF1cbiAgfSlcblxuICB2YXIgbGlzdCA9IHN0YWNrLnR5cGVzW3RhcmdldF1cbiAgaWYgKCFsaXN0KSByZXR1cm4gLy8gQ2FuJ3QgZmluZCB0YWcgYHRhZ2BcblxuICByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDEgLSBkZXB0aF1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiB0cmltIHRoZSByaWdodFxuICovXG5cbmZ1bmN0aW9uIHRyaW1SaWdodCAob2JqLCBhdHRyKSB7XG4gIG9ialthdHRyXSA9IG9ialthdHRyXS5yZXBsYWNlKC9cXHMqJC8sICcnKVxufVxuXG4vKipcbiAqIFByaXZhdGU6IGFwcGx5IHRhZyB0byB0b2tlblxuICpcbiAqICAgICBhcHBseVRvVG9rZW4odG9rZW4sICcuY2xhc3NuYW1lJylcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRvVG9rZW4gKHRva2VuLCBhdHRycykge1xuICB2YXIgbVxuICB2YXIgdG9kbyA9IFtdXG5cbiAgd2hpbGUgKGF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKlxcLihbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyAnY2xhc3MnLCBtWzFdLCB7IGFwcGVuZDogdHJ1ZSB9IF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqIyhbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyAnaWQnLCBtWzFdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPVwiKFteXCJdKilcIi8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPScoW14nXSopJy8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPShbXiBdKikvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCAnJyBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKy8pKSB7XG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHRvZG8uZm9yRWFjaChmdW5jdGlvbiAoYXJncykgeyBzZXRBdHRyLmFwcGx5KHRoaXMsIFt0b2tlbl0uY29uY2F0KGFyZ3MpKSB9KVxuICByZXR1cm4gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHNoaWZ0ICgpIHtcbiAgICBhdHRycyA9IGF0dHJzLnN1YnN0cihtWzBdLmxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHNldHMgYW4gYXR0cmlidXRlIGBhdHRyYCB0byBgdmFsdWVgIGluIGEgdG9rZW4uIElmIGBvcHRpb25zLmFwcGVuZGBcbiAqIGlzIHRydWUsIGFwcGVuZCB0byB0aGUgb2xkIHZhbHVlIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXQuXG4gKi9cblxuZnVuY3Rpb24gc2V0QXR0ciAodG9rZW4sIGF0dHIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBpZHggPSB0b2tlbi5hdHRySW5kZXgoYXR0cilcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRva2VuLmF0dHJQdXNoKFsgYXR0ciwgdmFsdWUgXSlcbiAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgdG9rZW4uYXR0cnNbaWR4XVsxXSA9XG4gICAgICB0b2tlbi5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0b2tlbi5hdHRyc1tpZHhdWzFdID0gdmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHB1c2hlcyBhIHRva2VuIHRvIHRoZSBzdGFja1xuICovXG5cbmZ1bmN0aW9uIHNwdXNoIChzdGFjaywgdG9rZW4pIHtcbiAgdmFyIHR5cGUgPSB0b2tlbi50eXBlLnJlcGxhY2UoL18ob3BlbnxzdGFydCkkLywgJycpXG4gIGlmICghc3RhY2sudHlwZXNbdHlwZV0pIHsgc3RhY2sudHlwZXNbdHlwZV0gPSBbXSB9XG4gIHN0YWNrLnR5cGVzW3R5cGVdLnB1c2godG9rZW4pXG4gIHN0YWNrLmxhc3QgPSB0b2tlblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0LWRlY29yYXRlL2luZGV4LmpzIiwiLypcblN5bnRheCBoaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBhdXRvZGV0ZWN0aW9uLlxuaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4qL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEZpbmQgdGhlIGdsb2JhbCBvYmplY3QgZm9yIGV4cG9ydCB0byBib3RoIHRoZSBicm93c2VyIGFuZCB3ZWIgd29ya2Vycy5cbiAgdmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdyB8fFxuICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGY7XG5cbiAgLy8gU2V0dXAgaGlnaGxpZ2h0LmpzIGZvciBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLiBGaXJzdCBpcyBOb2RlLmpzIG9yXG4gIC8vIENvbW1vbkpTLlxuICBpZih0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICB9IGVsc2UgaWYoZ2xvYmFsT2JqZWN0KSB7XG4gICAgLy8gRXhwb3J0IGhsanMgZ2xvYmFsbHkgZXZlbiB3aGVuIHVzaW5nIEFNRCBmb3IgY2FzZXMgd2hlbiB0aGlzIHNjcmlwdFxuICAgIC8vIGlzIGxvYWRlZCB3aXRoIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgaGxqcy5cbiAgICBnbG9iYWxPYmplY3QuaGxqcyA9IGZhY3Rvcnkoe30pO1xuXG4gICAgLy8gRmluYWxseSByZWdpc3RlciB0aGUgZ2xvYmFsIGhsanMgd2l0aCBBTUQuXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsT2JqZWN0LmhsanM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufShmdW5jdGlvbihobGpzKSB7XG4gIC8vIENvbnZlbmllbmNlIHZhcmlhYmxlcyBmb3IgYnVpbGQtaW4gb2JqZWN0c1xuICB2YXIgQXJyYXlQcm90byA9IFtdLFxuICAgICAgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzO1xuXG4gIC8vIEdsb2JhbCBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCB3aXRoaW4gdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICB2YXIgbGFuZ3VhZ2VzID0ge30sXG4gICAgICBhbGlhc2VzICAgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgdGhyb3VnaG91dCB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIHZhciBub0hpZ2hsaWdodFJlICAgID0gL14obm8tP2hpZ2hsaWdodHxwbGFpbnx0ZXh0KSQvaSxcbiAgICAgIGxhbmd1YWdlUHJlZml4UmUgPSAvXFxibGFuZyg/OnVhZ2UpPy0oW1xcdy1dKylcXGIvaSxcbiAgICAgIGZpeE1hcmt1cFJlICAgICAgPSAvKCheKDxbXj5dKz58XFx0fCkrfCg/OlxcbikpKS9nbTtcblxuICB2YXIgc3BhbkVuZFRhZyA9ICc8L3NwYW4+JztcblxuICAvLyBHbG9iYWwgb3B0aW9ucyB1c2VkIHdoZW4gd2l0aGluIGV4dGVybmFsIEFQSXMuIFRoaXMgaXMgbW9kaWZpZWQgd2hlblxuICAvLyBjYWxsaW5nIHRoZSBgaGxqcy5jb25maWd1cmVgIGZ1bmN0aW9uLlxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjbGFzc1ByZWZpeDogJ2hsanMtJyxcbiAgICB0YWJSZXBsYWNlOiBudWxsLFxuICAgIHVzZUJSOiBmYWxzZSxcbiAgICBsYW5ndWFnZXM6IHVuZGVmaW5lZFxuICB9O1xuXG5cbiAgLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuICBmdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdFJlKHJlLCBsZXhlbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSByZSAmJiByZS5leGVjKGxleGVtZSk7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RIaWdobGlnaHRlZChsYW5ndWFnZSkge1xuICAgIHJldHVybiBub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2tMYW5ndWFnZShibG9jaykge1xuICAgIHZhciBpLCBtYXRjaCwgbGVuZ3RoLCBfY2xhc3M7XG4gICAgdmFyIGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIG1hdGNoID0gbGFuZ3VhZ2VQcmVmaXhSZS5leGVjKGNsYXNzZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIGdldExhbmd1YWdlKG1hdGNoWzFdKSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIF9jbGFzcyA9IGNsYXNzZXNbaV1cblxuICAgICAgaWYgKGlzTm90SGlnaGxpZ2h0ZWQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBfY2xhc3M7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQpIHsgIC8vIGluaGVyaXQocGFyZW50LCBvdmVycmlkZV9vYmosIG92ZXJyaWRlX29iaiwgLi4uKVxuICAgIHZhciBrZXk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGZvciAoa2V5IGluIHBhcmVudClcbiAgICAgIHJlc3VsdFtrZXldID0gcGFyZW50W2tleV07XG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgZm9yIChrZXkgaW4gb2JqKVxuICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiBTdHJlYW0gbWVyZ2luZyAqL1xuXG4gIGZ1bmN0aW9uIG5vZGVTdHJlYW0obm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAoZnVuY3Rpb24gX25vZGVTdHJlYW0obm9kZSwgb2Zmc2V0KSB7XG4gICAgICBmb3IgKHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzKVxuICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9mZnNldCA9IF9ub2RlU3RyZWFtKGNoaWxkLCBvZmZzZXQpO1xuICAgICAgICAgIC8vIFByZXZlbnQgdm9pZCBlbGVtZW50cyBmcm9tIGhhdmluZyBhbiBlbmQgdGFnIHRoYXQgd291bGQgYWN0dWFsbHlcbiAgICAgICAgICAvLyBkb3VibGUgdGhlbSBpbiB0aGUgb3V0cHV0LiBUaGVyZSBhcmUgbW9yZSB2b2lkIGVsZW1lbnRzIGluIEhUTUxcbiAgICAgICAgICAvLyBidXQgd2UgbGlzdCBvbmx5IHRob3NlIHJlYWxpc3RpY2FsbHkgZXhwZWN0ZWQgaW4gY29kZSBkaXNwbGF5LlxuICAgICAgICAgIGlmICghdGFnKGNoaWxkKS5tYXRjaCgvYnJ8aHJ8aW1nfGlucHV0LykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgZXZlbnQ6ICdzdG9wJyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgIG5vZGU6IGNoaWxkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSkobm9kZSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhvcmlnaW5hbCwgaGlnaGxpZ2h0ZWQsIHZhbHVlKSB7XG4gICAgdmFyIHByb2Nlc3NlZCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBub2RlU3RhY2sgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNlbGVjdFN0cmVhbSgpIHtcbiAgICAgIGlmICghb3JpZ2luYWwubGVuZ3RoIHx8ICFoaWdobGlnaHRlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmxlbmd0aCA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxbMF0ub2Zmc2V0ICE9PSBoaWdobGlnaHRlZFswXS5vZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbFswXS5vZmZzZXQgPCBoaWdobGlnaHRlZFswXS5vZmZzZXQpID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFRvIGF2b2lkIHN0YXJ0aW5nIHRoZSBzdHJlYW0ganVzdCBiZWZvcmUgaXQgc2hvdWxkIHN0b3AgdGhlIG9yZGVyIGlzXG4gICAgICBlbnN1cmVkIHRoYXQgb3JpZ2luYWwgYWx3YXlzIHN0YXJ0cyBmaXJzdCBhbmQgY2xvc2VzIGxhc3Q6XG5cbiAgICAgIGlmIChldmVudDEgPT0gJ3N0YXJ0JyAmJiBldmVudDIgPT0gJ3N0YXJ0JylcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICAgIHJldHVybiBoaWdobGlnaHRlZDtcbiAgICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICBpZiAoZXZlbnQxID09ICdzdG9wJyAmJiBldmVudDIgPT0gJ3N0b3AnKVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQ7XG5cbiAgICAgIC4uLiB3aGljaCBpcyBjb2xsYXBzZWQgdG86XG4gICAgICAqL1xuICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkWzBdLmV2ZW50ID09PSAnc3RhcnQnID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVuKG5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIGF0dHJfc3RyKGEpIHtyZXR1cm4gJyAnICsgYS5ub2RlTmFtZSArICc9XCInICsgZXNjYXBlKGEudmFsdWUpLnJlcGxhY2UoJ1wiJywgJyZxdW90OycpICsgJ1wiJzt9XG4gICAgICByZXN1bHQgKz0gJzwnICsgdGFnKG5vZGUpICsgQXJyYXlQcm90by5tYXAuY2FsbChub2RlLmF0dHJpYnV0ZXMsIGF0dHJfc3RyKS5qb2luKCcnKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZShub2RlKSB7XG4gICAgICByZXN1bHQgKz0gJzwvJyArIHRhZyhub2RlKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoZXZlbnQpIHtcbiAgICAgIChldmVudC5ldmVudCA9PT0gJ3N0YXJ0JyA/IG9wZW4gOiBjbG9zZSkoZXZlbnQubm9kZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9yaWdpbmFsLmxlbmd0aCB8fCBoaWdobGlnaHRlZC5sZW5ndGgpIHtcbiAgICAgIHZhciBzdHJlYW0gPSBzZWxlY3RTdHJlYW0oKTtcbiAgICAgIHJlc3VsdCArPSBlc2NhcGUodmFsdWUuc3Vic3RyaW5nKHByb2Nlc3NlZCwgc3RyZWFtWzBdLm9mZnNldCkpO1xuICAgICAgcHJvY2Vzc2VkID0gc3RyZWFtWzBdLm9mZnNldDtcbiAgICAgIGlmIChzdHJlYW0gPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIC8qXG4gICAgICAgIE9uIGFueSBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnIG9mIHRoZSBvcmlnaW5hbCBtYXJrdXAgd2UgZmlyc3QgY2xvc2VcbiAgICAgICAgdGhlIGVudGlyZSBoaWdobGlnaHRlZCBub2RlIHN0YWNrLCB0aGVuIHJlbmRlciB0aGUgb3JpZ2luYWwgdGFnIGFsb25nXG4gICAgICAgIHdpdGggYWxsIHRoZSBmb2xsb3dpbmcgb3JpZ2luYWwgdGFncyBhdCB0aGUgc2FtZSBvZmZzZXQgYW5kIHRoZW5cbiAgICAgICAgcmVvcGVuIGFsbCB0aGUgdGFncyBvbiB0aGUgaGlnaGxpZ2h0ZWQgc3RhY2suXG4gICAgICAgICovXG4gICAgICAgIG5vZGVTdGFjay5yZXZlcnNlKCkuZm9yRWFjaChjbG9zZSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICAgICAgc3RyZWFtID0gc2VsZWN0U3RyZWFtKCk7XG4gICAgICAgIH0gd2hpbGUgKHN0cmVhbSA9PT0gb3JpZ2luYWwgJiYgc3RyZWFtLmxlbmd0aCAmJiBzdHJlYW1bMF0ub2Zmc2V0ID09PSBwcm9jZXNzZWQpO1xuICAgICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2gob3Blbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyZWFtWzBdLmV2ZW50ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgbm9kZVN0YWNrLnB1c2goc3RyZWFtWzBdLm5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGUodmFsdWUuc3Vic3RyKHByb2Nlc3NlZCkpO1xuICB9XG5cbiAgLyogSW5pdGlhbGl6YXRpb24gKi9cblxuICBmdW5jdGlvbiBleHBhbmRfbW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUudmFyaWFudHMgJiYgIW1vZGUuY2FjaGVkX3ZhcmlhbnRzKSB7XG4gICAgICBtb2RlLmNhY2hlZF92YXJpYW50cyA9IG1vZGUudmFyaWFudHMubWFwKGZ1bmN0aW9uKHZhcmlhbnQpIHtcbiAgICAgICAgcmV0dXJuIGluaGVyaXQobW9kZSwge3ZhcmlhbnRzOiBudWxsfSwgdmFyaWFudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGUuY2FjaGVkX3ZhcmlhbnRzIHx8IChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIFtpbmhlcml0KG1vZGUpXSkgfHwgW21vZGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKSB7XG5cbiAgICBmdW5jdGlvbiByZVN0cihyZSkge1xuICAgICAgICByZXR1cm4gKHJlICYmIHJlLnNvdXJjZSkgfHwgcmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgICByZVN0cih2YWx1ZSksXG4gICAgICAgICdtJyArIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gJ2knIDogJycpICsgKGdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlTW9kZShtb2RlLCBwYXJlbnQpIHtcbiAgICAgIGlmIChtb2RlLmNvbXBpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBtb2RlLmNvbXBpbGVkID0gdHJ1ZTtcblxuICAgICAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICAgICAgaWYgKG1vZGUua2V5d29yZHMpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVkX2tleXdvcmRzID0ge307XG5cbiAgICAgICAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihjbGFzc05hbWUsIHN0cikge1xuICAgICAgICAgIGlmIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihrdykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBrdy5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgY29tcGlsZWRfa2V5d29yZHNbcGFpclswXV0gPSBbY2xhc3NOYW1lLCBwYWlyWzFdID8gTnVtYmVyKHBhaXJbMV0pIDogMV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlLmtleXdvcmRzID09PSAnc3RyaW5nJykgeyAvLyBzdHJpbmdcbiAgICAgICAgICBmbGF0dGVuKCdrZXl3b3JkJywgbW9kZS5rZXl3b3Jkcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0S2V5cyhtb2RlLmtleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oY2xhc3NOYW1lLCBtb2RlLmtleXdvcmRzW2NsYXNzTmFtZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUua2V5d29yZHMgPSBjb21waWxlZF9rZXl3b3JkcztcbiAgICAgIH1cbiAgICAgIG1vZGUubGV4ZW1lc1JlID0gbGFuZ1JlKG1vZGUubGV4ZW1lcyB8fCAvXFx3Ky8sIHRydWUpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChtb2RlLmJlZ2luS2V5d29yZHMpIHtcbiAgICAgICAgICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKVxcXFxiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUuYmVnaW4pXG4gICAgICAgICAgbW9kZS5iZWdpbiA9IC9cXEJ8XFxiLztcbiAgICAgICAgbW9kZS5iZWdpblJlID0gbGFuZ1JlKG1vZGUuYmVnaW4pO1xuICAgICAgICBpZiAoIW1vZGUuZW5kICYmICFtb2RlLmVuZHNXaXRoUGFyZW50KVxuICAgICAgICAgIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgICBpZiAobW9kZS5lbmQpXG4gICAgICAgICAgbW9kZS5lbmRSZSA9IGxhbmdSZShtb2RlLmVuZCk7XG4gICAgICAgIG1vZGUudGVybWluYXRvcl9lbmQgPSByZVN0cihtb2RlLmVuZCkgfHwgJyc7XG4gICAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIHBhcmVudC50ZXJtaW5hdG9yX2VuZClcbiAgICAgICAgICBtb2RlLnRlcm1pbmF0b3JfZW5kICs9IChtb2RlLmVuZCA/ICd8JyA6ICcnKSArIHBhcmVudC50ZXJtaW5hdG9yX2VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmlsbGVnYWwpXG4gICAgICAgIG1vZGUuaWxsZWdhbFJlID0gbGFuZ1JlKG1vZGUuaWxsZWdhbCk7XG4gICAgICBpZiAobW9kZS5yZWxldmFuY2UgPT0gbnVsbClcbiAgICAgICAgbW9kZS5yZWxldmFuY2UgPSAxO1xuICAgICAgaWYgKCFtb2RlLmNvbnRhaW5zKSB7XG4gICAgICAgIG1vZGUuY29udGFpbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG1vZGUuY29udGFpbnMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBtb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRfbW9kZShjID09PSAnc2VsZicgPyBtb2RlIDogYylcbiAgICAgIH0pKTtcbiAgICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaChmdW5jdGlvbihjKSB7Y29tcGlsZU1vZGUoYywgbW9kZSk7fSk7XG5cbiAgICAgIGlmIChtb2RlLnN0YXJ0cykge1xuICAgICAgICBjb21waWxlTW9kZShtb2RlLnN0YXJ0cywgcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlcm1pbmF0b3JzID1cbiAgICAgICAgbW9kZS5jb250YWlucy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjLmJlZ2luS2V5d29yZHMgPyAnXFxcXC4/KCcgKyBjLmJlZ2luICsgJylcXFxcLj8nIDogYy5iZWdpbjtcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbmNhdChbbW9kZS50ZXJtaW5hdG9yX2VuZCwgbW9kZS5pbGxlZ2FsXSlcbiAgICAgICAgLm1hcChyZVN0cilcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIG1vZGUudGVybWluYXRvcnMgPSB0ZXJtaW5hdG9ycy5sZW5ndGggPyBsYW5nUmUodGVybWluYXRvcnMuam9pbignfCcpLCB0cnVlKSA6IHtleGVjOiBmdW5jdGlvbigvKnMqLykge3JldHVybiBudWxsO319O1xuICAgIH1cblxuICAgIGNvbXBpbGVNb2RlKGxhbmd1YWdlKTtcbiAgfVxuXG4gIC8qXG4gIENvcmUgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uLiBBY2NlcHRzIGEgbGFuZ3VhZ2UgbmFtZSwgb3IgYW4gYWxpYXMsIGFuZCBhXG4gIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gIHByb3BlcnRpZXM6XG5cbiAgLSByZWxldmFuY2UgKGludClcbiAgLSB2YWx1ZSAoYW4gSFRNTCBzdHJpbmcgd2l0aCBoaWdobGlnaHRpbmcgbWFya3VwKVxuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodChuYW1lLCB2YWx1ZSwgaWdub3JlX2lsbGVnYWxzLCBjb250aW51YXRpb24pIHtcblxuICAgIGZ1bmN0aW9uIHN1Yk1vZGUobGV4ZW1lLCBtb2RlKSB7XG4gICAgICB2YXIgaSwgbGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBtb2RlLmNvbnRhaW5zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0UmUobW9kZS5jb250YWluc1tpXS5iZWdpblJlLCBsZXhlbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGUuY29udGFpbnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZk1vZGUobW9kZSwgbGV4ZW1lKSB7XG4gICAgICBpZiAodGVzdFJlKG1vZGUuZW5kUmUsIGxleGVtZSkpIHtcbiAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgIG1vZGUgPSBtb2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIGxleGVtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJbGxlZ2FsKGxleGVtZSwgbW9kZSkge1xuICAgICAgcmV0dXJuICFpZ25vcmVfaWxsZWdhbHMgJiYgdGVzdFJlKG1vZGUuaWxsZWdhbFJlLCBsZXhlbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXdvcmRNYXRjaChtb2RlLCBtYXRjaCkge1xuICAgICAgdmFyIG1hdGNoX3N0ciA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICByZXR1cm4gbW9kZS5rZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShtYXRjaF9zdHIpICYmIG1vZGUua2V5d29yZHNbbWF0Y2hfc3RyXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFNwYW4oY2xhc3NuYW1lLCBpbnNpZGVTcGFuLCBsZWF2ZU9wZW4sIG5vUHJlZml4KSB7XG4gICAgICB2YXIgY2xhc3NQcmVmaXggPSBub1ByZWZpeCA/ICcnIDogb3B0aW9ucy5jbGFzc1ByZWZpeCxcbiAgICAgICAgICBvcGVuU3BhbiAgICA9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc1ByZWZpeCxcbiAgICAgICAgICBjbG9zZVNwYW4gICA9IGxlYXZlT3BlbiA/ICcnIDogc3BhbkVuZFRhZ1xuXG4gICAgICBvcGVuU3BhbiArPSBjbGFzc25hbWUgKyAnXCI+JztcblxuICAgICAgcmV0dXJuIG9wZW5TcGFuICsgaW5zaWRlU3BhbiArIGNsb3NlU3BhbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzS2V5d29yZHMoKSB7XG4gICAgICB2YXIga2V5d29yZF9tYXRjaCwgbGFzdF9pbmRleCwgbWF0Y2gsIHJlc3VsdDtcblxuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpXG4gICAgICAgIHJldHVybiBlc2NhcGUobW9kZV9idWZmZXIpO1xuXG4gICAgICByZXN1bHQgPSAnJztcbiAgICAgIGxhc3RfaW5kZXggPSAwO1xuICAgICAgdG9wLmxleGVtZXNSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1lc1JlLmV4ZWMobW9kZV9idWZmZXIpO1xuXG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0ICs9IGVzY2FwZShtb2RlX2J1ZmZlci5zdWJzdHJpbmcobGFzdF9pbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAga2V5d29yZF9tYXRjaCA9IGtleXdvcmRNYXRjaCh0b3AsIG1hdGNoKTtcbiAgICAgICAgaWYgKGtleXdvcmRfbWF0Y2gpIHtcbiAgICAgICAgICByZWxldmFuY2UgKz0ga2V5d29yZF9tYXRjaFsxXTtcbiAgICAgICAgICByZXN1bHQgKz0gYnVpbGRTcGFuKGtleXdvcmRfbWF0Y2hbMF0sIGVzY2FwZShtYXRjaFswXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGUobWF0Y2hbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfaW5kZXggPSB0b3AubGV4ZW1lc1JlLmxhc3RJbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1lc1JlLmV4ZWMobW9kZV9idWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZShtb2RlX2J1ZmZlci5zdWJzdHIobGFzdF9pbmRleCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnO1xuICAgICAgaWYgKGV4cGxpY2l0ICYmICFsYW5ndWFnZXNbdG9wLnN1Ykxhbmd1YWdlXSkge1xuICAgICAgICByZXR1cm4gZXNjYXBlKG1vZGVfYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGV4cGxpY2l0ID9cbiAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlX2J1ZmZlciwgdHJ1ZSwgY29udGludWF0aW9uc1t0b3Auc3ViTGFuZ3VhZ2VdKSA6XG4gICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0QXV0byhtb2RlX2J1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIC8vIENvdW50aW5nIGVtYmVkZGVkIGxhbmd1YWdlIHNjb3JlIHRvd2FyZHMgdGhlIGhvc3QgbGFuZ3VhZ2UgbWF5IGJlIGRpc2FibGVkXG4gICAgICAvLyB3aXRoIHplcm9pbmcgdGhlIGNvbnRhaW5pbmcgbW9kZSByZWxldmFuY2UuIFVzZWNhc2UgaW4gcG9pbnQgaXMgTWFya2Rvd24gdGhhdFxuICAgICAgLy8gYWxsb3dzIFhNTCBldmVyeXdoZXJlIGFuZCBtYWtlcyBldmVyeSBYTUwgc25pcHBldCB0byBoYXZlIGEgbXVjaCBsYXJnZXIgTWFya2Rvd25cbiAgICAgIC8vIHNjb3JlLlxuICAgICAgaWYgKHRvcC5yZWxldmFuY2UgPiAwKSB7XG4gICAgICAgIHJlbGV2YW5jZSArPSByZXN1bHQucmVsZXZhbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGxpY2l0KSB7XG4gICAgICAgIGNvbnRpbnVhdGlvbnNbdG9wLnN1Ykxhbmd1YWdlXSA9IHJlc3VsdC50b3A7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRTcGFuKHJlc3VsdC5sYW5ndWFnZSwgcmVzdWx0LnZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0J1ZmZlcigpIHtcbiAgICAgIHJlc3VsdCArPSAodG9wLnN1Ykxhbmd1YWdlICE9IG51bGwgPyBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSA6IHByb2Nlc3NLZXl3b3JkcygpKTtcbiAgICAgIG1vZGVfYnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnROZXdNb2RlKG1vZGUpIHtcbiAgICAgIHJlc3VsdCArPSBtb2RlLmNsYXNzTmFtZT8gYnVpbGRTcGFuKG1vZGUuY2xhc3NOYW1lLCAnJywgdHJ1ZSk6ICcnO1xuICAgICAgdG9wID0gT2JqZWN0LmNyZWF0ZShtb2RlLCB7cGFyZW50OiB7dmFsdWU6IHRvcH19KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGV4ZW1lKGJ1ZmZlciwgbGV4ZW1lKSB7XG5cbiAgICAgIG1vZGVfYnVmZmVyICs9IGJ1ZmZlcjtcblxuICAgICAgaWYgKGxleGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfbW9kZSA9IHN1Yk1vZGUobGV4ZW1lLCB0b3ApO1xuICAgICAgaWYgKG5ld19tb2RlKSB7XG4gICAgICAgIGlmIChuZXdfbW9kZS5za2lwKSB7XG4gICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdfbW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICAgIGlmICghbmV3X21vZGUucmV0dXJuQmVnaW4gJiYgIW5ld19tb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0TmV3TW9kZShuZXdfbW9kZSwgbGV4ZW1lKTtcbiAgICAgICAgcmV0dXJuIG5ld19tb2RlLnJldHVybkJlZ2luID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmRfbW9kZSA9IGVuZE9mTW9kZSh0b3AsIGxleGVtZSk7XG4gICAgICBpZiAoZW5kX21vZGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRvcDtcbiAgICAgICAgaWYgKG9yaWdpbi5za2lwKSB7XG4gICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghKG9yaWdpbi5yZXR1cm5FbmQgfHwgb3JpZ2luLmV4Y2x1ZGVFbmQpKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgICBpZiAob3JpZ2luLmV4Y2x1ZGVFbmQpIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHRvcC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzcGFuRW5kVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRvcC5za2lwKSB7XG4gICAgICAgICAgICByZWxldmFuY2UgKz0gdG9wLnJlbGV2YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAodG9wICE9PSBlbmRfbW9kZS5wYXJlbnQpO1xuICAgICAgICBpZiAoZW5kX21vZGUuc3RhcnRzKSB7XG4gICAgICAgICAgc3RhcnROZXdNb2RlKGVuZF9tb2RlLnN0YXJ0cywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4ucmV0dXJuRW5kID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lsbGVnYWwobGV4ZW1lLCB0b3ApKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgbGV4ZW1lIFwiJyArIGxleGVtZSArICdcIiBmb3IgbW9kZSBcIicgKyAodG9wLmNsYXNzTmFtZSB8fCAnPHVubmFtZWQ+JykgKyAnXCInKTtcblxuICAgICAgLypcbiAgICAgIFBhcnNlciBzaG91bGQgbm90IHJlYWNoIHRoaXMgcG9pbnQgYXMgYWxsIHR5cGVzIG9mIGxleGVtZXMgc2hvdWxkIGJlIGNhdWdodFxuICAgICAgZWFybGllciwgYnV0IGlmIGl0IGRvZXMgZHVlIHRvIHNvbWUgYnVnIG1ha2Ugc3VyZSBpdCBhZHZhbmNlcyBhdCBsZWFzdCBvbmVcbiAgICAgIGNoYXJhY3RlciBmb3J3YXJkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcGluZy5cbiAgICAgICovXG4gICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICByZXR1cm4gbGV4ZW1lLmxlbmd0aCB8fCAxO1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZTogXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSk7XG4gICAgdmFyIHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBsYW5ndWFnZTtcbiAgICB2YXIgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICB2YXIgcmVzdWx0ID0gJycsIGN1cnJlbnQ7XG4gICAgZm9yKGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQgIT09IGxhbmd1YWdlOyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmNsYXNzTmFtZSkge1xuICAgICAgICByZXN1bHQgPSBidWlsZFNwYW4oY3VycmVudC5jbGFzc05hbWUsICcnLCB0cnVlKSArIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1vZGVfYnVmZmVyID0gJyc7XG4gICAgdmFyIHJlbGV2YW5jZSA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaCwgY291bnQsIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRvcC50ZXJtaW5hdG9ycy5sYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AudGVybWluYXRvcnMuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvdW50ID0gcHJvY2Vzc0xleGVtZSh2YWx1ZS5zdWJzdHJpbmcoaW5kZXgsIG1hdGNoLmluZGV4KSwgbWF0Y2hbMF0pO1xuICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgY291bnQ7XG4gICAgICB9XG4gICAgICBwcm9jZXNzTGV4ZW1lKHZhbHVlLnN1YnN0cihpbmRleCkpO1xuICAgICAgZm9yKGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQucGFyZW50OyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHsgLy8gY2xvc2UgZGFuZ2xpbmcgbW9kZXNcbiAgICAgICAgaWYgKGN1cnJlbnQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHNwYW5FbmRUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBsYW5ndWFnZTogbmFtZSxcbiAgICAgICAgdG9wOiB0b3BcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubWVzc2FnZSAmJiBlLm1lc3NhZ2UuaW5kZXhPZignSWxsZWdhbCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICBIaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24uIEFjY2VwdHMgYSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0b1xuICBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gbGFuZ3VhZ2UgKGRldGVjdGVkIGxhbmd1YWdlKVxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG4gIC0gc2Vjb25kX2Jlc3QgKG9iamVjdCB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBmb3Igc2Vjb25kLWJlc3QgaGV1cmlzdGljYWxseVxuICAgIGRldGVjdGVkIGxhbmd1YWdlLCBtYXkgYmUgYWJzZW50KVxuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG8odGV4dCwgbGFuZ3VhZ2VTdWJzZXQpIHtcbiAgICBsYW5ndWFnZVN1YnNldCA9IGxhbmd1YWdlU3Vic2V0IHx8IG9wdGlvbnMubGFuZ3VhZ2VzIHx8IG9iamVjdEtleXMobGFuZ3VhZ2VzKTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgdmFsdWU6IGVzY2FwZSh0ZXh0KVxuICAgIH07XG4gICAgdmFyIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgIGxhbmd1YWdlU3Vic2V0LmZpbHRlcihnZXRMYW5ndWFnZSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGhpZ2hsaWdodChuYW1lLCB0ZXh0LCBmYWxzZSk7XG4gICAgICBjdXJyZW50Lmxhbmd1YWdlID0gbmFtZTtcbiAgICAgIGlmIChjdXJyZW50LnJlbGV2YW5jZSA+IHNlY29uZF9iZXN0LnJlbGV2YW5jZSkge1xuICAgICAgICBzZWNvbmRfYmVzdCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5yZWxldmFuY2UgPiByZXN1bHQucmVsZXZhbmNlKSB7XG4gICAgICAgIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzZWNvbmRfYmVzdC5sYW5ndWFnZSkge1xuICAgICAgcmVzdWx0LnNlY29uZF9iZXN0ID0gc2Vjb25kX2Jlc3Q7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICBQb3N0LXByb2Nlc3Npbmcgb2YgdGhlIGhpZ2hsaWdodGVkIG1hcmt1cDpcblxuICAtIHJlcGxhY2UgVEFCcyB3aXRoIHNvbWV0aGluZyBtb3JlIHVzZWZ1bFxuICAtIHJlcGxhY2UgcmVhbCBsaW5lLWJyZWFrcyB3aXRoICc8YnI+JyBmb3Igbm9uLXByZSBjb250YWluZXJzXG5cbiAgKi9cbiAgZnVuY3Rpb24gZml4TWFya3VwKHZhbHVlKSB7XG4gICAgcmV0dXJuICEob3B0aW9ucy50YWJSZXBsYWNlIHx8IG9wdGlvbnMudXNlQlIpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHZhbHVlLnJlcGxhY2UoZml4TWFya3VwUmUsIGZ1bmN0aW9uKG1hdGNoLCBwMSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUJSICYmIG1hdGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICc8YnI+JztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFiUmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHAxLnJlcGxhY2UoL1xcdC9nLCBvcHRpb25zLnRhYlJlcGxhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lKHByZXZDbGFzc05hbWUsIGN1cnJlbnRMYW5nLCByZXN1bHRMYW5nKSB7XG4gICAgdmFyIGxhbmd1YWdlID0gY3VycmVudExhbmcgPyBhbGlhc2VzW2N1cnJlbnRMYW5nXSA6IHJlc3VsdExhbmcsXG4gICAgICAgIHJlc3VsdCAgID0gW3ByZXZDbGFzc05hbWUudHJpbSgpXTtcblxuICAgIGlmICghcHJldkNsYXNzTmFtZS5tYXRjaCgvXFxiaGxqc1xcYi8pKSB7XG4gICAgICByZXN1bHQucHVzaCgnaGxqcycpO1xuICAgIH1cblxuICAgIGlmIChwcmV2Q2xhc3NOYW1lLmluZGV4T2YobGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgcmVzdWx0LnB1c2gobGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGEgRE9NIG5vZGUgY29udGFpbmluZyBjb2RlLiBBY2NlcHRzIGEgRE9NIG5vZGUgYW5kXG4gIHR3byBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBmaXhNYXJrdXAuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEJsb2NrKGJsb2NrKSB7XG4gICAgdmFyIG5vZGUsIG9yaWdpbmFsU3RyZWFtLCByZXN1bHQsIHJlc3VsdE5vZGUsIHRleHQ7XG4gICAgdmFyIGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShibG9jayk7XG5cbiAgICBpZiAoaXNOb3RIaWdobGlnaHRlZChsYW5ndWFnZSkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLnVzZUJSKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2RpdicpO1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBibG9jay5pbm5lckhUTUwucmVwbGFjZSgvXFxuL2csICcnKS5yZXBsYWNlKC88YnJbIFxcL10qPi9nLCAnXFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBibG9jaztcbiAgICB9XG4gICAgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgcmVzdWx0ID0gbGFuZ3VhZ2UgPyBoaWdobGlnaHQobGFuZ3VhZ2UsIHRleHQsIHRydWUpIDogaGlnaGxpZ2h0QXV0byh0ZXh0KTtcblxuICAgIG9yaWdpbmFsU3RyZWFtID0gbm9kZVN0cmVhbShub2RlKTtcbiAgICBpZiAob3JpZ2luYWxTdHJlYW0ubGVuZ3RoKSB7XG4gICAgICByZXN1bHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2RpdicpO1xuICAgICAgcmVzdWx0Tm9kZS5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXN1bHQudmFsdWUgPSBtZXJnZVN0cmVhbXMob3JpZ2luYWxTdHJlYW0sIG5vZGVTdHJlYW0ocmVzdWx0Tm9kZSksIHRleHQpO1xuICAgIH1cbiAgICByZXN1bHQudmFsdWUgPSBmaXhNYXJrdXAocmVzdWx0LnZhbHVlKTtcblxuICAgIGJsb2NrLmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICBibG9jay5jbGFzc05hbWUgPSBidWlsZENsYXNzTmFtZShibG9jay5jbGFzc05hbWUsIGxhbmd1YWdlLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIGJsb2NrLnJlc3VsdCA9IHtcbiAgICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgICByZTogcmVzdWx0LnJlbGV2YW5jZVxuICAgIH07XG4gICAgaWYgKHJlc3VsdC5zZWNvbmRfYmVzdCkge1xuICAgICAgYmxvY2suc2Vjb25kX2Jlc3QgPSB7XG4gICAgICAgIGxhbmd1YWdlOiByZXN1bHQuc2Vjb25kX2Jlc3QubGFuZ3VhZ2UsXG4gICAgICAgIHJlOiByZXN1bHQuc2Vjb25kX2Jlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIFVwZGF0ZXMgaGlnaGxpZ2h0LmpzIGdsb2JhbCBvcHRpb25zIHdpdGggdmFsdWVzIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBhbiBvYmplY3QuXG4gICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZSh1c2VyX29wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gaW5oZXJpdChvcHRpb25zLCB1c2VyX29wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gYWxsIDxwcmU+PGNvZGU+Li48L2NvZGU+PC9wcmU+IGJsb2NrcyBvbiBhIHBhZ2UuXG4gICovXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmcoKSB7XG4gICAgaWYgKGluaXRIaWdobGlnaHRpbmcuY2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGluaXRIaWdobGlnaHRpbmcuY2FsbGVkID0gdHJ1ZTtcblxuICAgIHZhciBibG9ja3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgIEFycmF5UHJvdG8uZm9yRWFjaC5jYWxsKGJsb2NrcywgaGlnaGxpZ2h0QmxvY2spO1xuICB9XG5cbiAgLypcbiAgQXR0YWNoZXMgaGlnaGxpZ2h0aW5nIHRvIHRoZSBwYWdlIGxvYWQgZXZlbnQuXG4gICovXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaW5pdEhpZ2hsaWdodGluZywgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMYW5ndWFnZShuYW1lLCBsYW5ndWFnZSkge1xuICAgIHZhciBsYW5nID0gbGFuZ3VhZ2VzW25hbWVdID0gbGFuZ3VhZ2UoaGxqcyk7XG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgbGFuZy5hbGlhc2VzLmZvckVhY2goZnVuY3Rpb24oYWxpYXMpIHthbGlhc2VzW2FsaWFzXSA9IG5hbWU7fSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlzdExhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhsYW5ndWFnZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UobmFtZSkge1xuICAgIG5hbWUgPSAobmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbGFuZ3VhZ2VzW25hbWVdIHx8IGxhbmd1YWdlc1thbGlhc2VzW25hbWVdXTtcbiAgfVxuXG4gIC8qIEludGVyZmFjZSBkZWZpbml0aW9uICovXG5cbiAgaGxqcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gIGhsanMuaGlnaGxpZ2h0QXV0byA9IGhpZ2hsaWdodEF1dG87XG4gIGhsanMuZml4TWFya3VwID0gZml4TWFya3VwO1xuICBobGpzLmhpZ2hsaWdodEJsb2NrID0gaGlnaGxpZ2h0QmxvY2s7XG4gIGhsanMuY29uZmlndXJlID0gY29uZmlndXJlO1xuICBobGpzLmluaXRIaWdobGlnaHRpbmcgPSBpbml0SGlnaGxpZ2h0aW5nO1xuICBobGpzLmluaXRIaWdobGlnaHRpbmdPbkxvYWQgPSBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkO1xuICBobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UgPSByZWdpc3Rlckxhbmd1YWdlO1xuICBobGpzLmxpc3RMYW5ndWFnZXMgPSBsaXN0TGFuZ3VhZ2VzO1xuICBobGpzLmdldExhbmd1YWdlID0gZ2V0TGFuZ3VhZ2U7XG4gIGhsanMuaW5oZXJpdCA9IGluaGVyaXQ7XG5cbiAgLy8gQ29tbW9uIHJlZ2V4cHNcbiAgaGxqcy5JREVOVF9SRSA9ICdbYS16QS1aXVxcXFx3Kic7XG4gIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSA9ICdbYS16QS1aX11cXFxcdyonO1xuICBobGpzLk5VTUJFUl9SRSA9ICdcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKyk/JztcbiAgaGxqcy5DX05VTUJFUl9SRSA9ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XSt8KFxcXFxiXFxcXGQrKFxcXFwuXFxcXGQqKT98XFxcXC5cXFxcZCspKFtlRV1bLStdP1xcXFxkKyk/KSc7IC8vIDB4Li4uLCAwLi4uLCBkZWNpbWFsLCBmbG9hdFxuICBobGpzLkJJTkFSWV9OVU1CRVJfUkUgPSAnXFxcXGIoMGJbMDFdKyknOyAvLyAwYi4uLlxuICBobGpzLlJFX1NUQVJURVJTX1JFID0gJyF8IT18IT09fCV8JT18JnwmJnwmPXxcXFxcKnxcXFxcKj18XFxcXCt8XFxcXCs9fCx8LXwtPXwvPXwvfDp8O3w8PHw8PD18PD18PHw9PT18PT18PXw+Pj49fD4+PXw+PXw+Pj58Pj58PnxcXFxcP3xcXFxcW3xcXFxce3xcXFxcKHxcXFxcXnxcXFxcXj18XFxcXHx8XFxcXHw9fFxcXFx8XFxcXHx8fic7XG5cbiAgLy8gQ29tbW9uIG1vZGVzXG4gIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSA9IHtcbiAgICBiZWdpbjogJ1xcXFxcXFxcW1xcXFxzXFxcXFNdJywgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQVBPU19TVFJJTkdfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnXFwnJyxcbiAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICB9O1xuICBobGpzLlFVT1RFX1NUUklOR19NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICB9O1xuICBobGpzLlBIUkFTQUxfV09SRFNfTU9ERSA9IHtcbiAgICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xuICB9O1xuICBobGpzLkNPTU1FTlQgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCwgaW5oZXJpdHMpIHtcbiAgICB2YXIgbW9kZSA9IGhsanMuaW5oZXJpdChcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGJlZ2luOiBiZWdpbiwgZW5kOiBlbmQsXG4gICAgICAgIGNvbnRhaW5zOiBbXVxuICAgICAgfSxcbiAgICAgIGluaGVyaXRzIHx8IHt9XG4gICAgKTtcbiAgICBtb2RlLmNvbnRhaW5zLnB1c2goaGxqcy5QSFJBU0FMX1dPUkRTX01PREUpO1xuICAgIG1vZGUuY29udGFpbnMucHVzaCh7XG4gICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgYmVnaW46ICcoPzpUT0RPfEZJWE1FfE5PVEV8QlVHfFhYWCk6JyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0pO1xuICAgIHJldHVybiBtb2RlO1xuICB9O1xuICBobGpzLkNfTElORV9DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJy8vJywgJyQnKTtcbiAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnL1xcXFwqJywgJ1xcXFwqLycpO1xuICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFID0gaGxqcy5DT01NRU5UKCcjJywgJyQnKTtcbiAgaGxqcy5OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLk5VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5DX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQklOQVJZX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuQklOQVJZX05VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5DU1NfTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5OVU1CRVJfUkUgKyAnKCcgK1xuICAgICAgJyV8ZW18ZXh8Y2h8cmVtJyAgK1xuICAgICAgJ3x2d3x2aHx2bWlufHZtYXgnICtcbiAgICAgICd8Y218bW18aW58cHR8cGN8cHgnICtcbiAgICAgICd8ZGVnfGdyYWR8cmFkfHR1cm4nICtcbiAgICAgICd8c3xtcycgK1xuICAgICAgJ3xIenxrSHonICtcbiAgICAgICd8ZHBpfGRwY218ZHBweCcgK1xuICAgICAgJyk/JyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5SRUdFWFBfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdyZWdleHAnLFxuICAgIGJlZ2luOiAvXFwvLywgZW5kOiAvXFwvW2dpbXV5XSovLFxuICAgIGlsbGVnYWw6IC9cXG4vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLywgZW5kOiAvXFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGhsanMuVElUTEVfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgYmVnaW46IGhsanMuSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLk1FVEhPRF9HVUFSRCA9IHtcbiAgICAvLyBleGNsdWRlcyBtZXRob2QgbmFtZXMgZnJvbSBrZXl3b3JkIHByb2Nlc3NpbmdcbiAgICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICByZXR1cm4gaGxqcztcbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2hpZ2hsaWdodC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW0EtWmEteiRfXVswLTlBLVphLXokX10qJztcbiAgdmFyIEtFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6XG4gICAgICAnaW4gb2YgaWYgZm9yIHdoaWxlIGZpbmFsbHkgdmFyIG5ldyBmdW5jdGlvbiBkbyByZXR1cm4gdm9pZCBlbHNlIGJyZWFrIGNhdGNoICcgK1xuICAgICAgJ2luc3RhbmNlb2Ygd2l0aCB0aHJvdyBjYXNlIGRlZmF1bHQgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHR5cGVvZiBkZWxldGUgJyArXG4gICAgICAnbGV0IHlpZWxkIGNvbnN0IGV4cG9ydCBzdXBlciBkZWJ1Z2dlciBhcyBhc3luYyBhd2FpdCBzdGF0aWMgJyArXG4gICAgICAvLyBFQ01BU2NyaXB0IDYgbW9kdWxlcyBpbXBvcnRcbiAgICAgICdpbXBvcnQgZnJvbSBhcydcbiAgICAsXG4gICAgbGl0ZXJhbDpcbiAgICAgICd0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkIE5hTiBJbmZpbml0eScsXG4gICAgYnVpbHRfaW46XG4gICAgICAnZXZhbCBpc0Zpbml0ZSBpc05hTiBwYXJzZUZsb2F0IHBhcnNlSW50IGRlY29kZVVSSSBkZWNvZGVVUklDb21wb25lbnQgJyArXG4gICAgICAnZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBlc2NhcGUgdW5lc2NhcGUgT2JqZWN0IEZ1bmN0aW9uIEJvb2xlYW4gRXJyb3IgJyArXG4gICAgICAnRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdG9wSXRlcmF0aW9uIFN5bnRheEVycm9yICcgK1xuICAgICAgJ1R5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgRmxvYXQzMkFycmF5ICcgK1xuICAgICAgJ0Zsb2F0NjRBcnJheSBJbnQxNkFycmF5IEludDMyQXJyYXkgSW50OEFycmF5IFVpbnQxNkFycmF5IFVpbnQzMkFycmF5ICcgK1xuICAgICAgJ1VpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBJbnRsIGFyZ3VtZW50cyByZXF1aXJlICcgK1xuICAgICAgJ21vZHVsZSBjb25zb2xlIHdpbmRvdyBkb2N1bWVudCBTeW1ib2wgU2V0IE1hcCBXZWFrU2V0IFdlYWtNYXAgUHJveHkgUmVmbGVjdCAnICtcbiAgICAgICdQcm9taXNlJ1xuICB9O1xuICB2YXIgRVhQUkVTU0lPTlM7XG4gIHZhciBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgeyBiZWdpbjogJ1xcXFxiKDBbYkJdWzAxXSspJyB9LFxuICAgICAgeyBiZWdpbjogJ1xcXFxiKDBbb09dWzAtN10rKScgfSxcbiAgICAgIHsgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUgfVxuICAgIF0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICdcXFxcJFxcXFx7JywgZW5kOiAnXFxcXH0nLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW10gIC8vIGRlZmluZWQgbGF0ZXJcbiAgfTtcbiAgdmFyIFRFTVBMQVRFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnYCcsIGVuZDogJ2AnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBTVUJTVFxuICAgIF1cbiAgfTtcbiAgU1VCU1QuY29udGFpbnMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIE5VTUJFUixcbiAgICBobGpzLlJFR0VYUF9NT0RFXG4gIF1cbiAgdmFyIFBBUkFNU19DT05UQUlOUyA9IFNVQlNULmNvbnRhaW5zLmNvbmNhdChbXG4gICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBobGpzLkNfTElORV9DT01NRU5UX01PREVcbiAgXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCddLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvXiMhLywgZW5kOiAvJC9cbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgVEVNUExBVEVfU1RSSU5HLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIE5VTUJFUixcbiAgICAgIHsgLy8gb2JqZWN0IGF0dHIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAvW3ssXVxccyovLCByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IElERU5UX1JFICsgJ1xcXFxzKjonLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbe2NsYXNzTmFtZTogJ2F0dHInLCBiZWdpbjogSURFTlRfUkUsIHJlbGV2YW5jZTogMH1dXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLlJFR0VYUF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIGJlZ2luOiAnKFxcXFwoLio/XFxcXCl8JyArIElERU5UX1JFICsgJylcXFxccyo9PicsIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgZW5kOiAnXFxcXHMqPT4nLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IElERU5UX1JFXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKFxccypcXCkvLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBFNFggLyBKU1hcbiAgICAgICAgICAgIGJlZ2luOiAvPC8sIGVuZDogLyhcXC9cXHcrfFxcdytcXC8pPi8sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7YmVnaW46IC88XFx3K1xccypcXC8+Lywgc2tpcDogdHJ1ZX0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLzxcXHcrLywgZW5kOiAvKFxcL1xcdyt8XFx3K1xcLyk+Lywgc2tpcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgICAge2JlZ2luOiAvPFxcdytcXHMqXFwvPi8sIHNraXA6IHRydWV9LFxuICAgICAgICAgICAgICAgICAgJ3NlbGYnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2Z1bmN0aW9uJywgZW5kOiAvXFx7LywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7YmVnaW46IElERU5UX1JFfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpbGxlZ2FsOiAvXFxbfCUvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9LFxuICAgICAgaGxqcy5NRVRIT0RfR1VBUkQsXG4gICAgICB7IC8vIEVTNiBjbGFzc1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdjbGFzcycsIGVuZDogL1t7Oz1dLywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgaWxsZWdhbDogL1s6XCJcXFtcXF1dLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7YmVnaW5LZXl3b3JkczogJ2V4dGVuZHMnfSxcbiAgICAgICAgICBobGpzLlVOREVSU0NPUkVfVElUTEVfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbktleXdvcmRzOiAnY29uc3RydWN0b3InLCBlbmQ6IC9cXHsvLCBleGNsdWRlRW5kOiB0cnVlXG4gICAgICB9XG4gICAgXSxcbiAgICBpbGxlZ2FsOiAvIyg/ISEpL1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvamF2YXNjcmlwdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW2EtekEtWi1dW2EtekEtWjAtOV8tXSonO1xuICB2YXIgUlVMRSA9IHtcbiAgICBiZWdpbjogL1tBLVpcXF9cXC5cXC1dK1xccyo6LywgcmV0dXJuQmVnaW46IHRydWUsIGVuZDogJzsnLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICBiZWdpbjogL1xcUy8sIGVuZDogJzonLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWdpbjogL1tcXHctXStcXCgvLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdidWlsdF9pbicsXG4gICAgICAgICAgICAgICAgICBiZWdpbjogL1tcXHctXSsvXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBobGpzLkNTU19OVU1CRVJfTU9ERSxcbiAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLCBiZWdpbjogJyNbMC05QS1GYS1mXSsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtZXRhJywgYmVnaW46ICchaW1wb3J0YW50J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgaWxsZWdhbDogL1s9XFwvfCdcXCRdLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItaWQnLCBiZWdpbjogLyNbQS1aYS16MC05Xy1dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWNsYXNzJywgYmVnaW46IC9cXC5bQS1aYS16MC05Xy1dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWF0dHInLFxuICAgICAgICBiZWdpbjogL1xcWy8sIGVuZDogL1xcXS8sXG4gICAgICAgIGlsbGVnYWw6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItcHNldWRvJyxcbiAgICAgICAgYmVnaW46IC86KDopP1thLXpBLVowLTlcXF9cXC1cXCtcXChcXClcIicuXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ0AoZm9udC1mYWNlfHBhZ2UpJyxcbiAgICAgICAgbGV4ZW1lczogJ1thLXotXSsnLFxuICAgICAgICBrZXl3b3JkczogJ2ZvbnQtZmFjZSBwYWdlJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAJywgZW5kOiAnW3s7XScsIC8vIGF0X3J1bGUgZWF0aW5nIGZpcnN0IFwie1wiIGlzIGEgZ29vZCB0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBkb2VzbuKAmXQgbGV0IGl0IHRvIGJlIHBhcnNlZCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBydWxlIHNldCBidXQgaW5zdGVhZCBkcm9wcyBwYXJzZXIgaW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgbW9kZSB3aGljaCBpcyBob3cgaXQgc2hvdWxkIGJlLlxuICAgICAgICBpbGxlZ2FsOiAvOi8sIC8vIGJyZWFrIG9uIExlc3MgdmFyaWFibGVzIEB2YXI6IC4uLlxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2tleXdvcmQnLFxuICAgICAgICAgICAgYmVnaW46IC9cXHcrL1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXHMvLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSwgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXRhZycsIGJlZ2luOiBJREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICAgICAgaWxsZWdhbDogL1xcUy8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBSVUxFLFxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBYTUxfSURFTlRfUkUgPSAnW0EtWmEtejAtOVxcXFwuXzotXSsnO1xuICB2YXIgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7YmVnaW46IC9cIi8sIGVuZDogL1wiL30sXG4gICAgICAgICAgICAgIHtiZWdpbjogLycvLCBlbmQ6IC8nL30sXG4gICAgICAgICAgICAgIHtiZWdpbjogL1teXFxzXCInPTw+YF0rL31cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIHJldHVybiB7XG4gICAgYWxpYXNlczogWydodG1sJywgJ3hodG1sJywgJ3JzcycsICdhdG9tJywgJ3hqYicsICd4c2QnLCAneHNsJywgJ3BsaXN0J10sXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46ICc8IURPQ1RZUEUnLCBlbmQ6ICc+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICdcXFxcWycsIGVuZDogJ1xcXFxdJ31dXG4gICAgICB9LFxuICAgICAgaGxqcy5DT01NRU5UKFxuICAgICAgICAnPCEtLScsXG4gICAgICAgICctLT4nLFxuICAgICAgICB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgICB9XG4gICAgICApLFxuICAgICAge1xuICAgICAgICBiZWdpbjogJzxcXFxcIVxcXFxbQ0RBVEFcXFxcWycsIGVuZDogJ1xcXFxdXFxcXF0+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC88XFw/KHBocCk/LywgZW5kOiAvXFw/Pi8sXG4gICAgICAgIHN1Ykxhbmd1YWdlOiAncGhwJyxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICcvXFxcXConLCBlbmQ6ICdcXFxcKi8nLCBza2lwOiB0cnVlfV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBsb29rYWhlYWQgcGF0dGVybiAoPz0uLi4pIGVuc3VyZXMgdGhhdCAnYmVnaW4nIG9ubHkgbWF0Y2hlc1xuICAgICAgICAnPHN0eWxlJyBhcyBhIHNpbmdsZSB3b3JkLCBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2Ugb3IgYW5cbiAgICAgICAgZW5kaW5nIGJyYWtldC4gVGhlICckJyBpcyBuZWVkZWQgZm9yIHRoZSBsZXhlbWUgdG8gYmUgcmVjb2duaXplZFxuICAgICAgICBieSBobGpzLnN1Yk1vZGUoKSB0aGF0IHRlc3RzIGxleGVtZXMgb3V0c2lkZSB0aGUgc3RyZWFtLlxuICAgICAgICAqL1xuICAgICAgICBiZWdpbjogJzxzdHlsZSg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHtuYW1lOiAnc3R5bGUnfSxcbiAgICAgICAgY29udGFpbnM6IFtUQUdfSU5URVJOQUxTXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnPC9zdHlsZT4nLCByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFsnY3NzJywgJ3htbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgPHN0eWxlIHRhZyBhYm91dCB0aGUgbG9va2FoZWFkIHBhdHRlcm5cbiAgICAgICAgYmVnaW46ICc8c2NyaXB0KD89XFxcXHN8PnwkKScsIGVuZDogJz4nLFxuICAgICAgICBrZXl3b3Jkczoge25hbWU6ICdzY3JpcHQnfSxcbiAgICAgICAgY29udGFpbnM6IFtUQUdfSU5URVJOQUxTXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnXFw8XFwvc2NyaXB0XFw+JywgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbJ2FjdGlvbnNjcmlwdCcsICdqYXZhc2NyaXB0JywgJ2hhbmRsZWJhcnMnLCAneG1sJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAge2JlZ2luOiAvPFxcP3htbC8sIGVuZDogL1xcPz4vLCByZWxldmFuY2U6IDEwfSxcbiAgICAgICAgICB7YmVnaW46IC88XFw/XFx3Ky8sIGVuZDogL1xcPz4vfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogJzwvPycsIGVuZDogJy8/PicsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsIGJlZ2luOiAvW15cXC8+PFxcc10rLywgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBUQUdfSU5URVJOQUxTXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFZBUiA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtiZWdpbjogL1xcJFtcXHdcXGQjQF1bXFx3XFxkX10qL30sXG4gICAgICB7YmVnaW46IC9cXCRcXHsoLio/KX0vfVxuICAgIF1cbiAgfTtcbiAgdmFyIFFVT1RFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvXCIvLCBlbmQ6IC9cIi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFZBUixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogL1xcJFxcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgdmFyIEFQT1NfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46IC8nLywgZW5kOiAvJy9cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFsaWFzZXM6IFsnc2gnLCAnenNoJ10sXG4gICAgbGV4ZW1lczogL1xcYi0/W2EtelxcLl9dK1xcYi8sXG4gICAga2V5d29yZHM6IHtcbiAgICAgIGtleXdvcmQ6XG4gICAgICAgICdpZiB0aGVuIGVsc2UgZWxpZiBmaSBmb3Igd2hpbGUgaW4gZG8gZG9uZSBjYXNlIGVzYWMgZnVuY3Rpb24nLFxuICAgICAgbGl0ZXJhbDpcbiAgICAgICAgJ3RydWUgZmFsc2UnLFxuICAgICAgYnVpbHRfaW46XG4gICAgICAgIC8vIFNoZWxsIGJ1aWx0LWluc1xuICAgICAgICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NoZWxsLUJ1aWx0aW4tQ29tbWFuZHMuaHRtbFxuICAgICAgICAnYnJlYWsgY2QgY29udGludWUgZXZhbCBleGVjIGV4aXQgZXhwb3J0IGdldG9wdHMgaGFzaCBwd2QgcmVhZG9ubHkgcmV0dXJuIHNoaWZ0IHRlc3QgdGltZXMgJyArXG4gICAgICAgICd0cmFwIHVtYXNrIHVuc2V0ICcgK1xuICAgICAgICAvLyBCYXNoIGJ1aWx0LWluc1xuICAgICAgICAnYWxpYXMgYmluZCBidWlsdGluIGNhbGxlciBjb21tYW5kIGRlY2xhcmUgZWNobyBlbmFibGUgaGVscCBsZXQgbG9jYWwgbG9nb3V0IG1hcGZpbGUgcHJpbnRmICcgK1xuICAgICAgICAncmVhZCByZWFkYXJyYXkgc291cmNlIHR5cGUgdHlwZXNldCB1bGltaXQgdW5hbGlhcyAnICtcbiAgICAgICAgLy8gU2hlbGwgbW9kaWZpZXJzXG4gICAgICAgICdzZXQgc2hvcHQgJyArXG4gICAgICAgIC8vIFpzaCBidWlsdC1pbnNcbiAgICAgICAgJ2F1dG9sb2FkIGJnIGJpbmRrZXkgYnllIGNhcCBjaGRpciBjbG9uZSBjb21wYXJndW1lbnRzIGNvbXBjYWxsIGNvbXBjdGwgY29tcGRlc2NyaWJlIGNvbXBmaWxlcyAnICtcbiAgICAgICAgJ2NvbXBncm91cHMgY29tcHF1b3RlIGNvbXB0YWdzIGNvbXB0cnkgY29tcHZhbHVlcyBkaXJzIGRpc2FibGUgZGlzb3duIGVjaG90YyBlY2hvdGkgZW11bGF0ZSAnICtcbiAgICAgICAgJ2ZjIGZnIGZsb2F0IGZ1bmN0aW9ucyBnZXRjYXAgZ2V0bG4gaGlzdG9yeSBpbnRlZ2VyIGpvYnMga2lsbCBsaW1pdCBsb2cgbm9nbG9iIHBvcGQgcHJpbnQgJyArXG4gICAgICAgICdwdXNoZCBwdXNobG4gcmVoYXNoIHNjaGVkIHNldGNhcCBzZXRvcHQgc3RhdCBzdXNwZW5kIHR0eWN0bCB1bmZ1bmN0aW9uIHVuaGFzaCB1bmxpbWl0ICcgK1xuICAgICAgICAndW5zZXRvcHQgdmFyZWQgd2FpdCB3aGVuY2Ugd2hlcmUgd2hpY2ggemNvbXBpbGUgemZvcm1hdCB6ZnRwIHpsZSB6bW9kbG9hZCB6cGFyc2VvcHRzIHpwcm9mICcgK1xuICAgICAgICAnenB0eSB6cmVnZXhwYXJzZSB6c29ja2V0IHpzdHlsZSB6dGNwJyxcbiAgICAgIF86XG4gICAgICAgICctbmUgLWVxIC1sdCAtZ3QgLWYgLWQgLWUgLXMgLWwgLWEnIC8vIHJlbGV2YW5jZSBib29zdGVyXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC9eIyFbXlxcbl0rc2hcXHMqJC8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW46IC9cXHdbXFx3XFxkX10qXFxzKlxcKFxccypcXClcXHMqXFx7LyxcbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwge2JlZ2luOiAvXFx3W1xcd1xcZF9dKi99KV0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICBRVU9URV9TVFJJTkcsXG4gICAgICBBUE9TX1NUUklORyxcbiAgICAgIFZBUlxuICAgIF1cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Jhc2guanMiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEludGFjdCB7XG4gICAgX21vdW50KCkge1xuICAgICAgICB0aGlzLiRib3JkZXIgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmJvcmRlcicpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3JkZXIoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQm9yZGVyKCkge1xuICAgICAgICBjb25zdCAkbmF2ID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJy5hY3RpdmUnKTtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBpZiAoJG5hdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSAkbmF2LnBvc2l0aW9uKCkubGVmdDtcbiAgICAgICAgICAgIHdpZHRoID0gJG5hdi5vdXRlcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYm9yZGVyLmFkZENsYXNzKCd0cmFuc2l0aW9uJyk7XG4gICAgICAgIHRoaXMuJGJvcmRlci5jc3Moe3dpZHRoOiB3aWR0aCwgbGVmdDogbGVmdH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL2xheW91dC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuL25vdycpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwidmFyIGJhc2VSYW5kb20gPSByZXF1aXJlKCcuL19iYXNlUmFuZG9tJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNodWZmbGVTZWxmO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2h1ZmZsZVNlbGYuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MpIHtcbmlmIChtb2R1bGUuaG90KSB7XG4gICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgZGF0YS52ZHQgPSBfX3RoaXM7XG4gICAgICAgIGRhdGEuaXNQYXJlbnQgPSBfX3RoaXMuZGF0YSAhPT0gb2JqO1xuICAgIH0pXG59XG5cbl9WZHQgfHwgKF9WZHQgPSBWZHQpO1xub2JqIHx8IChvYmogPSB7fSk7XG5ibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbnZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG5fX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsXG5fX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG5fc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbl9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbnNlbGYgPSB0aGlzLmRhdGEsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9IHNlbGYgJiYgc2VsZi5fcGFyZW50VGVtcGxhdGVcbmNvbnN0IGxheW91dCA9IHJlcXVpcmUoJy4uL2xheW91dC52ZHQnKTtcblxuY29uc3QgY2F0YWxvZ3MgPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogJ+WfuuehgCcsXG4gICAgICAgIHN1YkNhdGFsb2dzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICflvIDlp4snLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdzdGFydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJbnRhY3Tlrp7kvosnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdpbnN0YW5jZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfnu4Tku7bnlJ/lkb3lkajmnJ8nLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdsaWZlY3ljbGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5qih5p2/6K+t5rOVJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnc3ludGF4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+S6i+S7tuWkhOeQhicsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2V2ZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+ihqOWNleWkhOeQhicsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2Zvcm0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn57uE5Lu2JyxcbiAgICAgICAgICAgICAgICBocmVmOiAnY29tcG9uZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+e7hOS7tue7p+aJvycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2V4dGVuZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ+i/m+mYticsXG4gICAgICAgIHN1YkNhdGFsb2dzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfliqjnlLsnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdhbmltYXRpb24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5qih5p2/dGVtcGxhdGUnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICd0ZW1wbGF0ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfot6/nlLEnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdyb3V0ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnd2VicGFja+Wunui3tScsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3Byb2plY3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5pyN5Yqh5Zmo56uv5riy5p+TJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnc3NyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcbmxldCBjdXJyZW50TmF2ID0ge307XG5cbmNvbnN0IFN1YnMgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFthdHRyLnN1YnNdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpID8gaCgndWwnLCBudWxsLCBfVmR0LnV0aWxzLm1hcChmdW5jdGlvbigpIHt0cnkge3JldHVybiBbYXR0ci5zdWJzXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xucmV0dXJuIGgoJ2xpJywgbnVsbCwgW2goJ2EnLCB7J2V2LWNsaWNrJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3NlbGYuc2Nyb2xsVG8uYmluZChzZWxmLCB2YWx1ZS50aXRsZSwgYXR0ci5zdWJzLmFjdGl2ZSldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpfSwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3ZhbHVlLnRpdGxlXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSksIGgoU3VicywgeydzdWJzJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3ZhbHVlLnN1YnNdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpfSldLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt7XG4gICAgICAgICAgICBhY3RpdmU6IHNlbGYuZ2V0KGF0dHIuc3Vicy5hY3RpdmUpID09PSB2YWx1ZS50aXRsZVxuICAgICAgICB9XVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSkpO1xufSwgdGhpcyksICdzdWItY2F0YWxvZ3MnKSA6IHVuZGVmaW5lZFxufTtcbnJldHVybiAoZnVuY3Rpb24oYmxvY2tzKSB7XG52YXIgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IGV4dGVuZCh7fSwgYmxvY2tzKSwgX29iaiA9IHsnbmF2SW5kZXgnOiAnZG9jdW1lbnQnLCAnY2xhc3NOYW1lJzogJ2RvY3VtZW50LXBhZ2UnfSB8fCB7fTtcbmlmIChfb2JqLmhhc093blByb3BlcnR5KFwiYXJndW1lbnRzXCIpKSB7IGV4dGVuZChfb2JqLCBfb2JqLmFyZ3VtZW50cyA9PT0gdHJ1ZSA/IG9iaiA6IF9vYmouYXJndW1lbnRzKTsgZGVsZXRlIF9vYmouYXJndW1lbnRzOyB9XG5yZXR1cm4gbGF5b3V0LmNhbGwodGhpcywgX29iaiwgX1ZkdCwgKF9ibG9ja3MuY29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCkge3JldHVybiBbaCgnYXNpZGUnLCBudWxsLCBoKCdkaXYnLCBudWxsLCBbX1ZkdC51dGlscy5tYXAoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW2NhdGFsb2dzXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xucmV0dXJuIGgoJ2RpdicsIG51bGwsIFtoKCdoNScsIG51bGwsIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt2YWx1ZS50aXRsZV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykpLCBoKCd1bCcsIG51bGwsIF9WZHQudXRpbHMubWFwKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt2YWx1ZS5zdWJDYXRhbG9nc11bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbnJldHVybiBoKCdsaScsIG51bGwsIFsnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcsIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFsoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaHJlZiA9PT0gc2VsZi5nZXQoJ3RpdGxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROYXYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCAnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcsIGgoJ2EnLCB7J2hyZWYnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbJyMvZG9jdW1lbnQvJyArIHZhbHVlLmhyZWZdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpfSwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3ZhbHVlLnRpdGxlXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSksIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt2YWx1ZS5ocmVmID09PSBzZWxmLmdldCgndGl0bGUnKV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykgPyBoKFN1YnMsIHsnc3Vicyc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtzZWxmLmdldCgnc3ViQ2F0YWxvZ3MnKV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyl9KSA6IHVuZGVmaW5lZF0sIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHZhbHVlLmhyZWYgPT09IHNlbGYuZ2V0KCd0aXRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSkpO1xufSwgdGhpcykpXSwgJ2NhdGFsb2ctc2VjdGlvbicpO1xufSwgdGhpcyksIGgoJ2RpdicsIG51bGwsIG51bGwsICdhc2lkZS1ib3JkZXIgdHJhbnNpdGlvbicpXSwgJ2FzaWRlLXdyYXBwZXInKSksIGgoJ2FydGljbGUnLCBudWxsLCBbaCgnZGl2JywgbnVsbCwgW2goJ2RpdicsIG51bGwsIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtjdXJyZW50TmF2LnRpdGxlXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgJ3RpdGxlJyksIGgoJ2RpdicsIG51bGwsIFsnXFxuICAgICAgICAgICAgICAgICAgICDlpoLmnpzkvaDlj5HnjrDmlofmoaPmnInpl67popjvvIzor7fluK7lv5nlnKhcXG4gICAgICAgICAgICAgICAgICAgICcsIGgoJ2EnLCB7J3RhcmdldCc6ICdfYmxhbmsnLCAnaHJlZic6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtgaHR0cHM6Ly9naXRodWIuY29tL0phdmV5L2phdmV5LmdpdGh1Yi5pby9ibG9iL21hc3Rlci9pbnRhY3QvZG9jcy8ke3NlbGYuZ2V0KCd0aXRsZScpfS5tZGBdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpfSwgJ2dpdGh1YicpLCAnXFxuICAgICAgICAgICAgICAgICAgICDkuIrkv67mraPor6XmlofmoaNcXG4gICAgICAgICAgICAgICAgJ10sICdlZGl0LWxpbmsnKV0sICdhcnRpY2xlLWhlYWQnKSwgaCgnZGl2Jywgeydpbm5lckhUTUwnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbc2VsZi5nZXQoJ2NvbnRlbnQnKV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyl9KV0pXTt9KSAmJiAoX19ibG9ja3MuY29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xudmFyIHNlbGYgPSB0aGlzO1xucmV0dXJuIGJsb2Nrcy5jb250ZW50ID8gYmxvY2tzLmNvbnRlbnQuY2FsbCh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBfYmxvY2tzLmNvbnRlbnQuY2FsbChzZWxmLCBwYXJlbnQpO1xufSkgOiBfYmxvY2tzLmNvbnRlbnQuY2FsbCh0aGlzLCBwYXJlbnQpO1xufSkgJiYgX19ibG9ja3MpfSkuY2FsbCh0aGlzLCBibG9ja3MpXG59XG5pZiAobW9kdWxlLmhvdCkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG4gICAgdmFyIHZkdCA9IG1vZHVsZS5ob3QuZGF0YSAmJiBtb2R1bGUuaG90LmRhdGEudmR0XG4gICAgaWYgKHZkdCkge1xuICAgICAgICBpZiAoIW1vZHVsZS5ob3QuZGF0YS5pc1BhcmVudCkge1xuICAgICAgICAgICAgdmR0LnRlbXBsYXRlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgdmR0LnVwZGF0ZSgpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC52ZHQiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vZG9jdW1lbnQuc3R5bFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vZG9jdW1lbnQuc3R5bFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vZG9jdW1lbnQuc3R5bFwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaGxqcyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG92ZXJmbG93LXg6IGF1dG87XFxuICBjb2xvcjogIzUyNTI1MjtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxufVxcbi5obGpzLWRvY3R5cGUge1xcbiAgY29sb3I6ICM5OTk7XFxufVxcbi5obGpzLXRhZyB7XFxuICBjb2xvcjogIzNlNzZmNjtcXG59XFxuLmhsanMtYXR0cmlidXRlIHtcXG4gIGNvbG9yOiAjZTk2OTAwO1xcbn1cXG4uaGxqcy12YWx1ZSB7XFxuICBjb2xvcjogIzQyYjk4MztcXG59XFxuLmhsanMta2V5d29yZCB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmhsanMtc3RyaW5nIHtcXG4gIGNvbG9yOiAjNDJiOTgzO1xcbn1cXG4uaGxqcy1jb21tZW50IHtcXG4gIGNvbG9yOiAjYjNiM2IzO1xcbn1cXG4uaGxqcy1vcGVyYXRvciAuaGxqcy1jb21tZW50IHtcXG4gIGNvbG9yOiAjNTI1MjUyO1xcbn1cXG4uaGxqcy1yZWdleHAge1xcbiAgY29sb3I6ICNhZjdkZmY7XFxufVxcbi5obGpzLWJ1aWx0X2luIHtcXG4gIGNvbG9yOiAjMmRiN2Y1O1xcbn1cXG4uY3NzIC5obGpzLWNsYXNzIHtcXG4gIGNvbG9yOiAjZTk2OTAwO1xcbn1cXG4uY3NzIC5obGpzLW51bWJlcixcXG4uamF2YXNjcmlwdCAuaGxqcy1udW1iZXIge1xcbiAgY29sb3I6ICNmYzFlNzA7XFxufVxcbi5jc3MgLmhsanMtYXR0cmlidXRlIHtcXG4gIGNvbG9yOiAjYWY3ZGZmO1xcbn1cXG4uY3NzIC5obGpzLWltcG9ydGFudCB7XFxuICBjb2xvcjogI2QwNDtcXG59XFxuLmFjdGlvbnNjcmlwdCAuaGxqcy1saXRlcmFsLFxcbi5qYXZhc2NyaXB0IC5obGpzLWxpdGVyYWwge1xcbiAgY29sb3I6ICNmYzFlNzA7XFxufVxcbnByZSB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5jb2RlIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJhY2tncm91bmQ6ICNmN2Y3Zjc7XFxuICBmb250LWZhbWlseTogQ29uc29sYXMsIE1vbmFjbywgQW5kYWxlIE1vbm8sIFVidW50dSBNb25vLCBtb25vc3BhY2U7XFxuICBtYXJnaW46IDNweDtcXG4gIHBhZGRpbmc6IDFweCA1cHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBjb2xvcjogIzY2NjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuLmRvY3VtZW50LXBhZ2Uge1xcbiAgcGFkZGluZy10b3A6IDk1cHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyLmZpeGVkIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIuZml4ZWQgYXNpZGUge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiA4MHB4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGhlaWdodDogY2FsYygxMDAlIC0gODBweCk7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIuZml4ZWQgYXJ0aWNsZSB7XFxuICBtYXJnaW4tbGVmdDogMjAwcHg7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIge1xcbiAgd2lkdGg6IDEwODBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgwLDAsMCwwLjA4KTtcXG4gIG1pbi1oZWlnaHQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFzaWRlIHtcXG4gIHdpZHRoOiAyMDBweDtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNlZWU7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIGg1IHtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIG1hcmdpbjogMjVweCAwIDE1cHggMjBweDtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIHVsIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIGEge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDMwcHg7XFxuICBsaW5lLWhlaWdodDogMzBweDtcXG4gIHBhZGRpbmctbGVmdDogMjVweDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIGE6aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2YzZjNmMztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciAuYWN0aXZlID4gYSB7XFxuICBjb2xvcjogI2ZlNDQ0NDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciAuc3ViLWNhdGFsb2dzIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIC5hc2lkZS1ib3JkZXIge1xcbiAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgI2ZlNDQ0NDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUge1xcbiAgZmxleDogMTtcXG4gIHBhZGRpbmc6IDEwcHggMjBweDtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hcnRpY2xlLWhlYWQgLnRpdGxlIHtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG4gIGZvbnQtc2l6ZTogMi4yZW07XFxuICBjb2xvcjogIzAwMDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXJ0aWNsZS1oZWFkIC5lZGl0LWxpbmsge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDIwcHg7XFxuICBjb2xvcjogIzk5OTtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIGgxIHtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbiAgbWFyZ2luOiAyMHB4IDA7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSBoMixcXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgaDMge1xcbiAgcGFkZGluZzogMTBweCAwO1xcbiAgbWFyZ2luOiAxNXB4IDA7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSBwIHtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgLm91dHB1dCB7XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIG1hcmdpbjogMjBweCAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXI/e1wiaW5jbHVkZSBjc3NcIjp0cnVlfSEuL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWxcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwidmFyIGFycmF5U2h1ZmZsZSA9IHJlcXVpcmUoJy4vX2FycmF5U2h1ZmZsZScpLFxuICAgIGJhc2VTaHVmZmxlID0gcmVxdWlyZSgnLi9fYmFzZVNodWZmbGUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2h1ZmZsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2h1ZmZsZS5qcyIsInZhciBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBzaHVmZmxlU2VsZiA9IHJlcXVpcmUoJy4vX3NodWZmbGVTZWxmJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTaHVmZmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTaHVmZmxlLmpzIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJhbmRvbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSYW5kb20uanMiLCJ2YXIgc2h1ZmZsZVNlbGYgPSByZXF1aXJlKCcuL19zaHVmZmxlU2VsZicpLFxuICAgIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2h1ZmZsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTaHVmZmxlLmpzIiwidmFyIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3ZhbHVlcy5qcyIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVmFsdWVzLmpzIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==