webpackJsonp([0,1],Array(35).concat([
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _document = __webpack_require__(126);

var _document2 = _interopRequireDefault(_document);

var _document3 = __webpack_require__(127);

var _document4 = _interopRequireDefault(_document3);

var _throttle = __webpack_require__(129);

var _throttle2 = _interopRequireDefault(_throttle);

var _shuffle = __webpack_require__(135);

var _shuffle2 = _interopRequireDefault(_shuffle);

var _debounce = __webpack_require__(120);

var _debounce2 = _interopRequireDefault(_debounce);

var _utils = __webpack_require__(56);

var _layout = __webpack_require__(118);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

// for debug
window.Intact = Intact;
window._ = { throttle: _throttle2['default'], shuffle: _shuffle2['default'], debounce: _debounce2['default'] };
window.$ = $;

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Layout) {
    _inherits(_default, _Layout);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Layout.apply(this, arguments));
    }

    _default.prototype._init = function _init() {
        var _this2 = this;

        return fetch('./docs/' + this.get('title') + '.md').then(function (response) {
            return response.text();
        }).then(function (md) {
            _this2.set('content', _utils.marked.render(md));
        });
    };

    _default.prototype._mount = function _mount() {
        _Layout.prototype._mount.call(this);
        var codes = this.element.querySelectorAll('pre code');
        codes.forEach(function (item) {
            _utils.highlight.highlightBlock(item);
        });
        var catalogs = [];
        catalogs.active = 'active1';
        this.element.querySelectorAll('h1').forEach(function (item) {
            var catalog = { title: item.innerText };
            var nextSibling = item.nextSibling;
            while (nextSibling) {
                var tagName = (nextSibling.tagName || '').toLowerCase();
                if (tagName === 'h1') break;
                if (tagName === 'h2') {
                    if (!catalog.subs) {
                        catalog.subs = [];
                        catalog.subs.active = 'active2';
                    }
                    catalog.subs.push({
                        title: nextSibling.innerText
                    });
                }
                nextSibling = nextSibling.nextSibling;
            }
            catalogs.push(catalog);
        });
        this.set('subCatalogs', catalogs);

        this.evalScript();
        this.onScroll();
    };

    _default.prototype.evalScript = function evalScript() {
        var $examples = $(this.element).find('.example');
        var template = void 0;
        for (var i = 0; i < $examples.length; i++) {
            var $example = $examples.eq(i);
            var code = $example.text();
            if ($example.hasClass('auto')) {
                var _C = void 0;
                if ($example.hasClass('language-html')) {
                    template = Intact.Vdt.compile(code);
                    _C = Intact.extend({
                        template: template
                    });
                } else if ($example.hasClass('javascript')) {
                    _C = eval(code);
                }
                var $container = $('<div class="output"></div>');
                $example.parent().after($container);
                Intact.mount(_C, $container[0]);
            } else if ($example.hasClass('manual')) {
                var $button = $('<button>点击运行</button>');
                var $p = $('<p></p>').append($button);
                $example.parent().after($p);
                $button.on('click', function (code) {
                    return function () {
                        eval(code);
                    };
                }(code));
            } else if ($example.hasClass('language-html')) {
                template = Intact.Vdt.compile(code);
            } else if ($example.hasClass('javascript')) {
                eval(code);
            } else if ($example.hasClass('language-css')) {
                $example.parent().after('<style>' + code + '</style>');
            }
        }

        // 执行script标签
        var $scripts = $(this.element).find('script');
        for (var _i = 0; _i < $scripts.length; _i++) {
            var $script = $scripts.eq(_i);
            var _code = $script.text();
            eval(_code);
        }
    };

    _default.prototype.onScroll = function onScroll() {
        var _this3 = this;

        var $wrapper = $(this.element).find('.content-wrapper');
        var $article = $(this.element).find('article');
        var $h1s = $article.find('h1');
        var $h2s = $article.find('h2');
        var $aside = $(this.element).find('aside');
        var $border = $aside.find('.aside-border');
        var $window = $(window);
        $window.off('scroll');
        $window.on('scroll.fix', function () {
            var scrollTop = $(window).scrollTop();
            $wrapper[scrollTop >= 15 ? 'addClass' : 'removeClass']('fixed');
        });
        $window.on('scroll.active', (0, _throttle2['default'])(function () {
            var scrollTop = $(window).scrollTop();

            function findActive($hs) {
                var minTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                for (var i = $hs.length - 1; i >= 0; i--) {
                    var $h = $hs.eq(i);
                    var top = $h.position().top;
                    if (top > minTop && scrollTop >= top - 60) {
                        return {
                            text: $h.text(),
                            top: top
                        };
                    }
                }
                return { text: '', top: 0 };
            }

            var active1 = findActive($h1s);
            var active2 = findActive($h2s, active1.top);

            _this3.set({
                active2: active2.text,
                active1: active1.text
            });

            var $activeA = $aside.find('.active').last().children('a');
            if ($activeA.length) {
                var height = $activeA.height();
                var top = $activeA.position().top;
                $border.css({ height: height, top: top });
            }
        }, 50));
        $window.trigger('scroll');
    };

    _default.prototype.scrollTo = function scrollTo(text, type) {
        var _this4 = this;

        var $article = $(this.element).find('article');
        var $hs = $article.find(type === 'active1' ? 'h1' : 'h2');

        for (var i = 0; i < $hs.length; i++) {
            var $h = $hs.eq(i);
            if ($h.text() === text) {
                var top = $h.position().top;
                $(window).off('scroll.active');
                $('html, body').animate({
                    scrollTop: top - 60
                }, {
                    complete: function complete() {
                        _this4.onScroll();
                    }
                });
                break;
            }
        }
    };

    _default.prototype._destroy = function _destroy() {
        $(window).off('scroll');
    };

    return _default;
}(_layout2['default']), _class2.template = _document2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(16)))

/***/ }),
/* 36 */,
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact) {exports.__esModule = true;
exports['default'] = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _desc, _value, _class;

var _document = __webpack_require__(35);

var _document2 = _interopRequireDefault(_document);

var _api = __webpack_require__(164);

var _api2 = _interopRequireDefault(_api);

var _api3 = __webpack_require__(165);

var _api4 = _interopRequireDefault(_api3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = function (_DocumentPage) {
    _inherits(_default, _DocumentPage);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _DocumentPage.apply(this, arguments));
    }

    _createClass(_default, [{
        key: 'template',
        get: function get() {
            return _api2['default'];
        }
    }]);

    return _default;
}(_document2['default']), (_applyDecoratedDescriptor(_class.prototype, 'template', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'template'), _class.prototype)), _class));

exports['default'] = _default;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(45);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(39);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(46);
exports.lib.ucmicro = __webpack_require__(64);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 40 */
/***/ (function(module, exports) {



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 41 */
/***/ (function(module, exports) {



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(122),
    getRawTag = __webpack_require__(133),
    objectToString = __webpack_require__(134);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {



/*eslint quotes:0*/
module.exports = __webpack_require__(59);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {



module.exports.encode = __webpack_require__(60);
module.exports.decode = __webpack_require__(61);
module.exports.format = __webpack_require__(62);
module.exports.parse = __webpack_require__(63);

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 50 */
/***/ (function(module, exports) {



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 51 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 52 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 53 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(121);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.marked = exports.highlight = undefined;

var _markdownIt = __webpack_require__(57);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _markdownItDecorate = __webpack_require__(112);

var _markdownItDecorate2 = _interopRequireDefault(_markdownItDecorate);

var _highlight = __webpack_require__(113);

var _highlight2 = _interopRequireDefault(_highlight);

var _javascript = __webpack_require__(114);

var _javascript2 = _interopRequireDefault(_javascript);

var _css = __webpack_require__(115);

var _css2 = _interopRequireDefault(_css);

var _xml = __webpack_require__(116);

var _xml2 = _interopRequireDefault(_xml);

var _bash = __webpack_require__(117);

var _bash2 = _interopRequireDefault(_bash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_highlight2['default'].registerLanguage('bash', _bash2['default']);
_highlight2['default'].registerLanguage('css', _css2['default']);
_highlight2['default'].registerLanguage('javascript', _javascript2['default']);
_highlight2['default'].registerLanguage('xml', _xml2['default']);

window.highlight = _highlight2['default'];

var marked = (0, _markdownIt2['default'])({
    html: true,
    breaks: false
}).use(_markdownItDecorate2['default']);
// 去掉段落softbreak
marked.renderer.rules.softbreak = function () {
    return '';
};

exports.highlight = _highlight2['default'];
exports.marked = marked;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = __webpack_require__(58);

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {



var utils = __webpack_require__(38);
var helpers = __webpack_require__(66);
var Renderer = __webpack_require__(70);
var ParserCore = __webpack_require__(71);
var ParserBlock = __webpack_require__(79);
var ParserInline = __webpack_require__(93);
var LinkifyIt = __webpack_require__(106);
var mdurl = __webpack_require__(46);
var punycode = __webpack_require__(108);

var config = {
  'default': __webpack_require__(109),
  zero: __webpack_require__(110),
  commonmark: __webpack_require__(111)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 60 */
/***/ (function(module, exports) {



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 61 */
/***/ (function(module, exports) {



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 62 */
/***/ (function(module, exports) {



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 63 */
/***/ (function(module, exports) {



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {



exports.Any = __webpack_require__(47);
exports.Cc = __webpack_require__(48);
exports.Cf = __webpack_require__(65);
exports.P = __webpack_require__(39);
exports.Z = __webpack_require__(49);

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {



exports.parseLinkLabel = __webpack_require__(67);
exports.parseLinkDestination = __webpack_require__(68);
exports.parseLinkTitle = __webpack_require__(69);

/***/ }),
/* 67 */
/***/ (function(module, exports) {



module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;
var unescapeAll = __webpack_require__(38).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {



var unescapeAll = __webpack_require__(38).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {



var assign = __webpack_require__(38).assign;
var unescapeAll = __webpack_require__(38).unescapeAll;
var escapeHtml = __webpack_require__(38).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

var _rules = [['normalize', __webpack_require__(72)], ['block', __webpack_require__(73)], ['inline', __webpack_require__(74)], ['linkify', __webpack_require__(75)], ['replacements', __webpack_require__(76)], ['smartquotes', __webpack_require__(77)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(78);

module.exports = Core;

/***/ }),
/* 72 */
/***/ (function(module, exports) {



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 73 */
/***/ (function(module, exports) {



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 74 */
/***/ (function(module, exports) {



module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {



var arrayReplaceAt = __webpack_require__(38).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 76 */
/***/ (function(module, exports) {



// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {



var isWhiteSpace = __webpack_require__(38).isWhiteSpace;
var isPunctChar = __webpack_require__(38).isPunctChar;
var isMdAsciiPunct = __webpack_require__(38).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(80), ['paragraph', 'reference']], ['code', __webpack_require__(81)], ['fence', __webpack_require__(82), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(83), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(84), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(85), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(86)], ['heading', __webpack_require__(87), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(88)], ['html_block', __webpack_require__(89), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(91)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(92);

module.exports = ParserBlock;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 81 */
/***/ (function(module, exports) {



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 82 */
/***/ (function(module, exports) {



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false;

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !wasOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 88 */
/***/ (function(module, exports) {



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {



var block_names = __webpack_require__(90);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(50).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 90 */
/***/ (function(module, exports) {



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 91 */
/***/ (function(module, exports) {



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);
var isSpace = __webpack_require__(38).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(94)], ['newline', __webpack_require__(95)], ['escape', __webpack_require__(96)], ['backticks', __webpack_require__(97)], ['strikethrough', __webpack_require__(51).tokenize], ['emphasis', __webpack_require__(52).tokenize], ['link', __webpack_require__(98)], ['image', __webpack_require__(99)], ['autolink', __webpack_require__(100)], ['html_inline', __webpack_require__(101)], ['entity', __webpack_require__(102)]];

var _rules2 = [['balance_pairs', __webpack_require__(103)], ['strikethrough', __webpack_require__(51).postProcess], ['emphasis', __webpack_require__(52).postProcess], ['text_collapse', __webpack_require__(104)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(105);

module.exports = ParserInline;

/***/ }),
/* 94 */
/***/ (function(module, exports) {



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 97 */
/***/ (function(module, exports) {



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 100 */
/***/ (function(module, exports) {



/*eslint max-len:0*/
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {



var HTML_TAG_RE = __webpack_require__(50).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {



var entities = __webpack_require__(45);
var has = __webpack_require__(38).has;
var isValidEntityCode = __webpack_require__(38).isValidEntityCode;
var fromCodePoint = __webpack_require__(38).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 103 */
/***/ (function(module, exports) {



module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 104 */
/***/ (function(module, exports) {



module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);
var isWhiteSpace = __webpack_require__(38).isWhiteSpace;
var isPunctChar = __webpack_require__(38).isPunctChar;
var isMdAsciiPunct = __webpack_require__(38).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(107)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(47).source;
  re.src_Cc = __webpack_require__(48).source;
  re.src_Z = __webpack_require__(49).source;
  re.src_P = __webpack_require__(39).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(53)) == 'object' && __webpack_require__(53)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module), __webpack_require__(54)))

/***/ }),
/* 109 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 110 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {


/* eslint-disable no-cond-assign */

var tagExpr = /^<!-- ?\{(?:([a-z0-9]+)(\^[0-9]*)?: ?)?(.*)\} ?-->\n?$/;

module.exports = function attributes(md) {
  md.core.ruler.push('curly_attributes', curlyAttrs);
};

/*
 * List of tag -> token type mappings. Eg, `<li>` is `list_item_open`.
 */

var opening = {
  li: ['list_item'],
  ul: ['bullet_list'],
  p: ['paragraph'],
  ol: ['ordered_list'],
  blockquote: ['blockquote'],
  h1: ['heading'],
  h2: ['heading'],
  h3: ['heading'],
  h4: ['heading'],
  h5: ['heading'],
  h6: ['heading'],
  a: ['link'],
  code: ['code_inline', 'code_block', 'fence']
};

var selfClosing = {
  hr: true,
  image: true

  /**
   * ...
   */

};function curlyAttrs(state) {
  var tokens = state.tokens;
  var omissions = [];
  var parent, m;
  var stack = { len: 0, contents: [], types: {} };

  tokens.forEach(function (token, i) {
    // Save breadcrumbs so html_block will pick it up
    if (isOpener(token.type) || selfClosing[token.type]) {
      spush(stack, token);
    }

    // "# Hello\n<!--{.classname}-->"
    // ...sequence of [heading_open, inline, heading_close, html_block]
    if (token.type === 'html_block') {
      m = token.content.match(tagExpr);
      if (!m) return;

      parent = findParent(stack, m[1], m[2]);
      if (parent && applyToToken(parent, m[3])) {
        omissions.unshift(i);
      }
    }

    // "# Hello <!--{.classname} -->"
    // { type: 'inline', children: { ..., '<!--{...}-->' } }
    if (token.type === 'inline') {
      curlyInline(token.children, stack);
    }
  });

  // Remove <!--...--> html_block tokens
  omissions.forEach(function (idx) {
    return tokens.splice(idx, 1);
  });
}

/**
 * Internal: checks in a token type is a block opener
 */

function isOpener(type) {
  return type.match(/_(open|start)$/) || type === 'fence' || type === 'code_block';
}

/**
 * Internal: Run through inline and stuff
 */

function curlyInline(children, stack) {
  var lastText, m, parent;

  // Keep a list of sub-tokens to be removed
  var omissions = [];

  children.forEach(function (child, i) {
    if (isOpener(child.type) || selfClosing[child.type] || child.type === 'code_inline') {
      spush(stack, child);
    }

    // Decorate tags are found
    if (m = child.content.match(tagExpr)) {
      var tag = m[1];
      var depth = m[2];
      var attrs = m[3];

      // Remove the comment, then remove the extra space
      parent = findParent(stack, tag, depth);
      if (parent && applyToToken(parent, attrs)) {
        omissions.unshift(i);
        if (lastText) trimRight(lastText, 'content');
      }
    }

    if (child.type === 'text') lastText = child;
  });

  // Remove them in a separate step so we don't
  omissions.forEach(function (idx) {
    children.splice(idx, 1);
  });
}

/**
 * Private: given a list of tokens `list` and `lastParent`, find the one that
 * matches `tag`.
 */

function findParent(stack, tag, depth) {
  if (!tag) return stack.last;

  if (depth === '^') {
    depth = 1;
  } else if (typeof depth === 'string') {
    /* '^2' */
    depth = +depth.substr(1);
  } else {
    depth = 0;
  }

  var targets = opening[tag.toLowerCase()] || [tag.toLowerCase()];

  var target = targets.filter(function (target) {
    return stack.types[target];
  });

  var list = stack.types[target];
  if (!list) return; // Can't find tag `tag`

  return list[list.length - 1 - depth];
}

/**
 * Private: trim the right
 */

function trimRight(obj, attr) {
  obj[attr] = obj[attr].replace(/\s*$/, '');
}

/**
 * Private: apply tag to token
 *
 *     applyToToken(token, '.classname')
 */

function applyToToken(token, attrs) {
  var m;
  var todo = [];

  while (attrs.length > 0) {
    if (m = attrs.match(/^\s*\.([a-zA-Z0-9\-_]+)/)) {
      todo.push(['class', m[1], { append: true }]);
      shift();
    } else if (m = attrs.match(/^\s*#([a-zA-Z0-9\-_]+)/)) {
      todo.push(['id', m[1]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)="([^"]*)"/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)='([^']*)'/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)=([^ ]*)/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)/)) {
      todo.push([m[1], '']);
      shift();
    } else if (m = attrs.match(/^\s+/)) {
      shift();
    } else {
      return;
    }
  }

  todo.forEach(function (args) {
    setAttr.apply(this, [token].concat(args));
  });
  return true;

  function shift() {
    attrs = attrs.substr(m[0].length);
  }
}

/**
 * Private: sets an attribute `attr` to `value` in a token. If `options.append`
 * is true, append to the old value instead of overwriting it.
 */

function setAttr(token, attr, value, options) {
  var idx = token.attrIndex(attr);

  if (idx === -1) {
    token.attrPush([attr, value]);
  } else if (options && options.append) {
    token.attrs[idx][1] = token.attrs[idx][1] + ' ' + value;
  } else {
    token.attrs[idx][1] = value;
  }
}

/**
 * Private: pushes a token to the stack
 */

function spush(stack, token) {
  var type = token.type.replace(/_(open|start)$/, '');
  if (!stack.types[type]) {
    stack.types[type] = [];
  }
  stack.types[type].push(token);
  stack.last = token;
}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function (factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if (true) {
    factory(exports);
  } else if (globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return globalObject.hljs;
      });
    }
  }
})(function (hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent) {
    // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent) {
      result[key] = parent[key];
    }objects.forEach(function (obj) {
      for (key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:
       if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;
       ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace('"', '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function expand_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function (variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];
  }

  function compileLanguage(language) {

    function reStr(re) {
      return re && re.source || re;
    }

    function langRe(value, global) {
      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }

    function compileMode(mode, parent) {
      if (mode.compiled) return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function flatten(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function (kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') {
          // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin) mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null) mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {
        return expand_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function (c) {
        compileMode(c, mode);
      });

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = mode.contains.map(function (c) {
        return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function exec() /*s*/{
          return null;
        } };
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:
   - relevance (int)
  - value (an HTML string with highlighting markup)
   */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan = '<span class="' + classPrefix,
          closeSpan = leaveOpen ? '' : spanEndTag;

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords) return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += top.subLanguage != null ? processSubLanguage() : processKeywords();
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className ? buildSpan(mode.className, '', true) : '';
      top = Object.create(mode, { parent: { value: top } });
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '',
        current;
    for (current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match,
          count,
          index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match) break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:
   - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)
   */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:
   - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers
   */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {
      if (options.useBR && match === '\n') {
        return '<br>';
      } else if (options.tabReplace) {
        return p1.replace(/\t/g, options.tabReplace);
      }
      return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language)) return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function (alias) {
        aliases[alias] = name;
      });
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
      className: 'comment',
      begin: begin, end: end,
      contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [hljs.BACKSLASH_ESCAPE, {
      begin: /\[/, end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
});

/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' +
    // ECMAScript 6 modules import
    'import from as',

    literal: 'true false null undefined NaN Infinity',
    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'
  };
  var EXPRESSIONS;
  var NUMBER = {
    className: 'number',
    variants: [{ begin: '\\b(0[bB][01]+)' }, { begin: '\\b(0[oO][0-7]+)' }, { begin: hljs.C_NUMBER_RE }],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: [] // defined later
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];
  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);

  return {
    aliases: ['js', 'jsx'],
    keywords: KEYWORDS,
    contains: [{
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, {
      className: 'meta',
      begin: /^#!/, end: /$/
    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, { // object attr container
      begin: /[{,]\s*/, relevance: 0,
      contains: [{
        begin: IDENT_RE + '\\s*:', returnBegin: true,
        relevance: 0,
        contains: [{ className: 'attr', begin: IDENT_RE, relevance: 0 }]
      }]
    }, { // "value" container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
      keywords: 'return throw case',
      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {
        className: 'function',
        begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
        end: '\\s*=>',
        contains: [{
          className: 'params',
          variants: [{
            begin: IDENT_RE
          }, {
            begin: /\(\s*\)/
          }, {
            begin: /\(/, end: /\)/,
            excludeBegin: true, excludeEnd: true,
            keywords: KEYWORDS,
            contains: PARAMS_CONTAINS
          }]
        }]
      }, { // E4X / JSX
        begin: /</, end: /(\/\w+|\w+\/)>/,
        subLanguage: 'xml',
        contains: [{ begin: /<\w+\s*\/>/, skip: true }, {
          begin: /<\w+/, end: /(\/\w+|\w+\/)>/, skip: true,
          contains: [{ begin: /<\w+\s*\/>/, skip: true }, 'self']
        }]
      }],
      relevance: 0
    }, {
      className: 'function',
      beginKeywords: 'function', end: /\{/, excludeEnd: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }), {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        contains: PARAMS_CONTAINS
      }],
      illegal: /\[|%/
    }, {
      begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
    }, hljs.METHOD_GUARD, { // ES6 class
      className: 'class',
      beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
      illegal: /[:"\[\]]/,
      contains: [{ beginKeywords: 'extends' }, hljs.UNDERSCORE_TITLE_MODE]
    }, {
      beginKeywords: 'constructor', end: /\{/, excludeEnd: true
    }],
    illegal: /#(?!!)/
  };
};

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /[A-Z\_\.\-]+\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [{
      className: 'attribute',
      begin: /\S/, end: ':', excludeEnd: true,
      starts: {
        endsWithParent: true, excludeEnd: true,
        contains: [{
          begin: /[\w-]+\(/, returnBegin: true,
          contains: [{
            className: 'built_in',
            begin: /[\w-]+/
          }, {
            begin: /\(/, end: /\)/,
            contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
          }]
        }, hljs.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, hljs.C_BLOCK_COMMENT_MODE, {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        }, {
          className: 'meta', begin: '!important'
        }]
      }
    }]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [hljs.C_BLOCK_COMMENT_MODE, {
      className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
    }, {
      className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
    }, {
      className: 'selector-attr',
      begin: /\[/, end: /\]/,
      illegal: '$'
    }, {
      className: 'selector-pseudo',
      begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
    }, {
      begin: '@(font-face|page)',
      lexemes: '[a-z-]+',
      keywords: 'font-face page'
    }, {
      begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
      // because it doesn’t let it to be parsed as
      // a rule set but instead drops parser into
      // the default mode which is how it should be.
      illegal: /:/, // break on Less variables @var: ...
      contains: [{
        className: 'keyword',
        begin: /\w+/
      }, {
        begin: /\s/, endsWithParent: true, excludeEnd: true,
        relevance: 0,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, hljs.CSS_NUMBER_MODE]
      }]
    }, {
      className: 'selector-tag', begin: IDENT_RE,
      relevance: 0
    }, {
      begin: '{', end: '}',
      illegal: /\S/,
      contains: [hljs.C_BLOCK_COMMENT_MODE, RULE]
    }]
  };
};

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [{
      className: 'attr',
      begin: XML_IDENT_RE,
      relevance: 0
    }, {
      begin: /=\s*/,
      relevance: 0,
      contains: [{
        className: 'string',
        endsParent: true,
        variants: [{ begin: /"/, end: /"/ }, { begin: /'/, end: /'/ }, { begin: /[^\s"'=<>`]+/ }]
      }]
    }]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
    case_insensitive: true,
    contains: [{
      className: 'meta',
      begin: '<!DOCTYPE', end: '>',
      relevance: 10,
      contains: [{ begin: '\\[', end: '\\]' }]
    }, hljs.COMMENT('<!--', '-->', {
      relevance: 10
    }), {
      begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
      relevance: 10
    }, {
      begin: /<\?(php)?/, end: /\?>/,
      subLanguage: 'php',
      contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
    }, {
      className: 'tag',
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending braket. The '$' is needed for the lexeme to be recognized
      by hljs.subMode() that tests lexemes outside the stream.
      */
      begin: '<style(?=\\s|>|$)', end: '>',
      keywords: { name: 'style' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '</style>', returnEnd: true,
        subLanguage: ['css', 'xml']
      }
    }, {
      className: 'tag',
      // See the comment in the <style tag about the lookahead pattern
      begin: '<script(?=\\s|>|$)', end: '>',
      keywords: { name: 'script' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '\<\/script\>', returnEnd: true,
        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
      }
    }, {
      className: 'meta',
      variants: [{ begin: /<\?xml/, end: /\?>/, relevance: 10 }, { begin: /<\?\w+/, end: /\?>/ }]
    }, {
      className: 'tag',
      begin: '</?', end: '/?>',
      contains: [{
        className: 'name', begin: /[^\/><\s]+/, relevance: 0
      }, TAG_INTERNALS]
    }]
  };
};

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var VAR = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d#@][\w\d_]*/ }, { begin: /\$\{(.*?)}/ }]
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: /"/, end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, {
      className: 'variable',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  var APOS_STRING = {
    className: 'string',
    begin: /'/, end: /'/
  };

  return {
    aliases: ['sh', 'zsh'],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: 'if then else elif fi for while in do done case esac function',
      literal: 'true false',
      built_in:
      // Shell built-ins
      // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' + 'trap umask unset ' +
      // Bash built-ins
      'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' + 'read readarray source type typeset ulimit unalias ' +
      // Shell modifiers
      'set shopt ' +
      // Zsh built-ins
      'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' + 'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' + 'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' + 'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' + 'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' + 'zpty zregexparse zsocket zstyle ztcp',
      _: '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster
    },
    contains: [{
      className: 'meta',
      begin: /^#![^\n]+sh\s*$/,
      relevance: 10
    }, {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, hljs.HASH_COMMENT_MODE, QUOTE_STRING, APOS_STRING, VAR]
  };
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _layout = __webpack_require__(119);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Intact) {
    _inherits(_default, _Intact);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _default.prototype._mount = function _mount() {
        this.$border = $(this.element).find('.border');
        this._updateBorder();
    };

    _default.prototype._updateBorder = function _updateBorder() {
        var $nav = $(this.element).find('.active');
        var width = 0;
        var left = 0;
        if ($nav.length) {
            left = $nav.position().left;
            width = $nav.outerWidth();
        }
        this.$border.addClass('transition');
        this.$border.css({ width: width, left: left });
    };

    return _default;
}(Intact), _class2.template = _layout2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(16)))

/***/ }),
/* 119 */
/***/ (function(module, exports) {

exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;
    var nav = [{
        title: '教程',
        href: 'document'
    }, {
        title: 'API',
        href: 'api'
    }];
    return h('div', null, [h('div', null, h('header', null, (_blocks["header"] = function (parent) {
        return [h('a', { 'href': '#/' }, 'Intact', 'logo'), h('nav', null, [_Vdt.utils.map(function () {
            try {
                return [nav][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), function (value, key) {
            return h('a', { 'href': function () {
                    try {
                        return ['#/' + value.href][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, function () {
                try {
                    return [value.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this), _className(function () {
                try {
                    return [{
                        active: value.href === scope.navIndex
                    }][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)));
        }, this), h('div', null, null, 'border')])];
    }) && (__blocks["header"] = function (parent) {
        var self = this;
        return blocks["header"] ? blocks["header"].call(this, function () {
            return _blocks["header"].call(self, parent);
        }) : _blocks["header"].call(this, parent);
    }) && __blocks["header"].call(this)), 'header-wrapper'), h('div', null, (_blocks["content"] = function (parent) {
        return null;
    }) && (__blocks["content"] = function (parent) {
        var self = this;
        return blocks["content"] ? blocks["content"].call(this, function () {
            return _blocks["content"].call(self, parent);
        }) : _blocks["content"].call(this, parent);
    }) && __blocks["content"].call(this), 'content-wrapper')], _className(function () {
        try {
            return ['main-wrapper ' + (scope.className || '')][0];
        } catch (e) {
            _e(e);
        }
    }.call(this)));
};

module.exports = exports['default'];

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(42),
    now = __webpack_require__(130),
    toNumber = __webpack_require__(131);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(55);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom = __webpack_require__(138);

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
    var index = -1,
        length = array.length,
        lastIndex = length - 1;

    size = size === undefined ? length : size;
    while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
    }
    array.length = size;
    return array;
}

module.exports = shuffleSelf;

/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 125 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 126 */
/***/ (function(module, exports) {

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;
    var catalogs = [{
        title: '基础',
        subCatalogs: [{
            title: '开始',
            href: 'start'
        }, {
            title: 'Intact实例',
            href: 'instance'
        }, {
            title: '组件生命周期',
            href: 'lifecycle'
        }, {
            title: '模板语法',
            href: 'syntax'
        }, {
            title: '事件处理',
            href: 'event'
        }, {
            title: '表单处理',
            href: 'form'
        }, {
            title: '组件',
            href: 'component'
        }, {
            title: '组件继承',
            href: 'extend'
        }]
    }, {
        title: '进阶',
        subCatalogs: [{
            title: '动画',
            href: 'animation'
        }, {
            title: '模板template',
            href: 'template'
        }, {
            title: '路由',
            href: 'router'
        }, {
            title: 'webpack实践',
            href: 'project'
        }, {
            title: '服务器端渲染',
            href: 'ssr'
        }]
    }];
    var currentNav = {};

    var Subs = function Subs(attr) {
        return function () {
            try {
                return [attr.subs][0];
            } catch (e) {
                _e(e);
            }
        }.call(this) ? h('ul', null, _Vdt.utils.map(function () {
            try {
                return [attr.subs][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), function (value, key) {
            return h('li', null, [h('a', { 'ev-click': function () {
                    try {
                        return [self.scrollTo.bind(self, value.title, attr.subs.active)][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, function () {
                try {
                    return [value.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)), h(Subs, { 'subs': function () {
                    try {
                        return [value.subs][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this), 'children': null, '_context': $this })], _className(function () {
                try {
                    return [{
                        active: self.get(attr.subs.active) === value.title
                    }][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)));
        }, this), 'sub-catalogs') : undefined;
    };
    return function () {
        var _obj = _extends({ 'navIndex': 'document', 'className': 'document-page' }, function () {
            try {
                return [scope][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), { 'children': null });
        if (_obj.hasOwnProperty("arguments")) {
            extend(_obj, _obj.arguments === true ? obj : _obj.arguments);
            delete _obj.arguments;
        }
        return parent.call(this, _obj, _Vdt, function (blocks) {
            var _blocks = {},
                __blocks = extend({}, blocks);
            return (_blocks["content"] = function (parent) {
                return [h('aside', null, h('div', null, [_Vdt.utils.map(function () {
                    try {
                        return [catalogs][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this), function (value, key) {
                    return h('div', null, [h('h5', null, function () {
                        try {
                            return [value.title][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this)), h('ul', null, _Vdt.utils.map(function () {
                        try {
                            return [value.subCatalogs][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this), function (value, key) {
                        return h('li', null, ['\n                            ', function () {
                            try {
                                return [function () {
                                    if (value.href === self.get('title')) {
                                        currentNav = value;
                                    }
                                }()][0];
                            } catch (e) {
                                _e(e);
                            }
                        }.call(this), '\n                            ', h('a', { 'href': function () {
                                try {
                                    return ['#/document/' + value.href][0];
                                } catch (e) {
                                    _e(e);
                                }
                            }.call(this) }, function () {
                            try {
                                return [value.title][0];
                            } catch (e) {
                                _e(e);
                            }
                        }.call(this)), function () {
                            try {
                                return [value.href === self.get('title')][0];
                            } catch (e) {
                                _e(e);
                            }
                        }.call(this) ? h(Subs, { 'subs': function () {
                                try {
                                    return [self.get('subCatalogs')][0];
                                } catch (e) {
                                    _e(e);
                                }
                            }.call(this), 'children': null, '_context': $this }) : undefined], _className(function () {
                            try {
                                return [{
                                    active: value.href === self.get('title')
                                }][0];
                            } catch (e) {
                                _e(e);
                            }
                        }.call(this)));
                    }, this))], 'catalog-section');
                }, this), h('div', null, null, 'aside-border transition')], 'aside-wrapper')), h('article', null, [h('div', null, [h('div', null, function () {
                    try {
                        return [currentNav.title][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this), 'title'), h('div', null, ['\n                    如果你发现文档有问题，请帮忙在\n                    ', h('a', { 'target': '_blank', 'href': function () {
                        try {
                            return ['https://github.com/Javey/javey.github.io/blob/master/intact/docs/' + self.get('title') + '.md'][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this) }, 'github'), '\n                    上修正该文档\n                '], 'edit-link')], 'article-head'), h('div', { 'innerHTML': function () {
                        try {
                            return [self.get('content')][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this) })])];
            }) && (__blocks["content"] = function (parent) {
                var self = this;
                return blocks["content"] ? blocks["content"].call(this, function () {
                    return _blocks["content"].call(self, parent);
                }) : _blocks["content"].call(this, parent);
            }), __blocks;
        }.call(this, blocks), parent);
    }.call(this);
};

module.exports = exports['default'];

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(128);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(10)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(9)(undefined);
// imports


// module
exports.push([module.i, ".hljs {\n  display: block;\n  overflow-x: auto;\n  color: #525252;\n  padding: 15px;\n  -webkit-text-size-adjust: none;\n  margin: 0;\n}\n.hljs-doctype {\n  color: #999;\n}\n.hljs-tag {\n  color: #3e76f6;\n}\n.hljs-attribute {\n  color: #e96900;\n}\n.hljs-value {\n  color: #42b983;\n}\n.hljs-keyword {\n  color: #e96900;\n}\n.hljs-string {\n  color: #42b983;\n}\n.hljs-comment {\n  color: #b3b3b3;\n}\n.hljs-operator .hljs-comment {\n  color: #525252;\n}\n.hljs-regexp {\n  color: #af7dff;\n}\n.hljs-built_in {\n  color: #2db7f5;\n}\n.css .hljs-class {\n  color: #e96900;\n}\n.css .hljs-number,\n.javascript .hljs-number {\n  color: #fc1e70;\n}\n.css .hljs-attribute {\n  color: #af7dff;\n}\n.css .hljs-important {\n  color: #d04;\n}\n.actionscript .hljs-literal,\n.javascript .hljs-literal {\n  color: #fc1e70;\n}\npre {\n  padding: 0;\n  margin: 0;\n}\ncode {\n  display: inline-block;\n  background: #f7f7f7;\n  font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;\n  margin: 3px;\n  padding: 1px 5px;\n  border-radius: 3px;\n  color: #666;\n  border: 1px solid #eee;\n  line-height: 20px;\n}\n.document-page {\n  padding-top: 95px;\n  box-sizing: border-box;\n}\n.document-page .content-wrapper.fixed {\n  margin-bottom: 0;\n}\n.document-page .content-wrapper.fixed aside {\n  position: fixed;\n  top: 80px;\n  background: #fff;\n  height: calc(100% - 80px);\n  overflow: auto;\n  box-sizing: border-box;\n}\n.document-page .content-wrapper.fixed article {\n  margin-left: 200px;\n}\n.document-page .content-wrapper {\n  width: 1080px;\n  display: flex;\n  background: #fff;\n  margin: 0 auto;\n  border-radius: 5px;\n  box-shadow: 0 1px 1px rgba(0,0,0,0.08);\n  min-height: calc(100% - 15px);\n}\n.document-page .content-wrapper aside {\n  width: 200px;\n  border-right: 1px solid #eee;\n}\n.document-page .content-wrapper .aside-wrapper {\n  position: relative;\n}\n.document-page .content-wrapper .aside-wrapper h5 {\n  font-size: 16px;\n  margin: 25px 0 15px 20px;\n  color: #999;\n}\n.document-page .content-wrapper .aside-wrapper ul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.document-page .content-wrapper .aside-wrapper a {\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  padding-left: 25px;\n  color: #333;\n}\n.document-page .content-wrapper .aside-wrapper a:hover {\n  background: #f3f3f3;\n}\n.document-page .content-wrapper .aside-wrapper .active > a {\n  color: #fe4444;\n}\n.document-page .content-wrapper .aside-wrapper .sub-catalogs {\n  margin-left: 10px;\n  font-size: 12px;\n}\n.document-page .content-wrapper .aside-wrapper .aside-border {\n  border-right: 2px solid #fe4444;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.document-page .content-wrapper article {\n  flex: 1;\n  padding: 10px 20px;\n  overflow: auto;\n}\n.document-page .content-wrapper .article-head .title {\n  padding: 10px 0;\n  font-size: 2.2em;\n  color: #000;\n  display: inline-block;\n}\n.document-page .content-wrapper .article-head .edit-link {\n  display: inline-block;\n  margin-left: 20px;\n  color: #999;\n  font-style: italic;\n}\n.document-page .content-wrapper article h1 {\n  padding: 10px 0;\n  border-bottom: 1px solid #eee;\n  margin: 20px 0;\n}\n.document-page .content-wrapper article h2,\n.document-page .content-wrapper article h3 {\n  padding: 10px 0;\n  margin: 15px 0;\n}\n.document-page .content-wrapper article p {\n  line-height: 25px;\n}\n.document-page .content-wrapper article .output {\n  padding: 20px;\n  border: 1px solid #eee;\n  margin: 20px 0;\n}\n", ""]);

// exports


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(120),
    isObject = __webpack_require__(42);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(55);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(42),
    isSymbol = __webpack_require__(132);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(43),
    isObjectLike = __webpack_require__(44);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(122);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var arrayShuffle = __webpack_require__(136),
    baseShuffle = __webpack_require__(139),
    isArray = __webpack_require__(124);

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  var func = isArray(collection) ? arrayShuffle : baseShuffle;
  return func(collection);
}

module.exports = shuffle;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray = __webpack_require__(137),
    shuffleSelf = __webpack_require__(123);

/**
 * A specialized version of `_.shuffle` for arrays.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function arrayShuffle(array) {
  return shuffleSelf(copyArray(array));
}

module.exports = arrayShuffle;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

/***/ }),
/* 138 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var shuffleSelf = __webpack_require__(123),
    values = __webpack_require__(140);

/**
 * The base implementation of `_.shuffle`.
 *
 * @private
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function baseShuffle(collection) {
  return shuffleSelf(values(collection));
}

module.exports = baseShuffle;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(141),
    keys = __webpack_require__(143);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(142);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(144),
    baseKeys = __webpack_require__(155),
    isArrayLike = __webpack_require__(159);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(145),
    isArguments = __webpack_require__(146),
    isArray = __webpack_require__(124),
    isBuffer = __webpack_require__(148),
    isIndex = __webpack_require__(150),
    isTypedArray = __webpack_require__(151);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(147),
    isObjectLike = __webpack_require__(44);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(43),
    isObjectLike = __webpack_require__(44);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(55),
    stubFalse = __webpack_require__(149);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(152),
    baseUnary = __webpack_require__(153),
    nodeUtil = __webpack_require__(154);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(43),
    isLength = __webpack_require__(125),
    isObjectLike = __webpack_require__(44);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(121);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(156),
    nativeKeys = __webpack_require__(157);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 156 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(158);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(160),
    isLength = __webpack_require__(125);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(43),
    isObject = __webpack_require__(42);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */
/***/ (function(module, exports) {

exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;
    var Subs = function Subs(attr) {
        return function () {
            try {
                return [attr.subs][0];
            } catch (e) {
                _e(e);
            }
        }.call(this) ? h('ul', null, _Vdt.utils.map(function () {
            try {
                return [attr.subs][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), function (value, key) {
            return h('li', null, [h('a', { 'ev-click': function () {
                    try {
                        return [self.scrollTo.bind(self, value.title, attr.subs.active)][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, function () {
                try {
                    return [value.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)), h(Subs, { 'subs': function () {
                    try {
                        return [value.subs][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this), 'children': null, '_context': $this })], _className(function () {
                try {
                    return [{
                        active: self.get(attr.subs.active) === value.title
                    }][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)));
        }, this), _className(function () {
            try {
                return [{ "sub-catalogs": !attr.isFirst }][0];
            } catch (e) {
                _e(e);
            }
        }.call(this))) : undefined;
    };
    return function () {
        var _obj = { 'navIndex': 'api', 'className': 'document-page api-page', 'children': null };
        if (_obj.hasOwnProperty("arguments")) {
            extend(_obj, _obj.arguments === true ? obj : _obj.arguments);
            delete _obj.arguments;
        }
        return parent.call(this, _obj, _Vdt, function (blocks) {
            var _blocks = {},
                __blocks = extend({}, blocks);
            return (_blocks["content"] = function (parent) {
                return [h('aside', null, h('div', null, [h(Subs, { 'subs': function () {
                        try {
                            return [self.get('subCatalogs')][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this), 'isFirst': function () {
                        try {
                            return [true][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this), 'children': null, '_context': $this }), h('div', null, null, 'aside-border transition')], 'aside-wrapper')), h('article', null, h('div', { 'innerHTML': function () {
                        try {
                            return [self.get('content')][0];
                        } catch (e) {
                            _e(e);
                        }
                    }.call(this) }))];
            }) && (__blocks["content"] = function (parent) {
                var self = this;
                return blocks["content"] ? blocks["content"].call(this, function () {
                    return _blocks["content"].call(self, parent);
                }) : _blocks["content"].call(this, parent);
            }), __blocks;
        }.call(this, blocks), parent);
    }.call(this);
};

module.exports = exports['default'];

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(166);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(10)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./api.styl", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./api.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(9)(undefined);
// imports


// module
exports.push([module.i, ".api-page .content-wrapper aside {\n  padding: 20px 0;\n}\n", ""]);

// exports


/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9kb2N1bWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9hcGkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9saWIvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC1kZWNvcmF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMveG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9iYXNoLmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2xheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9sYXlvdXQudmR0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2h1ZmZsZVNlbGYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQudmR0Iiwid2VicGFjazovLy8uL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWw/NGRhYyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC5zdHlsIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTaHVmZmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmFuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTaHVmZmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvYXBpL2FwaS52ZHQiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvYXBpL2FwaS5zdHlsPzExMzUiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvYXBpL2FwaS5zdHlsIl0sIm5hbWVzIjpbIndpbmRvdyIsIkludGFjdCIsIl8iLCJ0aHJvdHRsZSIsInNodWZmbGUiLCJkZWJvdW5jZSIsIiQiLCJ0ZW1wbGF0ZSIsIl9pbml0IiwiZmV0Y2giLCJnZXQiLCJ0aGVuIiwicmVzcG9uc2UiLCJ0ZXh0Iiwic2V0IiwicmVuZGVyIiwibWQiLCJfbW91bnQiLCJjb2RlcyIsImVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImhpZ2hsaWdodEJsb2NrIiwiaXRlbSIsImNhdGFsb2dzIiwiYWN0aXZlIiwiY2F0YWxvZyIsInRpdGxlIiwiaW5uZXJUZXh0IiwibmV4dFNpYmxpbmciLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJzdWJzIiwicHVzaCIsImV2YWxTY3JpcHQiLCJvblNjcm9sbCIsIiRleGFtcGxlcyIsImZpbmQiLCJpIiwibGVuZ3RoIiwiJGV4YW1wbGUiLCJlcSIsImNvZGUiLCJoYXNDbGFzcyIsIl9DIiwiVmR0IiwiY29tcGlsZSIsImV4dGVuZCIsImV2YWwiLCIkY29udGFpbmVyIiwicGFyZW50IiwiYWZ0ZXIiLCJtb3VudCIsIiRidXR0b24iLCIkcCIsImFwcGVuZCIsIm9uIiwiJHNjcmlwdHMiLCIkc2NyaXB0IiwiJHdyYXBwZXIiLCIkYXJ0aWNsZSIsIiRoMXMiLCIkaDJzIiwiJGFzaWRlIiwiJGJvcmRlciIsIiR3aW5kb3ciLCJvZmYiLCJzY3JvbGxUb3AiLCJmaW5kQWN0aXZlIiwiJGhzIiwibWluVG9wIiwiJGgiLCJ0b3AiLCJwb3NpdGlvbiIsImFjdGl2ZTEiLCJhY3RpdmUyIiwiJGFjdGl2ZUEiLCJsYXN0IiwiY2hpbGRyZW4iLCJoZWlnaHQiLCJjc3MiLCJ0cmlnZ2VyIiwic2Nyb2xsVG8iLCJ0eXBlIiwiYW5pbWF0ZSIsImNvbXBsZXRlIiwiX2Rlc3Ryb3kiLCJfY2xhc3MiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0Iiwia2V5IiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJUeXBlRXJyb3IiLCJrZXlzIiwiYXJyYXlSZXBsYWNlQXQiLCJzcmMiLCJwb3MiLCJuZXdFbGVtZW50cyIsImNvbmNhdCIsImlzVmFsaWRFbnRpdHlDb2RlIiwiYyIsImZyb21Db2RlUG9pbnQiLCJzdXJyb2dhdGUxIiwic3Vycm9nYXRlMiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVORVNDQVBFX01EX1JFIiwiRU5USVRZX1JFIiwiVU5FU0NBUEVfQUxMX1JFIiwiUmVnRXhwIiwiRElHSVRBTF9FTlRJVFlfVEVTVF9SRSIsImVudGl0aWVzIiwicmVxdWlyZSIsInJlcGxhY2VFbnRpdHlQYXR0ZXJuIiwibWF0Y2giLCJuYW1lIiwiY2hhckNvZGVBdCIsInRlc3QiLCJwYXJzZUludCIsInVuZXNjYXBlTWQiLCJzdHIiLCJpbmRleE9mIiwicmVwbGFjZSIsInVuZXNjYXBlQWxsIiwiZXNjYXBlZCIsImVudGl0eSIsIkhUTUxfRVNDQVBFX1RFU1RfUkUiLCJIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFIiwiSFRNTF9SRVBMQUNFTUVOVFMiLCJyZXBsYWNlVW5zYWZlQ2hhciIsImNoIiwiZXNjYXBlSHRtbCIsIlJFR0VYUF9FU0NBUEVfUkUiLCJlc2NhcGVSRSIsImlzU3BhY2UiLCJpc1doaXRlU3BhY2UiLCJVTklDT0RFX1BVTkNUX1JFIiwiaXNQdW5jdENoYXIiLCJpc01kQXNjaWlQdW5jdCIsIm5vcm1hbGl6ZVJlZmVyZW5jZSIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImV4cG9ydHMiLCJsaWIiLCJtZHVybCIsInVjbWljcm8iLCJtb2R1bGUiLCJSdWxlciIsIl9fcnVsZXNfXyIsIl9fY2FjaGVfXyIsIl9fZmluZF9fIiwiX19jb21waWxlX18iLCJzZWxmIiwiY2hhaW5zIiwicnVsZSIsImVuYWJsZWQiLCJhbHQiLCJhbHROYW1lIiwiY2hhaW4iLCJmbiIsImF0Iiwib3B0aW9ucyIsImluZGV4Iiwib3B0IiwiRXJyb3IiLCJiZWZvcmUiLCJiZWZvcmVOYW1lIiwicnVsZU5hbWUiLCJzcGxpY2UiLCJhZnRlck5hbWUiLCJlbmFibGUiLCJsaXN0IiwiaWdub3JlSW52YWxpZCIsImlzQXJyYXkiLCJyZXN1bHQiLCJpZHgiLCJlbmFibGVPbmx5IiwiZGlzYWJsZSIsImdldFJ1bGVzIiwiY2hhaW5OYW1lIiwiVG9rZW4iLCJ0YWciLCJuZXN0aW5nIiwiYXR0cnMiLCJtYXAiLCJsZXZlbCIsImNvbnRlbnQiLCJtYXJrdXAiLCJpbmZvIiwibWV0YSIsImJsb2NrIiwiaGlkZGVuIiwiYXR0ckluZGV4IiwibGVuIiwiYXR0clB1c2giLCJhdHRyRGF0YSIsImF0dHJTZXQiLCJ2YWx1ZSIsImF0dHJHZXQiLCJhdHRySm9pbiIsImlzT2JqZWN0IiwiU3ltYm9sIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImJhc2VHZXRUYWciLCJpc09iamVjdExpa2UiLCJlbmNvZGUiLCJkZWNvZGUiLCJmb3JtYXQiLCJwYXJzZSIsImF0dHJfbmFtZSIsInVucXVvdGVkIiwic2luZ2xlX3F1b3RlZCIsImRvdWJsZV9xdW90ZWQiLCJhdHRyX3ZhbHVlIiwiYXR0cmlidXRlIiwib3Blbl90YWciLCJjbG9zZV90YWciLCJjb21tZW50IiwicHJvY2Vzc2luZyIsImRlY2xhcmF0aW9uIiwiY2RhdGEiLCJIVE1MX1RBR19SRSIsIkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUiLCJ0b2tlbml6ZSIsInN0cmlrZXRocm91Z2giLCJzdGF0ZSIsInNpbGVudCIsInNjYW5uZWQiLCJ0b2tlbiIsInN0YXJ0IiwibWFya2VyIiwic2NhbkRlbGltcyIsImRlbGltaXRlcnMiLCJqdW1wIiwidG9rZW5zIiwiZW5kIiwib3BlbiIsImNhbl9vcGVuIiwiY2xvc2UiLCJjYW5fY2xvc2UiLCJwb3N0UHJvY2VzcyIsImoiLCJzdGFydERlbGltIiwiZW5kRGVsaW0iLCJsb25lTWFya2VycyIsIm1heCIsInBvcCIsImVtcGhhc2lzIiwiaXNTdHJvbmciLCJnIiwiRnVuY3Rpb24iLCJlIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsInJlZ2lzdGVyTGFuZ3VhZ2UiLCJoaWdobGlnaHQiLCJtYXJrZWQiLCJodG1sIiwiYnJlYWtzIiwidXNlIiwicmVuZGVyZXIiLCJydWxlcyIsInNvZnRicmVhayIsInV0aWxzIiwiaGVscGVycyIsIlJlbmRlcmVyIiwiUGFyc2VyQ29yZSIsIlBhcnNlckJsb2NrIiwiUGFyc2VySW5saW5lIiwiTGlua2lmeUl0IiwicHVueWNvZGUiLCJjb25maWciLCJ6ZXJvIiwiY29tbW9ubWFyayIsIkJBRF9QUk9UT19SRSIsIkdPT0RfREFUQV9SRSIsInZhbGlkYXRlTGluayIsInVybCIsIlJFQ09ERV9IT1NUTkFNRV9GT1IiLCJub3JtYWxpemVMaW5rIiwicGFyc2VkIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRvQVNDSUkiLCJlciIsIm5vcm1hbGl6ZUxpbmtUZXh0IiwidG9Vbmljb2RlIiwiTWFya2Rvd25JdCIsInByZXNldE5hbWUiLCJpbmxpbmUiLCJjb3JlIiwibGlua2lmeSIsImNvbmZpZ3VyZSIsInByZXNldHMiLCJjb21wb25lbnRzIiwicnVsZXIiLCJydWxlczIiLCJydWxlcjIiLCJtaXNzZWQiLCJmaWx0ZXIiLCJwbHVnaW4iLCJhcmdzIiwiYXBwbHkiLCJlbnYiLCJTdGF0ZSIsInByb2Nlc3MiLCJwYXJzZUlubGluZSIsImlubGluZU1vZGUiLCJyZW5kZXJJbmxpbmUiLCJlbmNvZGVDYWNoZSIsImdldEVuY29kZUNhY2hlIiwiZXhjbHVkZSIsImNhY2hlIiwic3RyaW5nIiwia2VlcEVzY2FwZWQiLCJsIiwibmV4dENvZGUiLCJkZWZhdWx0Q2hhcnMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb21wb25lbnRDaGFycyIsImRlY29kZUNhY2hlIiwiZ2V0RGVjb2RlQ2FjaGUiLCJzZXEiLCJiMSIsImIyIiwiYjMiLCJiNCIsImNociIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsIlVybCIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwidXJsUGFyc2UiLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJsb3dlclByb3RvIiwiaGVjIiwicmVzdCIsInNwbGl0Iiwic2ltcGxlUGF0aCIsImV4ZWMiLCJwcm90byIsInN1YnN0ciIsImhvc3RFbmQiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsImhvc3QiLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsImsiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInVuc2hpZnQiLCJqb2luIiwicW0iLCJBbnkiLCJDYyIsIkNmIiwiUCIsIloiLCJwYXJzZUxpbmtMYWJlbCIsInBhcnNlTGlua0Rlc3RpbmF0aW9uIiwicGFyc2VMaW5rVGl0bGUiLCJkaXNhYmxlTmVzdGVkIiwiZm91bmQiLCJwcmV2UG9zIiwibGFiZWxFbmQiLCJwb3NNYXgiLCJvbGRQb3MiLCJza2lwVG9rZW4iLCJsaW5lcyIsIm9rIiwiZGVmYXVsdF9ydWxlcyIsImNvZGVfaW5saW5lIiwic2xmIiwicmVuZGVyQXR0cnMiLCJjb2RlX2Jsb2NrIiwiZmVuY2UiLCJsYW5nTmFtZSIsImhpZ2hsaWdodGVkIiwidG1wQXR0cnMiLCJ0bXBUb2tlbiIsImxhbmdQcmVmaXgiLCJpbWFnZSIsInJlbmRlcklubGluZUFzVGV4dCIsInJlbmRlclRva2VuIiwiaGFyZGJyZWFrIiwieGh0bWxPdXQiLCJodG1sX2Jsb2NrIiwiaHRtbF9pbmxpbmUiLCJuZXh0VG9rZW4iLCJuZWVkTGYiLCJfcnVsZXMiLCJDb3JlIiwiTkVXTElORVNfUkUiLCJOVUxMX1JFIiwidG9rIiwiaXNMaW5rT3BlbiIsImlzTGlua0Nsb3NlIiwiY3VycmVudFRva2VuIiwibm9kZXMiLCJsbiIsImxhc3RQb3MiLCJodG1sTGlua0xldmVsIiwiZnVsbFVybCIsInVybFRleHQiLCJibG9ja1Rva2VucyIsImxpbmtzIiwicHJldGVzdCIsInNjaGVtYSIsImxhc3RJbmRleCIsIlJBUkVfUkUiLCJTQ09QRURfQUJCUl9URVNUX1JFIiwiU0NPUEVEX0FCQlJfUkUiLCJTQ09QRURfQUJCUiIsInIiLCJwIiwidG0iLCJyZXBsYWNlRm4iLCJyZXBsYWNlX3Njb3BlZCIsImlubGluZVRva2VucyIsImluc2lkZV9hdXRvbGluayIsInJlcGxhY2VfcmFyZSIsImJsa0lkeCIsInR5cG9ncmFwaGVyIiwiUVVPVEVfVEVTVF9SRSIsIlFVT1RFX1JFIiwiQVBPU1RST1BIRSIsInJlcGxhY2VBdCIsInByb2Nlc3NfaW5saW5lcyIsInQiLCJ0aGlzTGV2ZWwiLCJsYXN0Q2hhciIsIm5leHRDaGFyIiwiaXNMYXN0UHVuY3RDaGFyIiwiaXNOZXh0UHVuY3RDaGFyIiwiaXNMYXN0V2hpdGVTcGFjZSIsImlzTmV4dFdoaXRlU3BhY2UiLCJjYW5PcGVuIiwiY2FuQ2xvc2UiLCJpc1NpbmdsZSIsInN0YWNrIiwib3BlblF1b3RlIiwiY2xvc2VRdW90ZSIsIk9VVEVSIiwic2luZ2xlIiwicXVvdGVzIiwic21hcnRxdW90ZXMiLCJTdGF0ZUNvcmUiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZSIsImhhc0VtcHR5TGluZXMiLCJtYXhOZXN0aW5nIiwic2tpcEVtcHR5TGluZXMiLCJzQ291bnQiLCJibGtJbmRlbnQiLCJ0aWdodCIsImlzRW1wdHkiLCJvdXRUb2tlbnMiLCJsaW5lTWF4IiwiZ2V0TGluZSIsImJNYXJrcyIsImVNYXJrcyIsImVzY2FwZWRTcGxpdCIsImVzY2FwZXMiLCJiYWNrVGlja2VkIiwibGFzdEJhY2tUaWNrIiwic3Vic3RyaW5nIiwidGFibGUiLCJsaW5lVGV4dCIsIm5leHRMaW5lIiwiY29sdW1ucyIsImNvbHVtbkNvdW50IiwiYWxpZ25zIiwidGFibGVMaW5lcyIsInRib2R5TGluZXMiLCJ0U2hpZnQiLCJnZXRMaW5lcyIsInBhcmFtcyIsIm1lbSIsImhhdmVFbmRNYXJrZXIiLCJza2lwQ2hhcnMiLCJza2lwU3BhY2VzIiwiYmxvY2txdW90ZSIsImFkanVzdFRhYiIsImluaXRpYWwiLCJsYXN0TGluZUVtcHR5Iiwib2Zmc2V0Iiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwid2FzT3V0ZGVudGVkIiwib2xkTGluZU1heCIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwiaHIiLCJjbnQiLCJza2lwQnVsbGV0TGlzdE1hcmtlciIsInNraXBPcmRlcmVkTGlzdE1hcmtlciIsIm1hcmtUaWdodFBhcmFncmFwaHMiLCJjb250ZW50U3RhcnQiLCJpbmRlbnQiLCJpbmRlbnRBZnRlck1hcmtlciIsImlzT3JkZXJlZCIsIml0ZW1MaW5lcyIsImxpc3RMaW5lcyIsImxpc3RUb2tJZHgiLCJtYXJrZXJDaGFyQ29kZSIsIm1hcmtlclZhbHVlIiwib2xkTEluZGVudCIsIm9sZFRpZ2h0IiwicG9zQWZ0ZXJNYXJrZXIiLCJwcmV2RW1wdHlFbmQiLCJpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoIiwiTnVtYmVyIiwiTWF0aCIsIm1pbiIsInJlZmVyZW5jZSIsIl9lbmRMaW5lIiwiZGVzdEVuZFBvcyIsImRlc3RFbmRMaW5lTm8iLCJocmVmIiwibGFiZWwiLCJyZXMiLCJyZWZlcmVuY2VzIiwiaGVhZGluZyIsInRtcCIsInNraXBTcGFjZXNCYWNrIiwic2tpcENoYXJzQmFjayIsImxoZWFkaW5nIiwiYmxvY2tfbmFtZXMiLCJIVE1MX1NFUVVFTkNFUyIsInBhcmFncmFwaCIsIlN0YXRlQmxvY2siLCJzIiwiaW5kZW50X2ZvdW5kIiwiZGRJbmRlbnQiLCJmcm9tIiwiYmVnaW4iLCJrZWVwTGFzdExGIiwibGluZUluZGVudCIsImZpcnN0IiwicXVldWUiLCJsaW5lU3RhcnQiLCJfcnVsZXMyIiwicGVuZGluZyIsInB1c2hQZW5kaW5nIiwiaXNUZXJtaW5hdG9yQ2hhciIsIm5ld2xpbmUiLCJwbWF4IiwiRVNDQVBFRCIsImVzY2FwZSIsImJhY2t0aWNrIiwibWF0Y2hTdGFydCIsIm1hdGNoRW5kIiwibGluayIsImxhYmVsU3RhcnQiLCJyZWYiLCJwYXJzZVJlZmVyZW5jZSIsIkVNQUlMX1JFIiwiQVVUT0xJTktfUkUiLCJhdXRvbGluayIsInRhaWwiLCJsaW5rTWF0Y2giLCJlbWFpbE1hdGNoIiwiaXNMZXR0ZXIiLCJsYyIsIkRJR0lUQUxfUkUiLCJOQU1FRF9SRSIsImxpbmtfcGFpcnMiLCJsYXN0RGVsaW0iLCJjdXJyRGVsaW0iLCJvZGRfbWF0Y2giLCJ0ZXh0X2NvbGxhcHNlIiwiY3VyciIsIlN0YXRlSW5saW5lIiwicGVuZGluZ0xldmVsIiwiY2FuU3BsaXRXb3JkIiwiY291bnQiLCJsZWZ0X2ZsYW5raW5nIiwicmlnaHRfZmxhbmtpbmciLCJpc1JlZ0V4cCIsImlzRnVuY3Rpb24iLCJkZWZhdWx0T3B0aW9ucyIsImZ1enp5TGluayIsImZ1enp5RW1haWwiLCJmdXp6eUlQIiwiaXNPcHRpb25zT2JqIiwicmVkdWNlIiwiYWNjIiwiZGVmYXVsdFNjaGVtYXMiLCJ2YWxpZGF0ZSIsInJlIiwiaHR0cCIsInNyY19hdXRoIiwic3JjX2hvc3RfcG9ydF9zdHJpY3QiLCJzcmNfcGF0aCIsIm5vX2h0dHAiLCJzcmNfZG9tYWluIiwic3JjX2RvbWFpbl9yb290Iiwic3JjX3BvcnQiLCJzcmNfaG9zdF90ZXJtaW5hdG9yIiwibWFpbHRvIiwic3JjX2VtYWlsX25hbWUiLCJzcmNfaG9zdF9zdHJpY3QiLCJ0bGRzXzJjaF9zcmNfcmUiLCJ0bGRzX2RlZmF1bHQiLCJyZXNldFNjYW5DYWNoZSIsIl9faW5kZXhfXyIsIl9fdGV4dF9jYWNoZV9fIiwiY3JlYXRlVmFsaWRhdG9yIiwiY3JlYXRlTm9ybWFsaXplciIsIm5vcm1hbGl6ZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiYWxpYXNlcyIsIl9fY29tcGlsZWRfXyIsInNjaGVtYUVycm9yIiwidmFsIiwiX19zY2hlbWFzX18iLCJjb21waWxlZCIsImFsaWFzIiwic2xpc3QiLCJzY2hlbWFfdGVzdCIsInNyY19aUENjIiwic2NoZW1hX3NlYXJjaCIsIk1hdGNoIiwic2hpZnQiLCJfX2xhc3RfaW5kZXhfXyIsIl9fc2NoZW1hX18iLCJyYXciLCJjcmVhdGVNYXRjaCIsInNjaGVtYXMiLCJhZGQiLCJkZWZpbml0aW9uIiwibSIsIm1sIiwibWUiLCJuZXh0IiwidGxkX3BvcyIsImF0X3BvcyIsInRlc3RTY2hlbWFBdCIsImtlZXBPbGQiLCJzb3J0IiwiZWwiLCJhcnIiLCJyZXZlcnNlIiwib3B0cyIsInNyY19BbnkiLCJzcmNfQ2MiLCJzcmNfWiIsInNyY19QIiwic3JjX1pDYyIsInRleHRfc2VwYXJhdG9ycyIsInNyY19wc2V1ZG9fbGV0dGVyIiwic3JjX2lwNCIsInNyY19ob3N0IiwidHBsX2hvc3RfZnV6enkiLCJ0cGxfaG9zdF9ub19pcF9mdXp6eSIsInRwbF9ob3N0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImdsb2JhbCIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiZXJyb3IiLCJSYW5nZUVycm9yIiwiYXJyYXkiLCJtYXBEb21haW4iLCJwYXJ0cyIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwib3V0IiwibiIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJ3IiwiYmFzZU1pbnVzVCIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsImRlZmluZSIsInRhZ0V4cHIiLCJhdHRyaWJ1dGVzIiwiY3VybHlBdHRycyIsIm9wZW5pbmciLCJsaSIsInVsIiwib2wiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJhIiwic2VsZkNsb3NpbmciLCJvbWlzc2lvbnMiLCJjb250ZW50cyIsInR5cGVzIiwiaXNPcGVuZXIiLCJzcHVzaCIsImZpbmRQYXJlbnQiLCJhcHBseVRvVG9rZW4iLCJjdXJseUlubGluZSIsImxhc3RUZXh0IiwiY2hpbGQiLCJkZXB0aCIsInRyaW1SaWdodCIsInRhcmdldHMiLCJ0YXJnZXQiLCJhdHRyIiwidG9kbyIsInNldEF0dHIiLCJmYWN0b3J5IiwiZ2xvYmFsT2JqZWN0IiwiaGxqcyIsImFtZCIsIkFycmF5UHJvdG8iLCJvYmplY3RLZXlzIiwibGFuZ3VhZ2VzIiwibm9IaWdobGlnaHRSZSIsImxhbmd1YWdlUHJlZml4UmUiLCJmaXhNYXJrdXBSZSIsInNwYW5FbmRUYWciLCJjbGFzc1ByZWZpeCIsInRhYlJlcGxhY2UiLCJ1c2VCUiIsIm5vZGUiLCJub2RlTmFtZSIsInRlc3RSZSIsImxleGVtZSIsImlzTm90SGlnaGxpZ2h0ZWQiLCJsYW5ndWFnZSIsImJsb2NrTGFuZ3VhZ2UiLCJjbGFzc2VzIiwiY2xhc3NOYW1lIiwicGFyZW50Tm9kZSIsImdldExhbmd1YWdlIiwiaW5oZXJpdCIsIm9iamVjdHMiLCJub2RlU3RyZWFtIiwiX25vZGVTdHJlYW0iLCJmaXJzdENoaWxkIiwibm9kZVZhbHVlIiwiZXZlbnQiLCJtZXJnZVN0cmVhbXMiLCJvcmlnaW5hbCIsInByb2Nlc3NlZCIsIm5vZGVTdGFjayIsInNlbGVjdFN0cmVhbSIsImF0dHJfc3RyIiwic3RyZWFtIiwiZXhwYW5kX21vZGUiLCJtb2RlIiwidmFyaWFudHMiLCJjYWNoZWRfdmFyaWFudHMiLCJ2YXJpYW50IiwiZW5kc1dpdGhQYXJlbnQiLCJjb21waWxlTGFuZ3VhZ2UiLCJyZVN0ciIsImxhbmdSZSIsImNhc2VfaW5zZW5zaXRpdmUiLCJjb21waWxlTW9kZSIsImtleXdvcmRzIiwiYmVnaW5LZXl3b3JkcyIsImNvbXBpbGVkX2tleXdvcmRzIiwiZmxhdHRlbiIsImt3IiwicGFpciIsImxleGVtZXNSZSIsImxleGVtZXMiLCJiZWdpblJlIiwiZW5kUmUiLCJ0ZXJtaW5hdG9yX2VuZCIsImlsbGVnYWwiLCJpbGxlZ2FsUmUiLCJyZWxldmFuY2UiLCJjb250YWlucyIsInN0YXJ0cyIsInRlcm1pbmF0b3JzIiwiQm9vbGVhbiIsImlnbm9yZV9pbGxlZ2FscyIsImNvbnRpbnVhdGlvbiIsInN1Yk1vZGUiLCJlbmRPZk1vZGUiLCJlbmRzUGFyZW50IiwiaXNJbGxlZ2FsIiwia2V5d29yZE1hdGNoIiwibWF0Y2hfc3RyIiwiYnVpbGRTcGFuIiwiY2xhc3NuYW1lIiwiaW5zaWRlU3BhbiIsImxlYXZlT3BlbiIsIm5vUHJlZml4Iiwib3BlblNwYW4iLCJjbG9zZVNwYW4iLCJwcm9jZXNzS2V5d29yZHMiLCJrZXl3b3JkX21hdGNoIiwibGFzdF9pbmRleCIsIm1vZGVfYnVmZmVyIiwicHJvY2Vzc1N1Ykxhbmd1YWdlIiwiZXhwbGljaXQiLCJzdWJMYW5ndWFnZSIsImNvbnRpbnVhdGlvbnMiLCJoaWdobGlnaHRBdXRvIiwicHJvY2Vzc0J1ZmZlciIsInN0YXJ0TmV3TW9kZSIsImNyZWF0ZSIsInByb2Nlc3NMZXhlbWUiLCJidWZmZXIiLCJuZXdfbW9kZSIsInNraXAiLCJleGNsdWRlQmVnaW4iLCJyZXR1cm5CZWdpbiIsImVuZF9tb2RlIiwib3JpZ2luIiwicmV0dXJuRW5kIiwiZXhjbHVkZUVuZCIsImN1cnJlbnQiLCJtZXNzYWdlIiwibGFuZ3VhZ2VTdWJzZXQiLCJzZWNvbmRfYmVzdCIsImZpeE1hcmt1cCIsInAxIiwiYnVpbGRDbGFzc05hbWUiLCJwcmV2Q2xhc3NOYW1lIiwiY3VycmVudExhbmciLCJyZXN1bHRMYW5nIiwib3JpZ2luYWxTdHJlYW0iLCJyZXN1bHROb2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudCIsInVzZXJfb3B0aW9ucyIsImluaXRIaWdobGlnaHRpbmciLCJjYWxsZWQiLCJibG9ja3MiLCJpbml0SGlnaGxpZ2h0aW5nT25Mb2FkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxhbmciLCJsaXN0TGFuZ3VhZ2VzIiwiSURFTlRfUkUiLCJVTkRFUlNDT1JFX0lERU5UX1JFIiwiTlVNQkVSX1JFIiwiQ19OVU1CRVJfUkUiLCJCSU5BUllfTlVNQkVSX1JFIiwiUkVfU1RBUlRFUlNfUkUiLCJCQUNLU0xBU0hfRVNDQVBFIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiUEhSQVNBTF9XT1JEU19NT0RFIiwiQ09NTUVOVCIsImluaGVyaXRzIiwiQ19MSU5FX0NPTU1FTlRfTU9ERSIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwiSEFTSF9DT01NRU5UX01PREUiLCJOVU1CRVJfTU9ERSIsIkNfTlVNQkVSX01PREUiLCJCSU5BUllfTlVNQkVSX01PREUiLCJDU1NfTlVNQkVSX01PREUiLCJSRUdFWFBfTU9ERSIsIlRJVExFX01PREUiLCJVTkRFUlNDT1JFX1RJVExFX01PREUiLCJNRVRIT0RfR1VBUkQiLCJLRVlXT1JEUyIsImtleXdvcmQiLCJsaXRlcmFsIiwiYnVpbHRfaW4iLCJFWFBSRVNTSU9OUyIsIk5VTUJFUiIsIlNVQlNUIiwiVEVNUExBVEVfU1RSSU5HIiwiUEFSQU1TX0NPTlRBSU5TIiwiUlVMRSIsIlhNTF9JREVOVF9SRSIsIlRBR19JTlRFUk5BTFMiLCJWQVIiLCJRVU9URV9TVFJJTkciLCJBUE9TX1NUUklORyIsIl91cGRhdGVCb3JkZXIiLCIkbmF2Iiwid2lkdGgiLCJsZWZ0Iiwib3V0ZXJXaWR0aCIsImFkZENsYXNzIiwiX1ZkdCIsIiRjYWxsZWUiLCJoIiwibWlzcyIsImhjIiwiaHUiLCJ3aWRnZXRzIiwiX2Jsb2NrcyIsIl9fYmxvY2tzIiwiX191IiwiX2UiLCJfY2xhc3NOYW1lIiwiX19vIiwiT3B0aW9ucyIsIl9nZXRNb2RlbCIsImdldE1vZGVsIiwiX3NldE1vZGVsIiwic2V0TW9kZWwiLCJfc2V0Q2hlY2tib3hNb2RlbCIsInNldENoZWNrYm94TW9kZWwiLCJfZGV0ZWN0Q2hlY2tib3hDaGVja2VkIiwiZGV0ZWN0Q2hlY2tib3hDaGVja2VkIiwiX3NldFNlbGVjdE1vZGVsIiwic2V0U2VsZWN0TW9kZWwiLCJkYXRhIiwiJHRoaXMiLCJzY29wZSIsIkFuaW1hdGUiLCJfc3VwZXIiLCJuYXYiLCJuYXZJbmRleCIsIm5vdyIsInRvTnVtYmVyIiwiRlVOQ19FUlJPUl9URVhUIiwibmF0aXZlTWF4IiwibmF0aXZlTWluIiwiZnVuYyIsIndhaXQiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJ0cmFpbGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwidGhpc0FyZyIsImxlYWRpbmdFZGdlIiwic2V0VGltZW91dCIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJiYXNlUmFuZG9tIiwic2h1ZmZsZVNlbGYiLCJzaXplIiwicmFuZCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0xlbmd0aCIsInN1YkNhdGFsb2dzIiwiY3VycmVudE5hdiIsIlN1YnMiLCJiaW5kIiwiX29iaiIsIkRhdGUiLCJpc1N5bWJvbCIsIk5BTiIsInJlVHJpbSIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc09jdGFsIiwiZnJlZVBhcnNlSW50Iiwib3RoZXIiLCJ2YWx1ZU9mIiwiaXNCaW5hcnkiLCJzeW1ib2xUYWciLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsImFycmF5U2h1ZmZsZSIsImJhc2VTaHVmZmxlIiwiY29sbGVjdGlvbiIsImNvcHlBcnJheSIsIm5hdGl2ZUZsb29yIiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwibG93ZXIiLCJ1cHBlciIsInZhbHVlcyIsImJhc2VWYWx1ZXMiLCJhcnJheU1hcCIsInByb3BzIiwiaXRlcmF0ZWUiLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXMiLCJpc0FycmF5TGlrZSIsImJhc2VUaW1lcyIsImlzQXJndW1lbnRzIiwiaXNCdWZmZXIiLCJpc0luZGV4IiwiaXNUeXBlZEFycmF5IiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiYmFzZUlzQXJndW1lbnRzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJhcmdzVGFnIiwic3R1YkZhbHNlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwicmVJc1VpbnQiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5Iiwibm9kZVV0aWwiLCJub2RlSXNUeXBlZEFycmF5IiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsImJpbmRpbmciLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXMiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwiYXJnIiwiYXN5bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRmlyc3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBQSxPQUFPQyxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBRCxPQUFPRSxDQUFQLEdBQVcsRUFBQ0MsK0JBQUQsRUFBV0MsNkJBQVgsRUFBb0JDLCtCQUFwQixFQUFYO0FBQ0FMLE9BQU9NLENBQVAsR0FBV0EsQ0FBWDs7dUJBR0tMLE9BQU9NLFFBQVAsRTs7Ozs7Ozs7O3VCQUdEQyxLLG9CQUFRO0FB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bEMsSUFSa0MsRUFRNUI2MEIsTUFSNEIsQ0FBOUIsRUFRV3YzQixNQVJYLENBQVA7QUFTSCxLQWZNLENBZUowQyxJQWZJLENBZUMsSUFmRCxDQUFQO0FBZ0JDLEM7Ozs7Ozs7O0FDbENEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7O0FDekJBO0FBQ0E7OztBQUdBO0FBQ0EsMkRBQTRELG9CQUFvQixHQUFHOztBQUVuRiIsImZpbGUiOiJzdGF0aWMvY2h1bmsvYzRiMjBlNGI1ZDk3MmYxMTIyYjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9kb2N1bWVudC52ZHQnO1xuaW1wb3J0IGNzcyBmcm9tICcuL2RvY3VtZW50LnN0eWwnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc2h1ZmZsZSBmcm9tICdsb2Rhc2gvc2h1ZmZsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbi8vIGZvciBkZWJ1Z1xud2luZG93LkludGFjdCA9IEludGFjdDtcbndpbmRvdy5fID0ge3Rocm90dGxlLCBzaHVmZmxlLCBkZWJvdW5jZX07XG53aW5kb3cuJCA9ICQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBASW50YWN0LnRlbXBsYXRlKClcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgIF9pbml0KCkge1xuICAgICAgICByZXR1cm4gZmV0Y2goYC4vZG9jcy8ke3RoaXMuZ2V0KCd0aXRsZScpfS5tZGApLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSkudGhlbihtZCA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldCgnY29udGVudCcsIG1hcmtlZC5yZW5kZXIobWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX21vdW50KCkge1xuICAgICAgICBzdXBlci5fbW91bnQoKTtcbiAgICAgICAgY29uc3QgY29kZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgY29kZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGhpZ2hsaWdodC5oaWdobGlnaHRCbG9jayhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhdGFsb2dzID0gW107XG4gICAgICAgIGNhdGFsb2dzLmFjdGl2ZSA9ICdhY3RpdmUxJztcbiAgICAgICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxJykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGFsb2cgPSB7dGl0bGU6IGl0ZW0uaW5uZXJUZXh0fTtcbiAgICAgICAgICAgIGxldCBuZXh0U2libGluZyA9IGl0ZW0ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gKG5leHRTaWJsaW5nLnRhZ05hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdoMScpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnaDInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2F0YWxvZy5zdWJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRhbG9nLnN1YnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGFsb2cuc3Vicy5hY3RpdmUgPSAnYWN0aXZlMic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0YWxvZy5zdWJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5leHRTaWJsaW5nLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGFsb2dzLnB1c2goY2F0YWxvZyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldCgnc3ViQ2F0YWxvZ3MnLCBjYXRhbG9ncyk7XG5cbiAgICAgICAgdGhpcy5ldmFsU2NyaXB0KCk7XG4gICAgICAgIHRoaXMub25TY3JvbGwoKTtcbiAgICB9XG5cbiAgICBldmFsU2NyaXB0KCkge1xuICAgICAgICBjb25zdCAkZXhhbXBsZXMgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmV4YW1wbGUnKTtcbiAgICAgICAgbGV0IHRlbXBsYXRlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRleGFtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0ICRleGFtcGxlID0gJGV4YW1wbGVzLmVxKGkpO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSAkZXhhbXBsZS50ZXh0KCk7XG4gICAgICAgICAgICBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2F1dG8nKSkge1xuICAgICAgICAgICAgICAgIGxldCBfQztcbiAgICAgICAgICAgICAgICBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2xhbmd1YWdlLWh0bWwnKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IEludGFjdC5WZHQuY29tcGlsZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgX0MgPSBJbnRhY3QuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdqYXZhc2NyaXB0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgX0MgPSBldmFsKGNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgJGNvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJvdXRwdXRcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAkZXhhbXBsZS5wYXJlbnQoKS5hZnRlcigkY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBJbnRhY3QubW91bnQoX0MsICRjb250YWluZXJbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbWFudWFsJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgJGJ1dHRvbiA9ICQoJzxidXR0b24+54K55Ye76L+Q6KGMPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgbGV0ICRwID0gJCgnPHA+PC9wPicpLmFwcGVuZCgkYnV0dG9uKTtcbiAgICAgICAgICAgICAgICAkZXhhbXBsZS5wYXJlbnQoKS5hZnRlcigkcCk7XG4gICAgICAgICAgICAgICAgJGJ1dHRvbi5vbignY2xpY2snLCAoKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkoY29kZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbGFuZ3VhZ2UtaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBJbnRhY3QuVmR0LmNvbXBpbGUoY29kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdqYXZhc2NyaXB0JykpIHtcbiAgICAgICAgICAgICAgICBldmFsKGNvZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbGFuZ3VhZ2UtY3NzJykpIHtcbiAgICAgICAgICAgICAgICAkZXhhbXBsZS5wYXJlbnQoKS5hZnRlcihgPHN0eWxlPiR7Y29kZX08L3N0eWxlPmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5omn6KGMc2NyaXB05qCH562+XG4gICAgICAgIGNvbnN0ICRzY3JpcHRzID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJ3NjcmlwdCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgJHNjcmlwdCA9ICRzY3JpcHRzLmVxKGkpO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSAkc2NyaXB0LnRleHQoKTtcbiAgICAgICAgICAgIGV2YWwoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNjcm9sbCgpIHtcbiAgICAgICAgY29uc3QgJHdyYXBwZXIgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmNvbnRlbnQtd3JhcHBlcicpO1xuICAgICAgICBjb25zdCAkYXJ0aWNsZSA9ICQodGhpcy5lbGVtZW50KS5maW5kKCdhcnRpY2xlJyk7XG4gICAgICAgIGNvbnN0ICRoMXMgPSAkYXJ0aWNsZS5maW5kKCdoMScpO1xuICAgICAgICBjb25zdCAkaDJzID0gJGFydGljbGUuZmluZCgnaDInKTtcbiAgICAgICAgY29uc3QgJGFzaWRlID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJ2FzaWRlJyk7XG4gICAgICAgIGNvbnN0ICRib3JkZXIgPSAkYXNpZGUuZmluZCgnLmFzaWRlLWJvcmRlcicpO1xuICAgICAgICBjb25zdCAkd2luZG93ID0gJCh3aW5kb3cpO1xuICAgICAgICAkd2luZG93Lm9mZignc2Nyb2xsJyk7XG4gICAgICAgICR3aW5kb3cub24oJ3Njcm9sbC5maXgnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAkd3JhcHBlcltzY3JvbGxUb3AgPj0gMTUgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oJ2ZpeGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkd2luZG93Lm9uKCdzY3JvbGwuYWN0aXZlJywgdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQWN0aXZlKCRocywgbWluVG9wID0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAkaHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRoID0gJGhzLmVxKGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gJGgucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AgPiBtaW5Ub3AgJiYgc2Nyb2xsVG9wID49IHRvcCAtIDYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRoLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge3RleHQ6ICcnLCB0b3A6IDB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhY3RpdmUxID0gZmluZEFjdGl2ZSgkaDFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZTIgPSBmaW5kQWN0aXZlKCRoMnMsIGFjdGl2ZTEudG9wKTtcblxuICAgICAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZTI6IGFjdGl2ZTIudGV4dCxcbiAgICAgICAgICAgICAgICBhY3RpdmUxOiBhY3RpdmUxLnRleHQgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgJGFjdGl2ZUEgPSAkYXNpZGUuZmluZCgnLmFjdGl2ZScpLmxhc3QoKS5jaGlsZHJlbignYScpO1xuICAgICAgICAgICAgaWYgKCRhY3RpdmVBLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSAkYWN0aXZlQS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gJGFjdGl2ZUEucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgJGJvcmRlci5jc3Moe2hlaWdodDogaGVpZ2h0LCB0b3A6IHRvcH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCA1MCkpO1xuICAgICAgICAkd2luZG93LnRyaWdnZXIoJ3Njcm9sbCcpO1xuICAgIH1cblxuICAgIHNjcm9sbFRvKHRleHQsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgJGFydGljbGUgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnYXJ0aWNsZScpO1xuICAgICAgICBjb25zdCAkaHMgPSAkYXJ0aWNsZS5maW5kKHR5cGUgPT09ICdhY3RpdmUxJyA/ICdoMScgOiAnaDInKTtcbiAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCAkaCA9ICRocy5lcShpKTtcbiAgICAgICAgICAgIGlmICgkaC50ZXh0KCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gJGgucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiB0b3AgLSA2MFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rlc3Ryb3koKSB7XG4gICAgICAgICQod2luZG93KS5vZmYoJ3Njcm9sbCcpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL2RvY3VtZW50L2luZGV4LmpzIiwiaW1wb3J0IERvY3VtZW50UGFnZSBmcm9tICcuLi9kb2N1bWVudCc7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9hcGkudmR0JztcbmltcG9ydCBjc3MgZnJvbSAnLi9hcGkuc3R5bCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgRG9jdW1lbnRQYWdlIHtcbiAgICBASW50YWN0LnRlbXBsYXRlKClcbiAgICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZTsgfSBcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL2FwaS9pbmRleC5qcyIsIi8vIFV0aWxpdGllc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIFJlbW92ZSBlbGVtZW50IGZyb20gYXJyYXkgYW5kIHB1dCBhbm90aGVyIGFycmF5IGF0IHRob3NlIHBvc2l0aW9uLlxuLy8gVXNlZnVsIGZvciBzb21lIG9wZXJhdGlvbnMgd2l0aCB0b2tlbnNcbmZ1bmN0aW9uIGFycmF5UmVwbGFjZUF0KHNyYywgcG9zLCBuZXdFbGVtZW50cykge1xuICByZXR1cm4gW10uY29uY2F0KHNyYy5zbGljZSgwLCBwb3MpLCBuZXdFbGVtZW50cywgc3JjLnNsaWNlKHBvcyArIDEpKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNWYWxpZEVudGl0eUNvZGUoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICAvLyBicm9rZW4gc2VxdWVuY2VcbiAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBuZXZlciB1c2VkXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKChjICYgMHhGRkZGKSA9PT0gMHhGRkZGIHx8IChjICYgMHhGRkZGKSA9PT0gMHhGRkZFKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBjb250cm9sIGNvZGVzXG4gIGlmIChjID49IDB4MDAgJiYgYyA8PSAweDA4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA9PT0gMHgwQikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHgwRSAmJiBjIDw9IDB4MUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4N0YgJiYgYyA8PSAweDlGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBvdXQgb2YgcmFuZ2VcbiAgaWYgKGMgPiAweDEwRkZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICBpZiAoYyA+IDB4ZmZmZikge1xuICAgIGMgLT0gMHgxMDAwMDtcbiAgICB2YXIgc3Vycm9nYXRlMSA9IDB4ZDgwMCArIChjID4+IDEwKSxcbiAgICAgICAgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjICYgMHgzZmYpO1xuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc3Vycm9nYXRlMSwgc3Vycm9nYXRlMik7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG59XG5cblxudmFyIFVORVNDQVBFX01EX1JFICA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dKS9nO1xudmFyIEVOVElUWV9SRSAgICAgICA9IC8mKFthLXojXVthLXowLTldezEsMzF9KTsvZ2k7XG52YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKTtcblxudmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG5cbnZhciBlbnRpdGllcyA9IHJlcXVpcmUoJy4vZW50aXRpZXMnKTtcblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIG5hbWUpIHtcbiAgdmFyIGNvZGUgPSAwO1xuXG4gIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGVudGl0aWVzW25hbWVdO1xuICB9XG5cbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMy8qICMgKi8gJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgY29kZSA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxuICAgIDpcbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMSksIDEwKTtcbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcbiAgLy8gaGVyZSB0byBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAvLyBtZW1iZXJzIChtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwibW9kdWxlLmV4cG9ydHM9L1shLSMlLVxcKiwtLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0NFxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODA1W1xcdURDNEItXFx1REM0RlxcdURDNUJcXHVEQzVEXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURFNjAtXFx1REU2Q1xcdURGM0MtXFx1REYzRV18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9yZ2FwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcbiAgICoqL1xuICB0aGlzLmluZm8gICAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21ldGEgLT4gT2JqZWN0XG4gICAqXG4gICAqIEEgcGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgYW4gYXJiaXRyYXJ5IGRhdGFcbiAgICoqL1xuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZTtcblxuICAvKipcbiAgICogVG9rZW4jaGlkZGVuIC0+IEJvb2xlYW5cbiAgICpcbiAgICogSWYgaXQncyB0cnVlLCBpZ25vcmUgdGhpcyBlbGVtZW50IHdoZW4gcmVuZGVyaW5nLiBVc2VkIGZvciB0aWdodCBsaXN0c1xuICAgKiB0byBoaWRlIHBhcmFncmFwaHMuXG4gICAqKi9cbiAgdGhpcy5oaWRkZW4gICA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxuICpcbiAqIFNlYXJjaCBhdHRyaWJ1dGUgaW5kZXggYnkgbmFtZS5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICB2YXIgYXR0cnMsIGksIGxlbjtcblxuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xOyB9XG5cbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRycy5wdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSxcbiAgICAgIGF0dHJEYXRhID0gWyBuYW1lLCB2YWx1ZSBdO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyR2V0KG5hbWUpXG4gKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhdHRyaWJ1dGUgYG5hbWVgLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCB2YWx1ZSA9IG51bGw7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySm9pbihuYW1lLCB2YWx1ZSlcbiAqXG4gKiBKb2luIHZhbHVlIHRvIGV4aXN0aW5nIGF0dHJpYnV0ZSB2aWEgc3BhY2UuIE9yIGNyZWF0ZSBuZXcgYXR0cmlidXRlIGlmIG5vdFxuICogZXhpc3RzLiBVc2VmdWwgdG8gb3BlcmF0ZSB3aXRoIHRva2VuIGNsYXNzZXMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckpvaW4gPSBmdW5jdGlvbiBhdHRySm9pbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKFsgbmFtZSwgdmFsdWUgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWU7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwiLy8gSFRNTDUgZW50aXRpZXMgbWFwOiB7IG5hbWUgLT4gdXRmMTZzdHJpbmcgfVxuLy9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgcXVvdGVzOjAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlICA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCIvLyBSZWdleHBzIHRvIG1hdGNoIGh0bWwgZWxlbWVudHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXR0cl9uYW1lICAgICA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG5cbnZhciB1bnF1b3RlZCAgICAgID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIHNpbmdsZV9xdW90ZWQgPSBcIidbXiddKidcIjtcbnZhciBkb3VibGVfcXVvdGVkID0gJ1wiW15cIl0qXCInO1xuXG52YXIgYXR0cl92YWx1ZSAgPSAnKD86JyArIHVucXVvdGVkICsgJ3wnICsgc2luZ2xlX3F1b3RlZCArICd8JyArIGRvdWJsZV9xdW90ZWQgKyAnKSc7XG5cbnZhciBhdHRyaWJ1dGUgICA9ICcoPzpcXFxccysnICsgYXR0cl9uYW1lICsgJyg/OlxcXFxzKj1cXFxccyonICsgYXR0cl92YWx1ZSArICcpPyknO1xuXG52YXIgb3Blbl90YWcgICAgPSAnPFtBLVphLXpdW0EtWmEtejAtOVxcXFwtXSonICsgYXR0cmlidXRlICsgJypcXFxccypcXFxcLz8+JztcblxudmFyIGNsb3NlX3RhZyAgID0gJzxcXFxcL1tBLVphLXpdW0EtWmEtejAtOVxcXFwtXSpcXFxccyo+JztcbnZhciBjb21tZW50ICAgICA9ICc8IS0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+JztcbnZhciBwcm9jZXNzaW5nICA9ICc8Wz9dLio/Wz9dPic7XG52YXIgZGVjbGFyYXRpb24gPSAnPCFbQS1aXStcXFxccytbXj5dKj4nO1xudmFyIGNkYXRhICAgICAgID0gJzwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPic7XG5cbnZhciBIVE1MX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnfCcgKyBjb21tZW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHByb2Nlc3NpbmcgKyAnfCcgKyBkZWNsYXJhdGlvbiArICd8JyArIGNkYXRhICsgJyknKTtcbnZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gbmV3IFJlZ0V4cCgnXig/OicgKyBvcGVuX3RhZyArICd8JyArIGNsb3NlX3RhZyArICcpJyk7XG5cbm1vZHVsZS5leHBvcnRzLkhUTUxfVEFHX1JFID0gSFRNTF9UQUdfUkU7XG5tb2R1bGUuZXhwb3J0cy5IVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBqdW1wOiAgIGksXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcbiAgICAgIGVuZDogICAgLTEsXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUpIHtcbiAgdmFyIGksIGosXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGxvbmVNYXJrZXJzID0gW10sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIi8vIFByb2Nlc3MgKnRoaXMqIGFuZCBfdGhhdF9cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4NUYgLyogXyAqLyAmJiBtYXJrZXIgIT09IDB4MkEgLyogKiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gMHgyQSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIC8vIENoYXIgY29kZSBvZiB0aGUgc3RhcnRpbmcgbWFya2VyIChudW1iZXIpLlxuICAgICAgLy9cbiAgICAgIG1hcmtlcjogbWFya2VyLFxuXG4gICAgICAvLyBUb3RhbCBsZW5ndGggb2YgdGhlc2Ugc2VyaWVzIG9mIGRlbGltaXRlcnMuXG4gICAgICAvL1xuICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcblxuICAgICAgLy8gQW4gYW1vdW50IG9mIGNoYXJhY3RlcnMgYmVmb3JlIHRoaXMgb25lIHRoYXQncyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyBjdXJyZW50IG9uZS4gSW4gcGxhaW4gRW5nbGlzaDogaWYgdGhpcyBkZWxpbWl0ZXIgZG9lcyBub3Qgb3BlblxuICAgICAgLy8gYW4gZW1waGFzaXMsIG5laXRoZXIgZG8gcHJldmlvdXMgYGp1bXBgIGNoYXJhY3RlcnMuXG4gICAgICAvL1xuICAgICAgLy8gVXNlZCB0byBza2lwIHNlcXVlbmNlcyBsaWtlIFwiKioqKipcIiBpbiBvbmUgc3RlcCwgZm9yIDFzdCBhc3Rlcmlza1xuICAgICAgLy8gdmFsdWUgd2lsbCBiZSAwLCBmb3IgMm5kIGl0J3MgMSBhbmQgc28gb24uXG4gICAgICAvL1xuICAgICAganVtcDogICBpLFxuXG4gICAgICAvLyBBIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiB0aGlzIGRlbGltaXRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgIC8vXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuXG4gICAgICAvLyBUb2tlbiBsZXZlbC5cbiAgICAgIC8vXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuXG4gICAgICAvLyBJZiB0aGlzIGRlbGltaXRlciBpcyBtYXRjaGVkIGFzIGEgdmFsaWQgb3BlbmVyLCBgZW5kYCB3aWxsIGJlXG4gICAgICAvLyBlcXVhbCB0byBpdHMgcG9zaXRpb24sIG90aGVyd2lzZSBpdCdzIGAtMWAuXG4gICAgICAvL1xuICAgICAgZW5kOiAgICAtMSxcblxuICAgICAgLy8gQm9vbGVhbiBmbGFncyB0aGF0IGRldGVybWluZSBpZiB0aGlzIGRlbGltaXRlciBjb3VsZCBvcGVuIG9yIGNsb3NlXG4gICAgICAvLyBhbiBlbXBoYXNpcy5cbiAgICAgIC8vXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gIHZhciBpLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBjaCxcbiAgICAgIGlzU3Ryb25nLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4MkEvKiAqICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIC8vIElmIHRoZSBuZXh0IGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSArIDEgPCBtYXggJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbiA9PT0gc3RhcnREZWxpbS50b2tlbiArIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgKyAxXS5tYXJrZXIgPT09IHN0YXJ0RGVsaW0ubWFya2VyO1xuXG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0RGVsaW0ubWFya2VyKTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19vcGVuJyA6ICdlbV9vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfY2xvc2UnIDogJ2VtX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW2kgKyAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgLSAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwiaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnbWFya2Rvd24taXQnO1xuaW1wb3J0IE1hcmtkb3duSXREZWNvcmF0ZSBmcm9tICdtYXJrZG93bi1pdC1kZWNvcmF0ZSc7XG5pbXBvcnQgaGlnaGxpZ2h0IGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvaGlnaGxpZ2h0JztcbmltcG9ydCBsSmF2YXNjcmlwdCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0JztcbmltcG9ydCBsQ3NzIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcyc7XG5pbXBvcnQgbFhtbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwnO1xuaW1wb3J0IGxCYXNoIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Jhc2gnO1xuXG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgnYmFzaCcsIGxCYXNoKTtcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdjc3MnLCBsQ3NzKTtcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdqYXZhc2NyaXB0JywgbEphdmFzY3JpcHQpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ3htbCcsIGxYbWwpO1xuXG53aW5kb3cuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG5jb25zdCBtYXJrZWQgPSBNYXJrZG93bkl0KHtcbiAgICBodG1sOiB0cnVlLFxuICAgIGJyZWFrczogZmFsc2UgXG59KS51c2UoTWFya2Rvd25JdERlY29yYXRlKTtcbi8vIOWOu+aOieauteiQvXNvZnRicmVha1xubWFya2VkLnJlbmRlcmVyLnJ1bGVzLnNvZnRicmVhayA9ICgpID0+ICcnO1xuXG5leHBvcnQge2hpZ2hsaWdodCwgbWFya2VkfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi91dGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2luZGV4LmpzIiwiLy8gTWFpbiBwYXJzZXIgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpO1xudmFyIGhlbHBlcnMgICAgICA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIFJlbmRlcmVyICAgICA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcbnZhciBQYXJzZXJDb3JlICAgPSByZXF1aXJlKCcuL3BhcnNlcl9jb3JlJyk7XG52YXIgUGFyc2VyQmxvY2sgID0gcmVxdWlyZSgnLi9wYXJzZXJfYmxvY2snKTtcbnZhciBQYXJzZXJJbmxpbmUgPSByZXF1aXJlKCcuL3BhcnNlcl9pbmxpbmUnKTtcbnZhciBMaW5raWZ5SXQgICAgPSByZXF1aXJlKCdsaW5raWZ5LWl0Jyk7XG52YXIgbWR1cmwgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbnZhciBwdW55Y29kZSAgICAgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5cbnZhciBjb25maWcgPSB7XG4gICdkZWZhdWx0JzogcmVxdWlyZSgnLi9wcmVzZXRzL2RlZmF1bHQnKSxcbiAgemVybzogcmVxdWlyZSgnLi9wcmVzZXRzL3plcm8nKSxcbiAgY29tbW9ubWFyazogcmVxdWlyZSgnLi9wcmVzZXRzL2NvbW1vbm1hcmsnKVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyBUaGlzIHZhbGlkYXRvciBjYW4gcHJvaGliaXQgbW9yZSB0aGFuIHJlYWxseSBuZWVkZWQgdG8gcHJldmVudCBYU1MuIEl0J3MgYVxuLy8gdHJhZGVvZmYgdG8ga2VlcCBjb2RlIHNpbXBsZSBhbmQgdG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQuXG4vL1xuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBkdW1teSBmdW5jdGlvbiBhbmQgdXNlIGV4dGVybmFsIHNhbml0aXplci5cbi8vXG5cbnZhciBCQURfUFJPVE9fUkUgPSAvXih2YnNjcmlwdHxqYXZhc2NyaXB0fGZpbGV8ZGF0YSk6LztcbnZhciBHT09EX0RBVEFfUkUgPSAvXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGluayh1cmwpIHtcbiAgLy8gdXJsIHNob3VsZCBiZSBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQsIGFuZCBleGlzdGluZyBlbnRpdGllcyBhcmUgZGVjb2RlZFxuICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBCQURfUFJPVE9fUkUudGVzdChzdHIpID8gKEdPT0RfREFUQV9SRS50ZXN0KHN0cikgPyB0cnVlIDogZmFsc2UpIDogdHJ1ZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgUkVDT0RFX0hPU1ROQU1FX0ZPUiA9IFsgJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JyBdO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rKHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5lbmNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rVGV4dCh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b1VuaWNvZGUocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5kZWNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTWFya2Rvd25JdFxuICpcbiAqIE1haW4gcGFyc2VyL3JlbmRlcmVyIGNsYXNzLlxuICpcbiAqICMjIyMjIFVzYWdlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gbm9kZS5qcywgXCJjbGFzc2ljXCIgd2F5OlxuICogdmFyIE1hcmtkb3duSXQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpLFxuICogICAgIG1kID0gbmV3IE1hcmtkb3duSXQoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICpcbiAqIC8vIG5vZGUuanMsIHRoZSBzYW1lLCBidXQgd2l0aCBzdWdhcjpcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICpcbiAqIC8vIGJyb3dzZXIgd2l0aG91dCBBTUQsIGFkZGVkIHRvIFwid2luZG93XCIgb24gc2NyaXB0IGxvYWRcbiAqIC8vIE5vdGUsIHRoZXJlIGFyZSBubyBkYXNoLlxuICogdmFyIG1kID0gd2luZG93Lm1hcmtkb3duaXQoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICogYGBgXG4gKlxuICogU2luZ2xlIGxpbmUgcmVuZGVyaW5nLCB3aXRob3V0IHBhcmFncmFwaCB3cmFwOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoJ19fbWFya2Rvd24taXRfXyBydWxlenohJyk7XG4gKiBgYGBcbiAqKi9cblxuLyoqXG4gKiBuZXcgTWFya2Rvd25JdChbcHJlc2V0TmFtZSwgb3B0aW9uc10pXG4gKiAtIHByZXNldE5hbWUgKFN0cmluZyk6IG9wdGlvbmFsLCBgY29tbW9ubWFya2AgLyBgemVyb2BcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KVxuICpcbiAqIENyZWF0ZXMgcGFyc2VyIGluc3RhbnNlIHdpdGggZ2l2ZW4gY29uZmlnLiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2AuXG4gKlxuICogIyMjIyMgcHJlc2V0TmFtZVxuICpcbiAqIE1hcmtkb3duSXQgcHJvdmlkZXMgbmFtZWQgcHJlc2V0cyBhcyBhIGNvbnZlbmllbmNlIHRvIHF1aWNrbHlcbiAqIGVuYWJsZS9kaXNhYmxlIGFjdGl2ZSBzeW50YXggcnVsZXMgYW5kIG9wdGlvbnMgZm9yIGNvbW1vbiB1c2UgY2FzZXMuXG4gKlxuICogLSBbXCJjb21tb25tYXJrXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzKSAtXG4gKiAgIGNvbmZpZ3VyZXMgcGFyc2VyIHRvIHN0cmljdCBbQ29tbW9uTWFya10oaHR0cDovL2NvbW1vbm1hcmsub3JnLykgbW9kZS5cbiAqIC0gW2RlZmF1bHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9kZWZhdWx0LmpzKSAtXG4gKiAgIHNpbWlsYXIgdG8gR0ZNLCB1c2VkIHdoZW4gbm8gcHJlc2V0IG5hbWUgZ2l2ZW4uIEVuYWJsZXMgYWxsIGF2YWlsYWJsZSBydWxlcyxcbiAqICAgYnV0IHN0aWxsIHdpdGhvdXQgaHRtbCwgdHlwb2dyYXBoZXIgJiBhdXRvbGlua2VyLlxuICogLSBbXCJ6ZXJvXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy96ZXJvLmpzKSAtXG4gKiAgIGFsbCBydWxlcyBkaXNhYmxlZC4gVXNlZnVsIHRvIHF1aWNrbHkgc2V0dXAgeW91ciBjb25maWcgdmlhIGAuZW5hYmxlKClgLlxuICogICBGb3IgZXhhbXBsZSwgd2hlbiB5b3UgbmVlZCBvbmx5IGBib2xkYCBhbmQgYGl0YWxpY2AgbWFya3VwIGFuZCBub3RoaW5nIGVsc2UuXG4gKlxuICogIyMjIyMgb3B0aW9uczpcbiAqXG4gKiAtIF9faHRtbF9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZS4gQmUgY2FyZWZ1bCFcbiAqICAgVGhhdCdzIG5vdCBzYWZlISBZb3UgbWF5IG5lZWQgZXh0ZXJuYWwgc2FuaXRpemVyIHRvIHByb3RlY3Qgb3V0cHV0IGZyb20gWFNTLlxuICogICBJdCdzIGJldHRlciB0byBleHRlbmQgZmVhdHVyZXMgdmlhIHBsdWdpbnMsIGluc3RlYWQgb2YgZW5hYmxpbmcgSFRNTC5cbiAqIC0gX194aHRtbE91dF9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhZGQgJy8nIHdoZW4gY2xvc2luZyBzaW5nbGUgdGFnc1xuICogICAoYDxiciAvPmApLiBUaGlzIGlzIG5lZWRlZCBvbmx5IGZvciBmdWxsIENvbW1vbk1hcmsgY29tcGF0aWJpbGl0eS4gSW4gcmVhbFxuICogICB3b3JsZCB5b3Ugd2lsbCBuZWVkIEhUTUwgb3V0cHV0LlxuICogLSBfX2JyZWFrc19fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBjb252ZXJ0IGBcXG5gIGluIHBhcmFncmFwaHMgaW50byBgPGJyPmAuXG4gKiAtIF9fbGFuZ1ByZWZpeF9fIC0gYGxhbmd1YWdlLWAuIENTUyBsYW5ndWFnZSBjbGFzcyBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3MuXG4gKiAgIENhbiBiZSB1c2VmdWwgZm9yIGV4dGVybmFsIGhpZ2hsaWdodGVycy5cbiAqIC0gX19saW5raWZ5X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHQgdG8gbGlua3MuXG4gKiAtIF9fdHlwb2dyYXBoZXJfXyAgLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBbc29tZSBsYW5ndWFnZS1uZXV0cmFsXG4gKiAgIHJlcGxhY2VtZW50XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzKSArXG4gKiAgIHF1b3RlcyBiZWF1dGlmaWNhdGlvbiAoc21hcnRxdW90ZXMpLlxuICogLSBfX3F1b3Rlc19fIC0gYOKAnOKAneKAmOKAmWAsIFN0cmluZyBvciBBcnJheS4gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudFxuICogICBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkIGFuZCBzbWFydHF1b3RlcyBvbi4gRm9yIGV4YW1wbGUsIHlvdSBjYW5cbiAqICAgdXNlIGAnwqvCu+KAnuKAnCdgIGZvciBSdXNzaWFuLCBgJ+KAnuKAnOKAmuKAmCdgIGZvciBHZXJtYW4sIGFuZFxuICogICBgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXWAgZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICogLSBfX2hpZ2hsaWdodF9fIC0gYG51bGxgLiBIaWdobGlnaHRlciBmdW5jdGlvbiBmb3IgZmVuY2VkIGNvZGUgYmxvY2tzLlxuICogICBIaWdobGlnaHRlciBgZnVuY3Rpb24gKHN0ciwgbGFuZylgIHNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLiBJdCBjYW4gYWxzb1xuICogICByZXR1cm4gZW1wdHkgc3RyaW5nIGlmIHRoZSBzb3VyY2Ugd2FzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZFxuICogICBleHRlcm5hbHkuIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gY29tbW9ubWFyayBtb2RlXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCdjb21tb25tYXJrJyk7XG4gKlxuICogLy8gZGVmYXVsdCBtb2RlXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBodG1sOiB0cnVlLFxuICogICBsaW5raWZ5OiB0cnVlLFxuICogICB0eXBvZ3JhcGhlcjogdHJ1ZVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMjIyBTeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogYGBganNcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHN0ciwgbGFuZykge1xuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcbiAqICAgICAgIHRyeSB7XG4gKiAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodChsYW5nLCBzdHIsIHRydWUpLnZhbHVlO1xuICogICAgICAgfSBjYXRjaCAoX18pIHt9XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gJyc7IC8vIHVzZSBleHRlcm5hbCBkZWZhdWx0IGVzY2FwaW5nXG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogT3Igd2l0aCBmdWxsIHdyYXBwZXIgb3ZlcnJpZGUgKGlmIHlvdSBuZWVkIGFzc2lnbiBjbGFzcyB0byBgPHByZT5gKTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuICpcbiAqIC8vIEFjdHVhbCBkZWZhdWx0IHZhbHVlc1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHN0ciwgbGFuZykge1xuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcbiAqICAgICAgIHRyeSB7XG4gKiAgICAgICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICtcbiAqICAgICAgICAgICAgICAgIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWUgK1xuICogICAgICAgICAgICAgICAgJzwvY29kZT48L3ByZT4nO1xuICogICAgICAgfSBjYXRjaCAoX18pIHt9XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gJzxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+JyArIG1kLnV0aWxzLmVzY2FwZUh0bWwoc3RyKSArICc8L2NvZGU+PC9wcmU+JztcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiovXG5mdW5jdGlvbiBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcmtkb3duSXQpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyhwcmVzZXROYW1lKSkge1xuICAgICAgb3B0aW9ucyA9IHByZXNldE5hbWUgfHwge307XG4gICAgICBwcmVzZXROYW1lID0gJ2RlZmF1bHQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2lubGluZSAtPiBQYXJzZXJJbmxpbmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJJbmxpbmVdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuaW5saW5lID0gbmV3IFBhcnNlcklubGluZSgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2Jsb2NrIC0+IFBhcnNlckJsb2NrXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VyQmxvY2tdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuYmxvY2sgPSBuZXcgUGFyc2VyQmxvY2soKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNjb3JlIC0+IENvcmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tDb3JlXV0gY2hhaW4gZXhlY3V0b3IuIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmNvcmUgPSBuZXcgUGFyc2VyQ29yZSgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3JlbmRlcmVyIC0+IFJlbmRlcmVyXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUmVuZGVyZXJdXS4gVXNlIGl0IHRvIG1vZGlmeSBvdXRwdXQgbG9vay4gT3IgdG8gYWRkIHJlbmRlcmluZ1xuICAgKiBydWxlcyBmb3IgbmV3IHRva2VuIHR5cGVzLCBnZW5lcmF0ZWQgYnkgcGx1Z2lucy5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogZnVuY3Rpb24gbXlUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzZWxmKSB7XG4gICAqICAgLy8uLi5cbiAgICogICByZXR1cm4gcmVzdWx0O1xuICAgKiB9O1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlc1snbXlfdG9rZW4nXSA9IG15VG9rZW5cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbW1JlbmRlcmVyXV0gZG9jcyBhbmQgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKS5cbiAgICoqL1xuICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbGlua2lmeSAtPiBMaW5raWZ5SXRcbiAgICpcbiAgICogW2xpbmtpZnktaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0KSBpbnN0YW5jZS5cbiAgICogVXNlZCBieSBbbGlua2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMpXG4gICAqIHJ1bGUuXG4gICAqKi9cbiAgdGhpcy5saW5raWZ5ID0gbmV3IExpbmtpZnlJdCgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3ZhbGlkYXRlTGluayh1cmwpIC0+IEJvb2xlYW5cbiAgICpcbiAgICogTGluayB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBDb21tb25NYXJrIGFsbG93cyB0b28gbXVjaCBpbiBsaW5rcy4gQnkgZGVmYXVsdFxuICAgKiB3ZSBkaXNhYmxlIGBqYXZhc2NyaXB0OmAsIGB2YnNjcmlwdDpgLCBgZmlsZTpgIHNjaGVtYXMsIGFuZCBhbG1vc3QgYWxsIGBkYXRhOi4uLmAgc2NoZW1hc1xuICAgKiBleGNlcHQgc29tZSBlbWJlZGRlZCBpbWFnZSB0eXBlcy5cbiAgICpcbiAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXI6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICAgKiBtZC52YWxpZGF0ZUxpbmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAqIGBgYFxuICAgKiovXG4gIHRoaXMudmFsaWRhdGVMaW5rID0gdmFsaWRhdGVMaW5rO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmsodXJsKSAtPiBTdHJpbmdcbiAgICpcbiAgICogRnVuY3Rpb24gdXNlZCB0byBlbmNvZGUgbGluayB1cmwgdG8gYSBtYWNoaW5lLXJlYWRhYmxlIGZvcm1hdCxcbiAgICogd2hpY2ggaW5jbHVkZXMgdXJsLWVuY29kaW5nLCBwdW55Y29kZSwgZXRjLlxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGluayA9IG5vcm1hbGl6ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGlua1RleHQodXJsKSAtPiBTdHJpbmdcbiAgICpcbiAgICogRnVuY3Rpb24gdXNlZCB0byBkZWNvZGUgbGluayB1cmwgdG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXRgXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rVGV4dCA9IG5vcm1hbGl6ZUxpbmtUZXh0O1xuXG5cbiAgLy8gRXhwb3NlIHV0aWxzICYgaGVscGVycyBmb3IgZWFzeSBhY2NlcyBmcm9tIHBsdWdpbnNcblxuICAvKipcbiAgICogTWFya2Rvd25JdCN1dGlscyAtPiB1dGlsc1xuICAgKlxuICAgKiBBc3NvcnRlZCB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXG4gICAqIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL2NvbW1vbi91dGlscy5qcykuXG4gICAqKi9cbiAgdGhpcy51dGlscyA9IHV0aWxzO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2hlbHBlcnMgLT4gaGVscGVyc1xuICAgKlxuICAgKiBMaW5rIGNvbXBvbmVudHMgcGFyc2VyIGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXG4gICAqIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL2hlbHBlcnMpLlxuICAgKiovXG4gIHRoaXMuaGVscGVycyA9IHV0aWxzLmFzc2lnbih7fSwgaGVscGVycyk7XG5cblxuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgdGhpcy5jb25maWd1cmUocHJlc2V0TmFtZSk7XG5cbiAgaWYgKG9wdGlvbnMpIHsgdGhpcy5zZXQob3B0aW9ucyk7IH1cbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LnNldChvcHRpb25zKVxuICpcbiAqIFNldCBwYXJzZXIgb3B0aW9ucyAoaW4gdGhlIHNhbWUgZm9ybWF0IGFzIGluIGNvbnN0cnVjdG9yKS4gUHJvYmFibHksIHlvdVxuICogd2lsbCBuZXZlciBuZWVkIGl0LCBidXQgeW91IGNhbiBjaGFuZ2Ugb3B0aW9ucyBhZnRlciBjb25zdHJ1Y3RvciBjYWxsLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC5zZXQoeyBodG1sOiB0cnVlLCBicmVha3M6IHRydWUgfSlcbiAqICAgICAgICAgICAgIC5zZXQoeyB0eXBvZ3JhcGhlciwgdHJ1ZSB9KTtcbiAqIGBgYFxuICpcbiAqIF9fTm90ZTpfXyBUbyBhY2hpZXZlIHRoZSBiZXN0IHBvc3NpYmxlIHBlcmZvcm1hbmNlLCBkb24ndCBtb2RpZnkgYVxuICogYG1hcmtkb3duLWl0YCBpbnN0YW5jZSBvcHRpb25zIG9uIHRoZSBmbHkuIElmIHlvdSBuZWVkIG11bHRpcGxlIGNvbmZpZ3VyYXRpb25zXG4gKiBpdCdzIGJlc3QgdG8gY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBhbmQgaW5pdGlhbGl6ZSBlYWNoIHdpdGggc2VwYXJhdGVcbiAqIGNvbmZpZy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHV0aWxzLmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZSwgaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQuY29uZmlndXJlKHByZXNldHMpXG4gKlxuICogQmF0Y2ggbG9hZCBvZiBhbGwgb3B0aW9ucyBhbmQgY29tcGVuZW50IHNldHRpbmdzLiBUaGlzIGlzIGludGVybmFsIG1ldGhvZCxcbiAqIGFuZCB5b3UgcHJvYmFibHkgd2lsbCBub3QgbmVlZCBpdC4gQnV0IGlmIHlvdSB3aXRoIC0gc2VlIGF2YWlsYWJsZSBwcmVzZXRzXG4gKiBhbmQgZGF0YSBzdHJ1Y3R1cmUgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC90cmVlL21hc3Rlci9saWIvcHJlc2V0cylcbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIHByZXNldHMgaW5zdGVhZCBvZiBkaXJlY3QgY29uZmlnIGxvYWRzLiBUaGF0XG4gKiB3aWxsIGdpdmUgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBuZXh0IHZlcnNpb25zLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHByZXNldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBwcmVzZXROYW1lO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhwcmVzZXRzKSkge1xuICAgIHByZXNldE5hbWUgPSBwcmVzZXRzO1xuICAgIHByZXNldHMgPSBjb25maWdbcHJlc2V0TmFtZV07XG4gICAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQgXCInICsgcHJlc2V0TmFtZSArICdcIiwgY2hlY2sgbmFtZScpOyB9XG4gIH1cblxuICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCwgY2FuXFwndCBiZSBlbXB0eScpOyB9XG5cbiAgaWYgKHByZXNldHMub3B0aW9ucykgeyBzZWxmLnNldChwcmVzZXRzLm9wdGlvbnMpOyB9XG5cbiAgaWYgKHByZXNldHMuY29tcG9uZW50cykge1xuICAgIE9iamVjdC5rZXlzKHByZXNldHMuY29tcG9uZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcykge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyLmVuYWJsZU9ubHkocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIyLmVuYWJsZU9ubHkocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZW5hYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgbGlzdCBvciBydWxlcy4gSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGZpbmQgYXBwcm9wcmlhdGUgY29tcG9uZW50cyxcbiAqIGNvbnRhaW5pbmcgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgcnVsZSBub3QgZm91bmQsIGFuZCBgaWdub3JlSW52YWxpZGBcbiAqIG5vdCBzZXQgLSB0aHJvd3MgZXhjZXB0aW9uLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC5lbmFibGUoWydzdWInLCAnc3VwJ10pXG4gKiAgICAgICAgICAgICAuZGlzYWJsZSgnc21hcnRxdW90ZXMnKTtcbiAqIGBgYFxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZW5hYmxlKGxpc3QsIHRydWUpKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZW5hYmxlKGxpc3QsIHRydWUpKTtcblxuICB2YXIgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDsgfSk7XG5cbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtkb3duSXQuIEZhaWxlZCB0byBlbmFibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmRpc2FibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LmVuYWJsZV1dLCBidXQgdHVybiBzcGVjaWZpZWQgcnVsZXMgb2ZmLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5kaXNhYmxlKGxpc3QsIHRydWUpKTtcblxuICB2YXIgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDsgfSk7XG5cbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtkb3duSXQuIEZhaWxlZCB0byBkaXNhYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQudXNlKHBsdWdpbiwgcGFyYW1zKVxuICpcbiAqIExvYWQgc3BlY2lmaWVkIHBsdWdpbiB3aXRoIGdpdmVuIHBhcmFtcyBpbnRvIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlLlxuICogSXQncyBqdXN0IGEgc3VnYXIgdG8gY2FsbCBgcGx1Z2luKG1kLCBwYXJhbXMpYCB3aXRoIGN1cnJpbmcuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBpdGVyYXRvciA9IHJlcXVpcmUoJ21hcmtkb3duLWl0LWZvci1pbmxpbmUnKTtcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnVzZShpdGVyYXRvciwgJ2Zvb19yZXBsYWNlJywgJ3RleHQnLCBmdW5jdGlvbiAodG9rZW5zLCBpZHgpIHtcbiAqICAgICAgICAgICAgICAgdG9rZW5zW2lkeF0uY29udGVudCA9IHRva2Vuc1tpZHhdLmNvbnRlbnQucmVwbGFjZSgvZm9vL2csICdiYXInKTtcbiAqICAgICAgICAgICAgIH0pO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luIC8qLCBwYXJhbXMsIC4uLiAqLykge1xuICB2YXIgYXJncyA9IFsgdGhpcyBdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgcGx1Z2luLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2Uoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBQYXJzZSBpbnB1dCBzdHJpbmcgYW5kIHJldHVybnMgbGlzdCBvZiBibG9jayB0b2tlbnMgKHNwZWNpYWwgdG9rZW4gdHlwZVxuICogXCJpbmxpbmVcIiB3aWxsIGNvbnRhaW4gbGlzdCBvZiBpbmxpbmUgdG9rZW5zKS4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzXG4gKiBtZXRob2QgZGlyZWN0bHksIHVudGlsIHlvdSB3cml0ZSBjdXN0b20gcmVuZGVyZXIgKGZvciBleGFtcGxlLCB0byBwcm9kdWNlXG4gKiBBU1QpLlxuICpcbiAqIGBlbnZgIGlzIHVzZWQgdG8gcGFzcyBkYXRhIGJldHdlZW4gXCJkaXN0cmlidXRlZFwiIHJ1bGVzIGFuZCByZXR1cm4gYWRkaXRpb25hbFxuICogbWV0YWRhdGEgbGlrZSByZWZlcmVuY2UgaW5mbywgbmVlZGVkIGZvciB0aGUgcmVuZGVyZXIuIEl0IGFsc28gY2FuIGJlIHVzZWQgdG9cbiAqIGluamVjdCBkYXRhIGluIHNwZWNpZmljIGNhc2VzLiBVc3VhbGx5LCB5b3Ugd2lsbCBiZSBvayB0byBwYXNzIGB7fWAsXG4gKiBhbmQgdGhlbiBwYXNzIHVwZGF0ZWQgb2JqZWN0IHRvIHJlbmRlcmVyLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHNob3VsZCBiZSBhIFN0cmluZycpO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG5cbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXIoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUmVuZGVyIG1hcmtkb3duIHN0cmluZyBpbnRvIGh0bWwuIEl0IGRvZXMgYWxsIG1hZ2ljIGZvciB5b3UgOikuXG4gKlxuICogYGVudmAgY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGFkZGl0aW9uYWwgbWV0YWRhdGEgKGB7fWAgYnkgZGVmYXVsdCkuXG4gKiBCdXQgeW91IHdpbGwgbm90IG5lZWQgaXQgd2l0aCBoaWdoIHByb2JhYmlsaXR5LiBTZWUgYWxzbyBjb21tZW50XG4gKiBpbiBbW01hcmtkb3duSXQucGFyc2VdXS5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2Uoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZUlubGluZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5wYXJzZV1dIGJ1dCBza2lwIGFsbCBibG9jayBydWxlcy4gSXQgcmV0dXJucyB0aGVcbiAqIGJsb2NrIHRva2VucyBsaXN0IHdpdGggdGhlIHNpbmdsZSBgaW5saW5lYCBlbGVtZW50LCBjb250YWluaW5nIHBhcnNlZCBpbmxpbmVcbiAqIHRva2VucyBpbiBgY2hpbGRyZW5gIHByb3BlcnR5LiBBbHNvIHVwZGF0ZXMgYGVudmAgb2JqZWN0LlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG5cbiAgc3RhdGUuaW5saW5lTW9kZSA9IHRydWU7XG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVySW5saW5lKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFNpbWlsYXIgdG8gW1tNYXJrZG93bkl0LnJlbmRlcl1dIGJ1dCBmb3Igc2luZ2xlIHBhcmFncmFwaCBjb250ZW50LiBSZXN1bHRcbiAqIHdpbGwgTk9UIGJlIHdyYXBwZWQgaW50byBgPHA+YCB0YWdzLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZUlubGluZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bkl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1wiQWFjdXRlXCI6XCLDgVwiLFwiYWFjdXRlXCI6XCLDoVwiLFwiQWJyZXZlXCI6XCLEglwiLFwiYWJyZXZlXCI6XCLEg1wiLFwiYWNcIjpcIuKIvlwiLFwiYWNkXCI6XCLiiL9cIixcImFjRVwiOlwi4oi+zLNcIixcIkFjaXJjXCI6XCLDglwiLFwiYWNpcmNcIjpcIsOiXCIsXCJhY3V0ZVwiOlwiwrRcIixcIkFjeVwiOlwi0JBcIixcImFjeVwiOlwi0LBcIixcIkFFbGlnXCI6XCLDhlwiLFwiYWVsaWdcIjpcIsOmXCIsXCJhZlwiOlwi4oGhXCIsXCJBZnJcIjpcIvCdlIRcIixcImFmclwiOlwi8J2UnlwiLFwiQWdyYXZlXCI6XCLDgFwiLFwiYWdyYXZlXCI6XCLDoFwiLFwiYWxlZnN5bVwiOlwi4oS1XCIsXCJhbGVwaFwiOlwi4oS1XCIsXCJBbHBoYVwiOlwizpFcIixcImFscGhhXCI6XCLOsVwiLFwiQW1hY3JcIjpcIsSAXCIsXCJhbWFjclwiOlwixIFcIixcImFtYWxnXCI6XCLiqL9cIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJhbmRhbmRcIjpcIuKplVwiLFwiQW5kXCI6XCLiqZNcIixcImFuZFwiOlwi4oinXCIsXCJhbmRkXCI6XCLiqZxcIixcImFuZHNsb3BlXCI6XCLiqZhcIixcImFuZHZcIjpcIuKpmlwiLFwiYW5nXCI6XCLiiKBcIixcImFuZ2VcIjpcIuKmpFwiLFwiYW5nbGVcIjpcIuKIoFwiLFwiYW5nbXNkYWFcIjpcIuKmqFwiLFwiYW5nbXNkYWJcIjpcIuKmqVwiLFwiYW5nbXNkYWNcIjpcIuKmqlwiLFwiYW5nbXNkYWRcIjpcIuKmq1wiLFwiYW5nbXNkYWVcIjpcIuKmrFwiLFwiYW5nbXNkYWZcIjpcIuKmrVwiLFwiYW5nbXNkYWdcIjpcIuKmrlwiLFwiYW5nbXNkYWhcIjpcIuKmr1wiLFwiYW5nbXNkXCI6XCLiiKFcIixcImFuZ3J0XCI6XCLiiJ9cIixcImFuZ3J0dmJcIjpcIuKKvlwiLFwiYW5ncnR2YmRcIjpcIuKmnVwiLFwiYW5nc3BoXCI6XCLiiKJcIixcImFuZ3N0XCI6XCLDhVwiLFwiYW5nemFyclwiOlwi4o28XCIsXCJBb2dvblwiOlwixIRcIixcImFvZ29uXCI6XCLEhVwiLFwiQW9wZlwiOlwi8J2UuFwiLFwiYW9wZlwiOlwi8J2VklwiLFwiYXBhY2lyXCI6XCLiqa9cIixcImFwXCI6XCLiiYhcIixcImFwRVwiOlwi4qmwXCIsXCJhcGVcIjpcIuKJilwiLFwiYXBpZFwiOlwi4omLXCIsXCJhcG9zXCI6XCInXCIsXCJBcHBseUZ1bmN0aW9uXCI6XCLigaFcIixcImFwcHJveFwiOlwi4omIXCIsXCJhcHByb3hlcVwiOlwi4omKXCIsXCJBcmluZ1wiOlwiw4VcIixcImFyaW5nXCI6XCLDpVwiLFwiQXNjclwiOlwi8J2SnFwiLFwiYXNjclwiOlwi8J2StlwiLFwiQXNzaWduXCI6XCLiiZRcIixcImFzdFwiOlwiKlwiLFwiYXN5bXBcIjpcIuKJiFwiLFwiYXN5bXBlcVwiOlwi4omNXCIsXCJBdGlsZGVcIjpcIsODXCIsXCJhdGlsZGVcIjpcIsOjXCIsXCJBdW1sXCI6XCLDhFwiLFwiYXVtbFwiOlwiw6RcIixcImF3Y29uaW50XCI6XCLiiLNcIixcImF3aW50XCI6XCLiqJFcIixcImJhY2tjb25nXCI6XCLiiYxcIixcImJhY2tlcHNpbG9uXCI6XCLPtlwiLFwiYmFja3ByaW1lXCI6XCLigLVcIixcImJhY2tzaW1cIjpcIuKIvVwiLFwiYmFja3NpbWVxXCI6XCLii41cIixcIkJhY2tzbGFzaFwiOlwi4oiWXCIsXCJCYXJ2XCI6XCLiq6dcIixcImJhcnZlZVwiOlwi4oq9XCIsXCJiYXJ3ZWRcIjpcIuKMhVwiLFwiQmFyd2VkXCI6XCLijIZcIixcImJhcndlZGdlXCI6XCLijIVcIixcImJicmtcIjpcIuKOtVwiLFwiYmJya3RicmtcIjpcIuKOtlwiLFwiYmNvbmdcIjpcIuKJjFwiLFwiQmN5XCI6XCLQkVwiLFwiYmN5XCI6XCLQsVwiLFwiYmRxdW9cIjpcIuKAnlwiLFwiYmVjYXVzXCI6XCLiiLVcIixcImJlY2F1c2VcIjpcIuKItVwiLFwiQmVjYXVzZVwiOlwi4oi1XCIsXCJiZW1wdHl2XCI6XCLiprBcIixcImJlcHNpXCI6XCLPtlwiLFwiYmVybm91XCI6XCLihKxcIixcIkJlcm5vdWxsaXNcIjpcIuKErFwiLFwiQmV0YVwiOlwizpJcIixcImJldGFcIjpcIs6yXCIsXCJiZXRoXCI6XCLihLZcIixcImJldHdlZW5cIjpcIuKJrFwiLFwiQmZyXCI6XCLwnZSFXCIsXCJiZnJcIjpcIvCdlJ9cIixcImJpZ2NhcFwiOlwi4ouCXCIsXCJiaWdjaXJjXCI6XCLil69cIixcImJpZ2N1cFwiOlwi4ouDXCIsXCJiaWdvZG90XCI6XCLiqIBcIixcImJpZ29wbHVzXCI6XCLiqIFcIixcImJpZ290aW1lc1wiOlwi4qiCXCIsXCJiaWdzcWN1cFwiOlwi4qiGXCIsXCJiaWdzdGFyXCI6XCLimIVcIixcImJpZ3RyaWFuZ2xlZG93blwiOlwi4pa9XCIsXCJiaWd0cmlhbmdsZXVwXCI6XCLilrNcIixcImJpZ3VwbHVzXCI6XCLiqIRcIixcImJpZ3ZlZVwiOlwi4ouBXCIsXCJiaWd3ZWRnZVwiOlwi4ouAXCIsXCJia2Fyb3dcIjpcIuKkjVwiLFwiYmxhY2tsb3plbmdlXCI6XCLip6tcIixcImJsYWNrc3F1YXJlXCI6XCLilqpcIixcImJsYWNrdHJpYW5nbGVcIjpcIuKWtFwiLFwiYmxhY2t0cmlhbmdsZWRvd25cIjpcIuKWvlwiLFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIuKXglwiLFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCLilrhcIixcImJsYW5rXCI6XCLikKNcIixcImJsazEyXCI6XCLilpJcIixcImJsazE0XCI6XCLilpFcIixcImJsazM0XCI6XCLilpNcIixcImJsb2NrXCI6XCLilohcIixcImJuZVwiOlwiPeKDpVwiLFwiYm5lcXVpdlwiOlwi4omh4oOlXCIsXCJiTm90XCI6XCLiq61cIixcImJub3RcIjpcIuKMkFwiLFwiQm9wZlwiOlwi8J2UuVwiLFwiYm9wZlwiOlwi8J2Vk1wiLFwiYm90XCI6XCLiiqVcIixcImJvdHRvbVwiOlwi4oqlXCIsXCJib3d0aWVcIjpcIuKLiFwiLFwiYm94Ym94XCI6XCLip4lcIixcImJveGRsXCI6XCLilJBcIixcImJveGRMXCI6XCLilZVcIixcImJveERsXCI6XCLilZZcIixcImJveERMXCI6XCLilZdcIixcImJveGRyXCI6XCLilIxcIixcImJveGRSXCI6XCLilZJcIixcImJveERyXCI6XCLilZNcIixcImJveERSXCI6XCLilZRcIixcImJveGhcIjpcIuKUgFwiLFwiYm94SFwiOlwi4pWQXCIsXCJib3hoZFwiOlwi4pSsXCIsXCJib3hIZFwiOlwi4pWkXCIsXCJib3hoRFwiOlwi4pWlXCIsXCJib3hIRFwiOlwi4pWmXCIsXCJib3hodVwiOlwi4pS0XCIsXCJib3hIdVwiOlwi4pWnXCIsXCJib3hoVVwiOlwi4pWoXCIsXCJib3hIVVwiOlwi4pWpXCIsXCJib3htaW51c1wiOlwi4oqfXCIsXCJib3hwbHVzXCI6XCLiip5cIixcImJveHRpbWVzXCI6XCLiiqBcIixcImJveHVsXCI6XCLilJhcIixcImJveHVMXCI6XCLilZtcIixcImJveFVsXCI6XCLilZxcIixcImJveFVMXCI6XCLilZ1cIixcImJveHVyXCI6XCLilJRcIixcImJveHVSXCI6XCLilZhcIixcImJveFVyXCI6XCLilZlcIixcImJveFVSXCI6XCLilZpcIixcImJveHZcIjpcIuKUglwiLFwiYm94VlwiOlwi4pWRXCIsXCJib3h2aFwiOlwi4pS8XCIsXCJib3h2SFwiOlwi4pWqXCIsXCJib3hWaFwiOlwi4pWrXCIsXCJib3hWSFwiOlwi4pWsXCIsXCJib3h2bFwiOlwi4pSkXCIsXCJib3h2TFwiOlwi4pWhXCIsXCJib3hWbFwiOlwi4pWiXCIsXCJib3hWTFwiOlwi4pWjXCIsXCJib3h2clwiOlwi4pScXCIsXCJib3h2UlwiOlwi4pWeXCIsXCJib3hWclwiOlwi4pWfXCIsXCJib3hWUlwiOlwi4pWgXCIsXCJicHJpbWVcIjpcIuKAtVwiLFwiYnJldmVcIjpcIsuYXCIsXCJCcmV2ZVwiOlwiy5hcIixcImJydmJhclwiOlwiwqZcIixcImJzY3JcIjpcIvCdkrdcIixcIkJzY3JcIjpcIuKErFwiLFwiYnNlbWlcIjpcIuKBj1wiLFwiYnNpbVwiOlwi4oi9XCIsXCJic2ltZVwiOlwi4ouNXCIsXCJic29sYlwiOlwi4qeFXCIsXCJic29sXCI6XCJcXFxcXCIsXCJic29saHN1YlwiOlwi4p+IXCIsXCJidWxsXCI6XCLigKJcIixcImJ1bGxldFwiOlwi4oCiXCIsXCJidW1wXCI6XCLiiY5cIixcImJ1bXBFXCI6XCLiqq5cIixcImJ1bXBlXCI6XCLiiY9cIixcIkJ1bXBlcVwiOlwi4omOXCIsXCJidW1wZXFcIjpcIuKJj1wiLFwiQ2FjdXRlXCI6XCLEhlwiLFwiY2FjdXRlXCI6XCLEh1wiLFwiY2FwYW5kXCI6XCLiqYRcIixcImNhcGJyY3VwXCI6XCLiqYlcIixcImNhcGNhcFwiOlwi4qmLXCIsXCJjYXBcIjpcIuKIqVwiLFwiQ2FwXCI6XCLii5JcIixcImNhcGN1cFwiOlwi4qmHXCIsXCJjYXBkb3RcIjpcIuKpgFwiLFwiQ2FwaXRhbERpZmZlcmVudGlhbERcIjpcIuKFhVwiLFwiY2Fwc1wiOlwi4oip77iAXCIsXCJjYXJldFwiOlwi4oGBXCIsXCJjYXJvblwiOlwiy4dcIixcIkNheWxleXNcIjpcIuKErVwiLFwiY2NhcHNcIjpcIuKpjVwiLFwiQ2Nhcm9uXCI6XCLEjFwiLFwiY2Nhcm9uXCI6XCLEjVwiLFwiQ2NlZGlsXCI6XCLDh1wiLFwiY2NlZGlsXCI6XCLDp1wiLFwiQ2NpcmNcIjpcIsSIXCIsXCJjY2lyY1wiOlwixIlcIixcIkNjb25pbnRcIjpcIuKIsFwiLFwiY2N1cHNcIjpcIuKpjFwiLFwiY2N1cHNzbVwiOlwi4qmQXCIsXCJDZG90XCI6XCLEilwiLFwiY2RvdFwiOlwixItcIixcImNlZGlsXCI6XCLCuFwiLFwiQ2VkaWxsYVwiOlwiwrhcIixcImNlbXB0eXZcIjpcIuKmslwiLFwiY2VudFwiOlwiwqJcIixcImNlbnRlcmRvdFwiOlwiwrdcIixcIkNlbnRlckRvdFwiOlwiwrdcIixcImNmclwiOlwi8J2UoFwiLFwiQ2ZyXCI6XCLihK1cIixcIkNIY3lcIjpcItCnXCIsXCJjaGN5XCI6XCLRh1wiLFwiY2hlY2tcIjpcIuKck1wiLFwiY2hlY2ttYXJrXCI6XCLinJNcIixcIkNoaVwiOlwizqdcIixcImNoaVwiOlwiz4dcIixcImNpcmNcIjpcIsuGXCIsXCJjaXJjZXFcIjpcIuKJl1wiLFwiY2lyY2xlYXJyb3dsZWZ0XCI6XCLihrpcIixcImNpcmNsZWFycm93cmlnaHRcIjpcIuKGu1wiLFwiY2lyY2xlZGFzdFwiOlwi4oqbXCIsXCJjaXJjbGVkY2lyY1wiOlwi4oqaXCIsXCJjaXJjbGVkZGFzaFwiOlwi4oqdXCIsXCJDaXJjbGVEb3RcIjpcIuKKmVwiLFwiY2lyY2xlZFJcIjpcIsKuXCIsXCJjaXJjbGVkU1wiOlwi4pOIXCIsXCJDaXJjbGVNaW51c1wiOlwi4oqWXCIsXCJDaXJjbGVQbHVzXCI6XCLiipVcIixcIkNpcmNsZVRpbWVzXCI6XCLiipdcIixcImNpclwiOlwi4peLXCIsXCJjaXJFXCI6XCLip4NcIixcImNpcmVcIjpcIuKJl1wiLFwiY2lyZm5pbnRcIjpcIuKokFwiLFwiY2lybWlkXCI6XCLiq69cIixcImNpcnNjaXJcIjpcIuKnglwiLFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCLiiLJcIixcIkNsb3NlQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCdXCIsXCJDbG9zZUN1cmx5UXVvdGVcIjpcIuKAmVwiLFwiY2x1YnNcIjpcIuKZo1wiLFwiY2x1YnN1aXRcIjpcIuKZo1wiLFwiY29sb25cIjpcIjpcIixcIkNvbG9uXCI6XCLiiLdcIixcIkNvbG9uZVwiOlwi4qm0XCIsXCJjb2xvbmVcIjpcIuKJlFwiLFwiY29sb25lcVwiOlwi4omUXCIsXCJjb21tYVwiOlwiLFwiLFwiY29tbWF0XCI6XCJAXCIsXCJjb21wXCI6XCLiiIFcIixcImNvbXBmblwiOlwi4oiYXCIsXCJjb21wbGVtZW50XCI6XCLiiIFcIixcImNvbXBsZXhlc1wiOlwi4oSCXCIsXCJjb25nXCI6XCLiiYVcIixcImNvbmdkb3RcIjpcIuKprVwiLFwiQ29uZ3J1ZW50XCI6XCLiiaFcIixcImNvbmludFwiOlwi4oiuXCIsXCJDb25pbnRcIjpcIuKIr1wiLFwiQ29udG91ckludGVncmFsXCI6XCLiiK5cIixcImNvcGZcIjpcIvCdlZRcIixcIkNvcGZcIjpcIuKEglwiLFwiY29wcm9kXCI6XCLiiJBcIixcIkNvcHJvZHVjdFwiOlwi4oiQXCIsXCJjb3B5XCI6XCLCqVwiLFwiQ09QWVwiOlwiwqlcIixcImNvcHlzclwiOlwi4oSXXCIsXCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCLiiLNcIixcImNyYXJyXCI6XCLihrVcIixcImNyb3NzXCI6XCLinJdcIixcIkNyb3NzXCI6XCLiqK9cIixcIkNzY3JcIjpcIvCdkp5cIixcImNzY3JcIjpcIvCdkrhcIixcImNzdWJcIjpcIuKrj1wiLFwiY3N1YmVcIjpcIuKrkVwiLFwiY3N1cFwiOlwi4quQXCIsXCJjc3VwZVwiOlwi4quSXCIsXCJjdGRvdFwiOlwi4ouvXCIsXCJjdWRhcnJsXCI6XCLipLhcIixcImN1ZGFycnJcIjpcIuKktVwiLFwiY3VlcHJcIjpcIuKLnlwiLFwiY3Vlc2NcIjpcIuKLn1wiLFwiY3VsYXJyXCI6XCLihrZcIixcImN1bGFycnBcIjpcIuKkvVwiLFwiY3VwYnJjYXBcIjpcIuKpiFwiLFwiY3VwY2FwXCI6XCLiqYZcIixcIkN1cENhcFwiOlwi4omNXCIsXCJjdXBcIjpcIuKIqlwiLFwiQ3VwXCI6XCLii5NcIixcImN1cGN1cFwiOlwi4qmKXCIsXCJjdXBkb3RcIjpcIuKKjVwiLFwiY3Vwb3JcIjpcIuKphVwiLFwiY3Vwc1wiOlwi4oiq77iAXCIsXCJjdXJhcnJcIjpcIuKGt1wiLFwiY3VyYXJybVwiOlwi4qS8XCIsXCJjdXJseWVxcHJlY1wiOlwi4oueXCIsXCJjdXJseWVxc3VjY1wiOlwi4oufXCIsXCJjdXJseXZlZVwiOlwi4ouOXCIsXCJjdXJseXdlZGdlXCI6XCLii49cIixcImN1cnJlblwiOlwiwqRcIixcImN1cnZlYXJyb3dsZWZ0XCI6XCLihrZcIixcImN1cnZlYXJyb3dyaWdodFwiOlwi4oa3XCIsXCJjdXZlZVwiOlwi4ouOXCIsXCJjdXdlZFwiOlwi4ouPXCIsXCJjd2NvbmludFwiOlwi4oiyXCIsXCJjd2ludFwiOlwi4oixXCIsXCJjeWxjdHlcIjpcIuKMrVwiLFwiZGFnZ2VyXCI6XCLigKBcIixcIkRhZ2dlclwiOlwi4oChXCIsXCJkYWxldGhcIjpcIuKEuFwiLFwiZGFyclwiOlwi4oaTXCIsXCJEYXJyXCI6XCLihqFcIixcImRBcnJcIjpcIuKHk1wiLFwiZGFzaFwiOlwi4oCQXCIsXCJEYXNodlwiOlwi4qukXCIsXCJkYXNodlwiOlwi4oqjXCIsXCJkYmthcm93XCI6XCLipI9cIixcImRibGFjXCI6XCLLnVwiLFwiRGNhcm9uXCI6XCLEjlwiLFwiZGNhcm9uXCI6XCLEj1wiLFwiRGN5XCI6XCLQlFwiLFwiZGN5XCI6XCLQtFwiLFwiZGRhZ2dlclwiOlwi4oChXCIsXCJkZGFyclwiOlwi4oeKXCIsXCJERFwiOlwi4oWFXCIsXCJkZFwiOlwi4oWGXCIsXCJERG90cmFoZFwiOlwi4qSRXCIsXCJkZG90c2VxXCI6XCLiqbdcIixcImRlZ1wiOlwiwrBcIixcIkRlbFwiOlwi4oiHXCIsXCJEZWx0YVwiOlwizpRcIixcImRlbHRhXCI6XCLOtFwiLFwiZGVtcHR5dlwiOlwi4qaxXCIsXCJkZmlzaHRcIjpcIuKlv1wiLFwiRGZyXCI6XCLwnZSHXCIsXCJkZnJcIjpcIvCdlKFcIixcImRIYXJcIjpcIuKlpVwiLFwiZGhhcmxcIjpcIuKHg1wiLFwiZGhhcnJcIjpcIuKHglwiLFwiRGlhY3JpdGljYWxBY3V0ZVwiOlwiwrRcIixcIkRpYWNyaXRpY2FsRG90XCI6XCLLmVwiLFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOlwiy51cIixcIkRpYWNyaXRpY2FsR3JhdmVcIjpcImBcIixcIkRpYWNyaXRpY2FsVGlsZGVcIjpcIsucXCIsXCJkaWFtXCI6XCLii4RcIixcImRpYW1vbmRcIjpcIuKLhFwiLFwiRGlhbW9uZFwiOlwi4ouEXCIsXCJkaWFtb25kc3VpdFwiOlwi4pmmXCIsXCJkaWFtc1wiOlwi4pmmXCIsXCJkaWVcIjpcIsKoXCIsXCJEaWZmZXJlbnRpYWxEXCI6XCLihYZcIixcImRpZ2FtbWFcIjpcIs+dXCIsXCJkaXNpblwiOlwi4ouyXCIsXCJkaXZcIjpcIsO3XCIsXCJkaXZpZGVcIjpcIsO3XCIsXCJkaXZpZGVvbnRpbWVzXCI6XCLii4dcIixcImRpdm9ueFwiOlwi4ouHXCIsXCJESmN5XCI6XCLQglwiLFwiZGpjeVwiOlwi0ZJcIixcImRsY29yblwiOlwi4oyeXCIsXCJkbGNyb3BcIjpcIuKMjVwiLFwiZG9sbGFyXCI6XCIkXCIsXCJEb3BmXCI6XCLwnZS7XCIsXCJkb3BmXCI6XCLwnZWVXCIsXCJEb3RcIjpcIsKoXCIsXCJkb3RcIjpcIsuZXCIsXCJEb3REb3RcIjpcIuKDnFwiLFwiZG90ZXFcIjpcIuKJkFwiLFwiZG90ZXFkb3RcIjpcIuKJkVwiLFwiRG90RXF1YWxcIjpcIuKJkFwiLFwiZG90bWludXNcIjpcIuKIuFwiLFwiZG90cGx1c1wiOlwi4oiUXCIsXCJkb3RzcXVhcmVcIjpcIuKKoVwiLFwiZG91YmxlYmFyd2VkZ2VcIjpcIuKMhlwiLFwiRG91YmxlQ29udG91ckludGVncmFsXCI6XCLiiK9cIixcIkRvdWJsZURvdFwiOlwiwqhcIixcIkRvdWJsZURvd25BcnJvd1wiOlwi4oeTXCIsXCJEb3VibGVMZWZ0QXJyb3dcIjpcIuKHkFwiLFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjpcIuKHlFwiLFwiRG91YmxlTGVmdFRlZVwiOlwi4qukXCIsXCJEb3VibGVMb25nTGVmdEFycm93XCI6XCLin7hcIixcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+6XCIsXCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOlwi4p+5XCIsXCJEb3VibGVSaWdodEFycm93XCI6XCLih5JcIixcIkRvdWJsZVJpZ2h0VGVlXCI6XCLiiqhcIixcIkRvdWJsZVVwQXJyb3dcIjpcIuKHkVwiLFwiRG91YmxlVXBEb3duQXJyb3dcIjpcIuKHlVwiLFwiRG91YmxlVmVydGljYWxCYXJcIjpcIuKIpVwiLFwiRG93bkFycm93QmFyXCI6XCLipJNcIixcImRvd25hcnJvd1wiOlwi4oaTXCIsXCJEb3duQXJyb3dcIjpcIuKGk1wiLFwiRG93bmFycm93XCI6XCLih5NcIixcIkRvd25BcnJvd1VwQXJyb3dcIjpcIuKHtVwiLFwiRG93bkJyZXZlXCI6XCLMkVwiLFwiZG93bmRvd25hcnJvd3NcIjpcIuKHilwiLFwiZG93bmhhcnBvb25sZWZ0XCI6XCLih4NcIixcImRvd25oYXJwb29ucmlnaHRcIjpcIuKHglwiLFwiRG93bkxlZnRSaWdodFZlY3RvclwiOlwi4qWQXCIsXCJEb3duTGVmdFRlZVZlY3RvclwiOlwi4qWeXCIsXCJEb3duTGVmdFZlY3RvckJhclwiOlwi4qWWXCIsXCJEb3duTGVmdFZlY3RvclwiOlwi4oa9XCIsXCJEb3duUmlnaHRUZWVWZWN0b3JcIjpcIuKln1wiLFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6XCLipZdcIixcIkRvd25SaWdodFZlY3RvclwiOlwi4oeBXCIsXCJEb3duVGVlQXJyb3dcIjpcIuKGp1wiLFwiRG93blRlZVwiOlwi4oqkXCIsXCJkcmJrYXJvd1wiOlwi4qSQXCIsXCJkcmNvcm5cIjpcIuKMn1wiLFwiZHJjcm9wXCI6XCLijIxcIixcIkRzY3JcIjpcIvCdkp9cIixcImRzY3JcIjpcIvCdkrlcIixcIkRTY3lcIjpcItCFXCIsXCJkc2N5XCI6XCLRlVwiLFwiZHNvbFwiOlwi4qe2XCIsXCJEc3Ryb2tcIjpcIsSQXCIsXCJkc3Ryb2tcIjpcIsSRXCIsXCJkdGRvdFwiOlwi4ouxXCIsXCJkdHJpXCI6XCLilr9cIixcImR0cmlmXCI6XCLilr5cIixcImR1YXJyXCI6XCLih7VcIixcImR1aGFyXCI6XCLipa9cIixcImR3YW5nbGVcIjpcIuKmplwiLFwiRFpjeVwiOlwi0I9cIixcImR6Y3lcIjpcItGfXCIsXCJkemlncmFyclwiOlwi4p+/XCIsXCJFYWN1dGVcIjpcIsOJXCIsXCJlYWN1dGVcIjpcIsOpXCIsXCJlYXN0ZXJcIjpcIuKprlwiLFwiRWNhcm9uXCI6XCLEmlwiLFwiZWNhcm9uXCI6XCLEm1wiLFwiRWNpcmNcIjpcIsOKXCIsXCJlY2lyY1wiOlwiw6pcIixcImVjaXJcIjpcIuKJllwiLFwiZWNvbG9uXCI6XCLiiZVcIixcIkVjeVwiOlwi0K1cIixcImVjeVwiOlwi0Y1cIixcImVERG90XCI6XCLiqbdcIixcIkVkb3RcIjpcIsSWXCIsXCJlZG90XCI6XCLEl1wiLFwiZURvdFwiOlwi4omRXCIsXCJlZVwiOlwi4oWHXCIsXCJlZkRvdFwiOlwi4omSXCIsXCJFZnJcIjpcIvCdlIhcIixcImVmclwiOlwi8J2UolwiLFwiZWdcIjpcIuKqmlwiLFwiRWdyYXZlXCI6XCLDiFwiLFwiZWdyYXZlXCI6XCLDqFwiLFwiZWdzXCI6XCLiqpZcIixcImVnc2RvdFwiOlwi4qqYXCIsXCJlbFwiOlwi4qqZXCIsXCJFbGVtZW50XCI6XCLiiIhcIixcImVsaW50ZXJzXCI6XCLij6dcIixcImVsbFwiOlwi4oSTXCIsXCJlbHNcIjpcIuKqlVwiLFwiZWxzZG90XCI6XCLiqpdcIixcIkVtYWNyXCI6XCLEklwiLFwiZW1hY3JcIjpcIsSTXCIsXCJlbXB0eVwiOlwi4oiFXCIsXCJlbXB0eXNldFwiOlwi4oiFXCIsXCJFbXB0eVNtYWxsU3F1YXJlXCI6XCLil7tcIixcImVtcHR5dlwiOlwi4oiFXCIsXCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOlwi4parXCIsXCJlbXNwMTNcIjpcIuKAhFwiLFwiZW1zcDE0XCI6XCLigIVcIixcImVtc3BcIjpcIuKAg1wiLFwiRU5HXCI6XCLFilwiLFwiZW5nXCI6XCLFi1wiLFwiZW5zcFwiOlwi4oCCXCIsXCJFb2dvblwiOlwixJhcIixcImVvZ29uXCI6XCLEmVwiLFwiRW9wZlwiOlwi8J2UvFwiLFwiZW9wZlwiOlwi8J2VllwiLFwiZXBhclwiOlwi4ouVXCIsXCJlcGFyc2xcIjpcIuKno1wiLFwiZXBsdXNcIjpcIuKpsVwiLFwiZXBzaVwiOlwizrVcIixcIkVwc2lsb25cIjpcIs6VXCIsXCJlcHNpbG9uXCI6XCLOtVwiLFwiZXBzaXZcIjpcIs+1XCIsXCJlcWNpcmNcIjpcIuKJllwiLFwiZXFjb2xvblwiOlwi4omVXCIsXCJlcXNpbVwiOlwi4omCXCIsXCJlcXNsYW50Z3RyXCI6XCLiqpZcIixcImVxc2xhbnRsZXNzXCI6XCLiqpVcIixcIkVxdWFsXCI6XCLiqbVcIixcImVxdWFsc1wiOlwiPVwiLFwiRXF1YWxUaWxkZVwiOlwi4omCXCIsXCJlcXVlc3RcIjpcIuKJn1wiLFwiRXF1aWxpYnJpdW1cIjpcIuKHjFwiLFwiZXF1aXZcIjpcIuKJoVwiLFwiZXF1aXZERFwiOlwi4qm4XCIsXCJlcXZwYXJzbFwiOlwi4qelXCIsXCJlcmFyclwiOlwi4qWxXCIsXCJlckRvdFwiOlwi4omTXCIsXCJlc2NyXCI6XCLihK9cIixcIkVzY3JcIjpcIuKEsFwiLFwiZXNkb3RcIjpcIuKJkFwiLFwiRXNpbVwiOlwi4qmzXCIsXCJlc2ltXCI6XCLiiYJcIixcIkV0YVwiOlwizpdcIixcImV0YVwiOlwizrdcIixcIkVUSFwiOlwiw5BcIixcImV0aFwiOlwiw7BcIixcIkV1bWxcIjpcIsOLXCIsXCJldW1sXCI6XCLDq1wiLFwiZXVyb1wiOlwi4oKsXCIsXCJleGNsXCI6XCIhXCIsXCJleGlzdFwiOlwi4oiDXCIsXCJFeGlzdHNcIjpcIuKIg1wiLFwiZXhwZWN0YXRpb25cIjpcIuKEsFwiLFwiZXhwb25lbnRpYWxlXCI6XCLihYdcIixcIkV4cG9uZW50aWFsRVwiOlwi4oWHXCIsXCJmYWxsaW5nZG90c2VxXCI6XCLiiZJcIixcIkZjeVwiOlwi0KRcIixcImZjeVwiOlwi0YRcIixcImZlbWFsZVwiOlwi4pmAXCIsXCJmZmlsaWdcIjpcIu+sg1wiLFwiZmZsaWdcIjpcIu+sgFwiLFwiZmZsbGlnXCI6XCLvrIRcIixcIkZmclwiOlwi8J2UiVwiLFwiZmZyXCI6XCLwnZSjXCIsXCJmaWxpZ1wiOlwi76yBXCIsXCJGaWxsZWRTbWFsbFNxdWFyZVwiOlwi4pe8XCIsXCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjpcIuKWqlwiLFwiZmpsaWdcIjpcImZqXCIsXCJmbGF0XCI6XCLima1cIixcImZsbGlnXCI6XCLvrIJcIixcImZsdG5zXCI6XCLilrFcIixcImZub2ZcIjpcIsaSXCIsXCJGb3BmXCI6XCLwnZS9XCIsXCJmb3BmXCI6XCLwnZWXXCIsXCJmb3JhbGxcIjpcIuKIgFwiLFwiRm9yQWxsXCI6XCLiiIBcIixcImZvcmtcIjpcIuKLlFwiLFwiZm9ya3ZcIjpcIuKrmVwiLFwiRm91cmllcnRyZlwiOlwi4oSxXCIsXCJmcGFydGludFwiOlwi4qiNXCIsXCJmcmFjMTJcIjpcIsK9XCIsXCJmcmFjMTNcIjpcIuKFk1wiLFwiZnJhYzE0XCI6XCLCvFwiLFwiZnJhYzE1XCI6XCLihZVcIixcImZyYWMxNlwiOlwi4oWZXCIsXCJmcmFjMThcIjpcIuKFm1wiLFwiZnJhYzIzXCI6XCLihZRcIixcImZyYWMyNVwiOlwi4oWWXCIsXCJmcmFjMzRcIjpcIsK+XCIsXCJmcmFjMzVcIjpcIuKFl1wiLFwiZnJhYzM4XCI6XCLihZxcIixcImZyYWM0NVwiOlwi4oWYXCIsXCJmcmFjNTZcIjpcIuKFmlwiLFwiZnJhYzU4XCI6XCLihZ1cIixcImZyYWM3OFwiOlwi4oWeXCIsXCJmcmFzbFwiOlwi4oGEXCIsXCJmcm93blwiOlwi4oyiXCIsXCJmc2NyXCI6XCLwnZK7XCIsXCJGc2NyXCI6XCLihLFcIixcImdhY3V0ZVwiOlwix7VcIixcIkdhbW1hXCI6XCLOk1wiLFwiZ2FtbWFcIjpcIs6zXCIsXCJHYW1tYWRcIjpcIs+cXCIsXCJnYW1tYWRcIjpcIs+dXCIsXCJnYXBcIjpcIuKqhlwiLFwiR2JyZXZlXCI6XCLEnlwiLFwiZ2JyZXZlXCI6XCLEn1wiLFwiR2NlZGlsXCI6XCLEolwiLFwiR2NpcmNcIjpcIsScXCIsXCJnY2lyY1wiOlwixJ1cIixcIkdjeVwiOlwi0JNcIixcImdjeVwiOlwi0LNcIixcIkdkb3RcIjpcIsSgXCIsXCJnZG90XCI6XCLEoVwiLFwiZ2VcIjpcIuKJpVwiLFwiZ0VcIjpcIuKJp1wiLFwiZ0VsXCI6XCLiqoxcIixcImdlbFwiOlwi4oubXCIsXCJnZXFcIjpcIuKJpVwiLFwiZ2VxcVwiOlwi4omnXCIsXCJnZXFzbGFudFwiOlwi4qm+XCIsXCJnZXNjY1wiOlwi4qqpXCIsXCJnZXNcIjpcIuKpvlwiLFwiZ2VzZG90XCI6XCLiqoBcIixcImdlc2RvdG9cIjpcIuKqglwiLFwiZ2VzZG90b2xcIjpcIuKqhFwiLFwiZ2VzbFwiOlwi4oub77iAXCIsXCJnZXNsZXNcIjpcIuKqlFwiLFwiR2ZyXCI6XCLwnZSKXCIsXCJnZnJcIjpcIvCdlKRcIixcImdnXCI6XCLiiatcIixcIkdnXCI6XCLii5lcIixcImdnZ1wiOlwi4ouZXCIsXCJnaW1lbFwiOlwi4oS3XCIsXCJHSmN5XCI6XCLQg1wiLFwiZ2pjeVwiOlwi0ZNcIixcImdsYVwiOlwi4qqlXCIsXCJnbFwiOlwi4om3XCIsXCJnbEVcIjpcIuKqklwiLFwiZ2xqXCI6XCLiqqRcIixcImduYXBcIjpcIuKqilwiLFwiZ25hcHByb3hcIjpcIuKqilwiLFwiZ25lXCI6XCLiqohcIixcImduRVwiOlwi4ompXCIsXCJnbmVxXCI6XCLiqohcIixcImduZXFxXCI6XCLiialcIixcImduc2ltXCI6XCLii6dcIixcIkdvcGZcIjpcIvCdlL5cIixcImdvcGZcIjpcIvCdlZhcIixcImdyYXZlXCI6XCJgXCIsXCJHcmVhdGVyRXF1YWxcIjpcIuKJpVwiLFwiR3JlYXRlckVxdWFsTGVzc1wiOlwi4oubXCIsXCJHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiadcIixcIkdyZWF0ZXJHcmVhdGVyXCI6XCLiqqJcIixcIkdyZWF0ZXJMZXNzXCI6XCLiibdcIixcIkdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb5cIixcIkdyZWF0ZXJUaWxkZVwiOlwi4omzXCIsXCJHc2NyXCI6XCLwnZKiXCIsXCJnc2NyXCI6XCLihIpcIixcImdzaW1cIjpcIuKJs1wiLFwiZ3NpbWVcIjpcIuKqjlwiLFwiZ3NpbWxcIjpcIuKqkFwiLFwiZ3RjY1wiOlwi4qqnXCIsXCJndGNpclwiOlwi4qm6XCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIkd0XCI6XCLiiatcIixcImd0ZG90XCI6XCLii5dcIixcImd0bFBhclwiOlwi4qaVXCIsXCJndHF1ZXN0XCI6XCLiqbxcIixcImd0cmFwcHJveFwiOlwi4qqGXCIsXCJndHJhcnJcIjpcIuKluFwiLFwiZ3RyZG90XCI6XCLii5dcIixcImd0cmVxbGVzc1wiOlwi4oubXCIsXCJndHJlcXFsZXNzXCI6XCLiqoxcIixcImd0cmxlc3NcIjpcIuKJt1wiLFwiZ3Ryc2ltXCI6XCLiibNcIixcImd2ZXJ0bmVxcVwiOlwi4omp77iAXCIsXCJndm5FXCI6XCLiianvuIBcIixcIkhhY2VrXCI6XCLLh1wiLFwiaGFpcnNwXCI6XCLigIpcIixcImhhbGZcIjpcIsK9XCIsXCJoYW1pbHRcIjpcIuKEi1wiLFwiSEFSRGN5XCI6XCLQqlwiLFwiaGFyZGN5XCI6XCLRilwiLFwiaGFycmNpclwiOlwi4qWIXCIsXCJoYXJyXCI6XCLihpRcIixcImhBcnJcIjpcIuKHlFwiLFwiaGFycndcIjpcIuKGrVwiLFwiSGF0XCI6XCJeXCIsXCJoYmFyXCI6XCLihI9cIixcIkhjaXJjXCI6XCLEpFwiLFwiaGNpcmNcIjpcIsSlXCIsXCJoZWFydHNcIjpcIuKZpVwiLFwiaGVhcnRzdWl0XCI6XCLimaVcIixcImhlbGxpcFwiOlwi4oCmXCIsXCJoZXJjb25cIjpcIuKKuVwiLFwiaGZyXCI6XCLwnZSlXCIsXCJIZnJcIjpcIuKEjFwiLFwiSGlsYmVydFNwYWNlXCI6XCLihItcIixcImhrc2Vhcm93XCI6XCLipKVcIixcImhrc3dhcm93XCI6XCLipKZcIixcImhvYXJyXCI6XCLih79cIixcImhvbXRodFwiOlwi4oi7XCIsXCJob29rbGVmdGFycm93XCI6XCLihqlcIixcImhvb2tyaWdodGFycm93XCI6XCLihqpcIixcImhvcGZcIjpcIvCdlZlcIixcIkhvcGZcIjpcIuKEjVwiLFwiaG9yYmFyXCI6XCLigJVcIixcIkhvcml6b250YWxMaW5lXCI6XCLilIBcIixcImhzY3JcIjpcIvCdkr1cIixcIkhzY3JcIjpcIuKEi1wiLFwiaHNsYXNoXCI6XCLihI9cIixcIkhzdHJva1wiOlwixKZcIixcImhzdHJva1wiOlwixKdcIixcIkh1bXBEb3duSHVtcFwiOlwi4omOXCIsXCJIdW1wRXF1YWxcIjpcIuKJj1wiLFwiaHlidWxsXCI6XCLigYNcIixcImh5cGhlblwiOlwi4oCQXCIsXCJJYWN1dGVcIjpcIsONXCIsXCJpYWN1dGVcIjpcIsOtXCIsXCJpY1wiOlwi4oGjXCIsXCJJY2lyY1wiOlwiw45cIixcImljaXJjXCI6XCLDrlwiLFwiSWN5XCI6XCLQmFwiLFwiaWN5XCI6XCLQuFwiLFwiSWRvdFwiOlwixLBcIixcIklFY3lcIjpcItCVXCIsXCJpZWN5XCI6XCLQtVwiLFwiaWV4Y2xcIjpcIsKhXCIsXCJpZmZcIjpcIuKHlFwiLFwiaWZyXCI6XCLwnZSmXCIsXCJJZnJcIjpcIuKEkVwiLFwiSWdyYXZlXCI6XCLDjFwiLFwiaWdyYXZlXCI6XCLDrFwiLFwiaWlcIjpcIuKFiFwiLFwiaWlpaW50XCI6XCLiqIxcIixcImlpaW50XCI6XCLiiK1cIixcImlpbmZpblwiOlwi4qecXCIsXCJpaW90YVwiOlwi4oSpXCIsXCJJSmxpZ1wiOlwixLJcIixcImlqbGlnXCI6XCLEs1wiLFwiSW1hY3JcIjpcIsSqXCIsXCJpbWFjclwiOlwixKtcIixcImltYWdlXCI6XCLihJFcIixcIkltYWdpbmFyeUlcIjpcIuKFiFwiLFwiaW1hZ2xpbmVcIjpcIuKEkFwiLFwiaW1hZ3BhcnRcIjpcIuKEkVwiLFwiaW1hdGhcIjpcIsSxXCIsXCJJbVwiOlwi4oSRXCIsXCJpbW9mXCI6XCLiirdcIixcImltcGVkXCI6XCLGtVwiLFwiSW1wbGllc1wiOlwi4oeSXCIsXCJpbmNhcmVcIjpcIuKEhVwiLFwiaW5cIjpcIuKIiFwiLFwiaW5maW5cIjpcIuKInlwiLFwiaW5maW50aWVcIjpcIuKnnVwiLFwiaW5vZG90XCI6XCLEsVwiLFwiaW50Y2FsXCI6XCLiirpcIixcImludFwiOlwi4oirXCIsXCJJbnRcIjpcIuKIrFwiLFwiaW50ZWdlcnNcIjpcIuKEpFwiLFwiSW50ZWdyYWxcIjpcIuKIq1wiLFwiaW50ZXJjYWxcIjpcIuKKulwiLFwiSW50ZXJzZWN0aW9uXCI6XCLii4JcIixcImludGxhcmhrXCI6XCLiqJdcIixcImludHByb2RcIjpcIuKovFwiLFwiSW52aXNpYmxlQ29tbWFcIjpcIuKBo1wiLFwiSW52aXNpYmxlVGltZXNcIjpcIuKBolwiLFwiSU9jeVwiOlwi0IFcIixcImlvY3lcIjpcItGRXCIsXCJJb2dvblwiOlwixK5cIixcImlvZ29uXCI6XCLEr1wiLFwiSW9wZlwiOlwi8J2VgFwiLFwiaW9wZlwiOlwi8J2VmlwiLFwiSW90YVwiOlwizplcIixcImlvdGFcIjpcIs65XCIsXCJpcHJvZFwiOlwi4qi8XCIsXCJpcXVlc3RcIjpcIsK/XCIsXCJpc2NyXCI6XCLwnZK+XCIsXCJJc2NyXCI6XCLihJBcIixcImlzaW5cIjpcIuKIiFwiLFwiaXNpbmRvdFwiOlwi4ou1XCIsXCJpc2luRVwiOlwi4ou5XCIsXCJpc2luc1wiOlwi4ou0XCIsXCJpc2luc3ZcIjpcIuKLs1wiLFwiaXNpbnZcIjpcIuKIiFwiLFwiaXRcIjpcIuKBolwiLFwiSXRpbGRlXCI6XCLEqFwiLFwiaXRpbGRlXCI6XCLEqVwiLFwiSXVrY3lcIjpcItCGXCIsXCJpdWtjeVwiOlwi0ZZcIixcIkl1bWxcIjpcIsOPXCIsXCJpdW1sXCI6XCLDr1wiLFwiSmNpcmNcIjpcIsS0XCIsXCJqY2lyY1wiOlwixLVcIixcIkpjeVwiOlwi0JlcIixcImpjeVwiOlwi0LlcIixcIkpmclwiOlwi8J2UjVwiLFwiamZyXCI6XCLwnZSnXCIsXCJqbWF0aFwiOlwiyLdcIixcIkpvcGZcIjpcIvCdlYFcIixcImpvcGZcIjpcIvCdlZtcIixcIkpzY3JcIjpcIvCdkqVcIixcImpzY3JcIjpcIvCdkr9cIixcIkpzZXJjeVwiOlwi0IhcIixcImpzZXJjeVwiOlwi0ZhcIixcIkp1a2N5XCI6XCLQhFwiLFwianVrY3lcIjpcItGUXCIsXCJLYXBwYVwiOlwizppcIixcImthcHBhXCI6XCLOulwiLFwia2FwcGF2XCI6XCLPsFwiLFwiS2NlZGlsXCI6XCLEtlwiLFwia2NlZGlsXCI6XCLEt1wiLFwiS2N5XCI6XCLQmlwiLFwia2N5XCI6XCLQulwiLFwiS2ZyXCI6XCLwnZSOXCIsXCJrZnJcIjpcIvCdlKhcIixcImtncmVlblwiOlwixLhcIixcIktIY3lcIjpcItClXCIsXCJraGN5XCI6XCLRhVwiLFwiS0pjeVwiOlwi0IxcIixcImtqY3lcIjpcItGcXCIsXCJLb3BmXCI6XCLwnZWCXCIsXCJrb3BmXCI6XCLwnZWcXCIsXCJLc2NyXCI6XCLwnZKmXCIsXCJrc2NyXCI6XCLwnZOAXCIsXCJsQWFyclwiOlwi4oeaXCIsXCJMYWN1dGVcIjpcIsS5XCIsXCJsYWN1dGVcIjpcIsS6XCIsXCJsYWVtcHR5dlwiOlwi4qa0XCIsXCJsYWdyYW5cIjpcIuKEklwiLFwiTGFtYmRhXCI6XCLOm1wiLFwibGFtYmRhXCI6XCLOu1wiLFwibGFuZ1wiOlwi4p+oXCIsXCJMYW5nXCI6XCLin6pcIixcImxhbmdkXCI6XCLippFcIixcImxhbmdsZVwiOlwi4p+oXCIsXCJsYXBcIjpcIuKqhVwiLFwiTGFwbGFjZXRyZlwiOlwi4oSSXCIsXCJsYXF1b1wiOlwiwqtcIixcImxhcnJiXCI6XCLih6RcIixcImxhcnJiZnNcIjpcIuKkn1wiLFwibGFyclwiOlwi4oaQXCIsXCJMYXJyXCI6XCLihp5cIixcImxBcnJcIjpcIuKHkFwiLFwibGFycmZzXCI6XCLipJ1cIixcImxhcnJoa1wiOlwi4oapXCIsXCJsYXJybHBcIjpcIuKGq1wiLFwibGFycnBsXCI6XCLipLlcIixcImxhcnJzaW1cIjpcIuKls1wiLFwibGFycnRsXCI6XCLihqJcIixcImxhdGFpbFwiOlwi4qSZXCIsXCJsQXRhaWxcIjpcIuKkm1wiLFwibGF0XCI6XCLiqqtcIixcImxhdGVcIjpcIuKqrVwiLFwibGF0ZXNcIjpcIuKqre+4gFwiLFwibGJhcnJcIjpcIuKkjFwiLFwibEJhcnJcIjpcIuKkjlwiLFwibGJicmtcIjpcIuKdslwiLFwibGJyYWNlXCI6XCJ7XCIsXCJsYnJhY2tcIjpcIltcIixcImxicmtlXCI6XCLipotcIixcImxicmtzbGRcIjpcIuKmj1wiLFwibGJya3NsdVwiOlwi4qaNXCIsXCJMY2Fyb25cIjpcIsS9XCIsXCJsY2Fyb25cIjpcIsS+XCIsXCJMY2VkaWxcIjpcIsS7XCIsXCJsY2VkaWxcIjpcIsS8XCIsXCJsY2VpbFwiOlwi4oyIXCIsXCJsY3ViXCI6XCJ7XCIsXCJMY3lcIjpcItCbXCIsXCJsY3lcIjpcItC7XCIsXCJsZGNhXCI6XCLipLZcIixcImxkcXVvXCI6XCLigJxcIixcImxkcXVvclwiOlwi4oCeXCIsXCJsZHJkaGFyXCI6XCLipadcIixcImxkcnVzaGFyXCI6XCLipYtcIixcImxkc2hcIjpcIuKGslwiLFwibGVcIjpcIuKJpFwiLFwibEVcIjpcIuKJplwiLFwiTGVmdEFuZ2xlQnJhY2tldFwiOlwi4p+oXCIsXCJMZWZ0QXJyb3dCYXJcIjpcIuKHpFwiLFwibGVmdGFycm93XCI6XCLihpBcIixcIkxlZnRBcnJvd1wiOlwi4oaQXCIsXCJMZWZ0YXJyb3dcIjpcIuKHkFwiLFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOlwi4oeGXCIsXCJsZWZ0YXJyb3d0YWlsXCI6XCLihqJcIixcIkxlZnRDZWlsaW5nXCI6XCLijIhcIixcIkxlZnREb3VibGVCcmFja2V0XCI6XCLin6ZcIixcIkxlZnREb3duVGVlVmVjdG9yXCI6XCLipaFcIixcIkxlZnREb3duVmVjdG9yQmFyXCI6XCLipZlcIixcIkxlZnREb3duVmVjdG9yXCI6XCLih4NcIixcIkxlZnRGbG9vclwiOlwi4oyKXCIsXCJsZWZ0aGFycG9vbmRvd25cIjpcIuKGvVwiLFwibGVmdGhhcnBvb251cFwiOlwi4oa8XCIsXCJsZWZ0bGVmdGFycm93c1wiOlwi4oeHXCIsXCJsZWZ0cmlnaHRhcnJvd1wiOlwi4oaUXCIsXCJMZWZ0UmlnaHRBcnJvd1wiOlwi4oaUXCIsXCJMZWZ0cmlnaHRhcnJvd1wiOlwi4oeUXCIsXCJsZWZ0cmlnaHRhcnJvd3NcIjpcIuKHhlwiLFwibGVmdHJpZ2h0aGFycG9vbnNcIjpcIuKHi1wiLFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOlwi4oatXCIsXCJMZWZ0UmlnaHRWZWN0b3JcIjpcIuKljlwiLFwiTGVmdFRlZUFycm93XCI6XCLihqRcIixcIkxlZnRUZWVcIjpcIuKKo1wiLFwiTGVmdFRlZVZlY3RvclwiOlwi4qWaXCIsXCJsZWZ0dGhyZWV0aW1lc1wiOlwi4ouLXCIsXCJMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj1wiLFwiTGVmdFRyaWFuZ2xlXCI6XCLiirJcIixcIkxlZnRUcmlhbmdsZUVxdWFsXCI6XCLiirRcIixcIkxlZnRVcERvd25WZWN0b3JcIjpcIuKlkVwiLFwiTGVmdFVwVGVlVmVjdG9yXCI6XCLipaBcIixcIkxlZnRVcFZlY3RvckJhclwiOlwi4qWYXCIsXCJMZWZ0VXBWZWN0b3JcIjpcIuKGv1wiLFwiTGVmdFZlY3RvckJhclwiOlwi4qWSXCIsXCJMZWZ0VmVjdG9yXCI6XCLihrxcIixcImxFZ1wiOlwi4qqLXCIsXCJsZWdcIjpcIuKLmlwiLFwibGVxXCI6XCLiiaRcIixcImxlcXFcIjpcIuKJplwiLFwibGVxc2xhbnRcIjpcIuKpvVwiLFwibGVzY2NcIjpcIuKqqFwiLFwibGVzXCI6XCLiqb1cIixcImxlc2RvdFwiOlwi4qm/XCIsXCJsZXNkb3RvXCI6XCLiqoFcIixcImxlc2RvdG9yXCI6XCLiqoNcIixcImxlc2dcIjpcIuKLmu+4gFwiLFwibGVzZ2VzXCI6XCLiqpNcIixcImxlc3NhcHByb3hcIjpcIuKqhVwiLFwibGVzc2RvdFwiOlwi4ouWXCIsXCJsZXNzZXFndHJcIjpcIuKLmlwiLFwibGVzc2VxcWd0clwiOlwi4qqLXCIsXCJMZXNzRXF1YWxHcmVhdGVyXCI6XCLii5pcIixcIkxlc3NGdWxsRXF1YWxcIjpcIuKJplwiLFwiTGVzc0dyZWF0ZXJcIjpcIuKJtlwiLFwibGVzc2d0clwiOlwi4om2XCIsXCJMZXNzTGVzc1wiOlwi4qqhXCIsXCJsZXNzc2ltXCI6XCLiibJcIixcIkxlc3NTbGFudEVxdWFsXCI6XCLiqb1cIixcIkxlc3NUaWxkZVwiOlwi4omyXCIsXCJsZmlzaHRcIjpcIuKlvFwiLFwibGZsb29yXCI6XCLijIpcIixcIkxmclwiOlwi8J2Uj1wiLFwibGZyXCI6XCLwnZSpXCIsXCJsZ1wiOlwi4om2XCIsXCJsZ0VcIjpcIuKqkVwiLFwibEhhclwiOlwi4qWiXCIsXCJsaGFyZFwiOlwi4oa9XCIsXCJsaGFydVwiOlwi4oa8XCIsXCJsaGFydWxcIjpcIuKlqlwiLFwibGhibGtcIjpcIuKWhFwiLFwiTEpjeVwiOlwi0IlcIixcImxqY3lcIjpcItGZXCIsXCJsbGFyclwiOlwi4oeHXCIsXCJsbFwiOlwi4omqXCIsXCJMbFwiOlwi4ouYXCIsXCJsbGNvcm5lclwiOlwi4oyeXCIsXCJMbGVmdGFycm93XCI6XCLih5pcIixcImxsaGFyZFwiOlwi4qWrXCIsXCJsbHRyaVwiOlwi4pe6XCIsXCJMbWlkb3RcIjpcIsS/XCIsXCJsbWlkb3RcIjpcIsWAXCIsXCJsbW91c3RhY2hlXCI6XCLijrBcIixcImxtb3VzdFwiOlwi4o6wXCIsXCJsbmFwXCI6XCLiqolcIixcImxuYXBwcm94XCI6XCLiqolcIixcImxuZVwiOlwi4qqHXCIsXCJsbkVcIjpcIuKJqFwiLFwibG5lcVwiOlwi4qqHXCIsXCJsbmVxcVwiOlwi4omoXCIsXCJsbnNpbVwiOlwi4oumXCIsXCJsb2FuZ1wiOlwi4p+sXCIsXCJsb2FyclwiOlwi4oe9XCIsXCJsb2Jya1wiOlwi4p+mXCIsXCJsb25nbGVmdGFycm93XCI6XCLin7VcIixcIkxvbmdMZWZ0QXJyb3dcIjpcIuKftVwiLFwiTG9uZ2xlZnRhcnJvd1wiOlwi4p+4XCIsXCJsb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKft1wiLFwiTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7dcIixcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+6XCIsXCJsb25nbWFwc3RvXCI6XCLin7xcIixcImxvbmdyaWdodGFycm93XCI6XCLin7ZcIixcIkxvbmdSaWdodEFycm93XCI6XCLin7ZcIixcIkxvbmdyaWdodGFycm93XCI6XCLin7lcIixcImxvb3BhcnJvd2xlZnRcIjpcIuKGq1wiLFwibG9vcGFycm93cmlnaHRcIjpcIuKGrFwiLFwibG9wYXJcIjpcIuKmhVwiLFwiTG9wZlwiOlwi8J2Vg1wiLFwibG9wZlwiOlwi8J2VnVwiLFwibG9wbHVzXCI6XCLiqK1cIixcImxvdGltZXNcIjpcIuKotFwiLFwibG93YXN0XCI6XCLiiJdcIixcImxvd2JhclwiOlwiX1wiLFwiTG93ZXJMZWZ0QXJyb3dcIjpcIuKGmVwiLFwiTG93ZXJSaWdodEFycm93XCI6XCLihphcIixcImxvelwiOlwi4peKXCIsXCJsb3plbmdlXCI6XCLil4pcIixcImxvemZcIjpcIuKnq1wiLFwibHBhclwiOlwiKFwiLFwibHBhcmx0XCI6XCLippNcIixcImxyYXJyXCI6XCLih4ZcIixcImxyY29ybmVyXCI6XCLijJ9cIixcImxyaGFyXCI6XCLih4tcIixcImxyaGFyZFwiOlwi4qWtXCIsXCJscm1cIjpcIuKAjlwiLFwibHJ0cmlcIjpcIuKKv1wiLFwibHNhcXVvXCI6XCLigLlcIixcImxzY3JcIjpcIvCdk4FcIixcIkxzY3JcIjpcIuKEklwiLFwibHNoXCI6XCLihrBcIixcIkxzaFwiOlwi4oawXCIsXCJsc2ltXCI6XCLiibJcIixcImxzaW1lXCI6XCLiqo1cIixcImxzaW1nXCI6XCLiqo9cIixcImxzcWJcIjpcIltcIixcImxzcXVvXCI6XCLigJhcIixcImxzcXVvclwiOlwi4oCaXCIsXCJMc3Ryb2tcIjpcIsWBXCIsXCJsc3Ryb2tcIjpcIsWCXCIsXCJsdGNjXCI6XCLiqqZcIixcImx0Y2lyXCI6XCLiqblcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwiTHRcIjpcIuKJqlwiLFwibHRkb3RcIjpcIuKLllwiLFwibHRocmVlXCI6XCLii4tcIixcImx0aW1lc1wiOlwi4ouJXCIsXCJsdGxhcnJcIjpcIuKltlwiLFwibHRxdWVzdFwiOlwi4qm7XCIsXCJsdHJpXCI6XCLil4NcIixcImx0cmllXCI6XCLiirRcIixcImx0cmlmXCI6XCLil4JcIixcImx0clBhclwiOlwi4qaWXCIsXCJsdXJkc2hhclwiOlwi4qWKXCIsXCJsdXJ1aGFyXCI6XCLipaZcIixcImx2ZXJ0bmVxcVwiOlwi4omo77iAXCIsXCJsdm5FXCI6XCLiiajvuIBcIixcIm1hY3JcIjpcIsKvXCIsXCJtYWxlXCI6XCLimYJcIixcIm1hbHRcIjpcIuKcoFwiLFwibWFsdGVzZVwiOlwi4pygXCIsXCJNYXBcIjpcIuKkhVwiLFwibWFwXCI6XCLihqZcIixcIm1hcHN0b1wiOlwi4oamXCIsXCJtYXBzdG9kb3duXCI6XCLihqdcIixcIm1hcHN0b2xlZnRcIjpcIuKGpFwiLFwibWFwc3RvdXBcIjpcIuKGpVwiLFwibWFya2VyXCI6XCLilq5cIixcIm1jb21tYVwiOlwi4qipXCIsXCJNY3lcIjpcItCcXCIsXCJtY3lcIjpcItC8XCIsXCJtZGFzaFwiOlwi4oCUXCIsXCJtRERvdFwiOlwi4oi6XCIsXCJtZWFzdXJlZGFuZ2xlXCI6XCLiiKFcIixcIk1lZGl1bVNwYWNlXCI6XCLigZ9cIixcIk1lbGxpbnRyZlwiOlwi4oSzXCIsXCJNZnJcIjpcIvCdlJBcIixcIm1mclwiOlwi8J2UqlwiLFwibWhvXCI6XCLihKdcIixcIm1pY3JvXCI6XCLCtVwiLFwibWlkYXN0XCI6XCIqXCIsXCJtaWRjaXJcIjpcIuKrsFwiLFwibWlkXCI6XCLiiKNcIixcIm1pZGRvdFwiOlwiwrdcIixcIm1pbnVzYlwiOlwi4oqfXCIsXCJtaW51c1wiOlwi4oiSXCIsXCJtaW51c2RcIjpcIuKIuFwiLFwibWludXNkdVwiOlwi4qiqXCIsXCJNaW51c1BsdXNcIjpcIuKIk1wiLFwibWxjcFwiOlwi4qubXCIsXCJtbGRyXCI6XCLigKZcIixcIm1ucGx1c1wiOlwi4oiTXCIsXCJtb2RlbHNcIjpcIuKKp1wiLFwiTW9wZlwiOlwi8J2VhFwiLFwibW9wZlwiOlwi8J2VnlwiLFwibXBcIjpcIuKIk1wiLFwibXNjclwiOlwi8J2TglwiLFwiTXNjclwiOlwi4oSzXCIsXCJtc3Rwb3NcIjpcIuKIvlwiLFwiTXVcIjpcIs6cXCIsXCJtdVwiOlwizrxcIixcIm11bHRpbWFwXCI6XCLiirhcIixcIm11bWFwXCI6XCLiirhcIixcIm5hYmxhXCI6XCLiiIdcIixcIk5hY3V0ZVwiOlwixYNcIixcIm5hY3V0ZVwiOlwixYRcIixcIm5hbmdcIjpcIuKIoOKDklwiLFwibmFwXCI6XCLiiYlcIixcIm5hcEVcIjpcIuKpsMy4XCIsXCJuYXBpZFwiOlwi4omLzLhcIixcIm5hcG9zXCI6XCLFiVwiLFwibmFwcHJveFwiOlwi4omJXCIsXCJuYXR1cmFsXCI6XCLima5cIixcIm5hdHVyYWxzXCI6XCLihJVcIixcIm5hdHVyXCI6XCLima5cIixcIm5ic3BcIjpcIsKgXCIsXCJuYnVtcFwiOlwi4omOzLhcIixcIm5idW1wZVwiOlwi4omPzLhcIixcIm5jYXBcIjpcIuKpg1wiLFwiTmNhcm9uXCI6XCLFh1wiLFwibmNhcm9uXCI6XCLFiFwiLFwiTmNlZGlsXCI6XCLFhVwiLFwibmNlZGlsXCI6XCLFhlwiLFwibmNvbmdcIjpcIuKJh1wiLFwibmNvbmdkb3RcIjpcIuKprcy4XCIsXCJuY3VwXCI6XCLiqYJcIixcIk5jeVwiOlwi0J1cIixcIm5jeVwiOlwi0L1cIixcIm5kYXNoXCI6XCLigJNcIixcIm5lYXJoa1wiOlwi4qSkXCIsXCJuZWFyclwiOlwi4oaXXCIsXCJuZUFyclwiOlwi4oeXXCIsXCJuZWFycm93XCI6XCLihpdcIixcIm5lXCI6XCLiiaBcIixcIm5lZG90XCI6XCLiiZDMuFwiLFwiTmVnYXRpdmVNZWRpdW1TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGluU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlXCI6XCLigItcIixcIm5lcXVpdlwiOlwi4omiXCIsXCJuZXNlYXJcIjpcIuKkqFwiLFwibmVzaW1cIjpcIuKJgsy4XCIsXCJOZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4omrXCIsXCJOZXN0ZWRMZXNzTGVzc1wiOlwi4omqXCIsXCJOZXdMaW5lXCI6XCJcXG5cIixcIm5leGlzdFwiOlwi4oiEXCIsXCJuZXhpc3RzXCI6XCLiiIRcIixcIk5mclwiOlwi8J2UkVwiLFwibmZyXCI6XCLwnZSrXCIsXCJuZ0VcIjpcIuKJp8y4XCIsXCJuZ2VcIjpcIuKJsVwiLFwibmdlcVwiOlwi4omxXCIsXCJuZ2VxcVwiOlwi4omnzLhcIixcIm5nZXFzbGFudFwiOlwi4qm+zLhcIixcIm5nZXNcIjpcIuKpvsy4XCIsXCJuR2dcIjpcIuKLmcy4XCIsXCJuZ3NpbVwiOlwi4om1XCIsXCJuR3RcIjpcIuKJq+KDklwiLFwibmd0XCI6XCLiia9cIixcIm5ndHJcIjpcIuKJr1wiLFwibkd0dlwiOlwi4omrzLhcIixcIm5oYXJyXCI6XCLihq5cIixcIm5oQXJyXCI6XCLih45cIixcIm5ocGFyXCI6XCLiq7JcIixcIm5pXCI6XCLiiItcIixcIm5pc1wiOlwi4ou8XCIsXCJuaXNkXCI6XCLii7pcIixcIm5pdlwiOlwi4oiLXCIsXCJOSmN5XCI6XCLQilwiLFwibmpjeVwiOlwi0ZpcIixcIm5sYXJyXCI6XCLihppcIixcIm5sQXJyXCI6XCLih41cIixcIm5sZHJcIjpcIuKApVwiLFwibmxFXCI6XCLiiabMuFwiLFwibmxlXCI6XCLiibBcIixcIm5sZWZ0YXJyb3dcIjpcIuKGmlwiLFwibkxlZnRhcnJvd1wiOlwi4oeNXCIsXCJubGVmdHJpZ2h0YXJyb3dcIjpcIuKGrlwiLFwibkxlZnRyaWdodGFycm93XCI6XCLih45cIixcIm5sZXFcIjpcIuKJsFwiLFwibmxlcXFcIjpcIuKJpsy4XCIsXCJubGVxc2xhbnRcIjpcIuKpvcy4XCIsXCJubGVzXCI6XCLiqb3MuFwiLFwibmxlc3NcIjpcIuKJrlwiLFwibkxsXCI6XCLii5jMuFwiLFwibmxzaW1cIjpcIuKJtFwiLFwibkx0XCI6XCLiiarig5JcIixcIm5sdFwiOlwi4omuXCIsXCJubHRyaVwiOlwi4ouqXCIsXCJubHRyaWVcIjpcIuKLrFwiLFwibkx0dlwiOlwi4omqzLhcIixcIm5taWRcIjpcIuKIpFwiLFwiTm9CcmVha1wiOlwi4oGgXCIsXCJOb25CcmVha2luZ1NwYWNlXCI6XCLCoFwiLFwibm9wZlwiOlwi8J2Vn1wiLFwiTm9wZlwiOlwi4oSVXCIsXCJOb3RcIjpcIuKrrFwiLFwibm90XCI6XCLCrFwiLFwiTm90Q29uZ3J1ZW50XCI6XCLiiaJcIixcIk5vdEN1cENhcFwiOlwi4omtXCIsXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwi4oimXCIsXCJOb3RFbGVtZW50XCI6XCLiiIlcIixcIk5vdEVxdWFsXCI6XCLiiaBcIixcIk5vdEVxdWFsVGlsZGVcIjpcIuKJgsy4XCIsXCJOb3RFeGlzdHNcIjpcIuKIhFwiLFwiTm90R3JlYXRlclwiOlwi4omvXCIsXCJOb3RHcmVhdGVyRXF1YWxcIjpcIuKJsVwiLFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnzLhcIixcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCLiiavMuFwiLFwiTm90R3JlYXRlckxlc3NcIjpcIuKJuVwiLFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvsy4XCIsXCJOb3RHcmVhdGVyVGlsZGVcIjpcIuKJtVwiLFwiTm90SHVtcERvd25IdW1wXCI6XCLiiY7MuFwiLFwiTm90SHVtcEVxdWFsXCI6XCLiiY/MuFwiLFwibm90aW5cIjpcIuKIiVwiLFwibm90aW5kb3RcIjpcIuKLtcy4XCIsXCJub3RpbkVcIjpcIuKLucy4XCIsXCJub3RpbnZhXCI6XCLiiIlcIixcIm5vdGludmJcIjpcIuKLt1wiLFwibm90aW52Y1wiOlwi4ou2XCIsXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj8y4XCIsXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIuKLqlwiLFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKLrFwiLFwiTm90TGVzc1wiOlwi4omuXCIsXCJOb3RMZXNzRXF1YWxcIjpcIuKJsFwiLFwiTm90TGVzc0dyZWF0ZXJcIjpcIuKJuFwiLFwiTm90TGVzc0xlc3NcIjpcIuKJqsy4XCIsXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwi4qm9zLhcIixcIk5vdExlc3NUaWxkZVwiOlwi4om0XCIsXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4qqizLhcIixcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCLiqqHMuFwiLFwibm90bmlcIjpcIuKIjFwiLFwibm90bml2YVwiOlwi4oiMXCIsXCJub3RuaXZiXCI6XCLii75cIixcIm5vdG5pdmNcIjpcIuKLvVwiLFwiTm90UHJlY2VkZXNcIjpcIuKKgFwiLFwiTm90UHJlY2VkZXNFcXVhbFwiOlwi4qqvzLhcIixcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4ougXCIsXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwi4oiMXCIsXCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5DMuFwiLFwiTm90UmlnaHRUcmlhbmdsZVwiOlwi4ourXCIsXCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKLrVwiLFwiTm90U3F1YXJlU3Vic2V0XCI6XCLiio/MuFwiLFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKLolwiLFwiTm90U3F1YXJlU3VwZXJzZXRcIjpcIuKKkMy4XCIsXCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLii6NcIixcIk5vdFN1YnNldFwiOlwi4oqC4oOSXCIsXCJOb3RTdWJzZXRFcXVhbFwiOlwi4oqIXCIsXCJOb3RTdWNjZWVkc1wiOlwi4oqBXCIsXCJOb3RTdWNjZWVkc0VxdWFsXCI6XCLiqrDMuFwiLFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCLii6FcIixcIk5vdFN1Y2NlZWRzVGlsZGVcIjpcIuKJv8y4XCIsXCJOb3RTdXBlcnNldFwiOlwi4oqD4oOSXCIsXCJOb3RTdXBlcnNldEVxdWFsXCI6XCLiiolcIixcIk5vdFRpbGRlXCI6XCLiiYFcIixcIk5vdFRpbGRlRXF1YWxcIjpcIuKJhFwiLFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIuKJh1wiLFwiTm90VGlsZGVUaWxkZVwiOlwi4omJXCIsXCJOb3RWZXJ0aWNhbEJhclwiOlwi4oikXCIsXCJucGFyYWxsZWxcIjpcIuKIplwiLFwibnBhclwiOlwi4oimXCIsXCJucGFyc2xcIjpcIuKrveKDpVwiLFwibnBhcnRcIjpcIuKIgsy4XCIsXCJucG9saW50XCI6XCLiqJRcIixcIm5wclwiOlwi4oqAXCIsXCJucHJjdWVcIjpcIuKLoFwiLFwibnByZWNcIjpcIuKKgFwiLFwibnByZWNlcVwiOlwi4qqvzLhcIixcIm5wcmVcIjpcIuKqr8y4XCIsXCJucmFycmNcIjpcIuKks8y4XCIsXCJucmFyclwiOlwi4oabXCIsXCJuckFyclwiOlwi4oePXCIsXCJucmFycndcIjpcIuKGncy4XCIsXCJucmlnaHRhcnJvd1wiOlwi4oabXCIsXCJuUmlnaHRhcnJvd1wiOlwi4oePXCIsXCJucnRyaVwiOlwi4ourXCIsXCJucnRyaWVcIjpcIuKLrVwiLFwibnNjXCI6XCLiioFcIixcIm5zY2N1ZVwiOlwi4ouhXCIsXCJuc2NlXCI6XCLiqrDMuFwiLFwiTnNjclwiOlwi8J2SqVwiLFwibnNjclwiOlwi8J2Tg1wiLFwibnNob3J0bWlkXCI6XCLiiKRcIixcIm5zaG9ydHBhcmFsbGVsXCI6XCLiiKZcIixcIm5zaW1cIjpcIuKJgVwiLFwibnNpbWVcIjpcIuKJhFwiLFwibnNpbWVxXCI6XCLiiYRcIixcIm5zbWlkXCI6XCLiiKRcIixcIm5zcGFyXCI6XCLiiKZcIixcIm5zcXN1YmVcIjpcIuKLolwiLFwibnNxc3VwZVwiOlwi4oujXCIsXCJuc3ViXCI6XCLiioRcIixcIm5zdWJFXCI6XCLiq4XMuFwiLFwibnN1YmVcIjpcIuKKiFwiLFwibnN1YnNldFwiOlwi4oqC4oOSXCIsXCJuc3Vic2V0ZXFcIjpcIuKKiFwiLFwibnN1YnNldGVxcVwiOlwi4quFzLhcIixcIm5zdWNjXCI6XCLiioFcIixcIm5zdWNjZXFcIjpcIuKqsMy4XCIsXCJuc3VwXCI6XCLiioVcIixcIm5zdXBFXCI6XCLiq4bMuFwiLFwibnN1cGVcIjpcIuKKiVwiLFwibnN1cHNldFwiOlwi4oqD4oOSXCIsXCJuc3Vwc2V0ZXFcIjpcIuKKiVwiLFwibnN1cHNldGVxcVwiOlwi4quGzLhcIixcIm50Z2xcIjpcIuKJuVwiLFwiTnRpbGRlXCI6XCLDkVwiLFwibnRpbGRlXCI6XCLDsVwiLFwibnRsZ1wiOlwi4om4XCIsXCJudHJpYW5nbGVsZWZ0XCI6XCLii6pcIixcIm50cmlhbmdsZWxlZnRlcVwiOlwi4ousXCIsXCJudHJpYW5nbGVyaWdodFwiOlwi4ourXCIsXCJudHJpYW5nbGVyaWdodGVxXCI6XCLii61cIixcIk51XCI6XCLOnVwiLFwibnVcIjpcIs69XCIsXCJudW1cIjpcIiNcIixcIm51bWVyb1wiOlwi4oSWXCIsXCJudW1zcFwiOlwi4oCHXCIsXCJudmFwXCI6XCLiiY3ig5JcIixcIm52ZGFzaFwiOlwi4oqsXCIsXCJudkRhc2hcIjpcIuKKrVwiLFwiblZkYXNoXCI6XCLiiq5cIixcIm5WRGFzaFwiOlwi4oqvXCIsXCJudmdlXCI6XCLiiaXig5JcIixcIm52Z3RcIjpcIj7ig5JcIixcIm52SGFyclwiOlwi4qSEXCIsXCJudmluZmluXCI6XCLip55cIixcIm52bEFyclwiOlwi4qSCXCIsXCJudmxlXCI6XCLiiaTig5JcIixcIm52bHRcIjpcIjzig5JcIixcIm52bHRyaWVcIjpcIuKKtOKDklwiLFwibnZyQXJyXCI6XCLipINcIixcIm52cnRyaWVcIjpcIuKKteKDklwiLFwibnZzaW1cIjpcIuKIvOKDklwiLFwibndhcmhrXCI6XCLipKNcIixcIm53YXJyXCI6XCLihpZcIixcIm53QXJyXCI6XCLih5ZcIixcIm53YXJyb3dcIjpcIuKGllwiLFwibnduZWFyXCI6XCLipKdcIixcIk9hY3V0ZVwiOlwiw5NcIixcIm9hY3V0ZVwiOlwiw7NcIixcIm9hc3RcIjpcIuKKm1wiLFwiT2NpcmNcIjpcIsOUXCIsXCJvY2lyY1wiOlwiw7RcIixcIm9jaXJcIjpcIuKKmlwiLFwiT2N5XCI6XCLQnlwiLFwib2N5XCI6XCLQvlwiLFwib2Rhc2hcIjpcIuKKnVwiLFwiT2RibGFjXCI6XCLFkFwiLFwib2RibGFjXCI6XCLFkVwiLFwib2RpdlwiOlwi4qi4XCIsXCJvZG90XCI6XCLiiplcIixcIm9kc29sZFwiOlwi4qa8XCIsXCJPRWxpZ1wiOlwixZJcIixcIm9lbGlnXCI6XCLFk1wiLFwib2ZjaXJcIjpcIuKmv1wiLFwiT2ZyXCI6XCLwnZSSXCIsXCJvZnJcIjpcIvCdlKxcIixcIm9nb25cIjpcIsubXCIsXCJPZ3JhdmVcIjpcIsOSXCIsXCJvZ3JhdmVcIjpcIsOyXCIsXCJvZ3RcIjpcIuKngVwiLFwib2hiYXJcIjpcIuKmtVwiLFwib2htXCI6XCLOqVwiLFwib2ludFwiOlwi4oiuXCIsXCJvbGFyclwiOlwi4oa6XCIsXCJvbGNpclwiOlwi4qa+XCIsXCJvbGNyb3NzXCI6XCLiprtcIixcIm9saW5lXCI6XCLigL5cIixcIm9sdFwiOlwi4qeAXCIsXCJPbWFjclwiOlwixYxcIixcIm9tYWNyXCI6XCLFjVwiLFwiT21lZ2FcIjpcIs6pXCIsXCJvbWVnYVwiOlwiz4lcIixcIk9taWNyb25cIjpcIs6fXCIsXCJvbWljcm9uXCI6XCLOv1wiLFwib21pZFwiOlwi4qa2XCIsXCJvbWludXNcIjpcIuKKllwiLFwiT29wZlwiOlwi8J2VhlwiLFwib29wZlwiOlwi8J2VoFwiLFwib3BhclwiOlwi4qa3XCIsXCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCcXCIsXCJPcGVuQ3VybHlRdW90ZVwiOlwi4oCYXCIsXCJvcGVycFwiOlwi4qa5XCIsXCJvcGx1c1wiOlwi4oqVXCIsXCJvcmFyclwiOlwi4oa7XCIsXCJPclwiOlwi4qmUXCIsXCJvclwiOlwi4oioXCIsXCJvcmRcIjpcIuKpnVwiLFwib3JkZXJcIjpcIuKEtFwiLFwib3JkZXJvZlwiOlwi4oS0XCIsXCJvcmRmXCI6XCLCqlwiLFwib3JkbVwiOlwiwrpcIixcIm9yaWdvZlwiOlwi4oq2XCIsXCJvcm9yXCI6XCLiqZZcIixcIm9yc2xvcGVcIjpcIuKpl1wiLFwib3J2XCI6XCLiqZtcIixcIm9TXCI6XCLik4hcIixcIk9zY3JcIjpcIvCdkqpcIixcIm9zY3JcIjpcIuKEtFwiLFwiT3NsYXNoXCI6XCLDmFwiLFwib3NsYXNoXCI6XCLDuFwiLFwib3NvbFwiOlwi4oqYXCIsXCJPdGlsZGVcIjpcIsOVXCIsXCJvdGlsZGVcIjpcIsO1XCIsXCJvdGltZXNhc1wiOlwi4qi2XCIsXCJPdGltZXNcIjpcIuKot1wiLFwib3RpbWVzXCI6XCLiipdcIixcIk91bWxcIjpcIsOWXCIsXCJvdW1sXCI6XCLDtlwiLFwib3ZiYXJcIjpcIuKMvVwiLFwiT3ZlckJhclwiOlwi4oC+XCIsXCJPdmVyQnJhY2VcIjpcIuKPnlwiLFwiT3ZlckJyYWNrZXRcIjpcIuKOtFwiLFwiT3ZlclBhcmVudGhlc2lzXCI6XCLij5xcIixcInBhcmFcIjpcIsK2XCIsXCJwYXJhbGxlbFwiOlwi4oilXCIsXCJwYXJcIjpcIuKIpVwiLFwicGFyc2ltXCI6XCLiq7NcIixcInBhcnNsXCI6XCLiq71cIixcInBhcnRcIjpcIuKIglwiLFwiUGFydGlhbERcIjpcIuKIglwiLFwiUGN5XCI6XCLQn1wiLFwicGN5XCI6XCLQv1wiLFwicGVyY250XCI6XCIlXCIsXCJwZXJpb2RcIjpcIi5cIixcInBlcm1pbFwiOlwi4oCwXCIsXCJwZXJwXCI6XCLiiqVcIixcInBlcnRlbmtcIjpcIuKAsVwiLFwiUGZyXCI6XCLwnZSTXCIsXCJwZnJcIjpcIvCdlK1cIixcIlBoaVwiOlwizqZcIixcInBoaVwiOlwiz4ZcIixcInBoaXZcIjpcIs+VXCIsXCJwaG1tYXRcIjpcIuKEs1wiLFwicGhvbmVcIjpcIuKYjlwiLFwiUGlcIjpcIs6gXCIsXCJwaVwiOlwiz4BcIixcInBpdGNoZm9ya1wiOlwi4ouUXCIsXCJwaXZcIjpcIs+WXCIsXCJwbGFuY2tcIjpcIuKEj1wiLFwicGxhbmNraFwiOlwi4oSOXCIsXCJwbGFua3ZcIjpcIuKEj1wiLFwicGx1c2FjaXJcIjpcIuKoo1wiLFwicGx1c2JcIjpcIuKKnlwiLFwicGx1c2NpclwiOlwi4qiiXCIsXCJwbHVzXCI6XCIrXCIsXCJwbHVzZG9cIjpcIuKIlFwiLFwicGx1c2R1XCI6XCLiqKVcIixcInBsdXNlXCI6XCLiqbJcIixcIlBsdXNNaW51c1wiOlwiwrFcIixcInBsdXNtblwiOlwiwrFcIixcInBsdXNzaW1cIjpcIuKoplwiLFwicGx1c3R3b1wiOlwi4qinXCIsXCJwbVwiOlwiwrFcIixcIlBvaW5jYXJlcGxhbmVcIjpcIuKEjFwiLFwicG9pbnRpbnRcIjpcIuKolVwiLFwicG9wZlwiOlwi8J2VoVwiLFwiUG9wZlwiOlwi4oSZXCIsXCJwb3VuZFwiOlwiwqNcIixcInByYXBcIjpcIuKqt1wiLFwiUHJcIjpcIuKqu1wiLFwicHJcIjpcIuKJulwiLFwicHJjdWVcIjpcIuKJvFwiLFwicHJlY2FwcHJveFwiOlwi4qq3XCIsXCJwcmVjXCI6XCLiibpcIixcInByZWNjdXJseWVxXCI6XCLiibxcIixcIlByZWNlZGVzXCI6XCLiibpcIixcIlByZWNlZGVzRXF1YWxcIjpcIuKqr1wiLFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCLiibxcIixcIlByZWNlZGVzVGlsZGVcIjpcIuKJvlwiLFwicHJlY2VxXCI6XCLiqq9cIixcInByZWNuYXBwcm94XCI6XCLiqrlcIixcInByZWNuZXFxXCI6XCLiqrVcIixcInByZWNuc2ltXCI6XCLii6hcIixcInByZVwiOlwi4qqvXCIsXCJwckVcIjpcIuKqs1wiLFwicHJlY3NpbVwiOlwi4om+XCIsXCJwcmltZVwiOlwi4oCyXCIsXCJQcmltZVwiOlwi4oCzXCIsXCJwcmltZXNcIjpcIuKEmVwiLFwicHJuYXBcIjpcIuKquVwiLFwicHJuRVwiOlwi4qq1XCIsXCJwcm5zaW1cIjpcIuKLqFwiLFwicHJvZFwiOlwi4oiPXCIsXCJQcm9kdWN0XCI6XCLiiI9cIixcInByb2ZhbGFyXCI6XCLijK5cIixcInByb2ZsaW5lXCI6XCLijJJcIixcInByb2ZzdXJmXCI6XCLijJNcIixcInByb3BcIjpcIuKInVwiLFwiUHJvcG9ydGlvbmFsXCI6XCLiiJ1cIixcIlByb3BvcnRpb25cIjpcIuKIt1wiLFwicHJvcHRvXCI6XCLiiJ1cIixcInByc2ltXCI6XCLiib5cIixcInBydXJlbFwiOlwi4oqwXCIsXCJQc2NyXCI6XCLwnZKrXCIsXCJwc2NyXCI6XCLwnZOFXCIsXCJQc2lcIjpcIs6oXCIsXCJwc2lcIjpcIs+IXCIsXCJwdW5jc3BcIjpcIuKAiFwiLFwiUWZyXCI6XCLwnZSUXCIsXCJxZnJcIjpcIvCdlK5cIixcInFpbnRcIjpcIuKojFwiLFwicW9wZlwiOlwi8J2VolwiLFwiUW9wZlwiOlwi4oSaXCIsXCJxcHJpbWVcIjpcIuKBl1wiLFwiUXNjclwiOlwi8J2SrFwiLFwicXNjclwiOlwi8J2ThlwiLFwicXVhdGVybmlvbnNcIjpcIuKEjVwiLFwicXVhdGludFwiOlwi4qiWXCIsXCJxdWVzdFwiOlwiP1wiLFwicXVlc3RlcVwiOlwi4omfXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyQWFyclwiOlwi4oebXCIsXCJyYWNlXCI6XCLiiL3MsVwiLFwiUmFjdXRlXCI6XCLFlFwiLFwicmFjdXRlXCI6XCLFlVwiLFwicmFkaWNcIjpcIuKImlwiLFwicmFlbXB0eXZcIjpcIuKms1wiLFwicmFuZ1wiOlwi4p+pXCIsXCJSYW5nXCI6XCLin6tcIixcInJhbmdkXCI6XCLippJcIixcInJhbmdlXCI6XCLipqVcIixcInJhbmdsZVwiOlwi4p+pXCIsXCJyYXF1b1wiOlwiwrtcIixcInJhcnJhcFwiOlwi4qW1XCIsXCJyYXJyYlwiOlwi4oelXCIsXCJyYXJyYmZzXCI6XCLipKBcIixcInJhcnJjXCI6XCLipLNcIixcInJhcnJcIjpcIuKGklwiLFwiUmFyclwiOlwi4oagXCIsXCJyQXJyXCI6XCLih5JcIixcInJhcnJmc1wiOlwi4qSeXCIsXCJyYXJyaGtcIjpcIuKGqlwiLFwicmFycmxwXCI6XCLihqxcIixcInJhcnJwbFwiOlwi4qWFXCIsXCJyYXJyc2ltXCI6XCLipbRcIixcIlJhcnJ0bFwiOlwi4qSWXCIsXCJyYXJydGxcIjpcIuKGo1wiLFwicmFycndcIjpcIuKGnVwiLFwicmF0YWlsXCI6XCLipJpcIixcInJBdGFpbFwiOlwi4qScXCIsXCJyYXRpb1wiOlwi4oi2XCIsXCJyYXRpb25hbHNcIjpcIuKEmlwiLFwicmJhcnJcIjpcIuKkjVwiLFwickJhcnJcIjpcIuKkj1wiLFwiUkJhcnJcIjpcIuKkkFwiLFwicmJicmtcIjpcIuKds1wiLFwicmJyYWNlXCI6XCJ9XCIsXCJyYnJhY2tcIjpcIl1cIixcInJicmtlXCI6XCLipoxcIixcInJicmtzbGRcIjpcIuKmjlwiLFwicmJya3NsdVwiOlwi4qaQXCIsXCJSY2Fyb25cIjpcIsWYXCIsXCJyY2Fyb25cIjpcIsWZXCIsXCJSY2VkaWxcIjpcIsWWXCIsXCJyY2VkaWxcIjpcIsWXXCIsXCJyY2VpbFwiOlwi4oyJXCIsXCJyY3ViXCI6XCJ9XCIsXCJSY3lcIjpcItCgXCIsXCJyY3lcIjpcItGAXCIsXCJyZGNhXCI6XCLipLdcIixcInJkbGRoYXJcIjpcIuKlqVwiLFwicmRxdW9cIjpcIuKAnVwiLFwicmRxdW9yXCI6XCLigJ1cIixcInJkc2hcIjpcIuKGs1wiLFwicmVhbFwiOlwi4oScXCIsXCJyZWFsaW5lXCI6XCLihJtcIixcInJlYWxwYXJ0XCI6XCLihJxcIixcInJlYWxzXCI6XCLihJ1cIixcIlJlXCI6XCLihJxcIixcInJlY3RcIjpcIuKWrVwiLFwicmVnXCI6XCLCrlwiLFwiUkVHXCI6XCLCrlwiLFwiUmV2ZXJzZUVsZW1lbnRcIjpcIuKIi1wiLFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6XCLih4tcIixcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6XCLipa9cIixcInJmaXNodFwiOlwi4qW9XCIsXCJyZmxvb3JcIjpcIuKMi1wiLFwicmZyXCI6XCLwnZSvXCIsXCJSZnJcIjpcIuKEnFwiLFwickhhclwiOlwi4qWkXCIsXCJyaGFyZFwiOlwi4oeBXCIsXCJyaGFydVwiOlwi4oeAXCIsXCJyaGFydWxcIjpcIuKlrFwiLFwiUmhvXCI6XCLOoVwiLFwicmhvXCI6XCLPgVwiLFwicmhvdlwiOlwiz7FcIixcIlJpZ2h0QW5nbGVCcmFja2V0XCI6XCLin6lcIixcIlJpZ2h0QXJyb3dCYXJcIjpcIuKHpVwiLFwicmlnaHRhcnJvd1wiOlwi4oaSXCIsXCJSaWdodEFycm93XCI6XCLihpJcIixcIlJpZ2h0YXJyb3dcIjpcIuKHklwiLFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOlwi4oeEXCIsXCJyaWdodGFycm93dGFpbFwiOlwi4oajXCIsXCJSaWdodENlaWxpbmdcIjpcIuKMiVwiLFwiUmlnaHREb3VibGVCcmFja2V0XCI6XCLin6dcIixcIlJpZ2h0RG93blRlZVZlY3RvclwiOlwi4qWdXCIsXCJSaWdodERvd25WZWN0b3JCYXJcIjpcIuKllVwiLFwiUmlnaHREb3duVmVjdG9yXCI6XCLih4JcIixcIlJpZ2h0Rmxvb3JcIjpcIuKMi1wiLFwicmlnaHRoYXJwb29uZG93blwiOlwi4oeBXCIsXCJyaWdodGhhcnBvb251cFwiOlwi4oeAXCIsXCJyaWdodGxlZnRhcnJvd3NcIjpcIuKHhFwiLFwicmlnaHRsZWZ0aGFycG9vbnNcIjpcIuKHjFwiLFwicmlnaHRyaWdodGFycm93c1wiOlwi4oeJXCIsXCJyaWdodHNxdWlnYXJyb3dcIjpcIuKGnVwiLFwiUmlnaHRUZWVBcnJvd1wiOlwi4oamXCIsXCJSaWdodFRlZVwiOlwi4oqiXCIsXCJSaWdodFRlZVZlY3RvclwiOlwi4qWbXCIsXCJyaWdodHRocmVldGltZXNcIjpcIuKLjFwiLFwiUmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQXCIsXCJSaWdodFRyaWFuZ2xlXCI6XCLiirNcIixcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4oq1XCIsXCJSaWdodFVwRG93blZlY3RvclwiOlwi4qWPXCIsXCJSaWdodFVwVGVlVmVjdG9yXCI6XCLipZxcIixcIlJpZ2h0VXBWZWN0b3JCYXJcIjpcIuKllFwiLFwiUmlnaHRVcFZlY3RvclwiOlwi4oa+XCIsXCJSaWdodFZlY3RvckJhclwiOlwi4qWTXCIsXCJSaWdodFZlY3RvclwiOlwi4oeAXCIsXCJyaW5nXCI6XCLLmlwiLFwicmlzaW5nZG90c2VxXCI6XCLiiZNcIixcInJsYXJyXCI6XCLih4RcIixcInJsaGFyXCI6XCLih4xcIixcInJsbVwiOlwi4oCPXCIsXCJybW91c3RhY2hlXCI6XCLijrFcIixcInJtb3VzdFwiOlwi4o6xXCIsXCJybm1pZFwiOlwi4quuXCIsXCJyb2FuZ1wiOlwi4p+tXCIsXCJyb2FyclwiOlwi4oe+XCIsXCJyb2Jya1wiOlwi4p+nXCIsXCJyb3BhclwiOlwi4qaGXCIsXCJyb3BmXCI6XCLwnZWjXCIsXCJSb3BmXCI6XCLihJ1cIixcInJvcGx1c1wiOlwi4qiuXCIsXCJyb3RpbWVzXCI6XCLiqLVcIixcIlJvdW5kSW1wbGllc1wiOlwi4qWwXCIsXCJycGFyXCI6XCIpXCIsXCJycGFyZ3RcIjpcIuKmlFwiLFwicnBwb2xpbnRcIjpcIuKoklwiLFwicnJhcnJcIjpcIuKHiVwiLFwiUnJpZ2h0YXJyb3dcIjpcIuKHm1wiLFwicnNhcXVvXCI6XCLigLpcIixcInJzY3JcIjpcIvCdk4dcIixcIlJzY3JcIjpcIuKEm1wiLFwicnNoXCI6XCLihrFcIixcIlJzaFwiOlwi4oaxXCIsXCJyc3FiXCI6XCJdXCIsXCJyc3F1b1wiOlwi4oCZXCIsXCJyc3F1b3JcIjpcIuKAmVwiLFwicnRocmVlXCI6XCLii4xcIixcInJ0aW1lc1wiOlwi4ouKXCIsXCJydHJpXCI6XCLilrlcIixcInJ0cmllXCI6XCLiirVcIixcInJ0cmlmXCI6XCLilrhcIixcInJ0cmlsdHJpXCI6XCLip45cIixcIlJ1bGVEZWxheWVkXCI6XCLip7RcIixcInJ1bHVoYXJcIjpcIuKlqFwiLFwicnhcIjpcIuKEnlwiLFwiU2FjdXRlXCI6XCLFmlwiLFwic2FjdXRlXCI6XCLFm1wiLFwic2JxdW9cIjpcIuKAmlwiLFwic2NhcFwiOlwi4qq4XCIsXCJTY2Fyb25cIjpcIsWgXCIsXCJzY2Fyb25cIjpcIsWhXCIsXCJTY1wiOlwi4qq8XCIsXCJzY1wiOlwi4om7XCIsXCJzY2N1ZVwiOlwi4om9XCIsXCJzY2VcIjpcIuKqsFwiLFwic2NFXCI6XCLiqrRcIixcIlNjZWRpbFwiOlwixZ5cIixcInNjZWRpbFwiOlwixZ9cIixcIlNjaXJjXCI6XCLFnFwiLFwic2NpcmNcIjpcIsWdXCIsXCJzY25hcFwiOlwi4qq6XCIsXCJzY25FXCI6XCLiqrZcIixcInNjbnNpbVwiOlwi4oupXCIsXCJzY3BvbGludFwiOlwi4qiTXCIsXCJzY3NpbVwiOlwi4om/XCIsXCJTY3lcIjpcItChXCIsXCJzY3lcIjpcItGBXCIsXCJzZG90YlwiOlwi4oqhXCIsXCJzZG90XCI6XCLii4VcIixcInNkb3RlXCI6XCLiqaZcIixcInNlYXJoa1wiOlwi4qSlXCIsXCJzZWFyclwiOlwi4oaYXCIsXCJzZUFyclwiOlwi4oeYXCIsXCJzZWFycm93XCI6XCLihphcIixcInNlY3RcIjpcIsKnXCIsXCJzZW1pXCI6XCI7XCIsXCJzZXN3YXJcIjpcIuKkqVwiLFwic2V0bWludXNcIjpcIuKIllwiLFwic2V0bW5cIjpcIuKIllwiLFwic2V4dFwiOlwi4py2XCIsXCJTZnJcIjpcIvCdlJZcIixcInNmclwiOlwi8J2UsFwiLFwic2Zyb3duXCI6XCLijKJcIixcInNoYXJwXCI6XCLima9cIixcIlNIQ0hjeVwiOlwi0KlcIixcInNoY2hjeVwiOlwi0YlcIixcIlNIY3lcIjpcItCoXCIsXCJzaGN5XCI6XCLRiFwiLFwiU2hvcnREb3duQXJyb3dcIjpcIuKGk1wiLFwiU2hvcnRMZWZ0QXJyb3dcIjpcIuKGkFwiLFwic2hvcnRtaWRcIjpcIuKIo1wiLFwic2hvcnRwYXJhbGxlbFwiOlwi4oilXCIsXCJTaG9ydFJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiU2hvcnRVcEFycm93XCI6XCLihpFcIixcInNoeVwiOlwiwq1cIixcIlNpZ21hXCI6XCLOo1wiLFwic2lnbWFcIjpcIs+DXCIsXCJzaWdtYWZcIjpcIs+CXCIsXCJzaWdtYXZcIjpcIs+CXCIsXCJzaW1cIjpcIuKIvFwiLFwic2ltZG90XCI6XCLiqapcIixcInNpbWVcIjpcIuKJg1wiLFwic2ltZXFcIjpcIuKJg1wiLFwic2ltZ1wiOlwi4qqeXCIsXCJzaW1nRVwiOlwi4qqgXCIsXCJzaW1sXCI6XCLiqp1cIixcInNpbWxFXCI6XCLiqp9cIixcInNpbW5lXCI6XCLiiYZcIixcInNpbXBsdXNcIjpcIuKopFwiLFwic2ltcmFyclwiOlwi4qWyXCIsXCJzbGFyclwiOlwi4oaQXCIsXCJTbWFsbENpcmNsZVwiOlwi4oiYXCIsXCJzbWFsbHNldG1pbnVzXCI6XCLiiJZcIixcInNtYXNocFwiOlwi4qizXCIsXCJzbWVwYXJzbFwiOlwi4qekXCIsXCJzbWlkXCI6XCLiiKNcIixcInNtaWxlXCI6XCLijKNcIixcInNtdFwiOlwi4qqqXCIsXCJzbXRlXCI6XCLiqqxcIixcInNtdGVzXCI6XCLiqqzvuIBcIixcIlNPRlRjeVwiOlwi0KxcIixcInNvZnRjeVwiOlwi0YxcIixcInNvbGJhclwiOlwi4oy/XCIsXCJzb2xiXCI6XCLip4RcIixcInNvbFwiOlwiL1wiLFwiU29wZlwiOlwi8J2VilwiLFwic29wZlwiOlwi8J2VpFwiLFwic3BhZGVzXCI6XCLimaBcIixcInNwYWRlc3VpdFwiOlwi4pmgXCIsXCJzcGFyXCI6XCLiiKVcIixcInNxY2FwXCI6XCLiipNcIixcInNxY2Fwc1wiOlwi4oqT77iAXCIsXCJzcWN1cFwiOlwi4oqUXCIsXCJzcWN1cHNcIjpcIuKKlO+4gFwiLFwiU3FydFwiOlwi4oiaXCIsXCJzcXN1YlwiOlwi4oqPXCIsXCJzcXN1YmVcIjpcIuKKkVwiLFwic3FzdWJzZXRcIjpcIuKKj1wiLFwic3FzdWJzZXRlcVwiOlwi4oqRXCIsXCJzcXN1cFwiOlwi4oqQXCIsXCJzcXN1cGVcIjpcIuKKklwiLFwic3FzdXBzZXRcIjpcIuKKkFwiLFwic3FzdXBzZXRlcVwiOlwi4oqSXCIsXCJzcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZUludGVyc2VjdGlvblwiOlwi4oqTXCIsXCJTcXVhcmVTdWJzZXRcIjpcIuKKj1wiLFwiU3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKKkVwiLFwiU3F1YXJlU3VwZXJzZXRcIjpcIuKKkFwiLFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oqSXCIsXCJTcXVhcmVVbmlvblwiOlwi4oqUXCIsXCJzcXVhcmZcIjpcIuKWqlwiLFwic3F1XCI6XCLilqFcIixcInNxdWZcIjpcIuKWqlwiLFwic3JhcnJcIjpcIuKGklwiLFwiU3NjclwiOlwi8J2SrlwiLFwic3NjclwiOlwi8J2TiFwiLFwic3NldG1uXCI6XCLiiJZcIixcInNzbWlsZVwiOlwi4oyjXCIsXCJzc3RhcmZcIjpcIuKLhlwiLFwiU3RhclwiOlwi4ouGXCIsXCJzdGFyXCI6XCLimIZcIixcInN0YXJmXCI6XCLimIVcIixcInN0cmFpZ2h0ZXBzaWxvblwiOlwiz7VcIixcInN0cmFpZ2h0cGhpXCI6XCLPlVwiLFwic3RybnNcIjpcIsKvXCIsXCJzdWJcIjpcIuKKglwiLFwiU3ViXCI6XCLii5BcIixcInN1YmRvdFwiOlwi4qq9XCIsXCJzdWJFXCI6XCLiq4VcIixcInN1YmVcIjpcIuKKhlwiLFwic3ViZWRvdFwiOlwi4quDXCIsXCJzdWJtdWx0XCI6XCLiq4FcIixcInN1Ym5FXCI6XCLiq4tcIixcInN1Ym5lXCI6XCLiiopcIixcInN1YnBsdXNcIjpcIuKqv1wiLFwic3VicmFyclwiOlwi4qW5XCIsXCJzdWJzZXRcIjpcIuKKglwiLFwiU3Vic2V0XCI6XCLii5BcIixcInN1YnNldGVxXCI6XCLiioZcIixcInN1YnNldGVxcVwiOlwi4quFXCIsXCJTdWJzZXRFcXVhbFwiOlwi4oqGXCIsXCJzdWJzZXRuZXFcIjpcIuKKilwiLFwic3Vic2V0bmVxcVwiOlwi4quLXCIsXCJzdWJzaW1cIjpcIuKrh1wiLFwic3Vic3ViXCI6XCLiq5VcIixcInN1YnN1cFwiOlwi4quTXCIsXCJzdWNjYXBwcm94XCI6XCLiqrhcIixcInN1Y2NcIjpcIuKJu1wiLFwic3VjY2N1cmx5ZXFcIjpcIuKJvVwiLFwiU3VjY2VlZHNcIjpcIuKJu1wiLFwiU3VjY2VlZHNFcXVhbFwiOlwi4qqwXCIsXCJTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKJvVwiLFwiU3VjY2VlZHNUaWxkZVwiOlwi4om/XCIsXCJzdWNjZXFcIjpcIuKqsFwiLFwic3VjY25hcHByb3hcIjpcIuKqulwiLFwic3VjY25lcXFcIjpcIuKqtlwiLFwic3VjY25zaW1cIjpcIuKLqVwiLFwic3VjY3NpbVwiOlwi4om/XCIsXCJTdWNoVGhhdFwiOlwi4oiLXCIsXCJzdW1cIjpcIuKIkVwiLFwiU3VtXCI6XCLiiJFcIixcInN1bmdcIjpcIuKZqlwiLFwic3VwMVwiOlwiwrlcIixcInN1cDJcIjpcIsKyXCIsXCJzdXAzXCI6XCLCs1wiLFwic3VwXCI6XCLiioNcIixcIlN1cFwiOlwi4ouRXCIsXCJzdXBkb3RcIjpcIuKqvlwiLFwic3VwZHN1YlwiOlwi4quYXCIsXCJzdXBFXCI6XCLiq4ZcIixcInN1cGVcIjpcIuKKh1wiLFwic3VwZWRvdFwiOlwi4quEXCIsXCJTdXBlcnNldFwiOlwi4oqDXCIsXCJTdXBlcnNldEVxdWFsXCI6XCLiiodcIixcInN1cGhzb2xcIjpcIuKfiVwiLFwic3VwaHN1YlwiOlwi4quXXCIsXCJzdXBsYXJyXCI6XCLipbtcIixcInN1cG11bHRcIjpcIuKrglwiLFwic3VwbkVcIjpcIuKrjFwiLFwic3VwbmVcIjpcIuKKi1wiLFwic3VwcGx1c1wiOlwi4quAXCIsXCJzdXBzZXRcIjpcIuKKg1wiLFwiU3Vwc2V0XCI6XCLii5FcIixcInN1cHNldGVxXCI6XCLiiodcIixcInN1cHNldGVxcVwiOlwi4quGXCIsXCJzdXBzZXRuZXFcIjpcIuKKi1wiLFwic3Vwc2V0bmVxcVwiOlwi4quMXCIsXCJzdXBzaW1cIjpcIuKriFwiLFwic3Vwc3ViXCI6XCLiq5RcIixcInN1cHN1cFwiOlwi4quWXCIsXCJzd2FyaGtcIjpcIuKkplwiLFwic3dhcnJcIjpcIuKGmVwiLFwic3dBcnJcIjpcIuKHmVwiLFwic3dhcnJvd1wiOlwi4oaZXCIsXCJzd253YXJcIjpcIuKkqlwiLFwic3psaWdcIjpcIsOfXCIsXCJUYWJcIjpcIlxcdFwiLFwidGFyZ2V0XCI6XCLijJZcIixcIlRhdVwiOlwizqRcIixcInRhdVwiOlwiz4RcIixcInRicmtcIjpcIuKOtFwiLFwiVGNhcm9uXCI6XCLFpFwiLFwidGNhcm9uXCI6XCLFpVwiLFwiVGNlZGlsXCI6XCLFolwiLFwidGNlZGlsXCI6XCLFo1wiLFwiVGN5XCI6XCLQolwiLFwidGN5XCI6XCLRglwiLFwidGRvdFwiOlwi4oObXCIsXCJ0ZWxyZWNcIjpcIuKMlVwiLFwiVGZyXCI6XCLwnZSXXCIsXCJ0ZnJcIjpcIvCdlLFcIixcInRoZXJlNFwiOlwi4oi0XCIsXCJ0aGVyZWZvcmVcIjpcIuKItFwiLFwiVGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXRhXCI6XCLOmFwiLFwidGhldGFcIjpcIs64XCIsXCJ0aGV0YXN5bVwiOlwiz5FcIixcInRoZXRhdlwiOlwiz5FcIixcInRoaWNrYXBwcm94XCI6XCLiiYhcIixcInRoaWNrc2ltXCI6XCLiiLxcIixcIlRoaWNrU3BhY2VcIjpcIuKBn+KAilwiLFwiVGhpblNwYWNlXCI6XCLigIlcIixcInRoaW5zcFwiOlwi4oCJXCIsXCJ0aGthcFwiOlwi4omIXCIsXCJ0aGtzaW1cIjpcIuKIvFwiLFwiVEhPUk5cIjpcIsOeXCIsXCJ0aG9yblwiOlwiw75cIixcInRpbGRlXCI6XCLLnFwiLFwiVGlsZGVcIjpcIuKIvFwiLFwiVGlsZGVFcXVhbFwiOlwi4omDXCIsXCJUaWxkZUZ1bGxFcXVhbFwiOlwi4omFXCIsXCJUaWxkZVRpbGRlXCI6XCLiiYhcIixcInRpbWVzYmFyXCI6XCLiqLFcIixcInRpbWVzYlwiOlwi4oqgXCIsXCJ0aW1lc1wiOlwiw5dcIixcInRpbWVzZFwiOlwi4qiwXCIsXCJ0aW50XCI6XCLiiK1cIixcInRvZWFcIjpcIuKkqFwiLFwidG9wYm90XCI6XCLijLZcIixcInRvcGNpclwiOlwi4quxXCIsXCJ0b3BcIjpcIuKKpFwiLFwiVG9wZlwiOlwi8J2Vi1wiLFwidG9wZlwiOlwi8J2VpVwiLFwidG9wZm9ya1wiOlwi4quaXCIsXCJ0b3NhXCI6XCLipKlcIixcInRwcmltZVwiOlwi4oC0XCIsXCJ0cmFkZVwiOlwi4oSiXCIsXCJUUkFERVwiOlwi4oSiXCIsXCJ0cmlhbmdsZVwiOlwi4pa1XCIsXCJ0cmlhbmdsZWRvd25cIjpcIuKWv1wiLFwidHJpYW5nbGVsZWZ0XCI6XCLil4NcIixcInRyaWFuZ2xlbGVmdGVxXCI6XCLiirRcIixcInRyaWFuZ2xlcVwiOlwi4omcXCIsXCJ0cmlhbmdsZXJpZ2h0XCI6XCLilrlcIixcInRyaWFuZ2xlcmlnaHRlcVwiOlwi4oq1XCIsXCJ0cmlkb3RcIjpcIuKXrFwiLFwidHJpZVwiOlwi4omcXCIsXCJ0cmltaW51c1wiOlwi4qi6XCIsXCJUcmlwbGVEb3RcIjpcIuKDm1wiLFwidHJpcGx1c1wiOlwi4qi5XCIsXCJ0cmlzYlwiOlwi4qeNXCIsXCJ0cml0aW1lXCI6XCLiqLtcIixcInRycGV6aXVtXCI6XCLij6JcIixcIlRzY3JcIjpcIvCdkq9cIixcInRzY3JcIjpcIvCdk4lcIixcIlRTY3lcIjpcItCmXCIsXCJ0c2N5XCI6XCLRhlwiLFwiVFNIY3lcIjpcItCLXCIsXCJ0c2hjeVwiOlwi0ZtcIixcIlRzdHJva1wiOlwixaZcIixcInRzdHJva1wiOlwixadcIixcInR3aXh0XCI6XCLiiaxcIixcInR3b2hlYWRsZWZ0YXJyb3dcIjpcIuKGnlwiLFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIuKGoFwiLFwiVWFjdXRlXCI6XCLDmlwiLFwidWFjdXRlXCI6XCLDulwiLFwidWFyclwiOlwi4oaRXCIsXCJVYXJyXCI6XCLihp9cIixcInVBcnJcIjpcIuKHkVwiLFwiVWFycm9jaXJcIjpcIuKliVwiLFwiVWJyY3lcIjpcItCOXCIsXCJ1YnJjeVwiOlwi0Z5cIixcIlVicmV2ZVwiOlwixaxcIixcInVicmV2ZVwiOlwixa1cIixcIlVjaXJjXCI6XCLDm1wiLFwidWNpcmNcIjpcIsO7XCIsXCJVY3lcIjpcItCjXCIsXCJ1Y3lcIjpcItGDXCIsXCJ1ZGFyclwiOlwi4oeFXCIsXCJVZGJsYWNcIjpcIsWwXCIsXCJ1ZGJsYWNcIjpcIsWxXCIsXCJ1ZGhhclwiOlwi4qWuXCIsXCJ1ZmlzaHRcIjpcIuKlvlwiLFwiVWZyXCI6XCLwnZSYXCIsXCJ1ZnJcIjpcIvCdlLJcIixcIlVncmF2ZVwiOlwiw5lcIixcInVncmF2ZVwiOlwiw7lcIixcInVIYXJcIjpcIuKlo1wiLFwidWhhcmxcIjpcIuKGv1wiLFwidWhhcnJcIjpcIuKGvlwiLFwidWhibGtcIjpcIuKWgFwiLFwidWxjb3JuXCI6XCLijJxcIixcInVsY29ybmVyXCI6XCLijJxcIixcInVsY3JvcFwiOlwi4oyPXCIsXCJ1bHRyaVwiOlwi4pe4XCIsXCJVbWFjclwiOlwixapcIixcInVtYWNyXCI6XCLFq1wiLFwidW1sXCI6XCLCqFwiLFwiVW5kZXJCYXJcIjpcIl9cIixcIlVuZGVyQnJhY2VcIjpcIuKPn1wiLFwiVW5kZXJCcmFja2V0XCI6XCLijrVcIixcIlVuZGVyUGFyZW50aGVzaXNcIjpcIuKPnVwiLFwiVW5pb25cIjpcIuKLg1wiLFwiVW5pb25QbHVzXCI6XCLiio5cIixcIlVvZ29uXCI6XCLFslwiLFwidW9nb25cIjpcIsWzXCIsXCJVb3BmXCI6XCLwnZWMXCIsXCJ1b3BmXCI6XCLwnZWmXCIsXCJVcEFycm93QmFyXCI6XCLipJJcIixcInVwYXJyb3dcIjpcIuKGkVwiLFwiVXBBcnJvd1wiOlwi4oaRXCIsXCJVcGFycm93XCI6XCLih5FcIixcIlVwQXJyb3dEb3duQXJyb3dcIjpcIuKHhVwiLFwidXBkb3duYXJyb3dcIjpcIuKGlVwiLFwiVXBEb3duQXJyb3dcIjpcIuKGlVwiLFwiVXBkb3duYXJyb3dcIjpcIuKHlVwiLFwiVXBFcXVpbGlicml1bVwiOlwi4qWuXCIsXCJ1cGhhcnBvb25sZWZ0XCI6XCLihr9cIixcInVwaGFycG9vbnJpZ2h0XCI6XCLihr5cIixcInVwbHVzXCI6XCLiio5cIixcIlVwcGVyTGVmdEFycm93XCI6XCLihpZcIixcIlVwcGVyUmlnaHRBcnJvd1wiOlwi4oaXXCIsXCJ1cHNpXCI6XCLPhVwiLFwiVXBzaVwiOlwiz5JcIixcInVwc2loXCI6XCLPklwiLFwiVXBzaWxvblwiOlwizqVcIixcInVwc2lsb25cIjpcIs+FXCIsXCJVcFRlZUFycm93XCI6XCLihqVcIixcIlVwVGVlXCI6XCLiiqVcIixcInVwdXBhcnJvd3NcIjpcIuKHiFwiLFwidXJjb3JuXCI6XCLijJ1cIixcInVyY29ybmVyXCI6XCLijJ1cIixcInVyY3JvcFwiOlwi4oyOXCIsXCJVcmluZ1wiOlwixa5cIixcInVyaW5nXCI6XCLFr1wiLFwidXJ0cmlcIjpcIuKXuVwiLFwiVXNjclwiOlwi8J2SsFwiLFwidXNjclwiOlwi8J2TilwiLFwidXRkb3RcIjpcIuKLsFwiLFwiVXRpbGRlXCI6XCLFqFwiLFwidXRpbGRlXCI6XCLFqVwiLFwidXRyaVwiOlwi4pa1XCIsXCJ1dHJpZlwiOlwi4pa0XCIsXCJ1dWFyclwiOlwi4oeIXCIsXCJVdW1sXCI6XCLDnFwiLFwidXVtbFwiOlwiw7xcIixcInV3YW5nbGVcIjpcIuKmp1wiLFwidmFuZ3J0XCI6XCLippxcIixcInZhcmVwc2lsb25cIjpcIs+1XCIsXCJ2YXJrYXBwYVwiOlwiz7BcIixcInZhcm5vdGhpbmdcIjpcIuKIhVwiLFwidmFycGhpXCI6XCLPlVwiLFwidmFycGlcIjpcIs+WXCIsXCJ2YXJwcm9wdG9cIjpcIuKInVwiLFwidmFyclwiOlwi4oaVXCIsXCJ2QXJyXCI6XCLih5VcIixcInZhcnJob1wiOlwiz7FcIixcInZhcnNpZ21hXCI6XCLPglwiLFwidmFyc3Vic2V0bmVxXCI6XCLiiorvuIBcIixcInZhcnN1YnNldG5lcXFcIjpcIuKri++4gFwiLFwidmFyc3Vwc2V0bmVxXCI6XCLiiovvuIBcIixcInZhcnN1cHNldG5lcXFcIjpcIuKrjO+4gFwiLFwidmFydGhldGFcIjpcIs+RXCIsXCJ2YXJ0cmlhbmdsZWxlZnRcIjpcIuKKslwiLFwidmFydHJpYW5nbGVyaWdodFwiOlwi4oqzXCIsXCJ2QmFyXCI6XCLiq6hcIixcIlZiYXJcIjpcIuKrq1wiLFwidkJhcnZcIjpcIuKrqVwiLFwiVmN5XCI6XCLQklwiLFwidmN5XCI6XCLQslwiLFwidmRhc2hcIjpcIuKKolwiLFwidkRhc2hcIjpcIuKKqFwiLFwiVmRhc2hcIjpcIuKKqVwiLFwiVkRhc2hcIjpcIuKKq1wiLFwiVmRhc2hsXCI6XCLiq6ZcIixcInZlZWJhclwiOlwi4oq7XCIsXCJ2ZWVcIjpcIuKIqFwiLFwiVmVlXCI6XCLii4FcIixcInZlZWVxXCI6XCLiiZpcIixcInZlbGxpcFwiOlwi4ouuXCIsXCJ2ZXJiYXJcIjpcInxcIixcIlZlcmJhclwiOlwi4oCWXCIsXCJ2ZXJ0XCI6XCJ8XCIsXCJWZXJ0XCI6XCLigJZcIixcIlZlcnRpY2FsQmFyXCI6XCLiiKNcIixcIlZlcnRpY2FsTGluZVwiOlwifFwiLFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIuKdmFwiLFwiVmVydGljYWxUaWxkZVwiOlwi4omAXCIsXCJWZXJ5VGhpblNwYWNlXCI6XCLigIpcIixcIlZmclwiOlwi8J2UmVwiLFwidmZyXCI6XCLwnZSzXCIsXCJ2bHRyaVwiOlwi4oqyXCIsXCJ2bnN1YlwiOlwi4oqC4oOSXCIsXCJ2bnN1cFwiOlwi4oqD4oOSXCIsXCJWb3BmXCI6XCLwnZWNXCIsXCJ2b3BmXCI6XCLwnZWnXCIsXCJ2cHJvcFwiOlwi4oidXCIsXCJ2cnRyaVwiOlwi4oqzXCIsXCJWc2NyXCI6XCLwnZKxXCIsXCJ2c2NyXCI6XCLwnZOLXCIsXCJ2c3VibkVcIjpcIuKri++4gFwiLFwidnN1Ym5lXCI6XCLiiorvuIBcIixcInZzdXBuRVwiOlwi4quM77iAXCIsXCJ2c3VwbmVcIjpcIuKKi++4gFwiLFwiVnZkYXNoXCI6XCLiiqpcIixcInZ6aWd6YWdcIjpcIuKmmlwiLFwiV2NpcmNcIjpcIsW0XCIsXCJ3Y2lyY1wiOlwixbVcIixcIndlZGJhclwiOlwi4qmfXCIsXCJ3ZWRnZVwiOlwi4oinXCIsXCJXZWRnZVwiOlwi4ouAXCIsXCJ3ZWRnZXFcIjpcIuKJmVwiLFwid2VpZXJwXCI6XCLihJhcIixcIldmclwiOlwi8J2UmlwiLFwid2ZyXCI6XCLwnZS0XCIsXCJXb3BmXCI6XCLwnZWOXCIsXCJ3b3BmXCI6XCLwnZWoXCIsXCJ3cFwiOlwi4oSYXCIsXCJ3clwiOlwi4omAXCIsXCJ3cmVhdGhcIjpcIuKJgFwiLFwiV3NjclwiOlwi8J2SslwiLFwid3NjclwiOlwi8J2TjFwiLFwieGNhcFwiOlwi4ouCXCIsXCJ4Y2lyY1wiOlwi4pevXCIsXCJ4Y3VwXCI6XCLii4NcIixcInhkdHJpXCI6XCLilr1cIixcIlhmclwiOlwi8J2Um1wiLFwieGZyXCI6XCLwnZS1XCIsXCJ4aGFyclwiOlwi4p+3XCIsXCJ4aEFyclwiOlwi4p+6XCIsXCJYaVwiOlwizp5cIixcInhpXCI6XCLOvlwiLFwieGxhcnJcIjpcIuKftVwiLFwieGxBcnJcIjpcIuKfuFwiLFwieG1hcFwiOlwi4p+8XCIsXCJ4bmlzXCI6XCLii7tcIixcInhvZG90XCI6XCLiqIBcIixcIlhvcGZcIjpcIvCdlY9cIixcInhvcGZcIjpcIvCdlalcIixcInhvcGx1c1wiOlwi4qiBXCIsXCJ4b3RpbWVcIjpcIuKoglwiLFwieHJhcnJcIjpcIuKftlwiLFwieHJBcnJcIjpcIuKfuVwiLFwiWHNjclwiOlwi8J2Ss1wiLFwieHNjclwiOlwi8J2TjVwiLFwieHNxY3VwXCI6XCLiqIZcIixcInh1cGx1c1wiOlwi4qiEXCIsXCJ4dXRyaVwiOlwi4pazXCIsXCJ4dmVlXCI6XCLii4FcIixcInh3ZWRnZVwiOlwi4ouAXCIsXCJZYWN1dGVcIjpcIsOdXCIsXCJ5YWN1dGVcIjpcIsO9XCIsXCJZQWN5XCI6XCLQr1wiLFwieWFjeVwiOlwi0Y9cIixcIlljaXJjXCI6XCLFtlwiLFwieWNpcmNcIjpcIsW3XCIsXCJZY3lcIjpcItCrXCIsXCJ5Y3lcIjpcItGLXCIsXCJ5ZW5cIjpcIsKlXCIsXCJZZnJcIjpcIvCdlJxcIixcInlmclwiOlwi8J2UtlwiLFwiWUljeVwiOlwi0IdcIixcInlpY3lcIjpcItGXXCIsXCJZb3BmXCI6XCLwnZWQXCIsXCJ5b3BmXCI6XCLwnZWqXCIsXCJZc2NyXCI6XCLwnZK0XCIsXCJ5c2NyXCI6XCLwnZOOXCIsXCJZVWN5XCI6XCLQrlwiLFwieXVjeVwiOlwi0Y5cIixcInl1bWxcIjpcIsO/XCIsXCJZdW1sXCI6XCLFuFwiLFwiWmFjdXRlXCI6XCLFuVwiLFwiemFjdXRlXCI6XCLFulwiLFwiWmNhcm9uXCI6XCLFvVwiLFwiemNhcm9uXCI6XCLFvlwiLFwiWmN5XCI6XCLQl1wiLFwiemN5XCI6XCLQt1wiLFwiWmRvdFwiOlwixbtcIixcInpkb3RcIjpcIsW8XCIsXCJ6ZWV0cmZcIjpcIuKEqFwiLFwiWmVyb1dpZHRoU3BhY2VcIjpcIuKAi1wiLFwiWmV0YVwiOlwizpZcIixcInpldGFcIjpcIs62XCIsXCJ6ZnJcIjpcIvCdlLdcIixcIlpmclwiOlwi4oSoXCIsXCJaSGN5XCI6XCLQllwiLFwiemhjeVwiOlwi0LZcIixcInppZ3JhcnJcIjpcIuKHnVwiLFwiem9wZlwiOlwi8J2Vq1wiLFwiWm9wZlwiOlwi4oSkXCIsXCJac2NyXCI6XCLwnZK1XCIsXCJ6c2NyXCI6XCLwnZOPXCIsXCJ6d2pcIjpcIuKAjVwiLFwiendualwiOlwi4oCMXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGVuY29kZUNhY2hlID0ge307XG5cblxuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG5cbiAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSxcbiAgICAgIHJlc3VsdCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICBrZWVwRXNjYXBlZCAgPSBleGNsdWRlO1xuICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZS5kZWZhdWx0Q2hhcnMgICA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWR1cmwvZW5jb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG52YXIgZGVjb2RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGNhY2hlLnB1c2goY2gpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcbiAgICBjYWNoZVtjaF0gPSAnJScgKyAoJzAnICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBEZWNvZGUgcGVyY2VudC1lbmNvZGVkIHN0cmluZy5cbi8vXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBleGNsdWRlKSB7XG4gIHZhciBjYWNoZTtcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXhjbHVkZSA9IGRlY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICB2YXIgaSwgbCwgYjEsIGIyLCBiMywgYjQsIGNocixcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuXG4gICAgICBpZiAoYjEgPCAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgNikgJiAweDdDMCkgfCAoYjIgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTIpICYgMHhGMDAwKSB8ICgoYjIgPDwgNikgJiAweEZDMCkgfCAoYjMgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGOCkgPT09IDB4RjAgJiYgKGkgKyA5IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjQgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDEwMDAwIHx8IGNociA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuXG5kZWNvZGUuZGVmYXVsdENoYXJzICAgPSAnOy8/OkAmPSskLCMnO1xuZGVjb2RlLmNvbXBvbmVudENoYXJzID0gJyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXQodXJsKSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyAnLy8nIDogJyc7XG4gIHJlc3VsdCArPSB1cmwuYXV0aCA/IHVybC5hdXRoICsgJ0AnIDogJyc7XG5cbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIC8vIGlwdjYgYWRkcmVzc1xuICAgIHJlc3VsdCArPSAnWycgKyB1cmwuaG9zdG5hbWUgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZSB8fCAnJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwucG9ydCA/ICc6JyArIHVybC5wb3J0IDogJyc7XG4gIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLmhhc2ggfHwgJyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWR1cmwvZm9ybWF0LmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIENoYW5nZXMgZnJvbSBqb3llbnQvbm9kZTpcbi8vXG4vLyAxLiBObyBsZWFkaW5nIHNsYXNoIGluIHBhdGhzLFxuLy8gICAgZS5nLiBpbiBgdXJsLnBhcnNlKCdodHRwOi8vZm9vP2JhcicpYCBwYXRobmFtZSBpcyBgYCwgbm90IGAvYFxuLy9cbi8vIDIuIEJhY2tzbGFzaGVzIGFyZSBub3QgcmVwbGFjZWQgd2l0aCBzbGFzaGVzLFxuLy8gICAgc28gYGh0dHA6XFxcXGV4YW1wbGUub3JnXFxgIGlzIHRyZWF0ZWQgbGlrZSBhIHJlbGF0aXZlIHBhdGhcbi8vXG4vLyAzLiBUcmFpbGluZyBjb2xvbiBpcyB0cmVhdGVkIGxpa2UgYSBwYXJ0IG9mIHRoZSBwYXRoLFxuLy8gICAgaS5lLiBpbiBgaHR0cDovL2V4YW1wbGUub3JnOmZvb2AgcGF0aG5hbWUgaXMgYDpmb29gXG4vL1xuLy8gNC4gTm90aGluZyBpcyBVUkwtZW5jb2RlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCxcbi8vICAgIChpbiBqb3llbnQvbm9kZSBzb21lIGNoYXJzIGluIGF1dGggYW5kIHBhdGhzIGFyZSBlbmNvZGVkKVxuLy9cbi8vIDUuIGB1cmwucGFyc2UoKWAgZG9lcyBub3QgaGF2ZSBgcGFyc2VRdWVyeVN0cmluZ2AgYXJndW1lbnRcbi8vXG4vLyA2LiBSZW1vdmVkIGV4dHJhbmVvdXMgcmVzdWx0IHByb3BlcnRpZXM6IGBob3N0YCwgYHBhdGhgLCBgcXVlcnlgLCBldGMuLFxuLy8gICAgd2hpY2ggY2FuIGJlIGNvbnN0cnVjdGVkIHVzaW5nIG90aGVyIHBhcnRzIG9mIHRoZSB1cmwuXG4vL1xuXG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbICc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0JyBdLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbICd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCcgXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWyAnXFwnJyBdLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyAnJScsICcvJywgJz8nLCAnOycsICcjJyBdLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbICcvJywgJz8nLCAnIycgXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNjcmlwdC11cmwgKi9cbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1zY3JpcHQtdXJsICovXG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIHZhciB1ID0gbmV3IFVybCgpO1xuICB1LnBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgdmFyIGksIGwsIGxvd2VyUHJvdG8sIGhlYywgc2xhc2hlcyxcbiAgICAgIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHJlc3RbaG9zdEVuZCAtIDFdID09PSAnOicpIHsgaG9zdEVuZC0tOyB9XG4gICAgdmFyIGhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdChob3N0KTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfVxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKGhvc3QpIHtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXJsUGFyc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWR1cmwvcGFyc2UuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQW55ID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzL0FueS9yZWdleCcpO1xuZXhwb3J0cy5DYyAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKTtcbmV4cG9ydHMuQ2YgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NmL3JlZ2V4Jyk7XG5leHBvcnRzLlAgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5leHBvcnRzLlogICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9aL3JlZ2V4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MDhFMlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0XFx1RENCRHxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCIvLyBKdXN0IGEgc2hvcnRjdXQgZm9yIGJ1bGsgZXhwb3J0XG4ndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xuZXhwb3J0cy5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xuZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua190aXRsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwiLy8gUGFyc2UgbGluayBsYWJlbFxuLy9cbi8vIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGZpcnN0IGNoYXJhY3RlciAoXCJbXCIpIGFscmVhZHkgbWF0Y2hlcztcbi8vIHJldHVybnMgdGhlIGVuZCBvZiB0aGUgbGFiZWxcbi8vXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0LCBkaXNhYmxlTmVzdGVkKSB7XG4gIHZhciBsZXZlbCwgZm91bmQsIG1hcmtlciwgcHJldlBvcyxcbiAgICAgIGxhYmVsRW5kID0gLTEsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3M7XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuICBsZXZlbCA9IDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldlBvcyA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcbiAgICBpZiAobWFya2VyID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIGlmIChwcmV2UG9zID09PSBzdGF0ZS5wb3MgLSAxKSB7XG4gICAgICAgIC8vIGluY3JlYXNlIGxldmVsIGlmIHdlIGZpbmQgdGV4dCBgW2AsIHdoaWNoIGlzIG5vdCBhIHBhcnQgb2YgYW55IHRva2VuXG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKGRpc2FibGVOZXN0ZWQpIHtcbiAgICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3M7XG4gIH1cblxuICAvLyByZXN0b3JlIG9sZCBzdGF0ZVxuICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG5cbiAgcmV0dXJuIGxhYmVsRW5kO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwiLy8gUGFyc2UgbGluayBkZXN0aW5hdGlvblxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNTcGFjZSAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLCBsZXZlbCxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4M0MgLyogPCAqLykge1xuICAgIHBvcysrO1xuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovIHx8IGlzU3BhY2UoY29kZSkpIHsgcmV0dXJuIHJlc3VsdDsgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4M0UgLyogPiAqLykge1xuICAgICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIC8vIG5vIGNsb3NpbmcgJz4nXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIHRoaXMgc2hvdWxkIGJlIC4uLiB9IGVsc2UgeyAuLi4gYnJhbmNoXG5cbiAgbGV2ZWwgPSAwO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyMCkgeyBicmVhazsgfVxuXG4gICAgLy8gYXNjaWkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAweDIwIHx8IGNvZGUgPT09IDB4N0YpIHsgYnJlYWs7IH1cblxuICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICAgIGlmIChsZXZlbCA+IDEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBwb3MpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgcmVzdWx0LnBvcyA9IHBvcztcbiAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIi8vIFBhcnNlIGxpbmsgdGl0bGVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLFxuICAgICAgbWFya2VyLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgbWFya2VyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDIyIC8qIFwiICovICYmIG1hcmtlciAhPT0gMHgyNyAvKiAnICovICYmIG1hcmtlciAhPT0gMHgyOCAvKiAoICovKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBwb3MrKztcblxuICAvLyBpZiBvcGVuaW5nIG1hcmtlciBpcyBcIihcIiwgc3dpdGNoIGl0IHRvIGNsb3NpbmcgbWFya2VyIFwiKVwiXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwiLyoqXG4gKiBjbGFzcyBSZW5kZXJlclxuICpcbiAqIEdlbmVyYXRlcyBIVE1MIGZyb20gcGFyc2VkIHRva2VuIHN0cmVhbS4gRWFjaCBpbnN0YW5jZSBoYXMgaW5kZXBlbmRlbnRcbiAqIGNvcHkgb2YgcnVsZXMuIFRob3NlIGNhbiBiZSByZXdyaXR0ZW4gd2l0aCBlYXNlLiBBbHNvLCB5b3UgY2FuIGFkZCBuZXdcbiAqIHJ1bGVzIGlmIHlvdSBjcmVhdGUgcGx1Z2luIGFuZCBhZGRzIG5ldyB0b2tlbiB0eXBlcy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXNzaWduICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5hc3NpZ247XG52YXIgdW5lc2NhcGVBbGwgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcbnZhciBlc2NhcGVIdG1sICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmVzY2FwZUh0bWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmF1bHRfcnVsZXMgPSB7fTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPHByZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz48Y29kZT4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuZmVuY2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdLFxuICAgICAgaW5mbyA9IHRva2VuLmluZm8gPyB1bmVzY2FwZUFsbCh0b2tlbi5pbmZvKS50cmltKCkgOiAnJyxcbiAgICAgIGxhbmdOYW1lID0gJycsXG4gICAgICBoaWdobGlnaHRlZCwgaSwgdG1wQXR0cnMsIHRtcFRva2VuO1xuXG4gIGlmIChpbmZvKSB7XG4gICAgbGFuZ05hbWUgPSBpbmZvLnNwbGl0KC9cXHMrL2cpWzBdO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi5jb250ZW50LCBsYW5nTmFtZSkgfHwgZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH1cblxuICBpZiAoaGlnaGxpZ2h0ZWQuaW5kZXhPZignPHByZScpID09PSAwKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkICsgJ1xcbic7XG4gIH1cblxuICAvLyBJZiBsYW5ndWFnZSBleGlzdHMsIGluamVjdCBjbGFzcyBnZW50bHksIHdpdGhvdXQgbW9kaWZ5aW5nIG9yaWdpbmFsIHRva2VuLlxuICAvLyBNYXkgYmUsIG9uZSBkYXkgd2Ugd2lsbCBhZGQgLmNsb25lKCkgZm9yIHRva2VuIGFuZCBzaW1wbGlmeSB0aGlzIHBhcnQsIGJ1dFxuICAvLyBub3cgd2UgcHJlZmVyIHRvIGtlZXAgdGhpbmdzIGxvY2FsLlxuICBpZiAoaW5mbykge1xuICAgIGkgICAgICAgID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpO1xuICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRtcEF0dHJzLnB1c2goWyAnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZSBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgfVxuXG4gICAgLy8gRmFrZSB0b2tlbiBqdXN0IHRvIHJlbmRlciBhdHRyaWJ1dGVzXG4gICAgdG1wVG9rZW4gPSB7XG4gICAgICBhdHRyczogdG1wQXR0cnNcbiAgICB9O1xuXG4gICAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG1wVG9rZW4pICsgJz4nXG4gICAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cblxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPidcbiAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gXCJhbHRcIiBhdHRyIE1VU1QgYmUgc2V0LCBldmVuIGlmIGVtcHR5LiBCZWNhdXNlIGl0J3MgbWFuZGF0b3J5IGFuZFxuICAvLyBzaG91bGQgYmUgcGxhY2VkIG9uIHByb3BlciBwb3NpdGlvbiBmb3IgdGVzdHMuXG4gIC8vXG4gIC8vIFJlcGxhY2UgY29udGVudCB3aXRoIGFjdHVhbCB2YWx1ZVxuXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cbiAgICBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuXG4gIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XG59O1xuZGVmYXVsdF9ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcblxuXG4vKipcbiAqIG5ldyBSZW5kZXJlcigpXG4gKlxuICogQ3JlYXRlcyBuZXcgW1tSZW5kZXJlcl1dIGluc3RhbmNlIGFuZCBmaWxsIFtbUmVuZGVyZXIjcnVsZXNdXSB3aXRoIGRlZmF1bHRzLlxuICoqL1xuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcmVyI3J1bGVzIC0+IE9iamVjdFxuICAgKlxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfb3BlbiAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPGI+JzsgfTtcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzwvYj4nOyB9O1xuICAgKlxuICAgKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKC4uLik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFYWNoIHJ1bGUgaXMgY2FsbGVkIGFzIGluZGVwZW5kZWQgc3RhdGljIGZ1bmN0aW9uIHdpdGggZml4ZWQgc2lnbmF0dXJlOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGZ1bmN0aW9uIG15X3Rva2VuX3JlbmRlcih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCByZW5kZXJlcikge1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIHJldHVybiByZW5kZXJlZEhUTUw7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpO1xufVxuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xuICpcbiAqIFJlbmRlciB0b2tlbiBhdHRyaWJ1dGVzIHRvIHN0cmluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJBdHRycyA9IGZ1bmN0aW9uIHJlbmRlckF0dHJzKHRva2VuKSB7XG4gIHZhciBpLCBsLCByZXN1bHQ7XG5cbiAgaWYgKCF0b2tlbi5hdHRycykgeyByZXR1cm4gJyc7IH1cblxuICByZXN1bHQgPSAnJztcblxuICBmb3IgKGkgPSAwLCBsID0gdG9rZW4uYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb2YgdG9rZW5zXG4gKiAtIGlkeCAoTnVtYmVkKTogdG9rZW4gaW5kZXggdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiBEZWZhdWx0IHRva2VuIHJlbmRlcmVyLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBmdW5jdGlvblxuICogaW4gW1tSZW5kZXJlciNydWxlc11dLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRva2VuID0gZnVuY3Rpb24gcmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgdmFyIG5leHRUb2tlbixcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbmVlZExmID0gZmFsc2UsXG4gICAgICB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFRpZ2h0IGxpc3QgcGFyYWdyYXBoc1xuICBpZiAodG9rZW4uaGlkZGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xuICAvLyBibG9jay1sZXZlbCB0YWcuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxuICAvLyAgLSBhXG4gIC8vICAgID5cbiAgLy9cbiAgaWYgKHRva2VuLmJsb2NrICYmIHRva2VuLm5lc3RpbmcgIT09IC0xICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0uaGlkZGVuKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgLy8gQWRkIHRva2VuIG5hbWUsIGUuZy4gYDxpbWdgXG4gIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyAnPC8nIDogJzwnKSArIHRva2VuLnRhZztcblxuICAvLyBFbmNvZGUgYXR0cmlidXRlcywgZS5nLiBgPGltZyBzcmM9XCJmb29cImBcbiAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xuXG4gIC8vIEFkZCBhIHNsYXNoIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZS5nLiBgPGltZyBzcmM9XCJmb29cIiAvYFxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgcmVzdWx0ICs9ICcgLyc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBhIG5ld2xpbmUgYWZ0ZXIgdGhpcyB0YWdcbiAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgbmVlZExmID0gdHJ1ZTtcblxuICAgIGlmICh0b2tlbi5uZXN0aW5nID09PSAxKSB7XG4gICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5zW2lkeCArIDFdO1xuXG4gICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJ2lubGluZScgfHwgbmV4dFRva2VuLmhpZGRlbikge1xuICAgICAgICAgIC8vIEJsb2NrLWxldmVsIHRhZyBjb250YWluaW5nIGFuIGlubGluZSB0YWcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi5uZXN0aW5nID09PSAtMSAmJiBuZXh0VG9rZW4udGFnID09PSB0b2tlbi50YWcpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIHRhZyArIGNsb3NpbmcgdGFnIG9mIHRoZSBzYW1lIHR5cGUuIEUuZy4gYDxsaT48L2xpPmAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCArPSBuZWVkTGYgPyAnPlxcbicgOiAnPic7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmUodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRoZSBzYW1lIGFzIFtbUmVuZGVyZXIucmVuZGVyXV0sIGJ1dCBmb3Igc2luZ2xlIHRva2VuIG9mIGBpbmxpbmVgIHR5cGUuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogUmVuZGVyZXIucmVuZGVySW5saW5lQXNUZXh0KHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBTcGVjaWFsIGtsdWRnZSBmb3IgaW1hZ2UgYGFsdGAgYXR0cmlidXRlcyB0byBjb25mb3JtIENvbW1vbk1hcmsgc3BlYy5cbiAqIERvbid0IHRyeSB0byB1c2UgaXQhIFNwZWMgcmVxdWlyZXMgdG8gc2hvdyBgYWx0YCBjb250ZW50IHdpdGggc3RyaXBwZWQgbWFya3VwLFxuICogaW5zdGVhZCBvZiBzaW1wbGUgZXNjYXBpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBDb3JlXG4gKlxuICogVG9wLWxldmVsIHJ1bGVzIGV4ZWN1dG9yLiBHbHVlcyBibG9jay9pbmxpbmUgcGFyc2VycyBhbmQgZG9lcyBpbnRlcm1lZGlhdGVcbiAqIHRyYW5zZm9ybWF0aW9ucy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ25vcm1hbGl6ZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL25vcm1hbGl6ZScpICAgICAgXSxcbiAgWyAnYmxvY2snLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYmxvY2snKSAgICAgICAgICBdLFxuICBbICdpbmxpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9pbmxpbmUnKSAgICAgICAgIF0sXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXSxcbiAgWyAncmVwbGFjZW1lbnRzJywgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzJykgICBdLFxuICBbICdzbWFydHF1b3RlcycsICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zbWFydHF1b3RlcycpICAgIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgQ29yZSgpXG4gKiovXG5mdW5jdGlvbiBDb3JlKCkge1xuICAvKipcbiAgICogQ29yZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBjb3JlIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcbiAqXG4gKiBFeGVjdXRlcyBjb3JlIGNoYWluIHJ1bGVzLlxuICoqL1xuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgaSwgbCwgcnVsZXM7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcblxuICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5Db3JlLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zdGF0ZV9jb3JlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIi8vIE5vcm1hbGl6ZSBpbnB1dCBzdHJpbmdcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBORVdMSU5FU19SRSAgPSAvXFxyW1xcblxcdTAwODVdP3xbXFx1MjQyNFxcdTIwMjhcXHUwMDg1XS9nO1xudmFyIE5VTExfUkUgICAgICA9IC9cXHUwMDAwL2c7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHN0cjtcblxuICAvLyBOb3JtYWxpemUgbmV3bGluZXNcbiAgc3RyID0gc3RhdGUuc3JjLnJlcGxhY2UoTkVXTElORVNfUkUsICdcXG4nKTtcblxuICAvLyBSZXBsYWNlIE5VTEwgY2hhcmFjdGVyc1xuICBzdHIgPSBzdHIucmVwbGFjZShOVUxMX1JFLCAnXFx1RkZGRCcpO1xuXG4gIHN0YXRlLnNyYyA9IHN0cjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCIvLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXG4vL1xuLy8gQ3VycmVudGx5IHJlc3RyaWN0ZWQgYnkgYG1kLnZhbGlkYXRlTGluaygpYCB0byBodHRwL2h0dHBzL2Z0cFxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXJyYXlSZXBsYWNlQXQgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5hcnJheVJlcGxhY2VBdDtcblxuXG5mdW5jdGlvbiBpc0xpbmtPcGVuKHN0cikge1xuICByZXR1cm4gL148YVs+XFxzXS9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzTGlua0Nsb3NlKHN0cikge1xuICByZXR1cm4gL148XFwvYVxccyo+L2kudGVzdChzdHIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua2lmeShzdGF0ZSkge1xuICB2YXIgaSwgaiwgbCwgdG9rZW5zLCB0b2tlbiwgY3VycmVudFRva2VuLCBub2RlcywgbG4sIHRleHQsIHBvcywgbGFzdFBvcyxcbiAgICAgIGxldmVsLCBodG1sTGlua0xldmVsLCB1cmwsIGZ1bGxVcmwsIHVybFRleHQsXG4gICAgICBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIGxpbmtzO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybjsgfVxuXG4gIGZvciAoaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIXN0YXRlLm1kLmxpbmtpZnkucHJldGVzdChibG9ja1Rva2Vuc1tqXS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdG9rZW5zID0gYmxvY2tUb2tlbnNbal0uY2hpbGRyZW47XG5cbiAgICBodG1sTGlua0xldmVsID0gMDtcblxuICAgIC8vIFdlIHNjYW4gZnJvbSB0aGUgZW5kLCB0byBrZWVwIHBvc2l0aW9uIHdoZW4gbmV3IHRhZ3MgYWRkZWQuXG4gICAgLy8gVXNlIHJldmVyc2VkIGxvZ2ljIGluIGxpbmtzIHN0YXJ0L2VuZCBtYXRjaFxuICAgIGZvciAoaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgbWFya2Rvd24gbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgd2hpbGUgKHRva2Vuc1tpXS5sZXZlbCAhPT0gY3VycmVudFRva2VuLmxldmVsICYmIHRva2Vuc1tpXS50eXBlICE9PSAnbGlua19vcGVuJykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIGh0bWwgdGFnIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdodG1sX2lubGluZScpIHtcbiAgICAgICAgaWYgKGlzTGlua09wZW4oY3VycmVudFRva2VuLmNvbnRlbnQpICYmIGh0bWxMaW5rTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbmtDbG9zZShjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBzdGF0ZS5tZC5saW5raWZ5LnRlc3QoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG5cbiAgICAgICAgdGV4dCA9IGN1cnJlbnRUb2tlbi5jb250ZW50O1xuICAgICAgICBsaW5rcyA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2godGV4dCk7XG5cbiAgICAgICAgLy8gTm93IHNwbGl0IHN0cmluZyB0byBub2Rlc1xuICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICBsZXZlbCA9IGN1cnJlbnRUb2tlbi5sZXZlbDtcbiAgICAgICAgbGFzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsbiA9IDA7IGxuIDwgbGlua3MubGVuZ3RoOyBsbisrKSB7XG5cbiAgICAgICAgICB1cmwgPSBsaW5rc1tsbl0udXJsO1xuICAgICAgICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIHVybFRleHQgPSBsaW5rc1tsbl0udGV4dDtcblxuICAgICAgICAgIC8vIExpbmtpZmllciBtaWdodCBzZW5kIHJhdyBob3N0bmFtZXMgbGlrZSBcImV4YW1wbGUuY29tXCIsIHdoZXJlIHVybFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIGRvbWFpbiBuYW1lLiBTbyB3ZSBwcmVwZW5kIGh0dHA6Ly8gaW4gdGhvc2UgY2FzZXMsXG4gICAgICAgICAgLy8gYW5kIHJlbW92ZSBpdCBhZnRlcndhcmRzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKCFsaW5rc1tsbl0uc2NoZW1hKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ2h0dHA6Ly8nICsgdXJsVGV4dCkucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgJycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlua3NbbG5dLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KHVybFRleHQpKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ21haWx0bzonICsgdXJsVGV4dCkucmVwbGFjZSgvXm1haWx0bzovLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmxUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3MgPSBsaW5rc1tsbl0uaW5kZXg7XG5cbiAgICAgICAgICBpZiAocG9zID4gbGFzdFBvcykge1xuICAgICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MsIHBvcyk7XG4gICAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWwrKztcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB1cmxUZXh0O1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gLS1sZXZlbDtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICBsYXN0UG9zID0gbGlua3NbbG5dLmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvcyA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIGN1cnJlbnQgbm9kZVxuICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IGFycmF5UmVwbGFjZUF0KHRva2VucywgaSwgbm9kZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwiLy8gU2ltcGxlIHR5cG9ncmFwaHljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy0vZywgJ8KxJylcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLnsyLH0vZywgJ+KApicpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCAnJDEuLicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLV0pLS0tKFteLV18JCkvbWcsICckMVxcdTIwMTQkMicpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLShcXHN8JCkvbWcsICckMVxcdTIwMTMkMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKFteLVxcc118JCkvbWcsICckMVxcdTIwMTMkMicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIGlmIChTQ09QRURfQUJCUl9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2Vfc2NvcGVkKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoUkFSRV9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3JhcmUoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcyIsIi8vIENvbnZlcnQgc3RyYWlnaHQgcXVvdGF0aW9uIG1hcmtzIHRvIHR5cG9ncmFwaGljIG9uZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxudmFyIFFVT1RFX1RFU1RfUkUgPSAvWydcIl0vO1xudmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XG52YXIgQVBPU1RST1BIRSA9ICdcXHUyMDE5JzsgLyog4oCZICovXG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KHN0ciwgaW5kZXgsIGNoKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2lubGluZXModG9rZW5zLCBzdGF0ZSkge1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGl0ZW0sIGxhc3RDaGFyLCBuZXh0Q2hhcixcbiAgICAgIGlzTGFzdFB1bmN0Q2hhciwgaXNOZXh0UHVuY3RDaGFyLCBpc0xhc3RXaGl0ZVNwYWNlLCBpc05leHRXaGl0ZVNwYWNlLFxuICAgICAgY2FuT3BlbiwgY2FuQ2xvc2UsIGosIGlzU2luZ2xlLCBzdGFjaywgb3BlblF1b3RlLCBjbG9zZVF1b3RlO1xuXG4gIHN0YWNrID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuXG4gICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gaiArIDE7XG5cbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICBwb3MgPSAwO1xuICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgLyplc2xpbnQgbm8tbGFiZWxzOjAsYmxvY2stc2NvcGVkLXZhcjowKi9cbiAgICBPVVRFUjpcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0KTtcbiAgICAgIGlmICghdCkgeyBicmVhazsgfVxuXG4gICAgICBjYW5PcGVuID0gY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XG5cbiAgICAgIC8vIEZpbmQgcHJldmlvdXMgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBsYXN0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmICh0LmluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgIGxhc3RDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHQuaW5kZXggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBsYXN0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQodG9rZW5zW2pdLmNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbmV4dENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG5leHRDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdHJlYXQgdGhpcyBhcyB0aGUgbWlkZGxlIG9mIHRoZSB3b3JkXG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgY2FuQ2xvc2UgPSBpc05leHRQdW5jdENoYXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuT3BlbiAmJiAhY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gbWlkZGxlIG9mIHdvcmRcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjbG9zaW5nIHF1b3RlLCByZXdpbmQgdGhlIHN0YWNrIHRvIGdldCBhIG1hdGNoXG4gICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgICAgICAgIGlmIChpdGVtLnNpbmdsZSA9PT0gaXNTaW5nbGUgJiYgc3RhY2tbal0ubGV2ZWwgPT09IHRoaXNMZXZlbCkge1xuICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMl07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1szXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdG9rZW4uY29udGVudCAqYmVmb3JlKiB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UsIGlmIHRoZXkgYXJlIHBvaW50aW5nIGF0IHRoZSBzYW1lIHRva2VuLCByZXBsYWNlQXRcbiAgICAgICAgICAgIC8vIGNvdWxkIG1lc3MgdXAgaW5kaWNlcyB3aGVuIHF1b3RlIGxlbmd0aCAhPSAxXG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIGNsb3NlUXVvdGUpO1xuICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQoXG4gICAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LCBpdGVtLnBvcywgb3BlblF1b3RlKTtcblxuICAgICAgICAgICAgcG9zICs9IGNsb3NlUXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChpdGVtLnRva2VuID09PSBpKSB7IHBvcyArPSBvcGVuUXVvdGUubGVuZ3RoIC0gMTsgfVxuXG4gICAgICAgICAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICAgICAgICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBqO1xuICAgICAgICAgICAgY29udGludWUgT1VURVI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuKSB7XG4gICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgIHRva2VuOiBpLFxuICAgICAgICAgIHBvczogdC5pbmRleCxcbiAgICAgICAgICBzaW5nbGU6IGlzU2luZ2xlLFxuICAgICAgICAgIGxldmVsOiB0aGlzTGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbkNsb3NlICYmIGlzU2luZ2xlKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzbWFydHF1b3RlcyhzdGF0ZSkge1xuICAvKmVzbGludCBtYXgtZGVwdGg6MCovXG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFRVU9URV9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb2Nlc3NfaW5saW5lcyhzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbiwgc3RhdGUpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwiLy8gQ29yZSBzdGF0ZSBvYmplY3Rcbi8vXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG5cblxuZnVuY3Rpb24gU3RhdGVDb3JlKHNyYywgbWQsIGVudikge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMuaW5saW5lTW9kZSA9IGZhbHNlO1xuICB0aGlzLm1kID0gbWQ7IC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG59XG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gY29yZSBydWxlc1xuU3RhdGVDb3JlLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVDb3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlckJsb2NrXG4gKlxuICogQmxvY2stbGV2ZWwgdG9rZW5pemVyLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgLy8gRmlyc3QgMiBwYXJhbXMgLSBydWxlIG5hbWUgJiBzb3VyY2UuIFNlY29uZGFyeSBhcnJheSAtIGxpc3Qgb2YgcnVsZXMsXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnIF0gXSxcbiAgWyAnY29kZScsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svY29kZScpIF0sXG4gIFsgJ2ZlbmNlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnYmxvY2txdW90ZScsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svYmxvY2txdW90ZScpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdocicsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ocicpLCAgICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2xpc3QnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xpc3QnKSwgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3JlZmVyZW5jZScsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZScpIF0sXG4gIFsgJ2hlYWRpbmcnLCAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hlYWRpbmcnKSwgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ2xoZWFkaW5nJywgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncGFyYWdyYXBoJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcGFyYWdyYXBoJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJCbG9jaygpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgLyoqXG4gICAqIFBhcnNlckJsb2NrI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gIH1cbn1cblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGxpbmUgPSBzdGFydExpbmUsXG4gICAgICBoYXNFbXB0eUxpbmVzID0gZmFsc2UsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXG4gICAgLy8gTmVzdGVkIGNhbGxzIGN1cnJlbnRseSB1c2VkIGZvciBibG9ja3F1b3RlcyAmIGxpc3RzXG4gICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gSWYgbmVzdGluZyBsZXZlbCBleGNlZWRlZCAtIHNraXAgdGFpbCB0byB0aGUgZW5kLiBUaGF0J3Mgbm90IG9yZGluYXJ5XG4gICAgLy8gc2l0dWF0aW9uIGFuZCB3ZSBzaG91bGQgbm90IGNhcmUgYWJvdXQgY29udGVudC5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPj0gbWF4TmVzdGluZykge1xuICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLmxpbmVgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGxpbmUsIGVuZExpbmUsIGZhbHNlKTtcbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZS50aWdodCBpZiB3ZSBoYWQgYW4gZW1wdHkgbGluZSBiZWZvcmUgY3VycmVudCB0YWdcbiAgICAvLyBpLmUuIGxhdGVzdCBlbXB0eSBsaW5lIHNob3VsZCBub3QgY291bnRcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsaW5lID0gc3RhdGUubGluZTtcblxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICAgIGxpbmUrKztcbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlckJsb2NrLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGJsb2NrIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJCbG9jay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3JjKSB7IHJldHVybjsgfVxuXG4gIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xufTtcblxuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzIiwiLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gZ2V0TGluZShzdGF0ZSwgbGluZSkge1xuICB2YXIgcG9zID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuYmxrSW5kZW50LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xuXG4gIHJldHVybiBzdGF0ZS5zcmMuc3Vic3RyKHBvcywgbWF4IC0gcG9zKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZFNwbGl0KHN0cikge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBwb3MgPSAwLFxuICAgICAgbWF4ID0gc3RyLmxlbmd0aCxcbiAgICAgIGNoLFxuICAgICAgZXNjYXBlcyA9IDAsXG4gICAgICBsYXN0UG9zID0gMCxcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZSxcbiAgICAgIGxhc3RCYWNrVGljayA9IDA7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDYwLyogYCAqLykge1xuICAgICAgaWYgKGJhY2tUaWNrZWQpIHtcbiAgICAgICAgLy8gbWFrZSBcXGAgY2xvc2UgY29kZSBzZXF1ZW5jZSwgYnV0IG5vdCBvcGVuIGl0O1xuICAgICAgICAvLyB0aGUgcmVhc29uIGlzOiBgXFxgIGlzIGNvcnJlY3QgY29kZSBibG9ja1xuICAgICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlcyAlIDIgPT09IDApIHtcbiAgICAgICAgYmFja1RpY2tlZCA9IHRydWU7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDdjLyogfCAqLyAmJiAoZXNjYXBlcyAlIDIgPT09IDApICYmICFiYWNrVGlja2VkKSB7XG4gICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDVjLyogXFwgKi8pIHtcbiAgICAgIGVzY2FwZXMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlcyA9IDA7XG4gICAgfVxuXG4gICAgcG9zKys7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gdW4tY2xvc2VkIGJhY2t0aWNrLCBnbyBiYWNrIHRvIGp1c3QgYWZ0ZXJcbiAgICAvLyB0aGUgbGFzdCBiYWNrdGljaywgYnV0IGFzIGlmIGl0IHdhcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAgICBpZiAocG9zID09PSBtYXggJiYgYmFja1RpY2tlZCkge1xuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgcG9zID0gbGFzdEJhY2tUaWNrICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MpKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGFibGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbmV4dExpbmUsIGNvbHVtbnMsIGNvbHVtbkNvdW50LCB0b2tlbixcbiAgICAgIGFsaWducywgdCwgdGFibGVMaW5lcywgdGJvZHlMaW5lcztcblxuICAvLyBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0d28gbGluZXNcbiAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2Vjb25kIGxpbmUgc2hvdWxkIGJlICd8JywgJy0nLCAnOicsXG4gIC8vIGFuZCBubyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkIGJ1dCBzcGFjZXM7XG4gIC8vIGJhc2ljYWxseSwgdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvXlstOnxdWy06fFxcc10qJC8gcmVnZXhwXG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUgKyAxKTtcblxuICBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoJ3wnKTtcbiAgYWxpZ25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIGlmICghdCkge1xuICAgICAgLy8gYWxsb3cgZW1wdHkgY29sdW1ucyBiZWZvcmUgYW5kIGFmdGVyIHRhYmxlLCBidXQgbm90IGluIGJldHdlZW4gY29sdW1ucztcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eOj8tKzo/JC8udGVzdCh0KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovID8gJ2NlbnRlcicgOiAncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWducy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgLy8gaGVhZGVyIHJvdyB3aWxsIGRlZmluZSBhbiBhbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZW50aXJlIHRhYmxlLFxuICAvLyBhbmQgYWxpZ24gcm93IHNob3VsZG4ndCBiZSBzbWFsbGVyIHRoYW4gdGhhdCAodGhlIHJlc3Qgb2YgdGhlIHJvd3MgY2FuKVxuICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPiBhbGlnbnMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0YWJsZV9vcGVuJywgJ3RhYmxlJywgMSk7XG4gIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX29wZW4nLCAndGhlYWQnLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX29wZW4nLCAndGgnLCAxKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgIH1cblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFsgc3RhcnRMaW5lICsgMiwgMCBdO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IGJyZWFrOyB9XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyBicmVhazsgfVxuICAgIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3Rib2R5X2Nsb3NlJywgJ3Rib2R5JywgLTEpO1xuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuXG4gIHRhYmxlTGluZXNbMV0gPSB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3Q7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfYmxvY2snLCAnY29kZScsIDApO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBpZiAocGFyYW1zLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKSA+PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbmNlIHN0YXJ0IGlzIGZvdW5kLCB3ZSBjYW4gcmVwb3J0IHN1Y2Nlc3MgaGVyZSBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNlYXJjaCBlbmQgb2YgYmxvY2tcbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG5cbiAgZm9yICg7Oykge1xuICAgIG5leHRMaW5lKys7XG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgIC8vIHVuY2xvc2VkIGJsb2NrIHNob3VsZCBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBkb2N1bWVudC5cbiAgICAgIC8vIGFsc28gYmxvY2sgc2VlbXMgdG8gYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgcGFyZW50XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgPSBtZW0gPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAvLyBub24tZW1wdHkgbGluZSB3aXRoIG5lZ2F0aXZlIGluZGVudCBzaG91bGQgc3RvcCB0aGUgbGlzdDpcbiAgICAgIC8vIC0gYGBgXG4gICAgICAvLyAgdGVzdFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IG1hcmtlcikgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgLy8gY2xvc2luZyBmZW5jZSBzaG91bGQgYmUgaW5kZW50ZWQgbGVzcyB0aGFuIDQgc3BhY2VzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gICAgLy8gY2xvc2luZyBjb2RlIGZlbmNlIG11c3QgYmUgYXQgbGVhc3QgYXMgbG9uZyBhcyB0aGUgb3BlbmluZyBvbmVcbiAgICBpZiAocG9zIC0gbWVtIDwgbGVuKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGFpbCBoYXMgc3BhY2VzIG9ubHlcbiAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICBpZiAocG9zIDwgbWF4KSB7IGNvbnRpbnVlOyB9XG5cbiAgICBoYXZlRW5kTWFya2VyID0gdHJ1ZTtcbiAgICAvLyBmb3VuZCFcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIElmIGEgZmVuY2UgaGFzIGhlYWRpbmcgc3BhY2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGZyb20gaXRzIGlubmVyIGJsb2NrXG4gIGxlbiA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIChoYXZlRW5kTWFya2VyID8gMSA6IDApO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdmZW5jZScsICdjb2RlJywgMCk7XG4gIHRva2VuLmluZm8gICAgPSBwYXJhbXM7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUgKyAxLCBuZXh0TGluZSwgbGVuLCB0cnVlKTtcbiAgdG9rZW4ubWFya3VwICA9IG1hcmt1cDtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgbCxcbiAgICAgIGxhc3RMaW5lRW1wdHksXG4gICAgICBsaW5lcyxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkQk1hcmtzLFxuICAgICAgb2xkQlNDb3VudCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRTQ291bnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBzcGFjZUFmdGVyTWFya2VyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICB3YXNPdXRkZW50ZWQsXG4gICAgICBvbGRMaW5lTWF4ID0gc3RhdGUubGluZU1heCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjaGVjayB0aGUgYmxvY2sgcXVvdGUgbWFya2VyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgIT09IDB4M0UvKiA+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHdlIGtub3cgdGhhdCBpdCdzIGdvaW5nIHRvIGJlIGEgdmFsaWQgYmxvY2txdW90ZSxcbiAgLy8gc28gbm8gcG9pbnQgdHJ5aW5nIHRvIGZpbmQgdGhlIGVuZCBvZiBpdCBpbiBzaWxlbnQgbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICBwb3MrKztcbiAgICBpbml0aWFsKys7XG4gICAgb2Zmc2V0Kys7XG4gICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgcG9zKys7XG4gICAgICBpbml0aWFsKys7XG4gICAgICBvZmZzZXQrKztcbiAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gIH1cblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBvbGRCU0NvdW50ID0gWyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgb2xkU0NvdW50ID0gWyBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgb2xkVFNoaWZ0ID0gWyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG4gIHdhc091dGRlbnRlZCA9IGZhbHNlO1xuXG4gIC8vIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBibG9ja1xuICAvL1xuICAvLyBCbG9jayBlbmRzIHdpdGggZWl0aGVyOlxuICAvLyAgMS4gYW4gZW1wdHkgbGluZSBvdXRzaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy9cbiAgLy8gICAgIGBgYFxuICAvLyAgMi4gYW4gZW1wdHkgbGluZSBpbnNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID5cbiAgLy8gICAgIHRlc3RcbiAgLy8gICAgIGBgYFxuICAvLyAgMy4gYW5vdGhlciB0YWc6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHdhc091dGRlbnRlZCA9IHRydWU7XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIXdhc091dGRlbnRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrKztcbiAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBDYXNlIDM6IGFub3RoZXIgdGFnIGZvdW5kLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgLy8gUXVpcmsgdG8gZW5mb3JjZSBcImhhcmQgdGVybWluYXRpb24gbW9kZVwiIGZvciBwYXJhZ3JhcGhzO1xuICAgICAgLy8gbm9ybWFsbHkgaWYgeW91IGNhbGwgYHRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKWAsXG4gICAgICAvLyBwYXJhZ3JhcGhzIHdpbGwgbG9vayBiZWxvdyBuZXh0TGluZSBmb3IgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbixcbiAgICAgIC8vIGJ1dCBpZiBibG9ja3F1b3RlIGlzIHRlcm1pbmF0ZWQgYnkgYW5vdGhlciB0YWcsIHRoZXkgc2hvdWxkbid0XG4gICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuXG4gICAgLy8gQSBuZWdhdGl2ZSBpbmRlbnRhdGlvbiBtZWFucyB0aGF0IHRoaXMgaXMgYSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgLy9cbiAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gLTE7XG4gIH1cblxuICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gIHN0YXRlLmJsa0luZGVudCA9IDA7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9vcGVuJywgJ2Jsb2NrcXVvdGUnLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuICB0b2tlbi5tYXAgICAgPSBsaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfY2xvc2UnLCAnYmxvY2txdW90ZScsIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuXG4gIHN0YXRlLmxpbmVNYXggPSBvbGRMaW5lTWF4O1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgbGluZXNbMV0gPSBzdGF0ZS5saW5lO1xuXG4gIC8vIFJlc3RvcmUgb3JpZ2luYWwgdFNoaWZ0OyB0aGlzIG1pZ2h0IG5vdCBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIHBhcnNlclxuICAvLyBoYXMgYWxyZWFkeSBiZWVuIGhlcmUsIGJ1dCBqdXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gZG8gdGhhdC5cbiAgZm9yIChpID0gMDsgaSA8IG9sZFRTaGlmdC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcbiAgICBzdGF0ZS50U2hpZnRbaSArIHN0YXJ0TGluZV0gPSBvbGRUU2hpZnRbaV07XG4gICAgc3RhdGUuc0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkU0NvdW50W2ldO1xuICAgIHN0YXRlLmJzQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRCU0NvdW50W2ldO1xuICB9XG4gIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCIvLyBIb3Jpem9udGFsIHJ1bGVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBocihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgY250LCBjaCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIC8vIENoZWNrIGhyIG1hcmtlclxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDVGLyogXyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb2YgdGhlbVxuXG4gIGNudCA9IDE7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGNoID09PSBtYXJrZXIpIHsgY250Kys7IH1cbiAgfVxuXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5tYXJrdXAgPSBBcnJheShjbnQgKyAxKS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcyIsIi8vIExpc3RzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbi8vIFNlYXJjaCBgWy0rKl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgbWFya2VyLCBwb3MsIG1heCwgY2g7XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgLXRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG4vLyBTZWFyY2ggYFxcZCtbLildW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhZnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIHBvcyA9IHN0YXJ0LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiBjaGFycyAoZGlnaXQgKyBkb3QpXG4gIGlmIChwb3MgKyAxID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoY2ggPj0gMHgzMC8qIDAgKi8gJiYgY2ggPD0gMHgzOS8qIDkgKi8pIHtcblxuICAgICAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgbm8gbW9yZSB0aGFuIDkgZGlnaXRzXG4gICAgICAvLyAocHJldmVudHMgaW50ZWdlciBvdmVyZmxvdyBpbiBicm93c2VycylcbiAgICAgIGlmIChwb3MgLSBzdGFydCA+PSAxMCkgeyByZXR1cm4gLTE7IH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZm91bmQgdmFsaWQgbWFya2VyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjb250ZW50U3RhcnQsXG4gICAgICBpLFxuICAgICAgaW5kZW50LFxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIsXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPcmRlcmVkLFxuICAgICAgaXRlbUxpbmVzLFxuICAgICAgbCxcbiAgICAgIGxpc3RMaW5lcyxcbiAgICAgIGxpc3RUb2tJZHgsXG4gICAgICBtYXJrZXJDaGFyQ29kZSxcbiAgICAgIG1hcmtlclZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRMSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIG9sZFRpZ2h0LFxuICAgICAgcG9zLFxuICAgICAgcG9zQWZ0ZXJNYXJrZXIsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICBzdGFydCxcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlLFxuICAgICAgdGlnaHQgPSB0cnVlO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGxpbWl0IGNvbmRpdGlvbnMgd2hlbiBsaXN0IGNhbiBpbnRlcnJ1cHRcbiAgLy8gYSBwYXJhZ3JhcGggKHZhbGlkYXRpb24gbW9kZSBvbmx5KVxuICBpZiAoc2lsZW50ICYmIHN0YXRlLnBhcmVudFR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgLy8gTmV4dCBsaXN0IGl0ZW0gc2hvdWxkIHN0aWxsIHRlcm1pbmF0ZSBwcmV2aW91cyBsaXN0IGl0ZW07XG4gICAgLy9cbiAgICAvLyBUaGlzIGNvZGUgY2FuIGZhaWwgaWYgcGx1Z2lucyB1c2UgYmxrSW5kZW50IGFzIHdlbGwgYXMgbGlzdHMsXG4gICAgLy8gYnV0IEkgaG9wZSB0aGUgc3BlYyBnZXRzIGZpeGVkIGxvbmcgYmVmb3JlIHRoYXQgaGFwcGVucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIERldGVjdCBsaXN0IHR5cGUgYW5kIHBvc2l0aW9uIGFmdGVyIG1hcmtlclxuICBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gdHJ1ZTtcbiAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgbWFya2VyVmFsdWUgPSBOdW1iZXIoc3RhdGUuc3JjLnN1YnN0cihzdGFydCwgcG9zQWZ0ZXJNYXJrZXIgLSBzdGFydCAtIDEpKTtcblxuICAgIC8vIElmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IG9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAgIC8vIGEgcGFyYWdyYXBoLCBpdCBzaG91bGQgc3RhcnQgd2l0aCAxLlxuICAgIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoICYmIG1hcmtlclZhbHVlICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgfSBlbHNlIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgdW5vcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgLy8gYSBwYXJhZ3JhcGgsIGZpcnN0IGxpbmUgc2hvdWxkIG5vdCBiZSBlbXB0eS5cbiAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGgpIHtcbiAgICBpZiAoc3RhdGUuc2tpcFNwYWNlcyhwb3NBZnRlck1hcmtlcikgPj0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIHNob3VsZCB0ZXJtaW5hdGUgbGlzdCBvbiBzdHlsZSBjaGFuZ2UuIFJlbWVtYmVyIGZpcnN0IG9uZSB0byBjb21wYXJlLlxuICBtYXJrZXJDaGFyQ29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSk7XG5cbiAgLy8gRm9yIHZhbGlkYXRpb24gbW9kZSB3ZSBjYW4gdGVybWluYXRlIGltbWVkaWF0ZWx5XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBTdGFydCBsaXN0XG4gIGxpc3RUb2tJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9vcGVuJywgJ29sJywgMSk7XG4gICAgaWYgKG1hcmtlclZhbHVlICE9PSAxKSB7XG4gICAgICB0b2tlbi5hdHRycyA9IFsgWyAnc3RhcnQnLCBtYXJrZXJWYWx1ZSBdIF07XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gICAgICAgPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9vcGVuJywgJ3VsJywgMSk7XG4gIH1cblxuICB0b2tlbi5tYXAgICAgPSBsaXN0TGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAvL1xuICAvLyBJdGVyYXRlIGxpc3QgaXRlbXNcbiAgLy9cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcbiAgcHJldkVtcHR5RW5kID0gZmFsc2U7XG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdsaXN0Jyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnbGlzdCc7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIHBvcyA9IHBvc0FmdGVyTWFya2VyO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvc0FmdGVyTWFya2VyIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pICUgNDtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjApIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgY29udGVudFN0YXJ0ID0gcG9zO1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcbiAgICAgIC8vIHRyaW1taW5nIHNwYWNlIGluIFwiLSAgICBcXG4gIDNcIiBjYXNlLCBpbmRlbnQgaXMgMSBoZXJlXG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiA0IHNwYWNlcywgdGhlIGluZGVudCBpcyAxXG4gICAgLy8gKHRoZSByZXN0IGlzIGp1c3QgaW5kZW50ZWQgY29kZSBibG9jaylcbiAgICBpZiAoaW5kZW50QWZ0ZXJNYXJrZXIgPiA0KSB7IGluZGVudEFmdGVyTWFya2VyID0gMTsgfVxuXG4gICAgLy8gXCIgIC0gIHRlc3RcIlxuICAgIC8vICBeXl5eXiAtIGNhbGN1bGF0aW5nIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRoaW5nXG4gICAgaW5kZW50ID0gaW5pdGlhbCArIGluZGVudEFmdGVyTWFya2VyO1xuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9vcGVuJywgJ2xpJywgMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgdG9rZW4ubWFwICAgID0gaXRlbUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG9sZExJbmRlbnQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBpbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvbGRMSW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBsaXN0XG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9jbG9zZScsICdvbCcsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X2Nsb3NlJywgJ3VsJywgLTEpO1xuICB9XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlKHN0YXRlLCBzdGFydExpbmUsIF9lbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgZGVzdEVuZFBvcyxcbiAgICAgIGRlc3RFbmRMaW5lTm8sXG4gICAgICBlbmRMaW5lLFxuICAgICAgaHJlZixcbiAgICAgIGksXG4gICAgICBsLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICByZXMsXG4gICAgICBzdGFydCxcbiAgICAgIHN0cixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW1wbGUgY2hlY2sgdG8gcXVpY2tseSBpbnRlcnJ1cHQgc2NhbiBvbiBbbGlua10odXJsKSBhdCB0aGUgc3RhcnQgb2YgbGluZS5cbiAgLy8gQ2FuIGJlIHVzZWZ1bCBvbiBwcmFjdGljZTogaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy81NFxuICB3aGlsZSAoKytwb3MgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovICYmXG4gICAgICAgIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyAtIDEpICE9PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGlmIChwb3MgKyAxID09PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncmVmZXJlbmNlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncmVmZXJlbmNlJztcblxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIHN0ciA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgbWF4ID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxhYmVsRW5kID0gcG9zO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwQSAvKiBcXG4gKi8pIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLykge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgXl5eIHNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICBeXl5eXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCk7XG4gIGlmICghcmVzLm9rKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSByZXMucG9zO1xuICBsaW5lcyArPSByZXMubGluZXM7XG5cbiAgLy8gc2F2ZSBjdXJzb3Igc3RhdGUsIHdlIGNvdWxkIHJlcXVpcmUgdG8gcm9sbGJhY2sgbGF0ZXJcbiAgZGVzdEVuZFBvcyA9IHBvcztcbiAgZGVzdEVuZExpbmVObyA9IGxpbmVzO1xuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeXl4gc2tpcHBpbmcgdGhvc2Ugc3BhY2VzXG4gIHN0YXJ0ID0gcG9zO1xuICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICBwb3MgPSByZXMucG9zO1xuICAgIGxpbmVzICs9IHJlcy5saW5lcztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9ICcnO1xuICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICB9XG5cbiAgLy8gc2tpcCB0cmFpbGluZyBzcGFjZXMgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBhZnRlciB0aXRsZSxcbiAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIHZhbGlkIHJlZmVyZW5jZSBpZiB3ZSByb2xsIGJhY2tcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBDb21tb25NYXJrIDAuMjAgZGlzYWxsb3dzIGVtcHR5IGxhYmVsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFJlZmVyZW5jZSBjYW4gbm90IHRlcm1pbmF0ZSBhbnl0aGluZy4gVGhpcyBjaGVjayBpcyBmb3Igc2FmZXR5IG9ubHkuXG4gIC8qaXN0YW5idWwgaWdub3JlIGlmKi9cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlOiB0aXRsZSwgaHJlZjogaHJlZiB9O1xuICB9XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIGxpbmVzICsgMTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCIvLyBoZWFkaW5nICgjLCAjIywgLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGV2ZWwsIHRtcCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4MjMvKiAjICovIHx8IHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXZlbCA9IDE7XG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XG4gICAgbGV2ZWwrKztcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiAhaXNTcGFjZShjaCkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBMZXQncyBjdXQgdGFpbHMgbGlrZSAnICAgICMjIyAgJyBmcm9tIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgbWF4ID0gc3RhdGUuc2tpcFNwYWNlc0JhY2sobWF4LCBwb3MpO1xuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xuICBpZiAodG1wID4gcG9zICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkpKSB7XG4gICAgbWF4ID0gdG1wO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkudHJpbSgpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBwb3MsIG1heCwgbGV2ZWwsIG1hcmtlcixcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgb2xkUGFyZW50VHlwZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnOyAvLyB1c2UgcGFyYWdyYXBoIHRvIG1hdGNoIHRlcm1pbmF0b3JSdWxlc1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAobWFya2VyID09PSAweDJELyogLSAqLyB8fCBtYXJrZXIgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICAgICAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIi8vIEhUTUwgYmxvY2tcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cbi8vIEFuIGFycmF5IG9mIG9wZW5pbmcgYW5kIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBzZXF1ZW5jZXMgZm9yIGh0bWwgdGFncyxcbi8vIGxhc3QgYXJndW1lbnQgZGVmaW5lcyB3aGV0aGVyIGl0IGNhbiB0ZXJtaW5hdGUgYSBwYXJhZ3JhcGggb3Igbm90XG4vL1xudmFyIEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbIC9ePChzY3JpcHR8cHJlfHN0eWxlKSg/PShcXHN8PnwkKSkvaSwgLzxcXC8oc2NyaXB0fHByZXxzdHlsZSk+L2ksIHRydWUgXSxcbiAgWyAvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZSBdLFxuICBbIC9ePFxcPy8sICAgICAgICAgL1xcPz4vLCAgIHRydWUgXSxcbiAgWyAvXjwhW0EtWl0vLCAgICAgLz4vLCAgICAgdHJ1ZSBdLFxuICBbIC9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoJ148Lz8oJyArIGJsb2NrX25hbWVzLmpvaW4oJ3wnKSArICcpKD89KFxcXFxzfC8/PnwkKSknLCAnaScpLCAvXiQvLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cChIVE1MX09QRU5fQ0xPU0VfVEFHX1JFLnNvdXJjZSArICdcXFxccyokJyksICAvXiQvLCBmYWxzZSBdXG5dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9ibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMF0udGVzdChsaW5lVGV4dCkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkge1xuICAgIC8vIHRydWUgaWYgdGhpcyBzZXF1ZW5jZSBjYW4gYmUgYSB0ZXJtaW5hdG9yLCBmYWxzZSBvdGhlcndpc2VcbiAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7IG5leHRMaW5lKys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2Jsb2NrJywgJycsIDApO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIG5leHRMaW5lIF07XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5qcyIsIi8vIExpc3Qgb2YgdmFsaWQgaHRtbCBibG9ja3MgbmFtZXMsIGFjY29ydGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2h0bWwtYmxvY2tzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdiYXNlJyxcbiAgJ2Jhc2Vmb250JyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdjYXB0aW9uJyxcbiAgJ2NlbnRlcicsXG4gICdjb2wnLFxuICAnY29sZ3JvdXAnLFxuICAnZGQnLFxuICAnZGV0YWlscycsXG4gICdkaWFsb2cnLFxuICAnZGlyJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdmcmFtZScsXG4gICdmcmFtZXNldCcsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkJyxcbiAgJ2hlYWRlcicsXG4gICdocicsXG4gICdodG1sJyxcbiAgJ2lmcmFtZScsXG4gICdsZWdlbmQnLFxuICAnbGknLFxuICAnbGluaycsXG4gICdtYWluJyxcbiAgJ21lbnUnLFxuICAnbWVudWl0ZW0nLFxuICAnbWV0YScsXG4gICduYXYnLFxuICAnbm9mcmFtZXMnLFxuICAnb2wnLFxuICAnb3B0Z3JvdXAnLFxuICAnb3B0aW9uJyxcbiAgJ3AnLFxuICAncGFyYW0nLFxuICAncHJlJyxcbiAgJ3NlY3Rpb24nLFxuICAnc291cmNlJyxcbiAgJ3RpdGxlJyxcbiAgJ3N1bW1hcnknLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGl0bGUnLFxuICAndHInLFxuICAndHJhY2snLFxuICAndWwnXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCIvLyBQYXJhZ3JhcGhcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyYWdyYXBoKHN0YXRlLCBzdGFydExpbmUvKiwgZW5kTGluZSovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpLFxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJztcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfb3BlbicsICdwJywgMSk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcyIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvciBleGFtcGxlLCBpZiB3ZSBhcmUgaW4gbGlzdClcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG5cbiAgLy8gY2FuIGJlICdibG9ja3F1b3RlJywgJ2xpc3QnLCAncm9vdCcsICdwYXJhZ3JhcGgnIG9yICdyZWZlcmVuY2UnXG4gIC8vIHVzZWQgaW4gbGlzdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgaW50ZXJydXB0IGEgcGFyYWdyYXBoXG4gIHRoaXMucGFyZW50VHlwZSA9ICdyb290JztcblxuICB0aGlzLmxldmVsID0gMDtcblxuICAvLyByZW5kZXJlclxuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIC8vIENyZWF0ZSBjYWNoZXNcbiAgLy8gR2VuZXJhdGUgbWFya2Vycy5cbiAgcyA9IHRoaXMuc3JjO1xuICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcblxuICBmb3IgKHN0YXJ0ID0gcG9zID0gaW5kZW50ID0gb2Zmc2V0ID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICBjaCA9IHMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpbmRlbnQrKztcblxuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIG9mZnNldCAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnRfZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSB8fCBwb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgIGlmIChjaCAhPT0gMHgwQSkgeyBwb3MrKzsgfVxuICAgICAgdGhpcy5iTWFya3MucHVzaChzdGFydCk7XG4gICAgICB0aGlzLmVNYXJrcy5wdXNoKHBvcyk7XG4gICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKG9mZnNldCk7XG4gICAgICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICAgICAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGZha2UgZW50cnkgdG8gc2ltcGxpZnkgY2FjaGUgYm91bmRzIGNoZWNrc1xuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy5lTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gIHRoaXMuc0NvdW50LnB1c2goMCk7XG4gIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gIHRoaXMubGluZU1heCA9IHRoaXMuYk1hcmtzLmxlbmd0aCAtIDE7IC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vL1xuU3RhdGVCbG9jay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG4gIHRva2VuLmJsb2NrID0gdHJ1ZTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShsaW5lKSB7XG4gIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XG4gICAgaWYgKHRoaXMuYk1hcmtzW2Zyb21dICsgdGhpcy50U2hpZnRbZnJvbV0gPCB0aGlzLmVNYXJrc1tmcm9tXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbi5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xuICB2YXIgY2g7XG5cbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGluIHJldmVyc2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKCFpc1NwYWNlKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzKHBvcywgY29kZSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyByZXZlcnNlIGZyb20gZ2l2ZW4gcG9zaXRpb24gLSAxXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmIChjb2RlICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJlZ2luLCBlbmQsIGluZGVudCwga2VlcExhc3RMRikge1xuICB2YXIgaSwgbGluZUluZGVudCwgY2gsIGZpcnN0LCBsYXN0LCBxdWV1ZSwgbGluZVN0YXJ0LFxuICAgICAgbGluZSA9IGJlZ2luO1xuXG4gIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG5cbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcbiAgICBsaW5lSW5kZW50ID0gMDtcbiAgICBsaW5lU3RhcnQgPSBmaXJzdCA9IHRoaXMuYk1hcmtzW2xpbmVdO1xuXG4gICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH1cblxuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QgJiYgbGluZUluZGVudCA8IGluZGVudCkge1xuICAgICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KGZpcnN0KTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0IC0gbGluZVN0YXJ0IDwgdGhpcy50U2hpZnRbbGluZV0pIHtcbiAgICAgICAgLy8gcGF0Y2hlZCB0U2hpZnQgbWFza2VkIGNoYXJhY3RlcnMgdG8gbG9vayBsaWtlIHNwYWNlcyAoYmxvY2txdW90ZXMsIGxpc3QgbWFya2VycylcbiAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Kys7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQgPiBpbmRlbnQpIHtcbiAgICAgIC8vIHBhcnRpYWxseSBleHBhbmRpbmcgdGFicyBpbiBjb2RlIGJsb2NrcywgZS5nICdcXHRcXHRmb29iYXInXG4gICAgICAvLyB3aXRoIGluZGVudD0yIGJlY29tZXMgJyAgXFx0Zm9vYmFyJ1xuICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oJyAnKSArIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXVlLmpvaW4oJycpO1xufTtcblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVCbG9jay5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJJbmxpbmVcbiAqXG4gKiBUb2tlbml6ZXMgcGFyYWdyYXBoIGNvbnRlbnQuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIHJ1bGVzXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ3RleHQnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHQnKSBdLFxuICBbICduZXdsaW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9uZXdsaW5lJykgXSxcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcbiAgWyAnYmFja3RpY2tzJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnRva2VuaXplIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykudG9rZW5pemUgXSxcbiAgWyAnbGluaycsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbGluaycpIF0sXG4gIFsgJ2ltYWdlJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2ltYWdlJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sX2lubGluZScsICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sX2lubGluZScpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbnZhciBfcnVsZXMyID0gW1xuICBbICdiYWxhbmNlX3BhaXJzJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykucG9zdFByb2Nlc3MgXSxcbiAgWyAndGV4dF9jb2xsYXBzZScsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZScpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VySW5saW5lKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgdmFyIGk7XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBpbmxpbmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlcjIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBTZWNvbmQgcnVsZXIgdXNlZCBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAqIChlLmcuIGluIGVtcGhhc2lzLWxpa2UgcnVsZXMpLlxuICAgKiovXG4gIHRoaXMucnVsZXIyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlczIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyMi5wdXNoKF9ydWxlczJbaV1bMF0sIF9ydWxlczJbaV1bMV0pO1xuICB9XG59XG5cblxuLy8gU2tpcCBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlO1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0ZWQgc3VjY2Vzc1xuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXG4gICAgICBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gSW5jcmVtZW50IHN0YXRlLmxldmVsIGFuZCBkZWNyZW1lbnQgaXQgbGF0ZXIgdG8gbGltaXQgcmVjdXJzaW9uLlxuICAgICAgLy8gSXQncyBoYXJtbGVzcyB0byBkbyBoZXJlLCBiZWNhdXNlIG5vIHRva2VucyBhcmUgY3JlYXRlZC4gQnV0IGlkZWFsbHksXG4gICAgICAvLyB3ZSdkIG5lZWQgYSBzZXBhcmF0ZSBwcml2YXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAvL1xuICAgICAgc3RhdGUubGV2ZWwrKztcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpO1xuICAgICAgc3RhdGUubGV2ZWwtLTtcblxuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heDtcbiAgfVxuXG4gIGlmICghb2spIHsgc3RhdGUucG9zKys7IH1cbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcbn07XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGVuZCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VySW5saW5lLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgaSwgcnVsZXMsIGxlbjtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpO1xuICBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qcyIsIi8vIFNraXAgdGV4dCBjaGFyYWN0ZXJzIGZvciB0ZXh0IHRva2VuLCBwbGFjZSB0aG9zZSB0byBwZW5kaW5nIGJ1ZmZlclxuLy8gYW5kIGluY3JlbWVudCBjdXJyZW50IHBvc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gUnVsZSB0byBza2lwIHB1cmUgdGV4dFxuLy8gJ3t9JCVAfis9OicgcmVzZXJ2ZWQgZm9yIGV4dGVudGlvbnNcblxuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG5cbi8vICEhISEgRG9uJ3QgY29uZnVzZSB3aXRoIFwiTWFya2Rvd24gQVNDSUkgUHVuY3R1YXRpb25cIiBjaGFyc1xuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JDaGFyKGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MEEvKiBcXG4gKi86XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA9PT0gc3RhdGUucG9zKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXRlLnBvcywgcG9zKTsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLCBmb3IgbWVtb3J5LlxuLy9cbi8vIEl0IGNvc3RzIDEwJSBvZiBwZXJmb3JtYW5jZSwgYnV0IGFsbG93cyBleHRlbmQgdGVybWluYXRvcnMgbGlzdCwgaWYgcGxhY2UgaXRcbi8vIHRvIGBQYXJjZXJJbmxpbmVgIHByb3BlcnR5LiBQcm9iYWJseSwgd2lsbCBzd2l0Y2ggdG8gaXQgc29tZXRpbWUsIHN1Y2hcbi8vIGZsZXhpYmlsaXR5IHJlcXVpcmVkLlxuXG4vKlxudmFyIFRFUk1JTkFUT1JfUkUgPSAvW1xcbiEjJCUmKitcXC06PD0+QFtcXFxcXFxdXl9ge31+XS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBpZHggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5zZWFyY2goVEVSTUlOQVRPUl9SRSk7XG5cbiAgLy8gZmlyc3QgY2hhciBpcyB0ZXJtaW5hdG9yIC0+IGVtcHR5IHRleHRcbiAgaWYgKGlkeCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBubyB0ZXJtaW5hdG9yIC0+IHRleHQgdGlsbCBlbmQgb2Ygc3RyaW5nXG4gIGlmIChpZHggPCAwKSB7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTsgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnNyYy5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIGlkeCk7IH1cblxuICBzdGF0ZS5wb3MgKz0gaWR4O1xuXG4gIHJldHVybiB0cnVlO1xufTsqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5qcyIsIi8vIFByb2NlZXNzICdcXG4nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwbWF4LCBtYXgsIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQS8qIFxcbiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgLy8gJyAgXFxuJyAtPiBoYXJkYnJlYWtcbiAgLy8gTG9va3VwIGluIHBlbmRpbmcgY2hhcnMgaXMgYmFkIHByYWN0aWNlISBEb24ndCBjb3B5IHRvIG90aGVyIHJ1bGVzIVxuICAvLyBQZW5kaW5nIHN0cmluZyBpcyBzdG9yZWQgaW4gY29uY2F0IG1vZGUsIGluZGV4ZWQgbG9va3VwcyB3aWxsIGNhdXNlXG4gIC8vIGNvbnZlcnRpb24gdG8gZmxhdCBtb2RlLlxuICBpZiAoIXNpbGVudCkge1xuICAgIGlmIChwbWF4ID49IDAgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXgpID09PSAweDIwKSB7XG4gICAgICBpZiAocG1heCA+PSAxICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4IC0gMSkgPT09IDB4MjApIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcucmVwbGFjZSgvICskLywgJycpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgc3RhdGUucHVzaCgnc29mdGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaCgnc29mdGJyZWFrJywgJ2JyJywgMCk7XG4gICAgfVxuICB9XG5cbiAgcG9zKys7XG5cbiAgLy8gc2tpcCBoZWFkaW5nIHNwYWNlcyBmb3IgbmV4dCBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkgeyBwb3MrKzsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIi8vIFByb2Nlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxudmFyIEVTQ0FQRUQgPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykgeyBFU0NBUEVELnB1c2goMCk7IH1cblxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xuICAuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxOyB9KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUMvKiBcXCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1twb3NdOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgICAgLy8gc2tpcCBsZWFkaW5nIHdoaXRlc3BhY2VzIGZyb20gbmV4dCBsaW5lXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnXFxcXCc7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIi8vIFBhcnNlIGJhY2t0aWNrc1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFja3RpY2soc3RhdGUsIHNpbGVudCkge1xuICB2YXIgc3RhcnQsIG1heCwgbWFya2VyLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDYwLyogYCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGFydCA9IHBvcztcbiAgcG9zKys7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuXG4gIG1hdGNoU3RhcnQgPSBtYXRjaEVuZCA9IHBvcztcblxuICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZignYCcsIG1hdGNoRW5kKSkgIT09IC0xKSB7XG4gICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgMTtcblxuICAgIHdoaWxlIChtYXRjaEVuZCA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDB4NjAvKiBgICovKSB7IG1hdGNoRW5kKys7IH1cblxuICAgIGlmIChtYXRjaEVuZCAtIG1hdGNoU3RhcnQgPT09IG1hcmtlci5sZW5ndGgpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2lubGluZScsICdjb2RlJywgMCk7XG4gICAgICAgIHRva2VuLm1hcmt1cCAgPSBtYXJrZXI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFxuXSsvZywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBtYXJrZXI7IH1cbiAgc3RhdGUucG9zICs9IG1hcmtlci5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIi8vIFByb2Nlc3MgW2xpbmtdKDx0bz4gXCJzdHVmZlwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVzLFxuICAgICAgcmVmLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMTtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gbWlnaHQgaGF2ZSBmb3VuZCBhIHZhbGlkIHNob3J0Y3V0IGxpbmssIGRpc2FibGUgcmVmZXJlbmNlIHBhcnNpbmdcbiAgICBwYXJzZVJlZmVyZW5jZSA9IGZhbHNlO1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICAvLyBwYXJzaW5nIGEgdmFsaWQgc2hvcnRjdXQgbGluayBmYWlsZWQsIGZhbGxiYWNrIHRvIHJlZmVyZW5jZVxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgc3RhdGUucG9zTWF4ID0gbGFiZWxFbmQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgIHRva2VuLmF0dHJzICA9IGF0dHJzID0gWyBbICdocmVmJywgaHJlZiBdIF07XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XG4gICAgfVxuXG4gICAgc3RhdGUubWQuaW5saW5lLnRva2VuaXplKHN0YXRlKTtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgQVVUT0xJTktfUkUgPSAvXjwoW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopPi87XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciB0YWlsLCBsaW5rTWF0Y2gsIGVtYWlsTWF0Y2gsIHVybCwgZnVsbFVybCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHRhaWwgPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTtcblxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChBVVRPTElOS19SRS50ZXN0KHRhaWwpKSB7XG4gICAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XG5cbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGxpbmtNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh0YWlsKSkge1xuICAgIGVtYWlsTWF0Y2ggPSB0YWlsLm1hdGNoKEVNQUlMX1JFKTtcblxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKCdtYWlsdG86JyArIHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGVtYWlsTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzIiwiLy8gUHJvY2VzcyBodG1sIHRhZ3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBIVE1MX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9UQUdfUkU7XG5cblxuZnVuY3Rpb24gaXNMZXR0ZXIoY2gpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgdmFyIGxjID0gY2ggfCAweDIwOyAvLyB0byBsb3dlciBjYXNlXG4gIHJldHVybiAobGMgPj0gMHg2MS8qIGEgKi8pICYmIChsYyA8PSAweDdhLyogeiAqLyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2lubGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbWF0Y2gsIG1heCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gQ2hlY2sgc3RhcnRcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8gfHxcbiAgICAgIHBvcyArIDIgPj0gbWF4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUXVpY2sgZmFpbCBvbiBzZWNvbmQgY2hhclxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICBpZiAoY2ggIT09IDB4MjEvKiAhICovICYmXG4gICAgICBjaCAhPT0gMHgzRi8qID8gKi8gJiZcbiAgICAgIGNoICE9PSAweDJGLyogLyAqLyAmJlxuICAgICAgIWlzTGV0dGVyKGNoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goSFRNTF9UQUdfUkUpO1xuICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBtYXRjaFswXS5sZW5ndGgpO1xuICB9XG4gIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzIiwiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdGllcyAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lbnRpdGllcycpO1xudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIGlzVmFsaWRFbnRpdHlDb2RlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNWYWxpZEVudGl0eUNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5mcm9tQ29kZVBvaW50O1xuXG5cbnZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSk7L2k7XG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgY29kZSwgbWF0Y2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMSA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMgLyogIyAqLykge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpID8gZnJvbUNvZGVQb2ludChjb2RlKSA6IGZyb21Db2RlUG9pbnQoMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07IH1cbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5qcyIsIi8vIEZvciBlYWNoIG9wZW5pbmcgZW1waGFzaXMtbGlrZSBtYXJrZXIgZmluZCBhIG1hdGNoaW5nIGNsb3Npbmcgb25lXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICB2YXIgaSwgaiwgbGFzdERlbGltLCBjdXJyRGVsaW0sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGxhc3REZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoIWxhc3REZWxpbS5jbG9zZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaiA9IGkgLSBsYXN0RGVsaW0uanVtcCAtIDE7XG5cbiAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICBjdXJyRGVsaW0gPSBkZWxpbWl0ZXJzW2pdO1xuXG4gICAgICBpZiAoY3VyckRlbGltLm9wZW4gJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubWFya2VyID09PSBsYXN0RGVsaW0ubWFya2VyICYmXG4gICAgICAgICAgY3VyckRlbGltLmVuZCA8IDAgJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubGV2ZWwgPT09IGxhc3REZWxpbS5sZXZlbCkge1xuXG4gICAgICAgIC8vIHR5cGVvZnMgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggcGx1Z2luc1xuICAgICAgICB2YXIgb2RkX21hdGNoID0gKGN1cnJEZWxpbS5jbG9zZSB8fCBsYXN0RGVsaW0ub3BlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyRGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3REZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VyckRlbGltLmxlbmd0aCArIGxhc3REZWxpbS5sZW5ndGgpICUgMyA9PT0gMDtcblxuICAgICAgICBpZiAoIW9kZF9tYXRjaCkge1xuICAgICAgICAgIGxhc3REZWxpbS5qdW1wID0gaSAtIGo7XG4gICAgICAgICAgbGFzdERlbGltLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kICA9IGk7XG4gICAgICAgICAgY3VyckRlbGltLmp1bXAgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGogLT0gY3VyckRlbGltLmp1bXAgKyAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCIvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lLCBhbmQgcmUtY2FsY3VsYXRlIGFsbCB0b2tlbiBsZXZlbHNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gIHZhciBjdXJyLCBsYXN0LFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgdG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBmb3IgKGN1cnIgPSBsYXN0ID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgLy8gcmUtY2FsY3VsYXRlIGxldmVsc1xuICAgIGxldmVsICs9IHRva2Vuc1tjdXJyXS5uZXN0aW5nO1xuICAgIHRva2Vuc1tjdXJyXS5sZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzIiwiLy8gSW5saW5lIHBhcnNlciBzdGF0ZVxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRva2VuICAgICAgICAgID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cblxuZnVuY3Rpb24gU3RhdGVJbmxpbmUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLm1kID0gbWQ7XG4gIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zO1xuXG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSAwO1xuXG4gIHRoaXMuY2FjaGUgPSB7fTsgICAgICAgIC8vIFN0b3JlcyB7IHN0YXJ0OiBlbmQgfSBwYWlycy4gVXNlZnVsIGZvciBiYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIG9mIHBhaXJzIHBhcnNlIChlbXBoYXNpcywgc3RyaWtlcykuXG5cbiAgdGhpcy5kZWxpbWl0ZXJzID0gW107ICAgLy8gRW1waGFzaXMtbGlrZSBkZWxpbWl0ZXJzXG59XG5cblxuLy8gRmx1c2ggcGVuZGluZyB0ZXh0XG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2hQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSB0aGlzLnBlbmRpbmc7XG4gIHRva2VuLmxldmVsID0gdGhpcy5wZW5kaW5nTGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgaWYgKHRoaXMucGVuZGluZykge1xuICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgfVxuXG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBTY2FuIGEgc2VxdWVuY2Ugb2YgZW1waGFzaXMtbGlrZSBtYXJrZXJzLCBhbmQgZGV0ZXJtaW5lIHdoZXRoZXJcbi8vIGl0IGNhbiBzdGFydCBhbiBlbXBoYXNpcyBzZXF1ZW5jZSBvciBlbmQgYW4gZW1waGFzaXMgc2VxdWVuY2UuXG4vL1xuLy8gIC0gc3RhcnQgLSBwb3NpdGlvbiB0byBzY2FuIGZyb20gKGl0IHNob3VsZCBwb2ludCBhdCBhIHZhbGlkIG1hcmtlcik7XG4vLyAgLSBjYW5TcGxpdFdvcmQgLSBkZXRlcm1pbmUgaWYgdGhlc2UgbWFya2VycyBjYW4gYmUgZm91bmQgaW5zaWRlIGEgd29yZFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKHN0YXJ0LCBjYW5TcGxpdFdvcmQpIHtcbiAgdmFyIHBvcyA9IHN0YXJ0LCBsYXN0Q2hhciwgbmV4dENoYXIsIGNvdW50LCBjYW5fb3BlbiwgY2FuX2Nsb3NlLFxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLFxuICAgICAgaXNOZXh0V2hpdGVTcGFjZSwgaXNOZXh0UHVuY3RDaGFyLFxuICAgICAgbGVmdF9mbGFua2luZyA9IHRydWUsXG4gICAgICByaWdodF9mbGFua2luZyA9IHRydWUsXG4gICAgICBtYXggPSB0aGlzLnBvc01heCxcbiAgICAgIG1hcmtlciA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIC8vIHRyZWF0IGJlZ2lubmluZyBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAweDIwO1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHsgcG9zKys7IH1cblxuICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuXG4gIC8vIHRyZWF0IGVuZCBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbmV4dENoYXIgPSBwb3MgPCBtYXggPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAweDIwO1xuXG4gIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjYW5TcGxpdFdvcmQpIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nICAmJiAoIXJpZ2h0X2ZsYW5raW5nIHx8IGlzTGFzdFB1bmN0Q2hhcik7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmcgJiYgKCFsZWZ0X2ZsYW5raW5nICB8fCBpc05leHRQdW5jdENoYXIpO1xuICB9IGVsc2Uge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmc7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNhbl9vcGVuOiAgY2FuX29wZW4sXG4gICAgY2FuX2Nsb3NlOiBjYW5fY2xvc2UsXG4gICAgbGVuZ3RoOiAgICBjb3VudFxuICB9O1xufTtcblxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlSW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsgfVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59O1xuXG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICB9LCBmYWxzZSk7XG59XG5cblxudmFyIGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUuaHR0cCkge1xuICAgICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICAnaHR0cDonLFxuICAnZnRwOic6ICAgICdodHRwOicsXG4gICcvLyc6ICAgICAge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBgOi8vYCAmIGAvLy9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICc6JykgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJy8nKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnbWFpbHRvOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG52YXIgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxudmFyIHRsZHNfZGVmYXVsdCA9ICdiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhCcuc3BsaXQoJ3wnKTtcblxuLyplc2xpbnQtZW5hYmxlIG1heC1sZW4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZShzZWxmKSB7XG4gIHNlbGYuX19pbmRleF9fID0gLTE7XG4gIHNlbGYuX190ZXh0X2NhY2hlX18gICA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfTtcbn1cblxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cbi8vXG5mdW5jdGlvbiBjb21waWxlKHNlbGYpIHtcblxuICAvLyBMb2FkICYgY2xvbmUgUkUgcGF0dGVybnMuXG4gIHZhciByZSA9IHNlbGYucmUgPSByZXF1aXJlKCcuL2xpYi9yZScpKHNlbGYuX19vcHRzX18pO1xuXG4gIC8vIERlZmluZSBkeW5hbWljIHBhdHRlcm5zXG4gIHZhciB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpO1xuXG4gIHNlbGYub25Db21waWxlKCk7XG5cbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgdGxkcy5wdXNoKHRsZHNfMmNoX3NyY19yZSk7XG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bik7XG5cbiAgcmUuc3JjX3RsZHMgPSB0bGRzLmpvaW4oJ3wnKTtcblxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cblxuICByZS5lbWFpbF9mdXp6eSAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKTtcbiAgcmUuaG9zdF9mdXp6eV90ZXN0ICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfaG9zdF9mdXp6eV90ZXN0KSwgJ2knKTtcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgdmFyIGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcoTGlua2lmeUl0KSBJbnZhbGlkIHNjaGVtYSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gc2VsZi5fX3NjaGVtYXNfX1tuYW1lXTtcblxuICAgIC8vIHNraXAgZGlzYWJsZWQgbWV0aG9kc1xuICAgIGlmICh2YWwgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgcG9zdHBvbmVkIGFsaWFzZXNcbiAgLy9cblxuICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgaWYgKCFzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0pIHtcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXG4gICAgICAvLyBzY2hlbWFFcnJvcihhbGlhcywgc2VsZi5fX3NjaGVtYXNfX1thbGlhc10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgdmFyIHNsaXN0ID0gT2JqZWN0LmtleXMoc2VsZi5fX2NvbXBpbGVkX18pXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRpc2FibGVkICYgZmFrZSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAwICYmIHNlbGYuX19jb21waWxlZF9fW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChlc2NhcGVSRSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXG4gIHNlbGYucmUuc2NoZW1hX3Rlc3QgICA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpO1xuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2lnJyk7XG5cbiAgc2VsZi5yZS5wcmV0ZXN0ICAgICAgID0gUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpJyk7XG5cbiAgLy9cbiAgLy8gQ2xlYW51cFxuICAvL1xuXG4gIHJlc2V0U2NhbkNhY2hlKHNlbGYpO1xufVxuXG4vKipcbiAqIGNsYXNzIE1hdGNoXG4gKlxuICogTWF0Y2ggcmVzdWx0LiBTaW5nbGUgZWxlbWVudCBvZiBhcnJheSwgcmV0dXJuZWQgYnkgW1tMaW5raWZ5SXQjbWF0Y2hdXVxuICoqL1xuZnVuY3Rpb24gTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIHN0YXJ0ID0gc2VsZi5fX2luZGV4X18sXG4gICAgICBlbmQgICA9IHNlbGYuX19sYXN0X2luZGV4X18sXG4gICAgICB0ZXh0ICA9IHNlbGYuX190ZXh0X2NhY2hlX18uc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgLyoqXG4gICAqIE1hdGNoI3NjaGVtYSAtPiBTdHJpbmdcbiAgICpcbiAgICogUHJlZml4IChwcm90b2NvbCkgZm9yIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuc2NoZW1hICAgID0gc2VsZi5fX3NjaGVtYV9fLnRvTG93ZXJDYXNlKCk7XG4gIC8qKlxuICAgKiBNYXRjaCNpbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogRmlyc3QgcG9zaXRpb24gb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5pbmRleCAgICAgPSBzdGFydCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjbGFzdEluZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBOZXh0IHBvc2l0aW9uIGFmdGVyIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMubGFzdEluZGV4ID0gZW5kICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNyYXcgLT4gU3RyaW5nXG4gICAqXG4gICAqIE1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMucmF3ICAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3RleHQgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vdG1hbGl6ZWQgdGV4dCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnRleHQgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN1cmwgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vcm1hbGl6ZWQgdXJsIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudXJsICAgICAgID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIG1hdGNoID0gbmV3IE1hdGNoKHNlbGYsIHNoaWZ0KTtcblxuICBzZWxmLl9fY29tcGlsZWRfX1ttYXRjaC5zY2hlbWFdLm5vcm1hbGl6ZShtYXRjaCwgc2VsZik7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTGlua2lmeUl0XG4gKiovXG5cbi8qKlxuICogbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKVxuICogLSBzY2hlbWFzIChPYmplY3QpOiBPcHRpb25hbC4gQWRkaXRpb25hbCBzY2hlbWFzIHRvIHZhbGlkYXRlIChwcmVmaXgvdmFsaWRhdG9yKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIENyZWF0ZXMgbmV3IGxpbmtpZmllciBpbnN0YW5jZSB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgc2NoZW1hcy5cbiAqIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YCBrZXl3b3JkIGZvciBjb252ZW5pZW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0IHVuZGVyc3RhbmRzOlxuICpcbiAqIC0gYGh0dHAocyk6Ly8uLi5gICwgYGZ0cDovLy4uLmAsIGBtYWlsdG86Li4uYCAmIGAvLy4uLmAgbGlua3NcbiAqIC0gXCJmdXp6eVwiIGxpbmtzIGFuZCBlbWFpbHMgKGV4YW1wbGUuY29tLCBmb29AYmFyLmNvbSkuXG4gKlxuICogYHNjaGVtYXNgIGlzIGFuIG9iamVjdCwgd2hlcmUgZWFjaCBrZXkvdmFsdWUgZGVzY3JpYmVzIHByb3RvY29sL3J1bGU6XG4gKlxuICogLSBfX2tleV9fIC0gbGluayBwcmVmaXggKHVzdWFsbHksIHByb3RvY29sIG5hbWUgd2l0aCBgOmAgYXQgdGhlIGVuZCwgYHNreXBlOmBcbiAqICAgZm9yIGV4YW1wbGUpLiBgbGlua2lmeS1pdGAgbWFrZXMgc2h1cmUgdGhhdCBwcmVmaXggaXMgbm90IHByZWNlZWRlZCB3aXRoXG4gKiAgIGFscGhhbnVtZXJpYyBjaGFyIGFuZCBzeW1ib2xzLiBPbmx5IHdoaXRlc3BhY2VzIGFuZCBwdW5jdHVhdGlvbiBhbGxvd2VkLlxuICogLSBfX3ZhbHVlX18gLSBydWxlIHRvIGNoZWNrIHRhaWwgYWZ0ZXIgbGluayBwcmVmaXhcbiAqICAgLSBfU3RyaW5nXyAtIGp1c3QgYWxpYXMgdG8gZXhpc3RpbmcgcnVsZVxuICogICAtIF9PYmplY3RfXG4gKiAgICAgLSBfdmFsaWRhdGVfIC0gdmFsaWRhdG9yIGZ1bmN0aW9uIChzaG91bGQgcmV0dXJuIG1hdGNoZWQgbGVuZ3RoIG9uIHN1Y2Nlc3MpLFxuICogICAgICAgb3IgYFJlZ0V4cGAuXG4gKiAgICAgLSBfbm9ybWFsaXplXyAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSB0ZXh0ICYgdXJsIG9mIG1hdGNoZWQgcmVzdWx0XG4gKiAgICAgICAoZm9yIGV4YW1wbGUsIGZvciBAdHdpdHRlciBtZW50aW9ucykuXG4gKlxuICogYG9wdGlvbnNgOlxuICpcbiAqIC0gX19mdXp6eUxpbmtfXyAtIHJlY29nbmlnZSBVUkwtcyB3aXRob3V0IGBodHRwKHMpOmAgcHJlZml4LiBEZWZhdWx0IGB0cnVlYC5cbiAqIC0gX19mdXp6eUlQX18gLSBhbGxvdyBJUHMgaW4gZnV6enkgbGlua3MgYWJvdmUuIENhbiBjb25mbGljdCB3aXRoIHNvbWUgdGV4dHNcbiAqICAgbGlrZSB2ZXJzaW9uIG51bWJlcnMuIERlZmF1bHQgYGZhbHNlYC5cbiAqIC0gX19mdXp6eUVtYWlsX18gLSByZWNvZ25pemUgZW1haWxzIHdpdGhvdXQgYG1haWx0bzpgIHByZWZpeC5cbiAqXG4gKiovXG5mdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlua2lmeUl0KSkge1xuICAgIHJldHVybiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKGlzT3B0aW9uc09iaihzY2hlbWFzKSkge1xuICAgICAgb3B0aW9ucyA9IHNjaGVtYXM7XG4gICAgICBzY2hlbWFzID0ge307XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fX29wdHNfXyAgICAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAvLyBDYWNoZSBsYXN0IHRlc3RlZCByZXN1bHQuIFVzZWQgdG8gc2tpcCByZXBlYXRpbmcgc3RlcHMgb24gbmV4dCBgbWF0Y2hgIGNhbGwuXG4gIHRoaXMuX19pbmRleF9fICAgICAgICAgID0gLTE7XG4gIHRoaXMuX19sYXN0X2luZGV4X18gICAgID0gLTE7IC8vIE5leHQgc2NhbiBwb3NpdGlvblxuICB0aGlzLl9fc2NoZW1hX18gICAgICAgICA9ICcnO1xuICB0aGlzLl9fdGV4dF9jYWNoZV9fICAgICA9ICcnO1xuXG4gIHRoaXMuX19zY2hlbWFzX18gICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0U2NoZW1hcywgc2NoZW1hcyk7XG4gIHRoaXMuX19jb21waWxlZF9fICAgICAgID0ge307XG5cbiAgdGhpcy5fX3RsZHNfXyAgICAgICAgICAgPSB0bGRzX2RlZmF1bHQ7XG4gIHRoaXMuX190bGRzX3JlcGxhY2VkX18gID0gZmFsc2U7XG5cbiAgdGhpcy5yZSA9IHt9O1xuXG4gIGNvbXBpbGUodGhpcyk7XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I2FkZChzY2hlbWEsIGRlZmluaXRpb24pXG4gKiAtIHNjaGVtYSAoU3RyaW5nKTogcnVsZSBuYW1lIChmaXhlZCBwYXR0ZXJuIHByZWZpeClcbiAqIC0gZGVmaW5pdGlvbiAoU3RyaW5nfFJlZ0V4cHxPYmplY3QpOiBzY2hlbWEgZGVmaW5pdGlvblxuICpcbiAqIEFkZCBuZXcgcnVsZSBkZWZpbml0aW9uLiBTZWUgY29uc3RydWN0b3IgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzY2hlbWEsIGRlZmluaXRpb24pIHtcbiAgdGhpcy5fX3NjaGVtYXNfX1tzY2hlbWFdID0gZGVmaW5pdGlvbjtcbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNzZXQob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBTZXQgcmVjb2duaXRpb24gb3B0aW9ucyBmb3IgbGlua3Mgd2l0aG91dCBzY2hlbWEuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gIHRoaXMuX19vcHRzX18gPSBhc3NpZ24odGhpcy5fX29wdHNfXywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBTZWFyY2hlcyBsaW5raWZpYWJsZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzIG9yIGBmYWxzZWAgb24gZmFpbC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QodGV4dCkge1xuICAvLyBSZXNldCBzY2FuIGNhY2hlXG4gIHRoaXMuX190ZXh0X2NhY2hlX18gPSB0ZXh0O1xuICB0aGlzLl9faW5kZXhfXyAgICAgID0gLTE7XG5cbiAgaWYgKCF0ZXh0Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIgbSwgbWwsIG1lLCBsZW4sIHNoaWZ0LCBuZXh0LCByZSwgdGxkX3BvcywgYXRfcG9zO1xuXG4gIC8vIHRyeSB0byBzY2FuIGZvciBsaW5rIHdpdGggc2NoZW1hIC0gdGhhdCdzIHRoZSBtb3N0IHNpbXBsZSBydWxlXG4gIGlmICh0aGlzLnJlLnNjaGVtYV90ZXN0LnRlc3QodGV4dCkpIHtcbiAgICByZSA9IHRoaXMucmUuc2NoZW1hX3NlYXJjaDtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobSA9IHJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICBsZW4gPSB0aGlzLnRlc3RTY2hlbWFBdCh0ZXh0LCBtWzJdLCByZS5sYXN0SW5kZXgpO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gbVsyXTtcbiAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IG0uaW5kZXggKyBtWzFdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBsaW5rc1xuICAgIHRsZF9wb3MgPSB0ZXh0LnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgaWYgKHRsZF9wb3MgPj0gMCkge1xuICAgICAgLy8gaWYgdGxkIGlzIGxvY2F0ZWQgYWZ0ZXIgZm91bmQgbGluayAtIG5vIG5lZWQgdG8gY2hlY2sgZnV6enkgcGF0dGVyblxuICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCB0bGRfcG9zIDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgaWYgKChtbCA9IHRleHQubWF0Y2godGhpcy5fX29wdHNfXy5mdXp6eUlQID8gdGhpcy5yZS5saW5rX2Z1enp5IDogdGhpcy5yZS5saW5rX25vX2lwX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtbC5pbmRleCArIG1sWzBdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUVtYWlsICYmIHRoaXMuX19jb21waWxlZF9fWydtYWlsdG86J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGVtYWlsc1xuICAgIGF0X3BvcyA9IHRleHQuaW5kZXhPZignQCcpO1xuICAgIGlmIChhdF9wb3MgPj0gMCkge1xuICAgICAgLy8gV2UgY2FuJ3Qgc2tpcCB0aGlzIGNoZWNrLCBiZWNhdXNlIHRoaXMgY2FzZXMgYXJlIHBvc3NpYmxlOlxuICAgICAgLy8gMTkyLjE2OC4xLjFAZ21haWwuY29tLCBteS5pbkBleGFtcGxlLmNvbVxuICAgICAgaWYgKChtZSA9IHRleHQubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgc2hpZnQgPSBtZS5pbmRleCArIG1lWzFdLmxlbmd0aDtcbiAgICAgICAgbmV4dCAgPSBtZS5pbmRleCArIG1lWzBdLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18gfHxcbiAgICAgICAgICAgIChzaGlmdCA9PT0gdGhpcy5fX2luZGV4X18gJiYgbmV4dCA+IHRoaXMuX19sYXN0X2luZGV4X18pKSB7XG4gICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICdtYWlsdG86JztcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjcHJldGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogVmVyeSBxdWljayBjaGVjaywgdGhhdCBjYW4gZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMuIFJldHVybnMgdHJ1ZSBpZiBsaW5rIE1BWSBCRVxuICogY2FuIGV4aXN0cy4gQ2FuIGJlIHVzZWQgZm9yIHNwZWVkIG9wdGltaXphdGlvbiwgd2hlbiB5b3UgbmVlZCB0byBjaGVjayB0aGF0XG4gKiBsaW5rIE5PVCBleGlzdHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnByZXRlc3QgPSBmdW5jdGlvbiBwcmV0ZXN0KHRleHQpIHtcbiAgcmV0dXJuIHRoaXMucmUucHJldGVzdC50ZXN0KHRleHQpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0U2NoZW1hQXQodGV4dCwgbmFtZSwgcG9zaXRpb24pIC0+IE51bWJlclxuICogLSB0ZXh0IChTdHJpbmcpOiB0ZXh0IHRvIHNjYW5cbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSAoc2NoZW1hKSBuYW1lXG4gKiAtIHBvc2l0aW9uIChOdW1iZXIpOiB0ZXh0IG9mZnNldCB0byBjaGVjayBmcm9tXG4gKlxuICogU2ltaWxhciB0byBbW0xpbmtpZnlJdCN0ZXN0XV0gYnV0IGNoZWNrcyBvbmx5IHNwZWNpZmljIHByb3RvY29sIHRhaWwgZXhhY3RseVxuICogYXQgZ2l2ZW4gcG9zaXRpb24uIFJldHVybnMgbGVuZ3RoIG9mIGZvdW5kIHBhdHRlcm4gKDAgb24gZmFpbCkuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3RTY2hlbWFBdCA9IGZ1bmN0aW9uIHRlc3RTY2hlbWFBdCh0ZXh0LCBzY2hlbWEsIHBvcykge1xuICAvLyBJZiBub3Qgc3VwcG9ydGVkIHNjaGVtYSBjaGVjayByZXF1ZXN0ZWQgLSB0ZXJtaW5hdGVcbiAgaWYgKCF0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldLnZhbGlkYXRlKHRleHQsIHBvcywgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I21hdGNoKHRleHQpIC0+IEFycmF5fG51bGxcbiAqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGZvdW5kIGxpbmsgZGVzY3JpcHRpb25zIG9yIGBudWxsYCBvbiBmYWlsLiBXZSBzdHJvbmdseVxuICogcmVjb21tZW5kIHRvIHVzZSBbW0xpbmtpZnlJdCN0ZXN0XV0gZmlyc3QsIGZvciBiZXN0IHNwZWVkLlxuICpcbiAqICMjIyMjIFJlc3VsdCBtYXRjaCBkZXNjcmlwdGlvblxuICpcbiAqIC0gX19zY2hlbWFfXyAtIGxpbmsgc2NoZW1hLCBjYW4gYmUgZW1wdHkgZm9yIGZ1enp5IGxpbmtzLCBvciBgLy9gIGZvclxuICogICBwcm90b2NvbC1uZXV0cmFsICBsaW5rcy5cbiAqIC0gX19pbmRleF9fIC0gb2Zmc2V0IG9mIG1hdGNoZWQgdGV4dFxuICogLSBfX2xhc3RJbmRleF9fIC0gaW5kZXggb2YgbmV4dCBjaGFyIGFmdGVyIG1hdGhjaCBlbmRcbiAqIC0gX19yYXdfXyAtIG1hdGNoZWQgdGV4dFxuICogLSBfX3RleHRfXyAtIG5vcm1hbGl6ZWQgdGV4dFxuICogLSBfX3VybF9fIC0gbGluaywgZ2VuZXJhdGVkIGZyb20gbWF0Y2hlZCB0ZXh0XG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2godGV4dCkge1xuICB2YXIgc2hpZnQgPSAwLCByZXN1bHQgPSBbXTtcblxuICAvLyBUcnkgdG8gdGFrZSBwcmV2aW91cyBlbGVtZW50IGZyb20gY2FjaGUsIGlmIC50ZXN0KCkgY2FsbGVkIGJlZm9yZVxuICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0KSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcbiAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxuICB2YXIgdGFpbCA9IHNoaWZ0ID8gdGV4dC5zbGljZShzaGlmdCkgOiB0ZXh0O1xuXG4gIC8vIFNjYW4gc3RyaW5nIHVudGlsIGVuZCByZWFjaGVkXG4gIHdoaWxlICh0aGlzLnRlc3QodGFpbCkpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuXG4gICAgdGFpbCA9IHRhaWwuc2xpY2UodGhpcy5fX2xhc3RfaW5kZXhfXyk7XG4gICAgc2hpZnQgKz0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjdGxkcyhsaXN0IFssIGtlZXBPbGRdKSAtPiB0aGlzXG4gKiAtIGxpc3QgKEFycmF5KTogbGlzdCBvZiB0bGRzXG4gKiAtIGtlZXBPbGQgKEJvb2xlYW4pOiBtZXJnZSB3aXRoIGN1cnJlbnQgbGlzdCBpZiBgdHJ1ZWAgKGBmYWxzZWAgYnkgZGVmYXVsdClcbiAqXG4gKiBMb2FkIChvciBtZXJnZSkgbmV3IHRsZHMgbGlzdC4gVGhvc2UgYXJlIHVzZXIgZm9yIGZ1enp5IGxpbmtzICh3aXRob3V0IHByZWZpeClcbiAqIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcy4gQnkgZGVmYXVsdCB0aGlzIGFsZ29yeXRobSB1c2VkOlxuICpcbiAqIC0gaG9zdG5hbWUgd2l0aCBhbnkgMi1sZXR0ZXIgcm9vdCB6b25lcyBhcmUgb2suXG4gKiAtIGJpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEXG4gKiAgIGFyZSBvay5cbiAqIC0gZW5jb2RlZCAoYHhuLS0uLi5gKSByb290IHpvbmVzIGFyZSBvay5cbiAqXG4gKiBJZiBsaXN0IGlzIHJlcGxhY2VkLCB0aGVuIGV4YWN0IG1hdGNoIGZvciAyLWNoYXJzIHJvb3Qgem9uZXMgd2lsbCBiZSBjaGVja2VkLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50bGRzID0gZnVuY3Rpb24gdGxkcyhsaXN0LCBrZWVwT2xkKSB7XG4gIGxpc3QgPSBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdCA6IFsgbGlzdCBdO1xuXG4gIGlmICgha2VlcE9sZCkge1xuICAgIHRoaXMuX190bGRzX18gPSBsaXN0LnNsaWNlKCk7XG4gICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XG4gICAgY29tcGlsZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX190bGRzX18gPSB0aGlzLl9fdGxkc19fLmNvbmNhdChsaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCAhPT0gYXJyW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcblxuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I25vcm1hbGl6ZShtYXRjaClcbiAqXG4gKiBEZWZhdWx0IG5vcm1hbGl6ZXIgKGlmIHNjaGVtYSBkb2VzIG5vdCBkZWZpbmUgaXQncyBvd24pLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWF0Y2gpIHtcblxuICAvLyBEbyBtaW5pbWFsIHBvc3NpYmxlIGNoYW5nZXMgYnkgZGVmYXVsdC4gTmVlZCB0byBjb2xsZWN0IGZlZWRiYWNrIHByaW9yXG4gIC8vIHRvIG1vdmUgZm9yd2FyZCBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdC9pc3N1ZXMvMVxuXG4gIGlmICghbWF0Y2guc2NoZW1hKSB7IG1hdGNoLnVybCA9ICdodHRwOi8vJyArIG1hdGNoLnVybDsgfVxuXG4gIGlmIChtYXRjaC5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdChtYXRjaC51cmwpKSB7XG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I29uQ29tcGlsZSgpXG4gKlxuICogT3ZlcnJpZGUgdG8gbW9kaWZ5IGJhc2ljIFJlZ0V4cC1zLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5vbkNvbXBpbGUgPSBmdW5jdGlvbiBvbkNvbXBpbGUoKSB7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgcmUgPSB7fTtcblxuICAvLyBVc2UgZGlyZWN0IGV4dHJhY3QgaW5zdGVhZCBvZiBgcmVnZW5lcmF0ZWAgdG8gcmVkdXNlIGJyb3dzZXJpZmllZCBzaXplXG4gIHJlLnNyY19BbnkgPSByZXF1aXJlKCd1Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX0NjICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19aICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19QICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgnKS5zb3VyY2U7XG5cbiAgLy8gXFxwe1xcWlxcUFxcQ2NcXENGfSAod2hpdGUgc3BhY2VzICsgY29udHJvbCArIGZvcm1hdCArIHB1bmN0dWF0aW9uKVxuICByZS5zcmNfWlBDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19QLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gXFxwe1xcWlxcQ2N9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sKVxuICByZS5zcmNfWkNjID0gWyByZS5zcmNfWiwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIEV4cGVyaW1lbnRhbC4gTGlzdCBvZiBjaGFycywgY29tcGxldGVseSBwcm9oaWJpdGVkIGluIGxpbmtzXG4gIC8vIGJlY2F1c2UgY2FuIHNlcGFyYXRlIGl0IGZyb20gb3RoZXIgcGFydCBvZiB0ZXh0XG4gIHZhciB0ZXh0X3NlcGFyYXRvcnMgPSAnWz48XFx1ZmY1Y10nO1xuXG4gIC8vIEFsbCBwb3NzaWJsZSB3b3JkIGNoYXJhY3RlcnMgKGV2ZXJ5dGhpbmcgd2l0aG91dCBwdW5jdHVhdGlvbiwgc3BhY2VzICYgY29udHJvbHMpXG4gIC8vIERlZmluZWQgdmlhIHB1bmN0dWF0aW9uICYgc3BhY2VzIHRvIHNhdmUgc3BhY2VcbiAgLy8gU2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlIFxccHtcXExcXE5cXFNcXE19IChcXHcgYnV0IHdpdGhvdXQgYF9gKVxuICByZS5zcmNfcHNldWRvX2xldHRlciAgICAgICA9ICcoPzooPyEnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKScgKyByZS5zcmNfQW55ICsgJyknO1xuICAvLyBUaGUgc2FtZSBhcyBhYm90aGUgYnV0IHdpdGhvdXQgWzAtOV1cbiAgLy8gdmFyIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kID0gJyg/Oig/IVswLTldfCcgKyBzcmNfWlBDYyArICcpJyArIHNyY19BbnkgKyAnKSc7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICByZS5zcmNfaXA0ID1cblxuICAgICcoPzooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJztcblxuICAvLyBQcm9oaWJpdCBhbnkgb2YgXCJAL1tdKClcIiBpbiB1c2VyL3Bhc3MgdG8gYXZvaWQgd3JvbmcgZG9tYWluIGZldGNoLlxuICByZS5zcmNfYXV0aCAgICA9ICcoPzooPzooPyEnICsgcmUuc3JjX1pDYyArICd8W0AvXFxcXFtcXFxcXSgpXSkuKStAKT8nO1xuXG4gIHJlLnNyY19wb3J0ID1cblxuICAgICcoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT8nO1xuXG4gIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgPVxuXG4gICAgJyg/PSR8JyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJykoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8JyArIHJlLnNyY19aUENjICsgJykpJztcblxuICByZS5zcmNfcGF0aCA9XG5cbiAgICAnKD86JyArXG4gICAgICAnWy8/I10nICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAgICcoPyEnICsgcmUuc3JjX1pDYyArICd8JyArIHRleHRfc2VwYXJhdG9ycyArICd8WygpW1xcXFxde30uLFwiXFwnPyFcXFxcLV0pLnwnICtcbiAgICAgICAgICAnXFxcXFsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8XFxcXF0pLikqXFxcXF18JyArXG4gICAgICAgICAgJ1xcXFwoKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFspXSkuKSpcXFxcKXwnICtcbiAgICAgICAgICAnXFxcXHsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W31dKS4pKlxcXFx9fCcgK1xuICAgICAgICAgICdcXFxcXCIoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W1wiXSkuKStcXFxcXCJ8JyArXG4gICAgICAgICAgXCJcXFxcJyg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFsnXSkuKStcXFxcJ3xcIiArXG4gICAgICAgICAgXCJcXFxcJyg/PVwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnfFstXSkufCcgKyAgLy8gYWxsb3cgYEknbV9raW5nYCBpZiBubyBwYWlyIGZvdW5kXG4gICAgICAgICAgJ1xcXFwuezIsM31bYS16QS1aMC05JS9dfCcgKyAvLyBnaXRodWIgaGFzIC4uLiBpbiBjb21taXQgcmFuZ2UgbGlua3MuIFJlc3RyaWN0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXSkufCcgK1xuICAgICAgICAgIChvcHRzICYmIG9wdHNbJy0tLSddID9cbiAgICAgICAgICAgICdcXFxcLSg/IS0tKD86W14tXXwkKSkoPzotKil8JyAvLyBgLS0tYCA9PiBsb25nIGRhc2gsIHRlcm1pbmF0ZVxuICAgICAgICAgIDpcbiAgICAgICAgICAgICdcXFxcLSt8J1xuICAgICAgICAgICkgK1xuICAgICAgICAgICdcXFxcLCg/IScgKyByZS5zcmNfWkNjICsgJykufCcgKyAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJ1xcXFwhKD8hJyArIHJlLnNyY19aQ2MgKyAnfFshXSkufCcgK1xuICAgICAgICAgICdcXFxcPyg/IScgKyByZS5zcmNfWkNjICsgJ3xbP10pLicgK1xuICAgICAgICAnKSsnICtcbiAgICAgICd8XFxcXC8nICtcbiAgICAnKT8nO1xuXG4gIHJlLnNyY19lbWFpbF9uYW1lID1cblxuICAgICdbXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKyc7XG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XG5cbiAgLy8gTW9yZSB0byByZWFkIGFib3V0IGRvbWFpbiBuYW1lc1xuICAvLyBodHRwOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy82MzgyNjAvXG5cbiAgcmUuc3JjX2RvbWFpbl9yb290ID1cblxuICAgIC8vIEFsbG93IGxldHRlcnMgJiBkaWdpdHMgKGh0dHA6Ly90ZXN0MSlcbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3sxLDYzfScgK1xuICAgICcpJztcblxuICByZS5zcmNfZG9tYWluID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgICAnfCcgK1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgYC0tYCBpbiBkb21haW4gbmFtZXMsIGJlY2F1c2U6XG4gICAgICAvLyAtIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggbWFya2Rvd24gJm1kYXNoOyAvICZuZGFzaDtcbiAgICAgIC8vIC0gbm9ib2R5IHVzZSB0aG9zZSBhbnl3YXlcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKD86LSg/IS0pfCcgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpezAsNjF9JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLypfcm9vdCovICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3RfZnV6enkgPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX2lwNCArXG4gICAgJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJztcblxuICByZS5zcmNfaG9zdF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJ1bGVzXG5cbiAgLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XG4gIHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QgPVxuXG4gICAgJ2xvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzonICsgcmUuc3JjX1pQQ2MgKyAnfD58JCkpJztcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKSgnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfbm9faXBfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmV0dXJuIHJlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMTAwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzIiwiLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXG4vLyBtb2Rlcy4gRm9yIGV4YW1wbGUsIHRvIHBhcnNlIGJvbGQvaXRhbGljIG9ubHkuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwiLy8gQ29tbW9ubWFyayBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICB0cnVlLCAgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICB0cnVlLCAgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnZmVuY2UnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdocicsXG4gICAgICAgICdodG1sX2Jsb2NrJyxcbiAgICAgICAgJ2xoZWFkaW5nJyxcbiAgICAgICAgJ2xpc3QnLFxuICAgICAgICAncmVmZXJlbmNlJyxcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYXV0b2xpbmsnLFxuICAgICAgICAnYmFja3RpY2tzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2VudGl0eScsXG4gICAgICAgICdlc2NhcGUnLFxuICAgICAgICAnaHRtbF9pbmxpbmUnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAnbGluaycsXG4gICAgICAgICduZXdsaW5lJyxcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCIndXNlIHN0cmljdCdcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cbnZhciB0YWdFeHByID0gL148IS0tID9cXHsoPzooW2EtejAtOV0rKShcXF5bMC05XSopPzogPyk/KC4qKVxcfSA/LS0+XFxuPyQvXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXR0cmlidXRlcyAobWQpIHtcbiAgbWQuY29yZS5ydWxlci5wdXNoKCdjdXJseV9hdHRyaWJ1dGVzJywgY3VybHlBdHRycylcbn1cblxuLypcbiAqIExpc3Qgb2YgdGFnIC0+IHRva2VuIHR5cGUgbWFwcGluZ3MuIEVnLCBgPGxpPmAgaXMgYGxpc3RfaXRlbV9vcGVuYC5cbiAqL1xuXG52YXIgb3BlbmluZyA9IHtcbiAgbGk6IFsnbGlzdF9pdGVtJ10sXG4gIHVsOiBbJ2J1bGxldF9saXN0J10sXG4gIHA6IFsncGFyYWdyYXBoJ10sXG4gIG9sOiBbJ29yZGVyZWRfbGlzdCddLFxuICBibG9ja3F1b3RlOiBbJ2Jsb2NrcXVvdGUnXSxcbiAgaDE6IFsnaGVhZGluZyddLFxuICBoMjogWydoZWFkaW5nJ10sXG4gIGgzOiBbJ2hlYWRpbmcnXSxcbiAgaDQ6IFsnaGVhZGluZyddLFxuICBoNTogWydoZWFkaW5nJ10sXG4gIGg2OiBbJ2hlYWRpbmcnXSxcbiAgYTogWydsaW5rJ10sXG4gIGNvZGU6IFsnY29kZV9pbmxpbmUnLCAnY29kZV9ibG9jaycsICdmZW5jZSddXG59XG5cbnZhciBzZWxmQ2xvc2luZyA9IHtcbiAgaHI6IHRydWUsXG4gIGltYWdlOiB0cnVlXG59XG5cbi8qKlxuICogLi4uXG4gKi9cblxuZnVuY3Rpb24gY3VybHlBdHRycyAoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2Vuc1xuICB2YXIgb21pc3Npb25zID0gW11cbiAgdmFyIHBhcmVudCwgbVxuICB2YXIgc3RhY2sgPSB7IGxlbjogMCwgY29udGVudHM6IFtdLCB0eXBlczoge30gfVxuXG4gIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbiwgaSkge1xuICAgIC8vIFNhdmUgYnJlYWRjcnVtYnMgc28gaHRtbF9ibG9jayB3aWxsIHBpY2sgaXQgdXBcbiAgICBpZiAoaXNPcGVuZXIodG9rZW4udHlwZSkgfHwgc2VsZkNsb3NpbmdbdG9rZW4udHlwZV0pIHtcbiAgICAgIHNwdXNoKHN0YWNrLCB0b2tlbilcbiAgICB9XG5cbiAgICAvLyBcIiMgSGVsbG9cXG48IS0tey5jbGFzc25hbWV9LS0+XCJcbiAgICAvLyAuLi5zZXF1ZW5jZSBvZiBbaGVhZGluZ19vcGVuLCBpbmxpbmUsIGhlYWRpbmdfY2xvc2UsIGh0bWxfYmxvY2tdXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdodG1sX2Jsb2NrJykge1xuICAgICAgbSA9IHRva2VuLmNvbnRlbnQubWF0Y2godGFnRXhwcilcbiAgICAgIGlmICghbSkgcmV0dXJuXG5cbiAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnQoc3RhY2ssIG1bMV0sIG1bMl0pXG4gICAgICBpZiAocGFyZW50ICYmIGFwcGx5VG9Ub2tlbihwYXJlbnQsIG1bM10pKSB7XG4gICAgICAgIG9taXNzaW9ucy51bnNoaWZ0KGkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gXCIjIEhlbGxvIDwhLS17LmNsYXNzbmFtZX0gLS0+XCJcbiAgICAvLyB7IHR5cGU6ICdpbmxpbmUnLCBjaGlsZHJlbjogeyAuLi4sICc8IS0tey4uLn0tLT4nIH0gfVxuICAgIGlmICh0b2tlbi50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgY3VybHlJbmxpbmUodG9rZW4uY2hpbGRyZW4sIHN0YWNrKVxuICAgIH1cbiAgfSlcblxuICAvLyBSZW1vdmUgPCEtLS4uLi0tPiBodG1sX2Jsb2NrIHRva2Vuc1xuICBvbWlzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiB0b2tlbnMuc3BsaWNlKGlkeCwgMSkgfSlcbn1cblxuLyoqXG4gKiBJbnRlcm5hbDogY2hlY2tzIGluIGEgdG9rZW4gdHlwZSBpcyBhIGJsb2NrIG9wZW5lclxuICovXG5cbmZ1bmN0aW9uIGlzT3BlbmVyICh0eXBlKSB7XG4gIHJldHVybiB0eXBlLm1hdGNoKC9fKG9wZW58c3RhcnQpJC8pIHx8XG4gICAgdHlwZSA9PT0gJ2ZlbmNlJyB8fCB0eXBlID09PSAnY29kZV9ibG9jaydcbn1cblxuLyoqXG4gKiBJbnRlcm5hbDogUnVuIHRocm91Z2ggaW5saW5lIGFuZCBzdHVmZlxuICovXG5cbmZ1bmN0aW9uIGN1cmx5SW5saW5lIChjaGlsZHJlbiwgc3RhY2spIHtcbiAgdmFyIGxhc3RUZXh0LCBtLCBwYXJlbnRcblxuICAvLyBLZWVwIGEgbGlzdCBvZiBzdWItdG9rZW5zIHRvIGJlIHJlbW92ZWRcbiAgdmFyIG9taXNzaW9ucyA9IFtdXG5cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICBpZiAoaXNPcGVuZXIoY2hpbGQudHlwZSkgfHxcbiAgICAgIHNlbGZDbG9zaW5nW2NoaWxkLnR5cGVdIHx8XG4gICAgICBjaGlsZC50eXBlID09PSAnY29kZV9pbmxpbmUnKSB7XG4gICAgICBzcHVzaChzdGFjaywgY2hpbGQpXG4gICAgfVxuXG4gICAgLy8gRGVjb3JhdGUgdGFncyBhcmUgZm91bmRcbiAgICBpZiAobSA9IGNoaWxkLmNvbnRlbnQubWF0Y2godGFnRXhwcikpIHtcbiAgICAgIHZhciB0YWcgPSBtWzFdXG4gICAgICB2YXIgZGVwdGggPSBtWzJdXG4gICAgICB2YXIgYXR0cnMgPSBtWzNdXG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgY29tbWVudCwgdGhlbiByZW1vdmUgdGhlIGV4dHJhIHNwYWNlXG4gICAgICBwYXJlbnQgPSBmaW5kUGFyZW50KHN0YWNrLCB0YWcsIGRlcHRoKVxuICAgICAgaWYgKHBhcmVudCAmJiBhcHBseVRvVG9rZW4ocGFyZW50LCBhdHRycykpIHtcbiAgICAgICAgb21pc3Npb25zLnVuc2hpZnQoaSlcbiAgICAgICAgaWYgKGxhc3RUZXh0KSB0cmltUmlnaHQobGFzdFRleHQsICdjb250ZW50JylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3RleHQnKSBsYXN0VGV4dCA9IGNoaWxkXG4gIH0pXG5cbiAgLy8gUmVtb3ZlIHRoZW0gaW4gYSBzZXBhcmF0ZSBzdGVwIHNvIHdlIGRvbid0XG4gIG9taXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKVxuICB9KVxufVxuXG4vKipcbiAqIFByaXZhdGU6IGdpdmVuIGEgbGlzdCBvZiB0b2tlbnMgYGxpc3RgIGFuZCBgbGFzdFBhcmVudGAsIGZpbmQgdGhlIG9uZSB0aGF0XG4gKiBtYXRjaGVzIGB0YWdgLlxuICovXG5cbmZ1bmN0aW9uIGZpbmRQYXJlbnQgKHN0YWNrLCB0YWcsIGRlcHRoKSB7XG4gIGlmICghdGFnKSByZXR1cm4gc3RhY2subGFzdFxuXG4gIGlmIChkZXB0aCA9PT0gJ14nKSB7XG4gICAgZGVwdGggPSAxXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlcHRoID09PSAnc3RyaW5nJykgeyAvKiAnXjInICovXG4gICAgZGVwdGggPSArZGVwdGguc3Vic3RyKDEpXG4gIH0gZWxzZSB7XG4gICAgZGVwdGggPSAwXG4gIH1cblxuICB2YXIgdGFyZ2V0cyA9IG9wZW5pbmdbdGFnLnRvTG93ZXJDYXNlKCldIHx8IFt0YWcudG9Mb3dlckNhc2UoKV1cblxuICB2YXIgdGFyZ2V0ID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiBzdGFjay50eXBlc1t0YXJnZXRdXG4gIH0pXG5cbiAgdmFyIGxpc3QgPSBzdGFjay50eXBlc1t0YXJnZXRdXG4gIGlmICghbGlzdCkgcmV0dXJuIC8vIENhbid0IGZpbmQgdGFnIGB0YWdgXG5cbiAgcmV0dXJuIGxpc3RbbGlzdC5sZW5ndGggLSAxIC0gZGVwdGhdXG59XG5cbi8qKlxuICogUHJpdmF0ZTogdHJpbSB0aGUgcmlnaHRcbiAqL1xuXG5mdW5jdGlvbiB0cmltUmlnaHQgKG9iaiwgYXR0cikge1xuICBvYmpbYXR0cl0gPSBvYmpbYXR0cl0ucmVwbGFjZSgvXFxzKiQvLCAnJylcbn1cblxuLyoqXG4gKiBQcml2YXRlOiBhcHBseSB0YWcgdG8gdG9rZW5cbiAqXG4gKiAgICAgYXBwbHlUb1Rva2VuKHRva2VuLCAnLmNsYXNzbmFtZScpXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUb1Rva2VuICh0b2tlbiwgYXR0cnMpIHtcbiAgdmFyIG1cbiAgdmFyIHRvZG8gPSBbXVxuXG4gIHdoaWxlIChhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccypcXC4oW2EtekEtWjAtOVxcLV9dKykvKSkge1xuICAgICAgdG9kby5wdXNoKFsgJ2NsYXNzJywgbVsxXSwgeyBhcHBlbmQ6IHRydWUgfSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKiMoW2EtekEtWjAtOVxcLV9dKykvKSkge1xuICAgICAgdG9kby5wdXNoKFsgJ2lkJywgbVsxXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKT1cIihbXlwiXSopXCIvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKT0nKFteJ10qKScvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKT0oW14gXSopLykpIHtcbiAgICAgIHRvZG8ucHVzaChbIG1bMV0sIG1bMl0gXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccyooW2EtekEtWjAtOVxcLV9dKykvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgJycgXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccysvKSkge1xuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB0b2RvLmZvckVhY2goZnVuY3Rpb24gKGFyZ3MpIHsgc2V0QXR0ci5hcHBseSh0aGlzLCBbdG9rZW5dLmNvbmNhdChhcmdzKSkgfSlcbiAgcmV0dXJuIHRydWVcblxuICBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgYXR0cnMgPSBhdHRycy5zdWJzdHIobVswXS5sZW5ndGgpXG4gIH1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiBzZXRzIGFuIGF0dHJpYnV0ZSBgYXR0cmAgdG8gYHZhbHVlYCBpbiBhIHRva2VuLiBJZiBgb3B0aW9ucy5hcHBlbmRgXG4gKiBpcyB0cnVlLCBhcHBlbmQgdG8gdGhlIG9sZCB2YWx1ZSBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nIGl0LlxuICovXG5cbmZ1bmN0aW9uIHNldEF0dHIgKHRva2VuLCBhdHRyLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgaWR4ID0gdG9rZW4uYXR0ckluZGV4KGF0dHIpXG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICB0b2tlbi5hdHRyUHVzaChbIGF0dHIsIHZhbHVlIF0pXG4gIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFwcGVuZCkge1xuICAgIHRva2VuLmF0dHJzW2lkeF1bMV0gPVxuICAgICAgdG9rZW4uYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdG9rZW4uYXR0cnNbaWR4XVsxXSA9IHZhbHVlXG4gIH1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiBwdXNoZXMgYSB0b2tlbiB0byB0aGUgc3RhY2tcbiAqL1xuXG5mdW5jdGlvbiBzcHVzaCAoc3RhY2ssIHRva2VuKSB7XG4gIHZhciB0eXBlID0gdG9rZW4udHlwZS5yZXBsYWNlKC9fKG9wZW58c3RhcnQpJC8sICcnKVxuICBpZiAoIXN0YWNrLnR5cGVzW3R5cGVdKSB7IHN0YWNrLnR5cGVzW3R5cGVdID0gW10gfVxuICBzdGFjay50eXBlc1t0eXBlXS5wdXNoKHRva2VuKVxuICBzdGFjay5sYXN0ID0gdG9rZW5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC1kZWNvcmF0ZS9pbmRleC5qcyIsIi8qXG5TeW50YXggaGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgYXV0b2RldGVjdGlvbi5cbmh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblxuICAvLyBGaW5kIHRoZSBnbG9iYWwgb2JqZWN0IGZvciBleHBvcnQgdG8gYm90aCB0aGUgYnJvd3NlciBhbmQgd2ViIHdvcmtlcnMuXG4gIHZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cgfHxcbiAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmO1xuXG4gIC8vIFNldHVwIGhpZ2hsaWdodC5qcyBmb3IgZGlmZmVyZW50IGVudmlyb25tZW50cy4gRmlyc3QgaXMgTm9kZS5qcyBvclxuICAvLyBDb21tb25KUy5cbiAgaWYodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTtcbiAgfSBlbHNlIGlmKGdsb2JhbE9iamVjdCkge1xuICAgIC8vIEV4cG9ydCBobGpzIGdsb2JhbGx5IGV2ZW4gd2hlbiB1c2luZyBBTUQgZm9yIGNhc2VzIHdoZW4gdGhpcyBzY3JpcHRcbiAgICAvLyBpcyBsb2FkZWQgd2l0aCBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIGhsanMuXG4gICAgZ2xvYmFsT2JqZWN0LmhsanMgPSBmYWN0b3J5KHt9KTtcblxuICAgIC8vIEZpbmFsbHkgcmVnaXN0ZXIgdGhlIGdsb2JhbCBobGpzIHdpdGggQU1ELlxuICAgIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbE9iamVjdC5obGpzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn0oZnVuY3Rpb24oaGxqcykge1xuICAvLyBDb252ZW5pZW5jZSB2YXJpYWJsZXMgZm9yIGJ1aWxkLWluIG9iamVjdHNcbiAgdmFyIEFycmF5UHJvdG8gPSBbXSxcbiAgICAgIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cztcblxuICAvLyBHbG9iYWwgaW50ZXJuYWwgdmFyaWFibGVzIHVzZWQgd2l0aGluIHRoZSBoaWdobGlnaHQuanMgbGlicmFyeS5cbiAgdmFyIGxhbmd1YWdlcyA9IHt9LFxuICAgICAgYWxpYXNlcyAgID0ge307XG5cbiAgLy8gUmVndWxhciBleHByZXNzaW9ucyB1c2VkIHRocm91Z2hvdXQgdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICB2YXIgbm9IaWdobGlnaHRSZSAgICA9IC9eKG5vLT9oaWdobGlnaHR8cGxhaW58dGV4dCkkL2ksXG4gICAgICBsYW5ndWFnZVByZWZpeFJlID0gL1xcYmxhbmcoPzp1YWdlKT8tKFtcXHctXSspXFxiL2ksXG4gICAgICBmaXhNYXJrdXBSZSAgICAgID0gLygoXig8W14+XSs+fFxcdHwpK3woPzpcXG4pKSkvZ207XG5cbiAgdmFyIHNwYW5FbmRUYWcgPSAnPC9zcGFuPic7XG5cbiAgLy8gR2xvYmFsIG9wdGlvbnMgdXNlZCB3aGVuIHdpdGhpbiBleHRlcm5hbCBBUElzLiBUaGlzIGlzIG1vZGlmaWVkIHdoZW5cbiAgLy8gY2FsbGluZyB0aGUgYGhsanMuY29uZmlndXJlYCBmdW5jdGlvbi5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgY2xhc3NQcmVmaXg6ICdobGpzLScsXG4gICAgdGFiUmVwbGFjZTogbnVsbCxcbiAgICB1c2VCUjogZmFsc2UsXG4gICAgbGFuZ3VhZ2VzOiB1bmRlZmluZWRcbiAgfTtcblxuXG4gIC8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbiAgZnVuY3Rpb24gZXNjYXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RSZShyZSwgbGV4ZW1lKSB7XG4gICAgdmFyIG1hdGNoID0gcmUgJiYgcmUuZXhlYyhsZXhlbWUpO1xuICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaC5pbmRleCA9PT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SGlnaGxpZ2h0ZWQobGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gbm9IaWdobGlnaHRSZS50ZXN0KGxhbmd1YWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJsb2NrTGFuZ3VhZ2UoYmxvY2spIHtcbiAgICB2YXIgaSwgbWF0Y2gsIGxlbmd0aCwgX2NsYXNzO1xuICAgIHZhciBjbGFzc2VzID0gYmxvY2suY2xhc3NOYW1lICsgJyAnO1xuXG4gICAgY2xhc3NlcyArPSBibG9jay5wYXJlbnROb2RlID8gYmxvY2sucGFyZW50Tm9kZS5jbGFzc05hbWUgOiAnJztcblxuICAgIC8vIGxhbmd1YWdlLSogdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5vbi1wcmVmaXhlZCBjbGFzcyBuYW1lcy5cbiAgICBtYXRjaCA9IGxhbmd1YWdlUHJlZml4UmUuZXhlYyhjbGFzc2VzKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBnZXRMYW5ndWFnZShtYXRjaFsxXSkgPyBtYXRjaFsxXSA6ICduby1oaWdobGlnaHQnO1xuICAgIH1cblxuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBfY2xhc3MgPSBjbGFzc2VzW2ldXG5cbiAgICAgIGlmIChpc05vdEhpZ2hsaWdodGVkKF9jbGFzcykgfHwgZ2V0TGFuZ3VhZ2UoX2NsYXNzKSkge1xuICAgICAgICByZXR1cm4gX2NsYXNzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaGVyaXQocGFyZW50KSB7ICAvLyBpbmhlcml0KHBhcmVudCwgb3ZlcnJpZGVfb2JqLCBvdmVycmlkZV9vYmosIC4uLilcbiAgICB2YXIga2V5O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpXG4gICAgICByZXN1bHRba2V5XSA9IHBhcmVudFtrZXldO1xuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGZvciAoa2V5IGluIG9iailcbiAgICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyogU3RyZWFtIG1lcmdpbmcgKi9cblxuICBmdW5jdGlvbiBub2RlU3RyZWFtKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgKGZ1bmN0aW9uIF9ub2RlU3RyZWFtKG5vZGUsIG9mZnNldCkge1xuICAgICAgZm9yICh2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMylcbiAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgbm9kZTogY2hpbGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZVN0cmVhbShjaGlsZCwgb2Zmc2V0KTtcbiAgICAgICAgICAvLyBQcmV2ZW50IHZvaWQgZWxlbWVudHMgZnJvbSBoYXZpbmcgYW4gZW5kIHRhZyB0aGF0IHdvdWxkIGFjdHVhbGx5XG4gICAgICAgICAgLy8gZG91YmxlIHRoZW0gaW4gdGhlIG91dHB1dC4gVGhlcmUgYXJlIG1vcmUgdm9pZCBlbGVtZW50cyBpbiBIVE1MXG4gICAgICAgICAgLy8gYnV0IHdlIGxpc3Qgb25seSB0aG9zZSByZWFsaXN0aWNhbGx5IGV4cGVjdGVkIGluIGNvZGUgZGlzcGxheS5cbiAgICAgICAgICBpZiAoIXRhZyhjaGlsZCkubWF0Y2goL2JyfGhyfGltZ3xpbnB1dC8pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIGV2ZW50OiAnc3RvcCcsXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0pKG5vZGUsIDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVN0cmVhbXMob3JpZ2luYWwsIGhpZ2hsaWdodGVkLCB2YWx1ZSkge1xuICAgIHZhciBwcm9jZXNzZWQgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbm9kZVN0YWNrID0gW107XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RTdHJlYW0oKSB7XG4gICAgICBpZiAoIW9yaWdpbmFsLmxlbmd0aCB8fCAhaGlnaGxpZ2h0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5sZW5ndGggPyBvcmlnaW5hbCA6IGhpZ2hsaWdodGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsWzBdLm9mZnNldCAhPT0gaGlnaGxpZ2h0ZWRbMF0ub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWxbMF0ub2Zmc2V0IDwgaGlnaGxpZ2h0ZWRbMF0ub2Zmc2V0KSA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBUbyBhdm9pZCBzdGFydGluZyB0aGUgc3RyZWFtIGp1c3QgYmVmb3JlIGl0IHNob3VsZCBzdG9wIHRoZSBvcmRlciBpc1xuICAgICAgZW5zdXJlZCB0aGF0IG9yaWdpbmFsIGFsd2F5cyBzdGFydHMgZmlyc3QgYW5kIGNsb3NlcyBsYXN0OlxuXG4gICAgICBpZiAoZXZlbnQxID09ICdzdGFydCcgJiYgZXZlbnQyID09ICdzdGFydCcpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgIGlmIChldmVudDEgPT0gJ3N0YXJ0JyAmJiBldmVudDIgPT0gJ3N0b3AnKVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQ7XG4gICAgICBpZiAoZXZlbnQxID09ICdzdG9wJyAmJiBldmVudDIgPT0gJ3N0YXJ0JylcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RvcCcgJiYgZXZlbnQyID09ICdzdG9wJylcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkO1xuXG4gICAgICAuLi4gd2hpY2ggaXMgY29sbGFwc2VkIHRvOlxuICAgICAgKi9cbiAgICAgIHJldHVybiBoaWdobGlnaHRlZFswXS5ldmVudCA9PT0gJ3N0YXJ0JyA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3Blbihub2RlKSB7XG4gICAgICBmdW5jdGlvbiBhdHRyX3N0cihhKSB7cmV0dXJuICcgJyArIGEubm9kZU5hbWUgKyAnPVwiJyArIGVzY2FwZShhLnZhbHVlKS5yZXBsYWNlKCdcIicsICcmcXVvdDsnKSArICdcIic7fVxuICAgICAgcmVzdWx0ICs9ICc8JyArIHRhZyhub2RlKSArIEFycmF5UHJvdG8ubWFwLmNhbGwobm9kZS5hdHRyaWJ1dGVzLCBhdHRyX3N0cikuam9pbignJykgKyAnPic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2Uobm9kZSkge1xuICAgICAgcmVzdWx0ICs9ICc8LycgKyB0YWcobm9kZSkgKyAnPic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKGV2ZW50KSB7XG4gICAgICAoZXZlbnQuZXZlbnQgPT09ICdzdGFydCcgPyBvcGVuIDogY2xvc2UpKGV2ZW50Lm5vZGUpO1xuICAgIH1cblxuICAgIHdoaWxlIChvcmlnaW5hbC5sZW5ndGggfHwgaGlnaGxpZ2h0ZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgc3RyZWFtID0gc2VsZWN0U3RyZWFtKCk7XG4gICAgICByZXN1bHQgKz0gZXNjYXBlKHZhbHVlLnN1YnN0cmluZyhwcm9jZXNzZWQsIHN0cmVhbVswXS5vZmZzZXQpKTtcbiAgICAgIHByb2Nlc3NlZCA9IHN0cmVhbVswXS5vZmZzZXQ7XG4gICAgICBpZiAoc3RyZWFtID09PSBvcmlnaW5hbCkge1xuICAgICAgICAvKlxuICAgICAgICBPbiBhbnkgb3BlbmluZyBvciBjbG9zaW5nIHRhZyBvZiB0aGUgb3JpZ2luYWwgbWFya3VwIHdlIGZpcnN0IGNsb3NlXG4gICAgICAgIHRoZSBlbnRpcmUgaGlnaGxpZ2h0ZWQgbm9kZSBzdGFjaywgdGhlbiByZW5kZXIgdGhlIG9yaWdpbmFsIHRhZyBhbG9uZ1xuICAgICAgICB3aXRoIGFsbCB0aGUgZm9sbG93aW5nIG9yaWdpbmFsIHRhZ3MgYXQgdGhlIHNhbWUgb2Zmc2V0IGFuZCB0aGVuXG4gICAgICAgIHJlb3BlbiBhbGwgdGhlIHRhZ3Mgb24gdGhlIGhpZ2hsaWdodGVkIHN0YWNrLlxuICAgICAgICAqL1xuICAgICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2goY2xvc2UpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcmVuZGVyKHN0cmVhbS5zcGxpY2UoMCwgMSlbMF0pO1xuICAgICAgICAgIHN0cmVhbSA9IHNlbGVjdFN0cmVhbSgpO1xuICAgICAgICB9IHdoaWxlIChzdHJlYW0gPT09IG9yaWdpbmFsICYmIHN0cmVhbS5sZW5ndGggJiYgc3RyZWFtWzBdLm9mZnNldCA9PT0gcHJvY2Vzc2VkKTtcbiAgICAgICAgbm9kZVN0YWNrLnJldmVyc2UoKS5mb3JFYWNoKG9wZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0cmVhbVswXS5ldmVudCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIG5vZGVTdGFjay5wdXNoKHN0cmVhbVswXS5ub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKHN0cmVhbS5zcGxpY2UoMCwgMSlbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlKHZhbHVlLnN1YnN0cihwcm9jZXNzZWQpKTtcbiAgfVxuXG4gIC8qIEluaXRpYWxpemF0aW9uICovXG5cbiAgZnVuY3Rpb24gZXhwYW5kX21vZGUobW9kZSkge1xuICAgIGlmIChtb2RlLnZhcmlhbnRzICYmICFtb2RlLmNhY2hlZF92YXJpYW50cykge1xuICAgICAgbW9kZS5jYWNoZWRfdmFyaWFudHMgPSBtb2RlLnZhcmlhbnRzLm1hcChmdW5jdGlvbih2YXJpYW50KSB7XG4gICAgICAgIHJldHVybiBpbmhlcml0KG1vZGUsIHt2YXJpYW50czogbnVsbH0sIHZhcmlhbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlLmNhY2hlZF92YXJpYW50cyB8fCAobW9kZS5lbmRzV2l0aFBhcmVudCAmJiBbaW5oZXJpdChtb2RlKV0pIHx8IFttb2RlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSkge1xuXG4gICAgZnVuY3Rpb24gcmVTdHIocmUpIHtcbiAgICAgICAgcmV0dXJuIChyZSAmJiByZS5zb3VyY2UpIHx8IHJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxhbmdSZSh2YWx1ZSwgZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgICAgcmVTdHIodmFsdWUpLFxuICAgICAgICAnbScgKyAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKSArIChnbG9iYWwgPyAnZycgOiAnJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGlsZU1vZGUobW9kZSwgcGFyZW50KSB7XG4gICAgICBpZiAobW9kZS5jb21waWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbW9kZS5jb21waWxlZCA9IHRydWU7XG5cbiAgICAgIG1vZGUua2V5d29yZHMgPSBtb2RlLmtleXdvcmRzIHx8IG1vZGUuYmVnaW5LZXl3b3JkcztcbiAgICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICAgIHZhciBjb21waWxlZF9rZXl3b3JkcyA9IHt9O1xuXG4gICAgICAgIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBzdHIpIHtcbiAgICAgICAgICBpZiAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ci5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oa3cpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0ga3cuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgIGNvbXBpbGVkX2tleXdvcmRzW3BhaXJbMF1dID0gW2NsYXNzTmFtZSwgcGFpclsxXSA/IE51bWJlcihwYWlyWzFdKSA6IDFdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kZS5rZXl3b3JkcyA9PT0gJ3N0cmluZycpIHsgLy8gc3RyaW5nXG4gICAgICAgICAgZmxhdHRlbigna2V5d29yZCcsIG1vZGUua2V5d29yZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdEtleXMobW9kZS5rZXl3b3JkcykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBmbGF0dGVuKGNsYXNzTmFtZSwgbW9kZS5rZXl3b3Jkc1tjbGFzc05hbWVdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZWRfa2V5d29yZHM7XG4gICAgICB9XG4gICAgICBtb2RlLmxleGVtZXNSZSA9IGxhbmdSZShtb2RlLmxleGVtZXMgfHwgL1xcdysvLCB0cnVlKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBpZiAobW9kZS5iZWdpbktleXdvcmRzKSB7XG4gICAgICAgICAgbW9kZS5iZWdpbiA9ICdcXFxcYignICsgbW9kZS5iZWdpbktleXdvcmRzLnNwbGl0KCcgJykuam9pbignfCcpICsgJylcXFxcYic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlLmJlZ2luKVxuICAgICAgICAgIG1vZGUuYmVnaW4gPSAvXFxCfFxcYi87XG4gICAgICAgIG1vZGUuYmVnaW5SZSA9IGxhbmdSZShtb2RlLmJlZ2luKTtcbiAgICAgICAgaWYgKCFtb2RlLmVuZCAmJiAhbW9kZS5lbmRzV2l0aFBhcmVudClcbiAgICAgICAgICBtb2RlLmVuZCA9IC9cXEJ8XFxiLztcbiAgICAgICAgaWYgKG1vZGUuZW5kKVxuICAgICAgICAgIG1vZGUuZW5kUmUgPSBsYW5nUmUobW9kZS5lbmQpO1xuICAgICAgICBtb2RlLnRlcm1pbmF0b3JfZW5kID0gcmVTdHIobW9kZS5lbmQpIHx8ICcnO1xuICAgICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCAmJiBwYXJlbnQudGVybWluYXRvcl9lbmQpXG4gICAgICAgICAgbW9kZS50ZXJtaW5hdG9yX2VuZCArPSAobW9kZS5lbmQgPyAnfCcgOiAnJykgKyBwYXJlbnQudGVybWluYXRvcl9lbmQ7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS5pbGxlZ2FsKVxuICAgICAgICBtb2RlLmlsbGVnYWxSZSA9IGxhbmdSZShtb2RlLmlsbGVnYWwpO1xuICAgICAgaWYgKG1vZGUucmVsZXZhbmNlID09IG51bGwpXG4gICAgICAgIG1vZGUucmVsZXZhbmNlID0gMTtcbiAgICAgIGlmICghbW9kZS5jb250YWlucykge1xuICAgICAgICBtb2RlLmNvbnRhaW5zID0gW107XG4gICAgICB9XG4gICAgICBtb2RlLmNvbnRhaW5zID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgbW9kZS5jb250YWlucy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gZXhwYW5kX21vZGUoYyA9PT0gJ3NlbGYnID8gbW9kZSA6IGMpXG4gICAgICB9KSk7XG4gICAgICBtb2RlLmNvbnRhaW5zLmZvckVhY2goZnVuY3Rpb24oYykge2NvbXBpbGVNb2RlKGMsIG1vZGUpO30pO1xuXG4gICAgICBpZiAobW9kZS5zdGFydHMpIHtcbiAgICAgICAgY29tcGlsZU1vZGUobW9kZS5zdGFydHMsIHBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXJtaW5hdG9ycyA9XG4gICAgICAgIG1vZGUuY29udGFpbnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5iZWdpbktleXdvcmRzID8gJ1xcXFwuPygnICsgYy5iZWdpbiArICcpXFxcXC4/JyA6IGMuYmVnaW47XG4gICAgICAgIH0pXG4gICAgICAgIC5jb25jYXQoW21vZGUudGVybWluYXRvcl9lbmQsIG1vZGUuaWxsZWdhbF0pXG4gICAgICAgIC5tYXAocmVTdHIpXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBtb2RlLnRlcm1pbmF0b3JzID0gdGVybWluYXRvcnMubGVuZ3RoID8gbGFuZ1JlKHRlcm1pbmF0b3JzLmpvaW4oJ3wnKSwgdHJ1ZSkgOiB7ZXhlYzogZnVuY3Rpb24oLypzKi8pIHtyZXR1cm4gbnVsbDt9fTtcbiAgICB9XG5cbiAgICBjb21waWxlTW9kZShsYW5ndWFnZSk7XG4gIH1cblxuICAvKlxuICBDb3JlIGhpZ2hsaWdodGluZyBmdW5jdGlvbi4gQWNjZXB0cyBhIGxhbmd1YWdlIG5hbWUsIG9yIGFuIGFsaWFzLCBhbmQgYVxuICBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICBwcm9wZXJ0aWVzOlxuXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcblxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHQobmFtZSwgdmFsdWUsIGlnbm9yZV9pbGxlZ2FscywgY29udGludWF0aW9uKSB7XG5cbiAgICBmdW5jdGlvbiBzdWJNb2RlKGxleGVtZSwgbW9kZSkge1xuICAgICAgdmFyIGksIGxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbW9kZS5jb250YWlucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGVzdFJlKG1vZGUuY29udGFpbnNbaV0uYmVnaW5SZSwgbGV4ZW1lKSkge1xuICAgICAgICAgIHJldHVybiBtb2RlLmNvbnRhaW5zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIGxleGVtZSkge1xuICAgICAgaWYgKHRlc3RSZShtb2RlLmVuZFJlLCBsZXhlbWUpKSB7XG4gICAgICAgIHdoaWxlIChtb2RlLmVuZHNQYXJlbnQgJiYgbW9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBtb2RlID0gbW9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCkge1xuICAgICAgICByZXR1cm4gZW5kT2ZNb2RlKG1vZGUucGFyZW50LCBsZXhlbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWxsZWdhbChsZXhlbWUsIG1vZGUpIHtcbiAgICAgIHJldHVybiAhaWdub3JlX2lsbGVnYWxzICYmIHRlc3RSZShtb2RlLmlsbGVnYWxSZSwgbGV4ZW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXl3b3JkTWF0Y2gobW9kZSwgbWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaF9zdHIgPSBsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSA6IG1hdGNoWzBdO1xuICAgICAgcmV0dXJuIG1vZGUua2V5d29yZHMuaGFzT3duUHJvcGVydHkobWF0Y2hfc3RyKSAmJiBtb2RlLmtleXdvcmRzW21hdGNoX3N0cl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRTcGFuKGNsYXNzbmFtZSwgaW5zaWRlU3BhbiwgbGVhdmVPcGVuLCBub1ByZWZpeCkge1xuICAgICAgdmFyIGNsYXNzUHJlZml4ID0gbm9QcmVmaXggPyAnJyA6IG9wdGlvbnMuY2xhc3NQcmVmaXgsXG4gICAgICAgICAgb3BlblNwYW4gICAgPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3NQcmVmaXgsXG4gICAgICAgICAgY2xvc2VTcGFuICAgPSBsZWF2ZU9wZW4gPyAnJyA6IHNwYW5FbmRUYWdcblxuICAgICAgb3BlblNwYW4gKz0gY2xhc3NuYW1lICsgJ1wiPic7XG5cbiAgICAgIHJldHVybiBvcGVuU3BhbiArIGluc2lkZVNwYW4gKyBjbG9zZVNwYW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXdvcmRzKCkge1xuICAgICAgdmFyIGtleXdvcmRfbWF0Y2gsIGxhc3RfaW5kZXgsIG1hdGNoLCByZXN1bHQ7XG5cbiAgICAgIGlmICghdG9wLmtleXdvcmRzKVxuICAgICAgICByZXR1cm4gZXNjYXBlKG1vZGVfYnVmZmVyKTtcblxuICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICBsYXN0X2luZGV4ID0gMDtcbiAgICAgIHRvcC5sZXhlbWVzUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIG1hdGNoID0gdG9wLmxleGVtZXNSZS5leGVjKG1vZGVfYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIHJlc3VsdCArPSBlc2NhcGUobW9kZV9idWZmZXIuc3Vic3RyaW5nKGxhc3RfaW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIGtleXdvcmRfbWF0Y2ggPSBrZXl3b3JkTWF0Y2godG9wLCBtYXRjaCk7XG4gICAgICAgIGlmIChrZXl3b3JkX21hdGNoKSB7XG4gICAgICAgICAgcmVsZXZhbmNlICs9IGtleXdvcmRfbWF0Y2hbMV07XG4gICAgICAgICAgcmVzdWx0ICs9IGJ1aWxkU3BhbihrZXl3b3JkX21hdGNoWzBdLCBlc2NhcGUobWF0Y2hbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2luZGV4ID0gdG9wLmxleGVtZXNSZS5sYXN0SW5kZXg7XG4gICAgICAgIG1hdGNoID0gdG9wLmxleGVtZXNSZS5leGVjKG1vZGVfYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGUobW9kZV9idWZmZXIuc3Vic3RyKGxhc3RfaW5kZXgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSB7XG4gICAgICB2YXIgZXhwbGljaXQgPSB0eXBlb2YgdG9wLnN1Ykxhbmd1YWdlID09PSAnc3RyaW5nJztcbiAgICAgIGlmIChleHBsaWNpdCAmJiAhbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZShtb2RlX2J1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBleHBsaWNpdCA/XG4gICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0KHRvcC5zdWJMYW5ndWFnZSwgbW9kZV9idWZmZXIsIHRydWUsIGNvbnRpbnVhdGlvbnNbdG9wLnN1Ykxhbmd1YWdlXSkgOlxuICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodEF1dG8obW9kZV9idWZmZXIsIHRvcC5zdWJMYW5ndWFnZS5sZW5ndGggPyB0b3Auc3ViTGFuZ3VhZ2UgOiB1bmRlZmluZWQpO1xuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2VjYXNlIGluIHBvaW50IGlzIE1hcmtkb3duIHRoYXRcbiAgICAgIC8vIGFsbG93cyBYTUwgZXZlcnl3aGVyZSBhbmQgbWFrZXMgZXZlcnkgWE1MIHNuaXBwZXQgdG8gaGF2ZSBhIG11Y2ggbGFyZ2VyIE1hcmtkb3duXG4gICAgICAvLyBzY29yZS5cbiAgICAgIGlmICh0b3AucmVsZXZhbmNlID4gMCkge1xuICAgICAgICByZWxldmFuY2UgKz0gcmVzdWx0LnJlbGV2YW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBsaWNpdCkge1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSByZXN1bHQudG9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkU3BhbihyZXN1bHQubGFuZ3VhZ2UsIHJlc3VsdC52YWx1ZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCdWZmZXIoKSB7XG4gICAgICByZXN1bHQgKz0gKHRvcC5zdWJMYW5ndWFnZSAhPSBudWxsID8gcHJvY2Vzc1N1Ykxhbmd1YWdlKCkgOiBwcm9jZXNzS2V5d29yZHMoKSk7XG4gICAgICBtb2RlX2J1ZmZlciA9ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlKSB7XG4gICAgICByZXN1bHQgKz0gbW9kZS5jbGFzc05hbWU/IGJ1aWxkU3Bhbihtb2RlLmNsYXNzTmFtZSwgJycsIHRydWUpOiAnJztcbiAgICAgIHRvcCA9IE9iamVjdC5jcmVhdGUobW9kZSwge3BhcmVudDoge3ZhbHVlOiB0b3B9fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xleGVtZShidWZmZXIsIGxleGVtZSkge1xuXG4gICAgICBtb2RlX2J1ZmZlciArPSBidWZmZXI7XG5cbiAgICAgIGlmIChsZXhlbWUgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3X21vZGUgPSBzdWJNb2RlKGxleGVtZSwgdG9wKTtcbiAgICAgIGlmIChuZXdfbW9kZSkge1xuICAgICAgICBpZiAobmV3X21vZGUuc2tpcCkge1xuICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3X21vZGUuZXhjbHVkZUJlZ2luKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgICBpZiAoIW5ld19tb2RlLnJldHVybkJlZ2luICYmICFuZXdfbW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydE5ld01vZGUobmV3X21vZGUsIGxleGVtZSk7XG4gICAgICAgIHJldHVybiBuZXdfbW9kZS5yZXR1cm5CZWdpbiA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kX21vZGUgPSBlbmRPZk1vZGUodG9wLCBsZXhlbWUpO1xuICAgICAgaWYgKGVuZF9tb2RlKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0b3A7XG4gICAgICAgIGlmIChvcmlnaW4uc2tpcCkge1xuICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIShvcmlnaW4ucmV0dXJuRW5kIHx8IG9yaWdpbi5leGNsdWRlRW5kKSkge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgICAgaWYgKG9yaWdpbi5leGNsdWRlRW5kKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmICh0b3AuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3BhbkVuZFRhZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0b3Auc2tpcCkge1xuICAgICAgICAgICAgcmVsZXZhbmNlICs9IHRvcC5yZWxldmFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIH0gd2hpbGUgKHRvcCAhPT0gZW5kX21vZGUucGFyZW50KTtcbiAgICAgICAgaWYgKGVuZF9tb2RlLnN0YXJ0cykge1xuICAgICAgICAgIHN0YXJ0TmV3TW9kZShlbmRfbW9kZS5zdGFydHMsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luLnJldHVybkVuZCA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbGxlZ2FsKGxleGVtZSwgdG9wKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGxleGVtZSBcIicgKyBsZXhlbWUgKyAnXCIgZm9yIG1vZGUgXCInICsgKHRvcC5jbGFzc05hbWUgfHwgJzx1bm5hbWVkPicpICsgJ1wiJyk7XG5cbiAgICAgIC8qXG4gICAgICBQYXJzZXIgc2hvdWxkIG5vdCByZWFjaCB0aGlzIHBvaW50IGFzIGFsbCB0eXBlcyBvZiBsZXhlbWVzIHNob3VsZCBiZSBjYXVnaHRcbiAgICAgIGVhcmxpZXIsIGJ1dCBpZiBpdCBkb2VzIGR1ZSB0byBzb21lIGJ1ZyBtYWtlIHN1cmUgaXQgYWR2YW5jZXMgYXQgbGVhc3Qgb25lXG4gICAgICBjaGFyYWN0ZXIgZm9yd2FyZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BpbmcuXG4gICAgICAqL1xuICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgcmV0dXJuIGxleGVtZS5sZW5ndGggfHwgMTtcbiAgICB9XG5cbiAgICB2YXIgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShuYW1lKTtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICAgIHZhciB0b3AgPSBjb250aW51YXRpb24gfHwgbGFuZ3VhZ2U7XG4gICAgdmFyIGNvbnRpbnVhdGlvbnMgPSB7fTsgLy8ga2VlcCBjb250aW51YXRpb25zIGZvciBzdWItbGFuZ3VhZ2VzXG4gICAgdmFyIHJlc3VsdCA9ICcnLCBjdXJyZW50O1xuICAgIGZvcihjdXJyZW50ID0gdG9wOyBjdXJyZW50ICE9PSBsYW5ndWFnZTsgY3VycmVudCA9IGN1cnJlbnQucGFyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5jbGFzc05hbWUpIHtcbiAgICAgICAgcmVzdWx0ID0gYnVpbGRTcGFuKGN1cnJlbnQuY2xhc3NOYW1lLCAnJywgdHJ1ZSkgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtb2RlX2J1ZmZlciA9ICcnO1xuICAgIHZhciByZWxldmFuY2UgPSAwO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbWF0Y2gsIGNvdW50LCBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0b3AudGVybWluYXRvcnMubGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgIG1hdGNoID0gdG9wLnRlcm1pbmF0b3JzLmV4ZWModmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb3VudCA9IHByb2Nlc3NMZXhlbWUodmFsdWUuc3Vic3RyaW5nKGluZGV4LCBtYXRjaC5pbmRleCksIG1hdGNoWzBdKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIGNvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtZSh2YWx1ZS5zdWJzdHIoaW5kZXgpKTtcbiAgICAgIGZvcihjdXJyZW50ID0gdG9wOyBjdXJyZW50LnBhcmVudDsgY3VycmVudCA9IGN1cnJlbnQucGFyZW50KSB7IC8vIGNsb3NlIGRhbmdsaW5nIG1vZGVzXG4gICAgICAgIGlmIChjdXJyZW50LmNsYXNzTmFtZSkge1xuICAgICAgICAgIHJlc3VsdCArPSBzcGFuRW5kVGFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxldmFuY2U6IHJlbGV2YW5jZSxcbiAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgbGFuZ3VhZ2U6IG5hbWUsXG4gICAgICAgIHRvcDogdG9wXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm1lc3NhZ2UgJiYgZS5tZXNzYWdlLmluZGV4T2YoJ0lsbGVnYWwnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZSh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgSGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgZGV0ZWN0aW9uLiBBY2NlcHRzIGEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG9cbiAgaGlnaGxpZ2h0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblxuICAtIGxhbmd1YWdlIChkZXRlY3RlZCBsYW5ndWFnZSlcbiAgLSByZWxldmFuY2UgKGludClcbiAgLSB2YWx1ZSAoYW4gSFRNTCBzdHJpbmcgd2l0aCBoaWdobGlnaHRpbmcgbWFya3VwKVxuICAtIHNlY29uZF9iZXN0IChvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgZm9yIHNlY29uZC1iZXN0IGhldXJpc3RpY2FsbHlcbiAgICBkZXRlY3RlZCBsYW5ndWFnZSwgbWF5IGJlIGFic2VudClcblxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBdXRvKHRleHQsIGxhbmd1YWdlU3Vic2V0KSB7XG4gICAgbGFuZ3VhZ2VTdWJzZXQgPSBsYW5ndWFnZVN1YnNldCB8fCBvcHRpb25zLmxhbmd1YWdlcyB8fCBvYmplY3RLZXlzKGxhbmd1YWdlcyk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIHZhbHVlOiBlc2NhcGUodGV4dClcbiAgICB9O1xuICAgIHZhciBzZWNvbmRfYmVzdCA9IHJlc3VsdDtcbiAgICBsYW5ndWFnZVN1YnNldC5maWx0ZXIoZ2V0TGFuZ3VhZ2UpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBoaWdobGlnaHQobmFtZSwgdGV4dCwgZmFsc2UpO1xuICAgICAgY3VycmVudC5sYW5ndWFnZSA9IG5hbWU7XG4gICAgICBpZiAoY3VycmVudC5yZWxldmFuY2UgPiBzZWNvbmRfYmVzdC5yZWxldmFuY2UpIHtcbiAgICAgICAgc2Vjb25kX2Jlc3QgPSBjdXJyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQucmVsZXZhbmNlID4gcmVzdWx0LnJlbGV2YW5jZSkge1xuICAgICAgICBzZWNvbmRfYmVzdCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc2Vjb25kX2Jlc3QubGFuZ3VhZ2UpIHtcbiAgICAgIHJlc3VsdC5zZWNvbmRfYmVzdCA9IHNlY29uZF9iZXN0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgUG9zdC1wcm9jZXNzaW5nIG9mIHRoZSBoaWdobGlnaHRlZCBtYXJrdXA6XG5cbiAgLSByZXBsYWNlIFRBQnMgd2l0aCBzb21ldGhpbmcgbW9yZSB1c2VmdWxcbiAgLSByZXBsYWNlIHJlYWwgbGluZS1icmVha3Mgd2l0aCAnPGJyPicgZm9yIG5vbi1wcmUgY29udGFpbmVyc1xuXG4gICovXG4gIGZ1bmN0aW9uIGZpeE1hcmt1cCh2YWx1ZSkge1xuICAgIHJldHVybiAhKG9wdGlvbnMudGFiUmVwbGFjZSB8fCBvcHRpb25zLnVzZUJSKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiB2YWx1ZS5yZXBsYWNlKGZpeE1hcmt1cFJlLCBmdW5jdGlvbihtYXRjaCwgcDEpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy51c2VCUiAmJiBtYXRjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGJyPic7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRhYlJlcGxhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwMS5yZXBsYWNlKC9cXHQvZywgb3B0aW9ucy50YWJSZXBsYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENsYXNzTmFtZShwcmV2Q2xhc3NOYW1lLCBjdXJyZW50TGFuZywgcmVzdWx0TGFuZykge1xuICAgIHZhciBsYW5ndWFnZSA9IGN1cnJlbnRMYW5nID8gYWxpYXNlc1tjdXJyZW50TGFuZ10gOiByZXN1bHRMYW5nLFxuICAgICAgICByZXN1bHQgICA9IFtwcmV2Q2xhc3NOYW1lLnRyaW0oKV07XG5cbiAgICBpZiAoIXByZXZDbGFzc05hbWUubWF0Y2goL1xcYmhsanNcXGIvKSkge1xuICAgICAgcmVzdWx0LnB1c2goJ2hsanMnKTtcbiAgICB9XG5cbiAgICBpZiAocHJldkNsYXNzTmFtZS5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvKlxuICBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhIERPTSBub2RlIGNvbnRhaW5pbmcgY29kZS4gQWNjZXB0cyBhIERPTSBub2RlIGFuZFxuICB0d28gb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgZml4TWFya3VwLlxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRCbG9jayhibG9jaykge1xuICAgIHZhciBub2RlLCBvcmlnaW5hbFN0cmVhbSwgcmVzdWx0LCByZXN1bHROb2RlLCB0ZXh0O1xuICAgIHZhciBsYW5ndWFnZSA9IGJsb2NrTGFuZ3VhZ2UoYmxvY2spO1xuXG4gICAgaWYgKGlzTm90SGlnaGxpZ2h0ZWQobGFuZ3VhZ2UpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAob3B0aW9ucy51c2VCUikge1xuICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdkaXYnKTtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gYmxvY2suaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9nLCAnJykucmVwbGFjZSgvPGJyWyBcXC9dKj4vZywgJ1xcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gYmxvY2s7XG4gICAgfVxuICAgIHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgIHJlc3VsdCA9IGxhbmd1YWdlID8gaGlnaGxpZ2h0KGxhbmd1YWdlLCB0ZXh0LCB0cnVlKSA6IGhpZ2hsaWdodEF1dG8odGV4dCk7XG5cbiAgICBvcmlnaW5hbFN0cmVhbSA9IG5vZGVTdHJlYW0obm9kZSk7XG4gICAgaWYgKG9yaWdpbmFsU3RyZWFtLmxlbmd0aCkge1xuICAgICAgcmVzdWx0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdkaXYnKTtcbiAgICAgIHJlc3VsdE5vZGUuaW5uZXJIVE1MID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmVzdWx0LnZhbHVlID0gbWVyZ2VTdHJlYW1zKG9yaWdpbmFsU3RyZWFtLCBub2RlU3RyZWFtKHJlc3VsdE5vZGUpLCB0ZXh0KTtcbiAgICB9XG4gICAgcmVzdWx0LnZhbHVlID0gZml4TWFya3VwKHJlc3VsdC52YWx1ZSk7XG5cbiAgICBibG9jay5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgYmxvY2suY2xhc3NOYW1lID0gYnVpbGRDbGFzc05hbWUoYmxvY2suY2xhc3NOYW1lLCBsYW5ndWFnZSwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICBibG9jay5yZXN1bHQgPSB7XG4gICAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgICAgcmU6IHJlc3VsdC5yZWxldmFuY2VcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuc2Vjb25kX2Jlc3QpIHtcbiAgICAgIGJsb2NrLnNlY29uZF9iZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZF9iZXN0Lmxhbmd1YWdlLFxuICAgICAgICByZTogcmVzdWx0LnNlY29uZF9iZXN0LnJlbGV2YW5jZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKlxuICBVcGRhdGVzIGhpZ2hsaWdodC5qcyBnbG9iYWwgb3B0aW9ucyB3aXRoIHZhbHVlcyBwYXNzZWQgaW4gdGhlIGZvcm0gb2YgYW4gb2JqZWN0LlxuICAqL1xuICBmdW5jdGlvbiBjb25maWd1cmUodXNlcl9vcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGluaGVyaXQob3B0aW9ucywgdXNlcl9vcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGFsbCA8cHJlPjxjb2RlPi4uPC9jb2RlPjwvcHJlPiBibG9ja3Mgb24gYSBwYWdlLlxuICAqL1xuICBmdW5jdGlvbiBpbml0SGlnaGxpZ2h0aW5nKCkge1xuICAgIGlmIChpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICBpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZCA9IHRydWU7XG5cbiAgICB2YXIgYmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICBBcnJheVByb3RvLmZvckVhY2guY2FsbChibG9ja3MsIGhpZ2hsaWdodEJsb2NrKTtcbiAgfVxuXG4gIC8qXG4gIEF0dGFjaGVzIGhpZ2hsaWdodGluZyB0byB0aGUgcGFnZSBsb2FkIGV2ZW50LlxuICAqL1xuICBmdW5jdGlvbiBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkKCkge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBpbml0SGlnaGxpZ2h0aW5nLCBmYWxzZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGFuZ3VhZ2UobmFtZSwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbGFuZyA9IGxhbmd1YWdlc1tuYW1lXSA9IGxhbmd1YWdlKGhsanMpO1xuICAgIGlmIChsYW5nLmFsaWFzZXMpIHtcbiAgICAgIGxhbmcuYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGFsaWFzKSB7YWxpYXNlc1thbGlhc10gPSBuYW1lO30pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIG9iamVjdEtleXMobGFuZ3VhZ2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhbmd1YWdlKG5hbWUpIHtcbiAgICBuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGxhbmd1YWdlc1tuYW1lXSB8fCBsYW5ndWFnZXNbYWxpYXNlc1tuYW1lXV07XG4gIH1cblxuICAvKiBJbnRlcmZhY2UgZGVmaW5pdGlvbiAqL1xuXG4gIGhsanMuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICBobGpzLmhpZ2hsaWdodEF1dG8gPSBoaWdobGlnaHRBdXRvO1xuICBobGpzLmZpeE1hcmt1cCA9IGZpeE1hcmt1cDtcbiAgaGxqcy5oaWdobGlnaHRCbG9jayA9IGhpZ2hsaWdodEJsb2NrO1xuICBobGpzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbiAgaGxqcy5pbml0SGlnaGxpZ2h0aW5nID0gaW5pdEhpZ2hsaWdodGluZztcbiAgaGxqcy5pbml0SGlnaGxpZ2h0aW5nT25Mb2FkID0gaW5pdEhpZ2hsaWdodGluZ09uTG9hZDtcbiAgaGxqcy5yZWdpc3Rlckxhbmd1YWdlID0gcmVnaXN0ZXJMYW5ndWFnZTtcbiAgaGxqcy5saXN0TGFuZ3VhZ2VzID0gbGlzdExhbmd1YWdlcztcbiAgaGxqcy5nZXRMYW5ndWFnZSA9IGdldExhbmd1YWdlO1xuICBobGpzLmluaGVyaXQgPSBpbmhlcml0O1xuXG4gIC8vIENvbW1vbiByZWdleHBzXG4gIGhsanMuSURFTlRfUkUgPSAnW2EtekEtWl1cXFxcdyonO1xuICBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgPSAnW2EtekEtWl9dXFxcXHcqJztcbiAgaGxqcy5OVU1CRVJfUkUgPSAnXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCspPyc7XG4gIGhsanMuQ19OVU1CRVJfUkUgPSAnKC0/KShcXFxcYjBbeFhdW2EtZkEtRjAtOV0rfChcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKik/fFxcXFwuXFxcXGQrKShbZUVdWy0rXT9cXFxcZCspPyknOyAvLyAweC4uLiwgMC4uLiwgZGVjaW1hbCwgZmxvYXRcbiAgaGxqcy5CSU5BUllfTlVNQkVSX1JFID0gJ1xcXFxiKDBiWzAxXSspJzsgLy8gMGIuLi5cbiAgaGxqcy5SRV9TVEFSVEVSU19SRSA9ICchfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH4nO1xuXG4gIC8vIENvbW1vbiBtb2Rlc1xuICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUgPSB7XG4gICAgYmVnaW46ICdcXFxcXFxcXFtcXFxcc1xcXFxTXScsIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLkFQT1NfU1RSSU5HX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ1xcJycsIGVuZDogJ1xcJycsXG4gICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgfTtcbiAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXCInLCBlbmQ6ICdcIicsXG4gICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgfTtcbiAgaGxqcy5QSFJBU0FMX1dPUkRTX01PREUgPSB7XG4gICAgYmVnaW46IC9cXGIoYXxhbnx0aGV8YXJlfEknbXxpc24ndHxkb24ndHxkb2Vzbid0fHdvbid0fGJ1dHxqdXN0fHNob3VsZHxwcmV0dHl8c2ltcGx5fGVub3VnaHxnb25uYXxnb2luZ3x3dGZ8c298c3VjaHx3aWxsfHlvdXx5b3VyfHRoZXl8bGlrZXxtb3JlKVxcYi9cbiAgfTtcbiAgaGxqcy5DT01NRU5UID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQsIGluaGVyaXRzKSB7XG4gICAgdmFyIG1vZGUgPSBobGpzLmluaGVyaXQoXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgICBiZWdpbjogYmVnaW4sIGVuZDogZW5kLFxuICAgICAgICBjb250YWluczogW11cbiAgICAgIH0sXG4gICAgICBpbmhlcml0cyB8fCB7fVxuICAgICk7XG4gICAgbW9kZS5jb250YWlucy5wdXNoKGhsanMuUEhSQVNBTF9XT1JEU19NT0RFKTtcbiAgICBtb2RlLmNvbnRhaW5zLnB1c2goe1xuICAgICAgY2xhc3NOYW1lOiAnZG9jdGFnJyxcbiAgICAgIGJlZ2luOiAnKD86VE9ET3xGSVhNRXxOT1RFfEJVR3xYWFgpOicsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZTtcbiAgfTtcbiAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFID0gaGxqcy5DT01NRU5UKCcvLycsICckJyk7XG4gIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJy9cXFxcKicsICdcXFxcKi8nKTtcbiAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnIycsICckJyk7XG4gIGhsanMuTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQ19OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLkNfTlVNQkVSX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLkJJTkFSWV9OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLkJJTkFSWV9OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQ1NTX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuTlVNQkVSX1JFICsgJygnICtcbiAgICAgICclfGVtfGV4fGNofHJlbScgICtcbiAgICAgICd8dnd8dmh8dm1pbnx2bWF4JyArXG4gICAgICAnfGNtfG1tfGlufHB0fHBjfHB4JyArXG4gICAgICAnfGRlZ3xncmFkfHJhZHx0dXJuJyArXG4gICAgICAnfHN8bXMnICtcbiAgICAgICd8SHp8a0h6JyArXG4gICAgICAnfGRwaXxkcGNtfGRwcHgnICtcbiAgICAgICcpPycsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuUkVHRVhQX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAncmVnZXhwJyxcbiAgICBiZWdpbjogL1xcLy8sIGVuZDogL1xcL1tnaW11eV0qLyxcbiAgICBpbGxlZ2FsOiAvXFxuLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcWy8sIGVuZDogL1xcXS8sXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBobGpzLlRJVExFX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgIGJlZ2luOiBobGpzLklERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLlVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5NRVRIT0RfR1VBUkQgPSB7XG4gICAgLy8gZXhjbHVkZXMgbWV0aG9kIG5hbWVzIGZyb20ga2V5d29yZCBwcm9jZXNzaW5nXG4gICAgYmVnaW46ICdcXFxcLlxcXFxzKicgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgcmV0dXJuIGhsanM7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIElERU5UX1JFID0gJ1tBLVphLXokX11bMC05QS1aYS16JF9dKic7XG4gIHZhciBLRVlXT1JEUyA9IHtcbiAgICBrZXl3b3JkOlxuICAgICAgJ2luIG9mIGlmIGZvciB3aGlsZSBmaW5hbGx5IHZhciBuZXcgZnVuY3Rpb24gZG8gcmV0dXJuIHZvaWQgZWxzZSBicmVhayBjYXRjaCAnICtcbiAgICAgICdpbnN0YW5jZW9mIHdpdGggdGhyb3cgY2FzZSBkZWZhdWx0IHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB0eXBlb2YgZGVsZXRlICcgK1xuICAgICAgJ2xldCB5aWVsZCBjb25zdCBleHBvcnQgc3VwZXIgZGVidWdnZXIgYXMgYXN5bmMgYXdhaXQgc3RhdGljICcgK1xuICAgICAgLy8gRUNNQVNjcmlwdCA2IG1vZHVsZXMgaW1wb3J0XG4gICAgICAnaW1wb3J0IGZyb20gYXMnXG4gICAgLFxuICAgIGxpdGVyYWw6XG4gICAgICAndHJ1ZSBmYWxzZSBudWxsIHVuZGVmaW5lZCBOYU4gSW5maW5pdHknLFxuICAgIGJ1aWx0X2luOlxuICAgICAgJ2V2YWwgaXNGaW5pdGUgaXNOYU4gcGFyc2VGbG9hdCBwYXJzZUludCBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50ICcgK1xuICAgICAgJ2VuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgZXNjYXBlIHVuZXNjYXBlIE9iamVjdCBGdW5jdGlvbiBCb29sZWFuIEVycm9yICcgK1xuICAgICAgJ0V2YWxFcnJvciBJbnRlcm5hbEVycm9yIFJhbmdlRXJyb3IgUmVmZXJlbmNlRXJyb3IgU3RvcEl0ZXJhdGlvbiBTeW50YXhFcnJvciAnICtcbiAgICAgICdUeXBlRXJyb3IgVVJJRXJyb3IgTnVtYmVyIE1hdGggRGF0ZSBTdHJpbmcgUmVnRXhwIEFycmF5IEZsb2F0MzJBcnJheSAnICtcbiAgICAgICdGbG9hdDY0QXJyYXkgSW50MTZBcnJheSBJbnQzMkFycmF5IEludDhBcnJheSBVaW50MTZBcnJheSBVaW50MzJBcnJheSAnICtcbiAgICAgICdVaW50OEFycmF5IFVpbnQ4Q2xhbXBlZEFycmF5IEFycmF5QnVmZmVyIERhdGFWaWV3IEpTT04gSW50bCBhcmd1bWVudHMgcmVxdWlyZSAnICtcbiAgICAgICdtb2R1bGUgY29uc29sZSB3aW5kb3cgZG9jdW1lbnQgU3ltYm9sIFNldCBNYXAgV2Vha1NldCBXZWFrTWFwIFByb3h5IFJlZmxlY3QgJyArXG4gICAgICAnUHJvbWlzZSdcbiAgfTtcbiAgdmFyIEVYUFJFU1NJT05TO1xuICB2YXIgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHsgYmVnaW46ICdcXFxcYigwW2JCXVswMV0rKScgfSxcbiAgICAgIHsgYmVnaW46ICdcXFxcYigwW29PXVswLTddKyknIH0sXG4gICAgICB7IGJlZ2luOiBobGpzLkNfTlVNQkVSX1JFIH1cbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAnXFxcXCRcXFxceycsIGVuZDogJ1xcXFx9JyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFtdICAvLyBkZWZpbmVkIGxhdGVyXG4gIH07XG4gIHZhciBURU1QTEFURV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ2AnLCBlbmQ6ICdgJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgU1VCU1RcbiAgICBdXG4gIH07XG4gIFNVQlNULmNvbnRhaW5zID0gW1xuICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICBOVU1CRVIsXG4gICAgaGxqcy5SRUdFWFBfTU9ERVxuICBdXG4gIHZhciBQQVJBTVNfQ09OVEFJTlMgPSBTVUJTVC5jb250YWlucy5jb25jYXQoW1xuICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXG4gIF0pO1xuXG4gIHJldHVybiB7XG4gICAgYWxpYXNlczogWydqcycsICdqc3gnXSxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHJlbGV2YW5jZTogMTAsXG4gICAgICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSAoc3RyaWN0fGFzbSlbJ1wiXS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogL14jIS8sIGVuZDogLyQvXG4gICAgICB9LFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBOVU1CRVIsXG4gICAgICB7IC8vIG9iamVjdCBhdHRyIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogL1t7LF1cXHMqLywgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiBJREVOVF9SRSArICdcXFxccyo6JywgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBjb250YWluczogW3tjbGFzc05hbWU6ICdhdHRyJywgYmVnaW46IElERU5UX1JFLCByZWxldmFuY2U6IDB9XVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHsgLy8gXCJ2YWx1ZVwiIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogJygnICsgaGxqcy5SRV9TVEFSVEVSU19SRSArICd8XFxcXGIoY2FzZXxyZXR1cm58dGhyb3cpXFxcXGIpXFxcXHMqJyxcbiAgICAgICAga2V5d29yZHM6ICdyZXR1cm4gdGhyb3cgY2FzZScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5SRUdFWFBfTU9ERSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBiZWdpbjogJyhcXFxcKC4qP1xcXFwpfCcgKyBJREVOVF9SRSArICcpXFxcXHMqPT4nLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGVuZDogJ1xcXFxzKj0+JyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiBJREVOVF9SRVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXChcXHMqXFwpLyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gRTRYIC8gSlNYXG4gICAgICAgICAgICBiZWdpbjogLzwvLCBlbmQ6IC8oXFwvXFx3K3xcXHcrXFwvKT4vLFxuICAgICAgICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge2JlZ2luOiAvPFxcdytcXHMqXFwvPi8sIHNraXA6IHRydWV9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC88XFx3Ky8sIGVuZDogLyhcXC9cXHcrfFxcdytcXC8pPi8sIHNraXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgIHtiZWdpbjogLzxcXHcrXFxzKlxcLz4vLCBza2lwOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICdzZWxmJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdmdW5jdGlvbicsIGVuZDogL1xcey8sIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwge2JlZ2luOiBJREVOVF9SRX0pLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaWxsZWdhbDogL1xcW3wlL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCRbKC5dLyAvLyByZWxldmFuY2UgYm9vc3RlciBmb3IgYSBwYXR0ZXJuIGNvbW1vbiB0byBKUyBsaWJzOiBgJChzb21ldGhpbmcpYCBhbmQgYCQuc29tZXRoaW5nYFxuICAgICAgfSxcbiAgICAgIGhsanMuTUVUSE9EX0dVQVJELFxuICAgICAgeyAvLyBFUzYgY2xhc3NcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgICAgICBiZWdpbktleXdvcmRzOiAnY2xhc3MnLCBlbmQ6IC9bezs9XS8sIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGlsbGVnYWw6IC9bOlwiXFxbXFxdXS8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge2JlZ2luS2V5d29yZHM6ICdleHRlbmRzJ30sXG4gICAgICAgICAgaGxqcy5VTkRFUlNDT1JFX1RJVExFX01PREVcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2NvbnN0cnVjdG9yJywgZW5kOiAvXFx7LywgZXhjbHVkZUVuZDogdHJ1ZVxuICAgICAgfVxuICAgIF0sXG4gICAgaWxsZWdhbDogLyMoPyEhKS9cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIElERU5UX1JFID0gJ1thLXpBLVotXVthLXpBLVowLTlfLV0qJztcbiAgdmFyIFJVTEUgPSB7XG4gICAgYmVnaW46IC9bQS1aXFxfXFwuXFwtXStcXHMqOi8sIHJldHVybkJlZ2luOiB0cnVlLCBlbmQ6ICc7JywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgYmVnaW46IC9cXFMvLCBlbmQ6ICc6JywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVnaW46IC9bXFx3LV0rXFwoLywgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYnVpbHRfaW4nLFxuICAgICAgICAgICAgICAgICAgYmVnaW46IC9bXFx3LV0rL1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREUsXG4gICAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgYmVnaW46ICcjWzAtOUEtRmEtZl0rJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsIGJlZ2luOiAnIWltcG9ydGFudCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGlsbGVnYWw6IC9bPVxcL3wnXFwkXS8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWlkJywgYmVnaW46IC8jW0EtWmEtejAtOV8tXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1jbGFzcycsIGJlZ2luOiAvXFwuW0EtWmEtejAtOV8tXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1hdHRyJyxcbiAgICAgICAgYmVnaW46IC9cXFsvLCBlbmQ6IC9cXF0vLFxuICAgICAgICBpbGxlZ2FsOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXBzZXVkbycsXG4gICAgICAgIGJlZ2luOiAvOig6KT9bYS16QS1aMC05XFxfXFwtXFwrXFwoXFwpXCInLl0rL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAKGZvbnQtZmFjZXxwYWdlKScsXG4gICAgICAgIGxleGVtZXM6ICdbYS16LV0rJyxcbiAgICAgICAga2V5d29yZHM6ICdmb250LWZhY2UgcGFnZSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQCcsIGVuZDogJ1t7O10nLCAvLyBhdF9ydWxlIGVhdGluZyBmaXJzdCBcIntcIiBpcyBhIGdvb2QgdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgZG9lc27igJl0IGxldCBpdCB0byBiZSBwYXJzZWQgYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgcnVsZSBzZXQgYnV0IGluc3RlYWQgZHJvcHMgcGFyc2VyIGludG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IG1vZGUgd2hpY2ggaXMgaG93IGl0IHNob3VsZCBiZS5cbiAgICAgICAgaWxsZWdhbDogLzovLCAvLyBicmVhayBvbiBMZXNzIHZhcmlhYmxlcyBAdmFyOiAuLi5cbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgIGJlZ2luOiAvXFx3Ky9cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvXFxzLywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgIGhsanMuQ1NTX05VTUJFUl9NT0RFXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci10YWcnLCBiZWdpbjogSURFTlRfUkUsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICd7JywgZW5kOiAnfScsXG4gICAgICAgIGlsbGVnYWw6IC9cXFMvLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgUlVMRSxcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgWE1MX0lERU5UX1JFID0gJ1tBLVphLXowLTlcXFxcLl86LV0rJztcbiAgdmFyIFRBR19JTlRFUk5BTFMgPSB7XG4gICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgaWxsZWdhbDogLzwvLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICAgICAgYmVnaW46IFhNTF9JREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLz1cXHMqLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAge2JlZ2luOiAvXCIvLCBlbmQ6IC9cIi99LFxuICAgICAgICAgICAgICB7YmVnaW46IC8nLywgZW5kOiAvJy99LFxuICAgICAgICAgICAgICB7YmVnaW46IC9bXlxcc1wiJz08PmBdKy99XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICByZXR1cm4ge1xuICAgIGFsaWFzZXM6IFsnaHRtbCcsICd4aHRtbCcsICdyc3MnLCAnYXRvbScsICd4amInLCAneHNkJywgJ3hzbCcsICdwbGlzdCddLFxuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAnPCFET0NUWVBFJywgZW5kOiAnPicsXG4gICAgICAgIHJlbGV2YW5jZTogMTAsXG4gICAgICAgIGNvbnRhaW5zOiBbe2JlZ2luOiAnXFxcXFsnLCBlbmQ6ICdcXFxcXSd9XVxuICAgICAgfSxcbiAgICAgIGhsanMuQ09NTUVOVChcbiAgICAgICAgJzwhLS0nLFxuICAgICAgICAnLS0+JyxcbiAgICAgICAge1xuICAgICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICc8XFxcXCFcXFxcW0NEQVRBXFxcXFsnLCBlbmQ6ICdcXFxcXVxcXFxdPicsXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPFxcPyhwaHApPy8sIGVuZDogL1xcPz4vLFxuICAgICAgICBzdWJMYW5ndWFnZTogJ3BocCcsXG4gICAgICAgIGNvbnRhaW5zOiBbe2JlZ2luOiAnL1xcXFwqJywgZW5kOiAnXFxcXCovJywgc2tpcDogdHJ1ZX1dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICAvKlxuICAgICAgICBUaGUgbG9va2FoZWFkIHBhdHRlcm4gKD89Li4uKSBlbnN1cmVzIHRoYXQgJ2JlZ2luJyBvbmx5IG1hdGNoZXNcbiAgICAgICAgJzxzdHlsZScgYXMgYSBzaW5nbGUgd29yZCwgZm9sbG93ZWQgYnkgYSB3aGl0ZXNwYWNlIG9yIGFuXG4gICAgICAgIGVuZGluZyBicmFrZXQuIFRoZSAnJCcgaXMgbmVlZGVkIGZvciB0aGUgbGV4ZW1lIHRvIGJlIHJlY29nbml6ZWRcbiAgICAgICAgYnkgaGxqcy5zdWJNb2RlKCkgdGhhdCB0ZXN0cyBsZXhlbWVzIG91dHNpZGUgdGhlIHN0cmVhbS5cbiAgICAgICAgKi9cbiAgICAgICAgYmVnaW46ICc8c3R5bGUoPz1cXFxcc3w+fCQpJywgZW5kOiAnPicsXG4gICAgICAgIGtleXdvcmRzOiB7bmFtZTogJ3N0eWxlJ30sXG4gICAgICAgIGNvbnRhaW5zOiBbVEFHX0lOVEVSTkFMU10sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogJzwvc3R5bGU+JywgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbJ2NzcycsICd4bWwnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIDxzdHlsZSB0YWcgYWJvdXQgdGhlIGxvb2thaGVhZCBwYXR0ZXJuXG4gICAgICAgIGJlZ2luOiAnPHNjcmlwdCg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHtuYW1lOiAnc2NyaXB0J30sXG4gICAgICAgIGNvbnRhaW5zOiBbVEFHX0lOVEVSTkFMU10sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogJ1xcPFxcL3NjcmlwdFxcPicsIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogWydhY3Rpb25zY3JpcHQnLCAnamF2YXNjcmlwdCcsICdoYW5kbGViYXJzJywgJ3htbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgIHtiZWdpbjogLzxcXD94bWwvLCBlbmQ6IC9cXD8+LywgcmVsZXZhbmNlOiAxMH0sXG4gICAgICAgICAge2JlZ2luOiAvPFxcP1xcdysvLCBlbmQ6IC9cXD8+L31cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46ICc8Lz8nLCBlbmQ6ICcvPz4nLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ25hbWUnLCBiZWdpbjogL1teXFwvPjxcXHNdKy8sIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVEFHX0lOVEVSTkFMU1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMveG1sLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBWQVIgPSB7XG4gICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7YmVnaW46IC9cXCRbXFx3XFxkI0BdW1xcd1xcZF9dKi99LFxuICAgICAge2JlZ2luOiAvXFwkXFx7KC4qPyl9L31cbiAgICBdXG4gIH07XG4gIHZhciBRVU9URV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogL1wiLywgZW5kOiAvXCIvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBWQVIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICAgICAgYmVnaW46IC9cXCRcXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIHZhciBBUE9TX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvJy8sIGVuZDogLycvXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhbGlhc2VzOiBbJ3NoJywgJ3pzaCddLFxuICAgIGxleGVtZXM6IC9cXGItP1thLXpcXC5fXStcXGIvLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnaWYgdGhlbiBlbHNlIGVsaWYgZmkgZm9yIHdoaWxlIGluIGRvIGRvbmUgY2FzZSBlc2FjIGZ1bmN0aW9uJyxcbiAgICAgIGxpdGVyYWw6XG4gICAgICAgICd0cnVlIGZhbHNlJyxcbiAgICAgIGJ1aWx0X2luOlxuICAgICAgICAvLyBTaGVsbCBidWlsdC1pbnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcbiAgICAgICAgJ2JyZWFrIGNkIGNvbnRpbnVlIGV2YWwgZXhlYyBleGl0IGV4cG9ydCBnZXRvcHRzIGhhc2ggcHdkIHJlYWRvbmx5IHJldHVybiBzaGlmdCB0ZXN0IHRpbWVzICcgK1xuICAgICAgICAndHJhcCB1bWFzayB1bnNldCAnICtcbiAgICAgICAgLy8gQmFzaCBidWlsdC1pbnNcbiAgICAgICAgJ2FsaWFzIGJpbmQgYnVpbHRpbiBjYWxsZXIgY29tbWFuZCBkZWNsYXJlIGVjaG8gZW5hYmxlIGhlbHAgbGV0IGxvY2FsIGxvZ291dCBtYXBmaWxlIHByaW50ZiAnICtcbiAgICAgICAgJ3JlYWQgcmVhZGFycmF5IHNvdXJjZSB0eXBlIHR5cGVzZXQgdWxpbWl0IHVuYWxpYXMgJyArXG4gICAgICAgIC8vIFNoZWxsIG1vZGlmaWVyc1xuICAgICAgICAnc2V0IHNob3B0ICcgK1xuICAgICAgICAvLyBac2ggYnVpbHQtaW5zXG4gICAgICAgICdhdXRvbG9hZCBiZyBiaW5ka2V5IGJ5ZSBjYXAgY2hkaXIgY2xvbmUgY29tcGFyZ3VtZW50cyBjb21wY2FsbCBjb21wY3RsIGNvbXBkZXNjcmliZSBjb21wZmlsZXMgJyArXG4gICAgICAgICdjb21wZ3JvdXBzIGNvbXBxdW90ZSBjb21wdGFncyBjb21wdHJ5IGNvbXB2YWx1ZXMgZGlycyBkaXNhYmxlIGRpc293biBlY2hvdGMgZWNob3RpIGVtdWxhdGUgJyArXG4gICAgICAgICdmYyBmZyBmbG9hdCBmdW5jdGlvbnMgZ2V0Y2FwIGdldGxuIGhpc3RvcnkgaW50ZWdlciBqb2JzIGtpbGwgbGltaXQgbG9nIG5vZ2xvYiBwb3BkIHByaW50ICcgK1xuICAgICAgICAncHVzaGQgcHVzaGxuIHJlaGFzaCBzY2hlZCBzZXRjYXAgc2V0b3B0IHN0YXQgc3VzcGVuZCB0dHljdGwgdW5mdW5jdGlvbiB1bmhhc2ggdW5saW1pdCAnICtcbiAgICAgICAgJ3Vuc2V0b3B0IHZhcmVkIHdhaXQgd2hlbmNlIHdoZXJlIHdoaWNoIHpjb21waWxlIHpmb3JtYXQgemZ0cCB6bGUgem1vZGxvYWQgenBhcnNlb3B0cyB6cHJvZiAnICtcbiAgICAgICAgJ3pwdHkgenJlZ2V4cGFyc2UgenNvY2tldCB6c3R5bGUgenRjcCcsXG4gICAgICBfOlxuICAgICAgICAnLW5lIC1lcSAtbHQgLWd0IC1mIC1kIC1lIC1zIC1sIC1hJyAvLyByZWxldmFuY2UgYm9vc3RlclxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvXiMhW15cXG5dK3NoXFxzKiQvLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luOiAvXFx3W1xcd1xcZF9dKlxccypcXChcXHMqXFwpXFxzKlxcey8sXG4gICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICBjb250YWluczogW2hsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHtiZWdpbjogL1xcd1tcXHdcXGRfXSovfSldLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAgUVVPVEVfU1RSSU5HLFxuICAgICAgQVBPU19TVFJJTkcsXG4gICAgICBWQVJcbiAgICBdXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9iYXNoLmpzIiwiaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vbGF5b3V0LnZkdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgSW50YWN0IHtcbiAgICBASW50YWN0LnRlbXBsYXRlKClcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgIF9tb3VudCgpIHtcbiAgICAgICAgdGhpcy4kYm9yZGVyID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJy5ib3JkZXInKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm9yZGVyKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUJvcmRlcigpIHtcbiAgICAgICAgY29uc3QgJG5hdiA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuYWN0aXZlJyk7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgaWYgKCRuYXYubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gJG5hdi5wb3NpdGlvbigpLmxlZnQ7XG4gICAgICAgICAgICB3aWR0aCA9ICRuYXYub3V0ZXJXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGJvcmRlci5hZGRDbGFzcygndHJhbnNpdGlvbicpO1xuICAgICAgICB0aGlzLiRib3JkZXIuY3NzKHt3aWR0aDogd2lkdGgsIGxlZnQ6IGxlZnR9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWdlcy9sYXlvdXQuanMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iaiwgX1ZkdCwgYmxvY2tzLCAkY2FsbGVlKSB7XG5fVmR0IHx8IChfVmR0ID0gVmR0KTtcbm9iaiB8fCAob2JqID0ge30pO1xuYmxvY2tzIHx8IChibG9ja3MgPSB7fSk7XG52YXIgaCA9IF9WZHQubWlzcy5oLCBoYyA9IF9WZHQubWlzcy5oYywgaHUgPSBfVmR0Lm1pc3MuaHUsIHdpZGdldHMgPSB0aGlzICYmIHRoaXMud2lkZ2V0cyB8fCB7fSwgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IHt9LFxuX191ID0gX1ZkdC51dGlscywgZXh0ZW5kID0gX191LmV4dGVuZCwgX2UgPSBfX3UuZXJyb3IsIF9jbGFzc05hbWUgPSBfX3UuY2xhc3NOYW1lLFxuX19vID0gX191Lk9wdGlvbnMsIF9nZXRNb2RlbCA9IF9fby5nZXRNb2RlbCwgX3NldE1vZGVsID0gX19vLnNldE1vZGVsLFxuX3NldENoZWNrYm94TW9kZWwgPSBfX3Uuc2V0Q2hlY2tib3hNb2RlbCwgX2RldGVjdENoZWNrYm94Q2hlY2tlZCA9IF9fdS5kZXRlY3RDaGVja2JveENoZWNrZWQsXG5fc2V0U2VsZWN0TW9kZWwgPSBfX3Uuc2V0U2VsZWN0TW9kZWwsXG5zZWxmID0gdGhpcy5kYXRhLCAkdGhpcyA9IHRoaXMsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9ICgkY2FsbGVlIHx8IHt9KS5fc3VwZXJcbmNvbnN0IG5hdiA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAn5pWZ56iLJyxcbiAgICAgICAgaHJlZjogJ2RvY3VtZW50J1xuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0FQSScsXG4gICAgICAgIGhyZWY6ICdhcGknXG4gICAgfSxcbiAgICAvLyB7XG4gICAgICAgIC8vIHRpdGxlOiAn56S65L6LJyxcbiAgICAgICAgLy8gaHJlZjogJ2V4YW1wbGVzJ1xuICAgIC8vIH1cbl1cbnJldHVybiBoKCdkaXYnLCBudWxsLCBbaCgnZGl2JywgbnVsbCwgaCgnaGVhZGVyJywgbnVsbCwgKF9ibG9ja3NbXCJoZWFkZXJcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtyZXR1cm4gW2goJ2EnLCB7J2hyZWYnOiAnIy8nfSwgJ0ludGFjdCcsICdsb2dvJyksIGgoJ25hdicsIG51bGwsIFtfVmR0LnV0aWxzLm1hcChmdW5jdGlvbigpIHt0cnkge3JldHVybiBbbmF2XVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xucmV0dXJuIGgoJ2EnLCB7J2hyZWYnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbYCMvJHt2YWx1ZS5ocmVmfWBdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpfSwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3ZhbHVlLnRpdGxlXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB2YWx1ZS5ocmVmID09PSBzY29wZS5uYXZJbmRleFxuICAgICAgICAgICAgICAgICAgICB9XVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSkpO1xufSwgdGhpcyksIGgoJ2RpdicsIG51bGwsIG51bGwsICdib3JkZXInKV0pXTt9KSAmJiAoX19ibG9ja3NbXCJoZWFkZXJcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtcbnZhciBzZWxmID0gdGhpcztcbnJldHVybiBibG9ja3NbXCJoZWFkZXJcIl0gPyBibG9ja3NbXCJoZWFkZXJcIl0uY2FsbCh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBfYmxvY2tzW1wiaGVhZGVyXCJdLmNhbGwoc2VsZiwgcGFyZW50KTtcbn0pIDogX2Jsb2Nrc1tcImhlYWRlclwiXS5jYWxsKHRoaXMsIHBhcmVudCk7XG59KSAmJiBfX2Jsb2Nrc1tcImhlYWRlclwiXS5jYWxsKHRoaXMpKSwgJ2hlYWRlci13cmFwcGVyJyksIGgoJ2RpdicsIG51bGwsIChfYmxvY2tzW1wiY29udGVudFwiXSA9IGZ1bmN0aW9uKHBhcmVudCkge3JldHVybiBudWxsO30pICYmIChfX2Jsb2Nrc1tcImNvbnRlbnRcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtcbnZhciBzZWxmID0gdGhpcztcbnJldHVybiBibG9ja3NbXCJjb250ZW50XCJdID8gYmxvY2tzW1wiY29udGVudFwiXS5jYWxsKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIF9ibG9ja3NbXCJjb250ZW50XCJdLmNhbGwoc2VsZiwgcGFyZW50KTtcbn0pIDogX2Jsb2Nrc1tcImNvbnRlbnRcIl0uY2FsbCh0aGlzLCBwYXJlbnQpO1xufSkgJiYgX19ibG9ja3NbXCJjb250ZW50XCJdLmNhbGwodGhpcyksICdjb250ZW50LXdyYXBwZXInKV0sIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gWydtYWluLXdyYXBwZXIgJyArIChzY29wZS5jbGFzc05hbWUgfHwgJycpXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSkpXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFnZXMvbGF5b3V0LnZkdCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuL25vdycpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwidmFyIGJhc2VSYW5kb20gPSByZXF1aXJlKCcuL19iYXNlUmFuZG9tJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNodWZmbGVTZWxmO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2h1ZmZsZVNlbGYuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MsICRjYWxsZWUpIHtcbl9WZHQgfHwgKF9WZHQgPSBWZHQpO1xub2JqIHx8IChvYmogPSB7fSk7XG5ibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbnZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG5fX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsXG5fX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG5fc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbl9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbnNlbGYgPSB0aGlzLmRhdGEsICR0aGlzID0gdGhpcywgc2NvcGUgPSBvYmosIEFuaW1hdGUgPSBzZWxmICYmIHNlbGYuQW5pbWF0ZSwgcGFyZW50ID0gKCRjYWxsZWUgfHwge30pLl9zdXBlclxuY29uc3QgY2F0YWxvZ3MgPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogJ+WfuuehgCcsXG4gICAgICAgIHN1YkNhdGFsb2dzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICflvIDlp4snLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdzdGFydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJbnRhY3Tlrp7kvosnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdpbnN0YW5jZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfnu4Tku7bnlJ/lkb3lkajmnJ8nLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdsaWZlY3ljbGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5qih5p2/6K+t5rOVJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnc3ludGF4J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+S6i+S7tuWkhOeQhicsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2V2ZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+ihqOWNleWkhOeQhicsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2Zvcm0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn57uE5Lu2JyxcbiAgICAgICAgICAgICAgICBocmVmOiAnY29tcG9uZW50J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+e7hOS7tue7p+aJvycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2V4dGVuZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ+i/m+mYticsXG4gICAgICAgIHN1YkNhdGFsb2dzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfliqjnlLsnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdhbmltYXRpb24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5qih5p2/dGVtcGxhdGUnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICd0ZW1wbGF0ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfot6/nlLEnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdyb3V0ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnd2VicGFja+Wunui3tScsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3Byb2plY3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5pyN5Yqh5Zmo56uv5riy5p+TJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnc3NyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcbmxldCBjdXJyZW50TmF2ID0ge307XG5cbmNvbnN0IFN1YnMgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFthdHRyLnN1YnNdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpID8gaCgndWwnLCBudWxsLCBfVmR0LnV0aWxzLm1hcChmdW5jdGlvbigpIHt0cnkge3JldHVybiBbYXR0ci5zdWJzXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xucmV0dXJuIGgoJ2xpJywgbnVsbCwgW2goJ2EnLCB7J2V2LWNsaWNrJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3NlbGYuc2Nyb2xsVG8uYmluZChzZWxmLCB2YWx1ZS50aXRsZSwgYXR0ci5zdWJzLmFjdGl2ZSldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpfSwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3ZhbHVlLnRpdGxlXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSksIGgoU3VicywgeydzdWJzJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3ZhbHVlLnN1YnNdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCAnY2hpbGRyZW4nOiBudWxsLCAnX2NvbnRleHQnOiAkdGhpc30pXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiBbe1xuICAgICAgICAgICAgYWN0aXZlOiBzZWxmLmdldChhdHRyLnN1YnMuYWN0aXZlKSA9PT0gdmFsdWUudGl0bGVcbiAgICAgICAgfV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykpKTtcbn0sIHRoaXMpLCAnc3ViLWNhdGFsb2dzJykgOiB1bmRlZmluZWRcbn07XG5yZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBfb2JqID0geyduYXZJbmRleCc6ICdkb2N1bWVudCcsICdjbGFzc05hbWUnOiAnZG9jdW1lbnQtcGFnZScsIC4uLmZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtzY29wZV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksICdjaGlsZHJlbic6IG51bGx9O1xuICAgIGlmIChfb2JqLmhhc093blByb3BlcnR5KFwiYXJndW1lbnRzXCIpKSB7XG4gICAgICAgIGV4dGVuZChfb2JqLCBfb2JqLmFyZ3VtZW50cyA9PT0gdHJ1ZSA/IG9iaiA6IF9vYmouYXJndW1lbnRzKTtcbiAgICAgICAgZGVsZXRlIF9vYmouYXJndW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50LmNhbGwodGhpcywgX29iaiwgX1ZkdCwgZnVuY3Rpb24oYmxvY2tzKSB7XG4gICAgdmFyIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSBleHRlbmQoe30sIGJsb2Nrcyk7XG4gICAgcmV0dXJuICgoX2Jsb2Nrc1tcImNvbnRlbnRcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtyZXR1cm4gW2goJ2FzaWRlJywgbnVsbCwgaCgnZGl2JywgbnVsbCwgW19WZHQudXRpbHMubWFwKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtjYXRhbG9nc11bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbnJldHVybiBoKCdkaXYnLCBudWxsLCBbaCgnaDUnLCBudWxsLCBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbdmFsdWUudGl0bGVdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpKSwgaCgndWwnLCBudWxsLCBfVmR0LnV0aWxzLm1hcChmdW5jdGlvbigpIHt0cnkge3JldHVybiBbdmFsdWUuc3ViQ2F0YWxvZ3NdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5yZXR1cm4gaCgnbGknLCBudWxsLCBbJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLCBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhyZWYgPT09IHNlbGYuZ2V0KCd0aXRsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmF2ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLCBoKCdhJywgeydocmVmJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gWycjL2RvY3VtZW50LycgKyB2YWx1ZS5ocmVmXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKX0sIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt2YWx1ZS50aXRsZV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykpLCBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbdmFsdWUuaHJlZiA9PT0gc2VsZi5nZXQoJ3RpdGxlJyldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpID8gaChTdWJzLCB7J3N1YnMnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbc2VsZi5nZXQoJ3N1YkNhdGFsb2dzJyldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCAnY2hpbGRyZW4nOiBudWxsLCAnX2NvbnRleHQnOiAkdGhpc30pIDogdW5kZWZpbmVkXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdmFsdWUuaHJlZiA9PT0gc2VsZi5nZXQoJ3RpdGxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpKSk7XG59LCB0aGlzKSldLCAnY2F0YWxvZy1zZWN0aW9uJyk7XG59LCB0aGlzKSwgaCgnZGl2JywgbnVsbCwgbnVsbCwgJ2FzaWRlLWJvcmRlciB0cmFuc2l0aW9uJyldLCAnYXNpZGUtd3JhcHBlcicpKSwgaCgnYXJ0aWNsZScsIG51bGwsIFtoKCdkaXYnLCBudWxsLCBbaCgnZGl2JywgbnVsbCwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW2N1cnJlbnROYXYudGl0bGVdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCAndGl0bGUnKSwgaCgnZGl2JywgbnVsbCwgWydcXG4gICAgICAgICAgICAgICAgICAgIOWmguaenOS9oOWPkeeOsOaWh+aho+aciemXrumimO+8jOivt+W4ruW/meWcqFxcbiAgICAgICAgICAgICAgICAgICAgJywgaCgnYScsIHsndGFyZ2V0JzogJ19ibGFuaycsICdocmVmJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW2BodHRwczovL2dpdGh1Yi5jb20vSmF2ZXkvamF2ZXkuZ2l0aHViLmlvL2Jsb2IvbWFzdGVyL2ludGFjdC9kb2NzLyR7c2VsZi5nZXQoJ3RpdGxlJyl9Lm1kYF1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyl9LCAnZ2l0aHViJyksICdcXG4gICAgICAgICAgICAgICAgICAgIOS4iuS/ruato+ivpeaWh+aho1xcbiAgICAgICAgICAgICAgICAnXSwgJ2VkaXQtbGluaycpXSwgJ2FydGljbGUtaGVhZCcpLCBoKCdkaXYnLCB7J2lubmVySFRNTCc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtzZWxmLmdldCgnY29udGVudCcpXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKX0pXSldO30pICYmIChfX2Jsb2Nrc1tcImNvbnRlbnRcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtcbnZhciBzZWxmID0gdGhpcztcbnJldHVybiBibG9ja3NbXCJjb250ZW50XCJdID8gYmxvY2tzW1wiY29udGVudFwiXS5jYWxsKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIF9ibG9ja3NbXCJjb250ZW50XCJdLmNhbGwoc2VsZiwgcGFyZW50KTtcbn0pIDogX2Jsb2Nrc1tcImNvbnRlbnRcIl0uY2FsbCh0aGlzLCBwYXJlbnQpO1xufSksIF9fYmxvY2tzKTtcbn0uY2FsbCh0aGlzLCBibG9ja3MpLCBwYXJlbnQpXG59KS5jYWxsKHRoaXMpXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQudmR0IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2RvY3VtZW50LnN0eWxcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2RvY3VtZW50LnN0eWxcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2RvY3VtZW50LnN0eWxcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQuc3R5bFxuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhsanMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgY29sb3I6ICM1MjUyNTI7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG4uaGxqcy1kb2N0eXBlIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uaGxqcy10YWcge1xcbiAgY29sb3I6ICMzZTc2ZjY7XFxufVxcbi5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmhsanMtdmFsdWUge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5obGpzLWtleXdvcmQge1xcbiAgY29sb3I6ICNlOTY5MDA7XFxufVxcbi5obGpzLXN0cmluZyB7XFxuICBjb2xvcjogIzQyYjk4MztcXG59XFxuLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogI2IzYjNiMztcXG59XFxuLmhsanMtb3BlcmF0b3IgLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogIzUyNTI1MjtcXG59XFxuLmhsanMtcmVnZXhwIHtcXG4gIGNvbG9yOiAjYWY3ZGZmO1xcbn1cXG4uaGxqcy1idWlsdF9pbiB7XFxuICBjb2xvcjogIzJkYjdmNTtcXG59XFxuLmNzcyAuaGxqcy1jbGFzcyB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmNzcyAuaGxqcy1udW1iZXIsXFxuLmphdmFzY3JpcHQgLmhsanMtbnVtYmVyIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG4uY3NzIC5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2FmN2RmZjtcXG59XFxuLmNzcyAuaGxqcy1pbXBvcnRhbnQge1xcbiAgY29sb3I6ICNkMDQ7XFxufVxcbi5hY3Rpb25zY3JpcHQgLmhsanMtbGl0ZXJhbCxcXG4uamF2YXNjcmlwdCAuaGxqcy1saXRlcmFsIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG5wcmUge1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG59XFxuY29kZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZjdmN2Y3O1xcbiAgZm9udC1mYW1pbHk6IENvbnNvbGFzLCBNb25hY28sIEFuZGFsZSBNb25vLCBVYnVudHUgTW9ubywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiAzcHg7XFxuICBwYWRkaW5nOiAxcHggNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5kb2N1bWVudC1wYWdlIHtcXG4gIHBhZGRpbmctdG9wOiA5NXB4O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlci5maXhlZCB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyLmZpeGVkIGFzaWRlIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogODBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDgwcHgpO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyLmZpeGVkIGFydGljbGUge1xcbiAgbWFyZ2luLWxlZnQ6IDIwMHB4O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIHtcXG4gIHdpZHRoOiAxMDgwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4wOCk7XFxuICBtaW4taGVpZ2h0OiBjYWxjKDEwMCUgLSAxNXB4KTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhc2lkZSB7XFxuICB3aWR0aDogMjAwcHg7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZWVlO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciBoNSB7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBtYXJnaW46IDI1cHggMCAxNXB4IDIwcHg7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciBhIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDI1cHg7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciBhOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6ICNmM2YzZjM7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgLmFjdGl2ZSA+IGEge1xcbiAgY29sb3I6ICNmZTQ0NDQ7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgLnN1Yi1jYXRhbG9ncyB7XFxuICBtYXJnaW4tbGVmdDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciAuYXNpZGUtYm9yZGVyIHtcXG4gIGJvcmRlci1yaWdodDogMnB4IHNvbGlkICNmZTQ0NDQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIHtcXG4gIGZsZXg6IDE7XFxuICBwYWRkaW5nOiAxMHB4IDIwcHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXJ0aWNsZS1oZWFkIC50aXRsZSB7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBmb250LXNpemU6IDIuMmVtO1xcbiAgY29sb3I6ICMwMDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFydGljbGUtaGVhZCAuZWRpdC1saW5rIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAyMHB4O1xcbiAgY29sb3I6ICM5OTk7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSBoMSB7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG4gIG1hcmdpbjogMjBweCAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgaDIsXFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIGgzIHtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG4gIG1hcmdpbjogMTVweCAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgcCB7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIC5vdXRwdXQge1xcbiAgcGFkZGluZzogMjBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXJnaW46IDIwcHggMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyP3tcImluY2x1ZGUgY3NzXCI6dHJ1ZX0hLi9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Rocm90dGxlLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsInZhciBhcnJheVNodWZmbGUgPSByZXF1aXJlKCcuL19hcnJheVNodWZmbGUnKSxcbiAgICBiYXNlU2h1ZmZsZSA9IHJlcXVpcmUoJy4vX2Jhc2VTaHVmZmxlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNodWZmbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NodWZmbGUuanMiLCJ2YXIgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgc2h1ZmZsZVNlbGYgPSByZXF1aXJlKCcuL19zaHVmZmxlU2VsZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U2h1ZmZsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U2h1ZmZsZS5qcyIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5kb207XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmFuZG9tLmpzIiwidmFyIHNodWZmbGVTZWxmID0gcmVxdWlyZSgnLi9fc2h1ZmZsZVNlbGYnKSxcbiAgICB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNodWZmbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2h1ZmZsZS5qcyIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi9fYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MsICRjYWxsZWUpIHtcbl9WZHQgfHwgKF9WZHQgPSBWZHQpO1xub2JqIHx8IChvYmogPSB7fSk7XG5ibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbnZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG5fX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsXG5fX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG5fc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbl9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbnNlbGYgPSB0aGlzLmRhdGEsICR0aGlzID0gdGhpcywgc2NvcGUgPSBvYmosIEFuaW1hdGUgPSBzZWxmICYmIHNlbGYuQW5pbWF0ZSwgcGFyZW50ID0gKCRjYWxsZWUgfHwge30pLl9zdXBlclxuY29uc3QgU3VicyA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW2F0dHIuc3Vic11bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykgPyBoKCd1bCcsIG51bGwsIF9WZHQudXRpbHMubWFwKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFthdHRyLnN1YnNdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5yZXR1cm4gaCgnbGknLCBudWxsLCBbaCgnYScsIHsnZXYtY2xpY2snOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbc2VsZi5zY3JvbGxUby5iaW5kKHNlbGYsIHZhbHVlLnRpdGxlLCBhdHRyLnN1YnMuYWN0aXZlKV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyl9LCBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbdmFsdWUudGl0bGVdWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpKSwgaChTdWJzLCB7J3N1YnMnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbdmFsdWUuc3Vic11bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksICdjaGlsZHJlbic6IG51bGwsICdfY29udGV4dCc6ICR0aGlzfSldLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt7XG4gICAgICAgICAgICBhY3RpdmU6IHNlbGYuZ2V0KGF0dHIuc3Vicy5hY3RpdmUpID09PSB2YWx1ZS50aXRsZVxuICAgICAgICB9XVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSkpO1xufSwgdGhpcyksIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3tcInN1Yi1jYXRhbG9nc1wiOiAhYXR0ci5pc0ZpcnN0fV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykpKSA6IHVuZGVmaW5lZFxufTtcbnJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9vYmogPSB7J25hdkluZGV4JzogJ2FwaScsICdjbGFzc05hbWUnOiAnZG9jdW1lbnQtcGFnZSBhcGktcGFnZScsICdjaGlsZHJlbic6IG51bGx9O1xuICAgIGlmIChfb2JqLmhhc093blByb3BlcnR5KFwiYXJndW1lbnRzXCIpKSB7XG4gICAgICAgIGV4dGVuZChfb2JqLCBfb2JqLmFyZ3VtZW50cyA9PT0gdHJ1ZSA/IG9iaiA6IF9vYmouYXJndW1lbnRzKTtcbiAgICAgICAgZGVsZXRlIF9vYmouYXJndW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50LmNhbGwodGhpcywgX29iaiwgX1ZkdCwgZnVuY3Rpb24oYmxvY2tzKSB7XG4gICAgdmFyIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSBleHRlbmQoe30sIGJsb2Nrcyk7XG4gICAgcmV0dXJuICgoX2Jsb2Nrc1tcImNvbnRlbnRcIl0gPSBmdW5jdGlvbihwYXJlbnQpIHtyZXR1cm4gW2goJ2FzaWRlJywgbnVsbCwgaCgnZGl2JywgbnVsbCwgW2goU3VicywgeydzdWJzJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3NlbGYuZ2V0KCdzdWJDYXRhbG9ncycpXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKSwgJ2lzRmlyc3QnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiBbdHJ1ZV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksICdjaGlsZHJlbic6IG51bGwsICdfY29udGV4dCc6ICR0aGlzfSksIGgoJ2RpdicsIG51bGwsIG51bGwsICdhc2lkZS1ib3JkZXIgdHJhbnNpdGlvbicpXSwgJ2FzaWRlLXdyYXBwZXInKSksIGgoJ2FydGljbGUnLCBudWxsLCBoKCdkaXYnLCB7J2lubmVySFRNTCc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFtzZWxmLmdldCgnY29udGVudCcpXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKX0pKV07fSkgJiYgKF9fYmxvY2tzW1wiY29udGVudFwiXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xudmFyIHNlbGYgPSB0aGlzO1xucmV0dXJuIGJsb2Nrc1tcImNvbnRlbnRcIl0gPyBibG9ja3NbXCJjb250ZW50XCJdLmNhbGwodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gX2Jsb2Nrc1tcImNvbnRlbnRcIl0uY2FsbChzZWxmLCBwYXJlbnQpO1xufSkgOiBfYmxvY2tzW1wiY29udGVudFwiXS5jYWxsKHRoaXMsIHBhcmVudCk7XG59KSwgX19ibG9ja3MpO1xufS5jYWxsKHRoaXMsIGJsb2NrcyksIHBhcmVudClcbn0pLmNhbGwodGhpcylcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWdlcy9hcGkvYXBpLnZkdCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTIhLi9hcGkuc3R5bFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vYXBpLnN0eWxcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2FwaS5zdHlsXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhZ2VzL2FwaS9hcGkuc3R5bFxuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hcGktcGFnZSAuY29udGVudC13cmFwcGVyIGFzaWRlIHtcXG4gIHBhZGRpbmc6IDIwcHggMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyP3tcImluY2x1ZGUgY3NzXCI6dHJ1ZX0hLi9wYWdlcy9hcGkvYXBpLnN0eWxcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9