webpackJsonp([2],Array(36).concat([
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, Intact) {exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = __webpack_require__(161);

var _index2 = _interopRequireDefault(_index);

var _index3 = __webpack_require__(162);

var _index4 = _interopRequireDefault(_index3);

var _utils = __webpack_require__(57);

var _layout = __webpack_require__(119);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _class = function (_Layout) {
    _inherits(_class, _Layout);

    function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _Layout.apply(this, arguments));
    }

    _class.prototype._mount = function _mount() {
        _Layout.prototype._mount.call(this);
        var $element = $(this.element);
        var $mds = $element.find('script[type="text/md"]');
        for (var i = 0; i < $mds.length; i++) {
            var $md = $($mds[i]);
            var md = $md.text();
            var html = _utils.marked.render(md);
            // $md.replaceWith($(html));
            $md.next('.code').html(html);
        }
        var $codes = $element.find('pre code');
        var template = void 0;
        for (var _i = 0; _i < $codes.length; _i++) {
            var $code = $($codes[_i]);
            var code = $code.text();
            if ($code.hasClass('language-html')) {
                template = Intact.Vdt.compile(code);
            } else if ($code.hasClass('language-css')) {
                $code.parent().after('<style>' + code + '</style>');
            } else if ($code.hasClass('language-js')) {
                eval(code);
            }
            _utils.highlight.highlightBlock($code[0]);
        }
    };

    _createClass(_class, [{
        key: 'template',
        get: function get() {
            return _index2.default;
        }
    }]);

    return _class;
}(_layout2.default);

exports.default = _class;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), __webpack_require__(7)))

/***/ }),
/* 37 */,
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(45);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(39);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(46);
exports.lib.ucmicro = __webpack_require__(65);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 40 */
/***/ (function(module, exports) {



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typorgapher replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 41 */
/***/ (function(module, exports) {



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports, __webpack_require__) {



/*eslint quotes:0*/
module.exports = __webpack_require__(60);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {



module.exports.encode = __webpack_require__(61);
module.exports.decode = __webpack_require__(62);
module.exports.format = __webpack_require__(63);
module.exports.parse = __webpack_require__(64);

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 50 */
/***/ (function(module, exports) {



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 51 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 52 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the next delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i + 1].token].content = '';
      state.tokens[delimiters[startDelim.end - 1].token].content = '';
      i++;
    }
  }
};

/***/ }),
/* 53 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 54 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 55 */,
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (obj, _Vdt, blocks) {
    if (false) {
        var __this = this;
        module.hot.dispose(function (data) {
            data.vdt = __this;
            data.isParent = __this.data !== obj;
        });
    }

    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        scope = obj,
        Animate = self && self.Animate,
        parent = self && self._parentTemplate;
    var nav = [{
        title: '教程',
        href: 'document'
    }, {
        title: 'API',
        href: 'api'
    }];
    return h('div', null, [h('div', null, h('header', null, (_blocks.header = function (parent) {
        return [h('a', { 'href': '#/' }, 'Intact', 'logo'), h('nav', null, [_Vdt.utils.map(function () {
            try {
                return [nav][0];
            } catch (e) {
                _e(e);
            }
        }.call(this), function (value, key) {
            return h('a', { 'href': function () {
                    try {
                        return ['#/' + value.href][0];
                    } catch (e) {
                        _e(e);
                    }
                }.call(this) }, function () {
                try {
                    return [value.title][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this), _className(function () {
                try {
                    return [{
                        active: value.href === scope.navIndex
                    }][0];
                } catch (e) {
                    _e(e);
                }
            }.call(this)));
        }, this), h('div', null, null, 'border')])];
    }) && (__blocks.header = function (parent) {
        var self = this;
        return blocks.header ? blocks.header.call(this, function () {
            return _blocks.header.call(self, parent);
        }) : _blocks.header.call(this, parent);
    }) && __blocks.header.call(this)), 'header-wrapper'), h('div', null, (_blocks.content = function (parent) {
        return null;
    }) && (__blocks.content = function (parent) {
        var self = this;
        return blocks.content ? blocks.content.call(this, function () {
            return _blocks.content.call(self, parent);
        }) : _blocks.content.call(this, parent);
    }) && __blocks.content.call(this), 'content-wrapper')], _className(function () {
        try {
            return ['main-wrapper ' + (scope.className || '')][0];
        } catch (e) {
            _e(e);
        }
    }.call(this)));
};
if (false) {
    module.hot.accept();
    var vdt = module.hot.data && module.hot.data.vdt;
    if (vdt) {
        if (!module.hot.data.isParent) {
            vdt.template = module.exports;
        }
        vdt.update();
    }
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.marked = exports.highlight = undefined;

var _markdownIt = __webpack_require__(58);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _markdownItDecorate = __webpack_require__(113);

var _markdownItDecorate2 = _interopRequireDefault(_markdownItDecorate);

var _highlight = __webpack_require__(114);

var _highlight2 = _interopRequireDefault(_highlight);

var _javascript = __webpack_require__(115);

var _javascript2 = _interopRequireDefault(_javascript);

var _css = __webpack_require__(116);

var _css2 = _interopRequireDefault(_css);

var _xml = __webpack_require__(117);

var _xml2 = _interopRequireDefault(_xml);

var _bash = __webpack_require__(118);

var _bash2 = _interopRequireDefault(_bash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_highlight2.default.registerLanguage('bash', _bash2.default);
_highlight2.default.registerLanguage('css', _css2.default);
_highlight2.default.registerLanguage('javascript', _javascript2.default);
_highlight2.default.registerLanguage('xml', _xml2.default);

window.highlight = _highlight2.default;

var marked = (0, _markdownIt2.default)({
    html: true,
    breaks: false
}).use(_markdownItDecorate2.default);
// 去掉段落softbreak
marked.renderer.rules.softbreak = function () {
    return '';
};

exports.highlight = _highlight2.default;
exports.marked = marked;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = __webpack_require__(59);

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {



var utils = __webpack_require__(38);
var helpers = __webpack_require__(67);
var Renderer = __webpack_require__(71);
var ParserCore = __webpack_require__(72);
var ParserBlock = __webpack_require__(80);
var ParserInline = __webpack_require__(94);
var LinkifyIt = __webpack_require__(107);
var mdurl = __webpack_require__(46);
var punycode = __webpack_require__(109);

var config = {
  'default': __webpack_require__(110),
  zero: __webpack_require__(111),
  commonmark: __webpack_require__(112)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 61 */
/***/ (function(module, exports) {



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 62 */
/***/ (function(module, exports) {



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 63 */
/***/ (function(module, exports) {



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 64 */
/***/ (function(module, exports) {



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {



exports.Any = __webpack_require__(47);
exports.Cc = __webpack_require__(48);
exports.Cf = __webpack_require__(66);
exports.P = __webpack_require__(39);
exports.Z = __webpack_require__(49);

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {



exports.parseLinkLabel = __webpack_require__(68);
exports.parseLinkDestination = __webpack_require__(69);
exports.parseLinkTitle = __webpack_require__(70);

/***/ }),
/* 68 */
/***/ (function(module, exports) {



module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;
var unescapeAll = __webpack_require__(38).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
        if (level > 1) {
          break;
        }
      }

    if (code === 0x29 /* ) */) {
        level--;
        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {



var unescapeAll = __webpack_require__(38).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {



var assign = __webpack_require__(38).assign;
var unescapeAll = __webpack_require__(38).unescapeAll;
var escapeHtml = __webpack_require__(38).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independed static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

var _rules = [['normalize', __webpack_require__(73)], ['block', __webpack_require__(74)], ['inline', __webpack_require__(75)], ['linkify', __webpack_require__(76)], ['replacements', __webpack_require__(77)], ['smartquotes', __webpack_require__(78)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(79);

module.exports = Core;

/***/ }),
/* 73 */
/***/ (function(module, exports) {



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 74 */
/***/ (function(module, exports) {



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 75 */
/***/ (function(module, exports) {



module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {



var arrayReplaceAt = __webpack_require__(38).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 77 */
/***/ (function(module, exports) {



// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {



var isWhiteSpace = __webpack_require__(38).isWhiteSpace;
var isPunctChar = __webpack_require__(38).isPunctChar;
var isMdAsciiPunct = __webpack_require__(38).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type !== 'text') {
            continue;
          }

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(81), ['paragraph', 'reference']], ['code', __webpack_require__(82)], ['fence', __webpack_require__(83), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(84), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(85), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(86), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(87)], ['heading', __webpack_require__(88), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(89)], ['html_block', __webpack_require__(90), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(92)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(93);

module.exports = ParserBlock;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 82 */
/***/ (function(module, exports) {



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 83 */
/***/ (function(module, exports) {



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false;

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !wasOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 89 */
/***/ (function(module, exports) {



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {



var block_names = __webpack_require__(91);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(50).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 91 */
/***/ (function(module, exports) {



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 92 */
/***/ (function(module, exports) {



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);
var isSpace = __webpack_require__(38).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(40);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(95)], ['newline', __webpack_require__(96)], ['escape', __webpack_require__(97)], ['backticks', __webpack_require__(98)], ['strikethrough', __webpack_require__(51).tokenize], ['emphasis', __webpack_require__(52).tokenize], ['link', __webpack_require__(99)], ['image', __webpack_require__(100)], ['autolink', __webpack_require__(101)], ['html_inline', __webpack_require__(102)], ['entity', __webpack_require__(103)]];

var _rules2 = [['balance_pairs', __webpack_require__(104)], ['strikethrough', __webpack_require__(51).postProcess], ['emphasis', __webpack_require__(52).postProcess], ['text_collapse', __webpack_require__(105)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(106);

module.exports = ParserInline;

/***/ }),
/* 95 */
/***/ (function(module, exports) {



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(38).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 98 */
/***/ (function(module, exports) {



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(38).normalizeReference;
var isSpace = __webpack_require__(38).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {



/*eslint max-len:0*/
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {



var HTML_TAG_RE = __webpack_require__(50).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {



var entities = __webpack_require__(45);
var has = __webpack_require__(38).has;
var isValidEntityCode = __webpack_require__(38).isValidEntityCode;
var fromCodePoint = __webpack_require__(38).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 104 */
/***/ (function(module, exports) {



module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 105 */
/***/ (function(module, exports) {



module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(41);
var isWhiteSpace = __webpack_require__(38).isWhiteSpace;
var isPunctChar = __webpack_require__(38).isPunctChar;
var isMdAsciiPunct = __webpack_require__(38).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(108)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(47).source;
  re.src_Cc = __webpack_require__(48).source;
  re.src_Z = __webpack_require__(49).source;
  re.src_P = __webpack_require__(39).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(53)) == 'object' && __webpack_require__(53)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module), __webpack_require__(54)))

/***/ }),
/* 110 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 113 */
/***/ (function(module, exports) {


/* eslint-disable no-cond-assign */

var tagExpr = /^<!-- ?\{(?:([a-z0-9]+)(\^[0-9]*)?: ?)?(.*)\} ?-->\n?$/;

module.exports = function attributes(md) {
  md.core.ruler.push('curly_attributes', curlyAttrs);
};

/*
 * List of tag -> token type mappings. Eg, `<li>` is `list_item_open`.
 */

var opening = {
  li: ['list_item'],
  ul: ['bullet_list'],
  p: ['paragraph'],
  ol: ['ordered_list'],
  blockquote: ['blockquote'],
  h1: ['heading'],
  h2: ['heading'],
  h3: ['heading'],
  h4: ['heading'],
  h5: ['heading'],
  h6: ['heading'],
  a: ['link'],
  code: ['code_inline', 'code_block', 'fence']
};

var selfClosing = {
  hr: true,
  image: true

  /**
   * ...
   */

};function curlyAttrs(state) {
  var tokens = state.tokens;
  var omissions = [];
  var parent, m;
  var stack = { len: 0, contents: [], types: {} };

  tokens.forEach(function (token, i) {
    // Save breadcrumbs so html_block will pick it up
    if (isOpener(token.type) || selfClosing[token.type]) {
      spush(stack, token);
    }

    // "# Hello\n<!--{.classname}-->"
    // ...sequence of [heading_open, inline, heading_close, html_block]
    if (token.type === 'html_block') {
      m = token.content.match(tagExpr);
      if (!m) return;

      parent = findParent(stack, m[1], m[2]);
      if (parent && applyToToken(parent, m[3])) {
        omissions.unshift(i);
      }
    }

    // "# Hello <!--{.classname} -->"
    // { type: 'inline', children: { ..., '<!--{...}-->' } }
    if (token.type === 'inline') {
      curlyInline(token.children, stack);
    }
  });

  // Remove <!--...--> html_block tokens
  omissions.forEach(function (idx) {
    return tokens.splice(idx, 1);
  });
}

/**
 * Internal: checks in a token type is a block opener
 */

function isOpener(type) {
  return type.match(/_(open|start)$/) || type === 'fence' || type === 'code_block';
}

/**
 * Internal: Run through inline and stuff
 */

function curlyInline(children, stack) {
  var lastText, m, parent;

  // Keep a list of sub-tokens to be removed
  var omissions = [];

  children.forEach(function (child, i) {
    if (isOpener(child.type) || selfClosing[child.type] || child.type === 'code_inline') {
      spush(stack, child);
    }

    // Decorate tags are found
    if (m = child.content.match(tagExpr)) {
      var tag = m[1];
      var depth = m[2];
      var attrs = m[3];

      // Remove the comment, then remove the extra space
      parent = findParent(stack, tag, depth);
      if (parent && applyToToken(parent, attrs)) {
        omissions.unshift(i);
        if (lastText) trimRight(lastText, 'content');
      }
    }

    if (child.type === 'text') lastText = child;
  });

  // Remove them in a separate step so we don't
  omissions.forEach(function (idx) {
    children.splice(idx, 1);
  });
}

/**
 * Private: given a list of tokens `list` and `lastParent`, find the one that
 * matches `tag`.
 */

function findParent(stack, tag, depth) {
  if (!tag) return stack.last;

  if (depth === '^') {
    depth = 1;
  } else if (typeof depth === 'string') {
    /* '^2' */
    depth = +depth.substr(1);
  } else {
    depth = 0;
  }

  var targets = opening[tag.toLowerCase()] || [tag.toLowerCase()];

  var target = targets.filter(function (target) {
    return stack.types[target];
  });

  var list = stack.types[target];
  if (!list) return; // Can't find tag `tag`

  return list[list.length - 1 - depth];
}

/**
 * Private: trim the right
 */

function trimRight(obj, attr) {
  obj[attr] = obj[attr].replace(/\s*$/, '');
}

/**
 * Private: apply tag to token
 *
 *     applyToToken(token, '.classname')
 */

function applyToToken(token, attrs) {
  var m;
  var todo = [];

  while (attrs.length > 0) {
    if (m = attrs.match(/^\s*\.([a-zA-Z0-9\-_]+)/)) {
      todo.push(['class', m[1], { append: true }]);
      shift();
    } else if (m = attrs.match(/^\s*#([a-zA-Z0-9\-_]+)/)) {
      todo.push(['id', m[1]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)="([^"]*)"/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)='([^']*)'/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)=([^ ]*)/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)/)) {
      todo.push([m[1], '']);
      shift();
    } else if (m = attrs.match(/^\s+/)) {
      shift();
    } else {
      return;
    }
  }

  todo.forEach(function (args) {
    setAttr.apply(this, [token].concat(args));
  });
  return true;

  function shift() {
    attrs = attrs.substr(m[0].length);
  }
}

/**
 * Private: sets an attribute `attr` to `value` in a token. If `options.append`
 * is true, append to the old value instead of overwriting it.
 */

function setAttr(token, attr, value, options) {
  var idx = token.attrIndex(attr);

  if (idx === -1) {
    token.attrPush([attr, value]);
  } else if (options && options.append) {
    token.attrs[idx][1] = token.attrs[idx][1] + ' ' + value;
  } else {
    token.attrs[idx][1] = value;
  }
}

/**
 * Private: pushes a token to the stack
 */

function spush(stack, token) {
  var type = token.type.replace(/_(open|start)$/, '');
  if (!stack.types[type]) {
    stack.types[type] = [];
  }
  stack.types[type].push(token);
  stack.last = token;
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function (factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if (true) {
    factory(exports);
  } else if (globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return globalObject.hljs;
      });
    }
  }
})(function (hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent) {
    // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent) {
      result[key] = parent[key];
    }objects.forEach(function (obj) {
      for (key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:
       if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;
       ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace('"', '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function expand_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function (variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];
  }

  function compileLanguage(language) {

    function reStr(re) {
      return re && re.source || re;
    }

    function langRe(value, global) {
      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }

    function compileMode(mode, parent) {
      if (mode.compiled) return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function flatten(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function (kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') {
          // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin) mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null) mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {
        return expand_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function (c) {
        compileMode(c, mode);
      });

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = mode.contains.map(function (c) {
        return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function exec() /*s*/{
          return null;
        } };
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:
   - relevance (int)
  - value (an HTML string with highlighting markup)
   */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan = '<span class="' + classPrefix,
          closeSpan = leaveOpen ? '' : spanEndTag;

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords) return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += top.subLanguage != null ? processSubLanguage() : processKeywords();
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className ? buildSpan(mode.className, '', true) : '';
      top = Object.create(mode, { parent: { value: top } });
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '',
        current;
    for (current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match,
          count,
          index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match) break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:
   - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)
   */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:
   - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers
   */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {
      if (options.useBR && match === '\n') {
        return '<br>';
      } else if (options.tabReplace) {
        return p1.replace(/\t/g, options.tabReplace);
      }
      return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language)) return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function (alias) {
        aliases[alias] = name;
      });
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
      className: 'comment',
      begin: begin, end: end,
      contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [hljs.BACKSLASH_ESCAPE, {
      begin: /\[/, end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
});

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' +
    // ECMAScript 6 modules import
    'import from as',

    literal: 'true false null undefined NaN Infinity',
    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'
  };
  var EXPRESSIONS;
  var NUMBER = {
    className: 'number',
    variants: [{ begin: '\\b(0[bB][01]+)' }, { begin: '\\b(0[oO][0-7]+)' }, { begin: hljs.C_NUMBER_RE }],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: [] // defined later
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];
  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);

  return {
    aliases: ['js', 'jsx'],
    keywords: KEYWORDS,
    contains: [{
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, {
      className: 'meta',
      begin: /^#!/, end: /$/
    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, { // object attr container
      begin: /[{,]\s*/, relevance: 0,
      contains: [{
        begin: IDENT_RE + '\\s*:', returnBegin: true,
        relevance: 0,
        contains: [{ className: 'attr', begin: IDENT_RE, relevance: 0 }]
      }]
    }, { // "value" container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
      keywords: 'return throw case',
      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {
        className: 'function',
        begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
        end: '\\s*=>',
        contains: [{
          className: 'params',
          variants: [{
            begin: IDENT_RE
          }, {
            begin: /\(\s*\)/
          }, {
            begin: /\(/, end: /\)/,
            excludeBegin: true, excludeEnd: true,
            keywords: KEYWORDS,
            contains: PARAMS_CONTAINS
          }]
        }]
      }, { // E4X / JSX
        begin: /</, end: /(\/\w+|\w+\/)>/,
        subLanguage: 'xml',
        contains: [{ begin: /<\w+\s*\/>/, skip: true }, {
          begin: /<\w+/, end: /(\/\w+|\w+\/)>/, skip: true,
          contains: [{ begin: /<\w+\s*\/>/, skip: true }, 'self']
        }]
      }],
      relevance: 0
    }, {
      className: 'function',
      beginKeywords: 'function', end: /\{/, excludeEnd: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }), {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        contains: PARAMS_CONTAINS
      }],
      illegal: /\[|%/
    }, {
      begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
    }, hljs.METHOD_GUARD, { // ES6 class
      className: 'class',
      beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
      illegal: /[:"\[\]]/,
      contains: [{ beginKeywords: 'extends' }, hljs.UNDERSCORE_TITLE_MODE]
    }, {
      beginKeywords: 'constructor', end: /\{/, excludeEnd: true
    }],
    illegal: /#(?!!)/
  };
};

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /[A-Z\_\.\-]+\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [{
      className: 'attribute',
      begin: /\S/, end: ':', excludeEnd: true,
      starts: {
        endsWithParent: true, excludeEnd: true,
        contains: [{
          begin: /[\w-]+\(/, returnBegin: true,
          contains: [{
            className: 'built_in',
            begin: /[\w-]+/
          }, {
            begin: /\(/, end: /\)/,
            contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
          }]
        }, hljs.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, hljs.C_BLOCK_COMMENT_MODE, {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        }, {
          className: 'meta', begin: '!important'
        }]
      }
    }]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [hljs.C_BLOCK_COMMENT_MODE, {
      className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
    }, {
      className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
    }, {
      className: 'selector-attr',
      begin: /\[/, end: /\]/,
      illegal: '$'
    }, {
      className: 'selector-pseudo',
      begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
    }, {
      begin: '@(font-face|page)',
      lexemes: '[a-z-]+',
      keywords: 'font-face page'
    }, {
      begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
      // because it doesn’t let it to be parsed as
      // a rule set but instead drops parser into
      // the default mode which is how it should be.
      illegal: /:/, // break on Less variables @var: ...
      contains: [{
        className: 'keyword',
        begin: /\w+/
      }, {
        begin: /\s/, endsWithParent: true, excludeEnd: true,
        relevance: 0,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, hljs.CSS_NUMBER_MODE]
      }]
    }, {
      className: 'selector-tag', begin: IDENT_RE,
      relevance: 0
    }, {
      begin: '{', end: '}',
      illegal: /\S/,
      contains: [hljs.C_BLOCK_COMMENT_MODE, RULE]
    }]
  };
};

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [{
      className: 'attr',
      begin: XML_IDENT_RE,
      relevance: 0
    }, {
      begin: /=\s*/,
      relevance: 0,
      contains: [{
        className: 'string',
        endsParent: true,
        variants: [{ begin: /"/, end: /"/ }, { begin: /'/, end: /'/ }, { begin: /[^\s"'=<>`]+/ }]
      }]
    }]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
    case_insensitive: true,
    contains: [{
      className: 'meta',
      begin: '<!DOCTYPE', end: '>',
      relevance: 10,
      contains: [{ begin: '\\[', end: '\\]' }]
    }, hljs.COMMENT('<!--', '-->', {
      relevance: 10
    }), {
      begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
      relevance: 10
    }, {
      begin: /<\?(php)?/, end: /\?>/,
      subLanguage: 'php',
      contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
    }, {
      className: 'tag',
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending braket. The '$' is needed for the lexeme to be recognized
      by hljs.subMode() that tests lexemes outside the stream.
      */
      begin: '<style(?=\\s|>|$)', end: '>',
      keywords: { name: 'style' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '</style>', returnEnd: true,
        subLanguage: ['css', 'xml']
      }
    }, {
      className: 'tag',
      // See the comment in the <style tag about the lookahead pattern
      begin: '<script(?=\\s|>|$)', end: '>',
      keywords: { name: 'script' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '\<\/script\>', returnEnd: true,
        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
      }
    }, {
      className: 'meta',
      variants: [{ begin: /<\?xml/, end: /\?>/, relevance: 10 }, { begin: /<\?\w+/, end: /\?>/ }]
    }, {
      className: 'tag',
      begin: '</?', end: '/?>',
      contains: [{
        className: 'name', begin: /[^\/><\s]+/, relevance: 0
      }, TAG_INTERNALS]
    }]
  };
};

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var VAR = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d#@][\w\d_]*/ }, { begin: /\$\{(.*?)}/ }]
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: /"/, end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, {
      className: 'variable',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  var APOS_STRING = {
    className: 'string',
    begin: /'/, end: /'/
  };

  return {
    aliases: ['sh', 'zsh'],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: 'if then else elif fi for while in do done case esac function',
      literal: 'true false',
      built_in:
      // Shell built-ins
      // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' + 'trap umask unset ' +
      // Bash built-ins
      'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' + 'read readarray source type typeset ulimit unalias ' +
      // Shell modifiers
      'set shopt ' +
      // Zsh built-ins
      'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' + 'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' + 'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' + 'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' + 'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' + 'zpty zregexparse zsocket zstyle ztcp',
      _: '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster
    },
    contains: [{
      className: 'meta',
      begin: /^#![^\n]+sh\s*$/,
      relevance: 10
    }, {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, hljs.HASH_COMMENT_MODE, QUOTE_STRING, APOS_STRING, VAR]
  };
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _class = function (_Intact) {
    _inherits(_class, _Intact);

    function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _class.prototype._mount = function _mount() {
        this.$border = $(this.element).find('.border');
        this._updateBorder();
    };

    _class.prototype._updateBorder = function _updateBorder() {
        var $nav = $(this.element).find('.active');
        var width = 0;
        var left = 0;
        if ($nav.length) {
            left = $nav.position().left;
            width = $nav.outerWidth();
        }
        this.$border.addClass('transition');
        this.$border.css({ width: width, left: left });
    };

    return _class;
}(Intact);

exports.default = _class;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(16)))

/***/ }),
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (obj, _Vdt, blocks) {
    if (false) {
        var __this = this;
        module.hot.dispose(function (data) {
            data.vdt = __this;
            data.isParent = __this.data !== obj;
        });
    }

    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        scope = obj,
        Animate = self && self.Animate,
        parent = self && self._parentTemplate;
    var layout = __webpack_require__(56);

    return function (blocks) {
        var _blocks = {},
            __blocks = extend({}, blocks),
            _obj = { 'className': 'index-page' } || {};
        if (_obj.hasOwnProperty("arguments")) {
            extend(_obj, _obj.arguments === true ? obj : _obj.arguments);delete _obj.arguments;
        }
        return layout.call(this, _obj, _Vdt, (_blocks.content = function (parent) {
            return [h('article', null, ['\n            ', hc(' <img src=\"images/logo.png\" /> '), h('h1', null, 'Intact'), h('p', null, '可继承的前端开发框架'), h('div', null, [h('a', { 'href': '#/document/start' }, '开始', 'button'), h('a', { 'href': 'https://github.com/Javey/intact', 'target': '_blank' }, 'GitHub', 'button white')], 'actions'), h('div', null, [h('div', null, [h('h2', null, '简单', 'blue'), h('div', null, '\n                        没有复杂的概念，你仅仅只需要了解HTML，CSS和JavaScript即可\n                    ')], 'feature'), h('div', null, [h('h2', null, '高效', 'yellow'), h('div', null, ['\n                        22KB min+gzip 大小，包含前端编译模块；', h('br'), '\n                        fork自目前最快的虚拟DOM引擎之一（inferno）构建\n                    '])], 'feature'), h('div', null, [h('h2', null, '可继承', 'red'), h('div', null, '\n                        充分发挥继承的优势，实现组件逻辑和模板的继承扩展，\n                        让你更快速方便地构建复杂的应用\n                    ')], 'feature')], 'features')], 'home-header'), h('article', null, ['\n            ', hc(' <h1>可继承的响应式组件</h1> '), h('h3', null, '通过继承的思想，来扩展父组件逻辑和模板。同时组件数据变更，界面会立即自动做出相应更新'), h('div', null, [h('script', { 'type': 'text/md', 'innerHTML': '\n```js\nvar Layout = Intact.extend({\n    template: \'<div>\\\n        <header>\\\n            <b:header>Extendable and Reactive Component</b:header>\\\n        </header>\\\n        <div>\\\n            <b:body>\\\n                <div class=\"count\">{self.get(\"count\")}</div>\\\n            </b:body>\\\n        </div>\\\n    </div>\',\n    defaults: function() {\n        return {count: 0};\n    }\n});\n\nvar Page = Layout.extend({\n    template: \'<t:parent>\\\n        <b:body>\\\n            {parent()}\\\n            <button class=\"button\"\\\n                ev-click={self.add.bind(self)}\\\n            >Click me!</button>\\\n        </b:body>\\\n    </t:parent>\',\n    add: function() {\n        this.set(\'count\', this.get(\'count\') + 1);\n    }\n});\n\nIntact.mount(Page, document.getElementById(\'app\'));\n```\n                ' }), h('div', null, null, 'code'), h('div', { 'id': 'app' }, null, 'output')], 'code-wrapper')], 'home-components')];
        }) && (__blocks.content = function (parent) {
            var self = this;
            return blocks.content ? blocks.content.call(this, function () {
                return _blocks.content.call(self, parent);
            }) : _blocks.content.call(this, parent);
        }) && __blocks);
    }.call(this, blocks);
};
if (false) {
    module.hot.accept();
    var vdt = module.hot.data && module.hot.data.vdt;
    if (vdt) {
        if (!module.hot.data.isParent) {
            vdt.template = module.exports;
        }
        vdt.update();
    }
}

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(163);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(9)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./index.styl", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/stylus-loader/index.js??ref--2-2!./index.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(undefined);
// imports


// module
exports.push([module.i, ".hljs {\n  display: block;\n  overflow-x: auto;\n  color: #525252;\n  padding: 15px;\n  -webkit-text-size-adjust: none;\n  margin: 0;\n}\n.hljs-doctype {\n  color: #999;\n}\n.hljs-tag {\n  color: #3e76f6;\n}\n.hljs-attribute {\n  color: #e96900;\n}\n.hljs-value {\n  color: #42b983;\n}\n.hljs-keyword {\n  color: #e96900;\n}\n.hljs-string {\n  color: #42b983;\n}\n.hljs-comment {\n  color: #b3b3b3;\n}\n.hljs-operator .hljs-comment {\n  color: #525252;\n}\n.hljs-regexp {\n  color: #af7dff;\n}\n.hljs-built_in {\n  color: #2db7f5;\n}\n.css .hljs-class {\n  color: #e96900;\n}\n.css .hljs-number,\n.javascript .hljs-number {\n  color: #fc1e70;\n}\n.css .hljs-attribute {\n  color: #af7dff;\n}\n.css .hljs-important {\n  color: #d04;\n}\n.actionscript .hljs-literal,\n.javascript .hljs-literal {\n  color: #fc1e70;\n}\npre {\n  padding: 0;\n  margin: 0;\n}\ncode {\n  display: inline-block;\n  background: #f7f7f7;\n  font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;\n  margin: 3px;\n  padding: 1px 5px;\n  border-radius: 3px;\n  color: #666;\n  border: 1px solid #eee;\n  line-height: 20px;\n}\n.index-page .content-wrapper {\n  min-height: 100%;\n  background: #fff;\n  padding-top: 80px;\n  box-sizing: border-box;\n  text-align: center;\n}\n.index-page .home-header {\n  padding: 50px 0;\n}\n.index-page .home-header h1 {\n  font-size: 5em;\n  font-weight: 600;\n  font-family: Arial;\n}\n.index-page .home-header p {\n  font-size: 2em;\n  font-weight: 300;\n  color: #46484a;\n}\n.index-page .home-header .button {\n  display: inline-block;\n  background: #d04;\n  color: #fff;\n  padding: 0 2em;\n  border-radius: 0.2em;\n  margin: 0 10px;\n  height: 3em;\n  line-height: 3em;\n  box-sizing: border-box;\n}\n.index-page .home-header .button:hover {\n  background: #fe4444;\n}\n.index-page .home-header .button.white {\n  background: #fff;\n  border: 1px solid #ccc;\n  color: #666;\n}\n.index-page .home-header .button.white:hover {\n  background: #eee;\n}\n.index-page .home-header .features {\n  width: 1080px;\n  margin: 0 auto;\n  display: flex;\n  margin-top: 50px;\n}\n.index-page .home-header .feature {\n  flex: 1;\n}\n.index-page .home-header .feature h2 {\n  margin: 10px;\n}\n.index-page .home-components {\n  background: #f8f8f8;\n  padding: 30px 0;\n}\n.index-page .home-components h1 {\n  font-size: 3em;\n  color: #111;\n}\n.index-page .home-components h3 {\n  color: #37393b;\n  font-size: 1.3em;\n  margin: 0.7em 0;\n}\n.index-page .code-wrapper {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  text-align: left;\n}\n.index-page .code-wrapper .code {\n  width: 620px;\n}\n.index-page .code-wrapper .code pre {\n  margin: 10px;\n}\n.index-page .code-wrapper .code code {\n  background: #fff;\n}\n.index-page .code-wrapper .output {\n  width: 300px;\n  margin: 10px;\n  background: #fff;\n  border-radius: 3px;\n  padding: 15px;\n}\n.index-page .code-wrapper .count {\n  color: #09d;\n  font-size: 3em;\n  margin: 10px 0 12px;\n}\n.index-page .code-wrapper .button {\n  font-size: 1.2em;\n  padding: 10px;\n}\n.index-page .code-wrapper header {\n  font-size: 2em;\n  margin: 10px 0;\n}\n", ""]);

// exports


/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9pbmRleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3BhZ2VzL2xheW91dC52ZHQiLCJ3ZWJwYWNrOi8vLy4vbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZHVybC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQtZGVjb3JhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9jc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaC5qcyIsIndlYnBhY2s6Ly8vLi9wYWdlcy9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFnZXMvaW5kZXgvaW5kZXgudmR0Iiwid2VicGFjazovLy8uL3BhZ2VzL2luZGV4L2luZGV4LnN0eWw/MTMyMiIsIndlYnBhY2s6Ly8vLi9wYWdlcy9pbmRleC9pbmRleC5zdHlsIl0sIm5hbWVzIjpbIl9tb3VudCIsIiRlbGVtZW50IiwiJCIsImVsZW1lbnQiLCIkbWRzIiwiZmluZCIsImkiLCJsZW5ndGgiLCIkbWQiLCJtZCIsInRleHQiLCJodG1sIiwicmVuZGVyIiwibmV4dCIsIiRjb2RlcyIsInRlbXBsYXRlIiwiJGNvZGUiLCJjb2RlIiwiaGFzQ2xhc3MiLCJJbnRhY3QiLCJWZHQiLCJjb21waWxlIiwicGFyZW50IiwiYWZ0ZXIiLCJldmFsIiwiaGlnaGxpZ2h0QmxvY2siLCJfY2xhc3MiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0Iiwia2V5IiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwic291cmNlIiwiVHlwZUVycm9yIiwia2V5cyIsImFycmF5UmVwbGFjZUF0Iiwic3JjIiwicG9zIiwibmV3RWxlbWVudHMiLCJjb25jYXQiLCJpc1ZhbGlkRW50aXR5Q29kZSIsImMiLCJmcm9tQ29kZVBvaW50Iiwic3Vycm9nYXRlMSIsInN1cnJvZ2F0ZTIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTkVTQ0FQRV9NRF9SRSIsIkVOVElUWV9SRSIsIlVORVNDQVBFX0FMTF9SRSIsIlJlZ0V4cCIsIkRJR0lUQUxfRU5USVRZX1RFU1RfUkUiLCJlbnRpdGllcyIsInJlcXVpcmUiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsIm1hdGNoIiwibmFtZSIsImNoYXJDb2RlQXQiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJwYXJzZUludCIsInVuZXNjYXBlTWQiLCJzdHIiLCJpbmRleE9mIiwicmVwbGFjZSIsInVuZXNjYXBlQWxsIiwiZXNjYXBlZCIsImVudGl0eSIsIkhUTUxfRVNDQVBFX1RFU1RfUkUiLCJIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFIiwiSFRNTF9SRVBMQUNFTUVOVFMiLCJyZXBsYWNlVW5zYWZlQ2hhciIsImNoIiwiZXNjYXBlSHRtbCIsIlJFR0VYUF9FU0NBUEVfUkUiLCJlc2NhcGVSRSIsImlzU3BhY2UiLCJpc1doaXRlU3BhY2UiLCJVTklDT0RFX1BVTkNUX1JFIiwiaXNQdW5jdENoYXIiLCJpc01kQXNjaWlQdW5jdCIsIm5vcm1hbGl6ZVJlZmVyZW5jZSIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImV4cG9ydHMiLCJsaWIiLCJtZHVybCIsInVjbWljcm8iLCJtb2R1bGUiLCJSdWxlciIsIl9fcnVsZXNfXyIsIl9fY2FjaGVfXyIsIl9fZmluZF9fIiwiX19jb21waWxlX18iLCJzZWxmIiwiY2hhaW5zIiwicnVsZSIsImVuYWJsZWQiLCJhbHQiLCJhbHROYW1lIiwicHVzaCIsImNoYWluIiwiZm4iLCJhdCIsIm9wdGlvbnMiLCJpbmRleCIsIm9wdCIsIkVycm9yIiwiYmVmb3JlIiwiYmVmb3JlTmFtZSIsInJ1bGVOYW1lIiwic3BsaWNlIiwiYWZ0ZXJOYW1lIiwiZW5hYmxlIiwibGlzdCIsImlnbm9yZUludmFsaWQiLCJpc0FycmF5IiwicmVzdWx0IiwiaWR4IiwiZW5hYmxlT25seSIsImRpc2FibGUiLCJnZXRSdWxlcyIsImNoYWluTmFtZSIsIlRva2VuIiwidHlwZSIsInRhZyIsIm5lc3RpbmciLCJhdHRycyIsIm1hcCIsImxldmVsIiwiY2hpbGRyZW4iLCJjb250ZW50IiwibWFya3VwIiwiaW5mbyIsIm1ldGEiLCJibG9jayIsImhpZGRlbiIsImF0dHJJbmRleCIsImxlbiIsImF0dHJQdXNoIiwiYXR0ckRhdGEiLCJhdHRyU2V0IiwidmFsdWUiLCJhdHRyR2V0IiwiYXR0ckpvaW4iLCJlbmNvZGUiLCJkZWNvZGUiLCJmb3JtYXQiLCJwYXJzZSIsImF0dHJfbmFtZSIsInVucXVvdGVkIiwic2luZ2xlX3F1b3RlZCIsImRvdWJsZV9xdW90ZWQiLCJhdHRyX3ZhbHVlIiwiYXR0cmlidXRlIiwib3Blbl90YWciLCJjbG9zZV90YWciLCJjb21tZW50IiwicHJvY2Vzc2luZyIsImRlY2xhcmF0aW9uIiwiY2RhdGEiLCJIVE1MX1RBR19SRSIsIkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUiLCJ0b2tlbml6ZSIsInN0cmlrZXRocm91Z2giLCJzdGF0ZSIsInNpbGVudCIsInNjYW5uZWQiLCJ0b2tlbiIsInN0YXJ0IiwibWFya2VyIiwic2NhbkRlbGltcyIsImRlbGltaXRlcnMiLCJqdW1wIiwidG9rZW5zIiwiZW5kIiwib3BlbiIsImNhbl9vcGVuIiwiY2xvc2UiLCJjYW5fY2xvc2UiLCJwb3N0UHJvY2VzcyIsImoiLCJzdGFydERlbGltIiwiZW5kRGVsaW0iLCJsb25lTWFya2VycyIsIm1heCIsInBvcCIsImVtcGhhc2lzIiwiaXNTdHJvbmciLCJnIiwiRnVuY3Rpb24iLCJlIiwid2luZG93IiwiX1ZkdCIsImJsb2NrcyIsIl9fdGhpcyIsImhvdCIsImRpc3Bvc2UiLCJkYXRhIiwidmR0IiwiaXNQYXJlbnQiLCJoIiwibWlzcyIsImhjIiwiaHUiLCJ3aWRnZXRzIiwiX2Jsb2NrcyIsIl9fYmxvY2tzIiwiX191IiwidXRpbHMiLCJleHRlbmQiLCJfZSIsImVycm9yIiwiX2NsYXNzTmFtZSIsImNsYXNzTmFtZSIsIl9fbyIsIk9wdGlvbnMiLCJfZ2V0TW9kZWwiLCJnZXRNb2RlbCIsIl9zZXRNb2RlbCIsInNldE1vZGVsIiwiX3NldENoZWNrYm94TW9kZWwiLCJzZXRDaGVja2JveE1vZGVsIiwiX2RldGVjdENoZWNrYm94Q2hlY2tlZCIsImRldGVjdENoZWNrYm94Q2hlY2tlZCIsIl9zZXRTZWxlY3RNb2RlbCIsInNldFNlbGVjdE1vZGVsIiwic2NvcGUiLCJBbmltYXRlIiwiX3BhcmVudFRlbXBsYXRlIiwibmF2IiwidGl0bGUiLCJocmVmIiwiaGVhZGVyIiwiYWN0aXZlIiwibmF2SW5kZXgiLCJhY2NlcHQiLCJ1cGRhdGUiLCJyZWdpc3Rlckxhbmd1YWdlIiwiaGlnaGxpZ2h0IiwibWFya2VkIiwiYnJlYWtzIiwidXNlIiwicmVuZGVyZXIiLCJydWxlcyIsInNvZnRicmVhayIsImhlbHBlcnMiLCJSZW5kZXJlciIsIlBhcnNlckNvcmUiLCJQYXJzZXJCbG9jayIsIlBhcnNlcklubGluZSIsIkxpbmtpZnlJdCIsInB1bnljb2RlIiwiY29uZmlnIiwiemVybyIsImNvbW1vbm1hcmsiLCJCQURfUFJPVE9fUkUiLCJHT09EX0RBVEFfUkUiLCJ2YWxpZGF0ZUxpbmsiLCJ1cmwiLCJSRUNPREVfSE9TVE5BTUVfRk9SIiwibm9ybWFsaXplTGluayIsInBhcnNlZCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJ0b0FTQ0lJIiwiZXIiLCJub3JtYWxpemVMaW5rVGV4dCIsInRvVW5pY29kZSIsIk1hcmtkb3duSXQiLCJwcmVzZXROYW1lIiwiaW5saW5lIiwiY29yZSIsImxpbmtpZnkiLCJjb25maWd1cmUiLCJzZXQiLCJwcmVzZXRzIiwiY29tcG9uZW50cyIsInJ1bGVyIiwicnVsZXMyIiwicnVsZXIyIiwibWlzc2VkIiwiZmlsdGVyIiwicGx1Z2luIiwiYXJncyIsImFwcGx5IiwiZW52IiwiU3RhdGUiLCJwcm9jZXNzIiwicGFyc2VJbmxpbmUiLCJpbmxpbmVNb2RlIiwicmVuZGVySW5saW5lIiwiZW5jb2RlQ2FjaGUiLCJnZXRFbmNvZGVDYWNoZSIsImV4Y2x1ZGUiLCJjYWNoZSIsInN0cmluZyIsImtlZXBFc2NhcGVkIiwibCIsIm5leHRDb2RlIiwiZGVmYXVsdENoYXJzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY29tcG9uZW50Q2hhcnMiLCJkZWNvZGVDYWNoZSIsImdldERlY29kZUNhY2hlIiwic2VxIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJjaHIiLCJzbGFzaGVzIiwiYXV0aCIsInBvcnQiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJVcmwiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInVybFBhcnNlIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwibG93ZXJQcm90byIsImhlYyIsInJlc3QiLCJzcGxpdCIsInNpbXBsZVBhdGgiLCJleGVjIiwicHJvdG8iLCJzdWJzdHIiLCJob3N0RW5kIiwiYXRTaWduIiwibGFzdEluZGV4T2YiLCJob3N0IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJrIiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJ1bnNoaWZ0Iiwiam9pbiIsInFtIiwiQW55IiwiQ2MiLCJDZiIsIlAiLCJaIiwicGFyc2VMaW5rTGFiZWwiLCJwYXJzZUxpbmtEZXN0aW5hdGlvbiIsInBhcnNlTGlua1RpdGxlIiwiZGlzYWJsZU5lc3RlZCIsImZvdW5kIiwicHJldlBvcyIsImxhYmVsRW5kIiwicG9zTWF4Iiwib2xkUG9zIiwic2tpcFRva2VuIiwibGluZXMiLCJvayIsImRlZmF1bHRfcnVsZXMiLCJjb2RlX2lubGluZSIsInNsZiIsInJlbmRlckF0dHJzIiwiY29kZV9ibG9jayIsImZlbmNlIiwibGFuZ05hbWUiLCJoaWdobGlnaHRlZCIsInRtcEF0dHJzIiwidG1wVG9rZW4iLCJsYW5nUHJlZml4IiwiaW1hZ2UiLCJyZW5kZXJJbmxpbmVBc1RleHQiLCJyZW5kZXJUb2tlbiIsImhhcmRicmVhayIsInhodG1sT3V0IiwiaHRtbF9ibG9jayIsImh0bWxfaW5saW5lIiwibmV4dFRva2VuIiwibmVlZExmIiwiX3J1bGVzIiwiQ29yZSIsIk5FV0xJTkVTX1JFIiwiTlVMTF9SRSIsInRvayIsImlzTGlua09wZW4iLCJpc0xpbmtDbG9zZSIsImN1cnJlbnRUb2tlbiIsIm5vZGVzIiwibG4iLCJsYXN0UG9zIiwiaHRtbExpbmtMZXZlbCIsImZ1bGxVcmwiLCJ1cmxUZXh0IiwiYmxvY2tUb2tlbnMiLCJsaW5rcyIsInByZXRlc3QiLCJzY2hlbWEiLCJsYXN0SW5kZXgiLCJSQVJFX1JFIiwiU0NPUEVEX0FCQlJfVEVTVF9SRSIsIlNDT1BFRF9BQkJSX1JFIiwiU0NPUEVEX0FCQlIiLCJyIiwicCIsInRtIiwicmVwbGFjZUZuIiwicmVwbGFjZV9zY29wZWQiLCJpbmxpbmVUb2tlbnMiLCJpbnNpZGVfYXV0b2xpbmsiLCJyZXBsYWNlX3JhcmUiLCJibGtJZHgiLCJ0eXBvZ3JhcGhlciIsIlFVT1RFX1RFU1RfUkUiLCJRVU9URV9SRSIsIkFQT1NUUk9QSEUiLCJyZXBsYWNlQXQiLCJwcm9jZXNzX2lubGluZXMiLCJ0IiwidGhpc0xldmVsIiwiaXRlbSIsImxhc3RDaGFyIiwibmV4dENoYXIiLCJpc0xhc3RQdW5jdENoYXIiLCJpc05leHRQdW5jdENoYXIiLCJpc0xhc3RXaGl0ZVNwYWNlIiwiaXNOZXh0V2hpdGVTcGFjZSIsImNhbk9wZW4iLCJjYW5DbG9zZSIsImlzU2luZ2xlIiwic3RhY2siLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJxdW90ZXMiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJsaW5lIiwiaGFzRW1wdHlMaW5lcyIsIm1heE5lc3RpbmciLCJza2lwRW1wdHlMaW5lcyIsInNDb3VudCIsImJsa0luZGVudCIsInRpZ2h0IiwiaXNFbXB0eSIsIm91dFRva2VucyIsImxpbmVNYXgiLCJnZXRMaW5lIiwiYk1hcmtzIiwiZU1hcmtzIiwiZXNjYXBlZFNwbGl0IiwiZXNjYXBlcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJzdWJzdHJpbmciLCJ0YWJsZSIsImxpbmVUZXh0IiwibmV4dExpbmUiLCJjb2x1bW5zIiwiY29sdW1uQ291bnQiLCJhbGlnbnMiLCJ0YWJsZUxpbmVzIiwidGJvZHlMaW5lcyIsInRTaGlmdCIsImxhc3QiLCJnZXRMaW5lcyIsInBhcmFtcyIsIm1lbSIsImhhdmVFbmRNYXJrZXIiLCJza2lwQ2hhcnMiLCJza2lwU3BhY2VzIiwiYmxvY2txdW90ZSIsImFkanVzdFRhYiIsImluaXRpYWwiLCJsYXN0TGluZUVtcHR5Iiwib2Zmc2V0Iiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwid2FzT3V0ZGVudGVkIiwib2xkTGluZU1heCIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwiaHIiLCJjbnQiLCJza2lwQnVsbGV0TGlzdE1hcmtlciIsInNraXBPcmRlcmVkTGlzdE1hcmtlciIsIm1hcmtUaWdodFBhcmFncmFwaHMiLCJjb250ZW50U3RhcnQiLCJpbmRlbnQiLCJpbmRlbnRBZnRlck1hcmtlciIsImlzT3JkZXJlZCIsIml0ZW1MaW5lcyIsImxpc3RMaW5lcyIsImxpc3RUb2tJZHgiLCJtYXJrZXJDaGFyQ29kZSIsIm1hcmtlclZhbHVlIiwib2xkTEluZGVudCIsIm9sZFRpZ2h0IiwicG9zQWZ0ZXJNYXJrZXIiLCJwcmV2RW1wdHlFbmQiLCJpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoIiwiTnVtYmVyIiwiTWF0aCIsIm1pbiIsInJlZmVyZW5jZSIsIl9lbmRMaW5lIiwiZGVzdEVuZFBvcyIsImRlc3RFbmRMaW5lTm8iLCJsYWJlbCIsInJlcyIsInJlZmVyZW5jZXMiLCJoZWFkaW5nIiwidG1wIiwic2tpcFNwYWNlc0JhY2siLCJza2lwQ2hhcnNCYWNrIiwibGhlYWRpbmciLCJibG9ja19uYW1lcyIsIkhUTUxfU0VRVUVOQ0VTIiwicGFyYWdyYXBoIiwiU3RhdGVCbG9jayIsInMiLCJpbmRlbnRfZm91bmQiLCJkZEluZGVudCIsImZyb20iLCJiZWdpbiIsImtlZXBMYXN0TEYiLCJsaW5lSW5kZW50IiwiZmlyc3QiLCJxdWV1ZSIsImxpbmVTdGFydCIsIl9ydWxlczIiLCJwZW5kaW5nIiwicHVzaFBlbmRpbmciLCJpc1Rlcm1pbmF0b3JDaGFyIiwibmV3bGluZSIsInBtYXgiLCJFU0NBUEVEIiwiZXNjYXBlIiwiYmFja3RpY2siLCJtYXRjaFN0YXJ0IiwibWF0Y2hFbmQiLCJsaW5rIiwibGFiZWxTdGFydCIsInJlZiIsInBhcnNlUmVmZXJlbmNlIiwiRU1BSUxfUkUiLCJBVVRPTElOS19SRSIsImF1dG9saW5rIiwidGFpbCIsImxpbmtNYXRjaCIsImVtYWlsTWF0Y2giLCJpc0xldHRlciIsImxjIiwiRElHSVRBTF9SRSIsIk5BTUVEX1JFIiwibGlua19wYWlycyIsImxhc3REZWxpbSIsImN1cnJEZWxpbSIsIm9kZF9tYXRjaCIsInRleHRfY29sbGFwc2UiLCJjdXJyIiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJjb3VudCIsImxlZnRfZmxhbmtpbmciLCJyaWdodF9mbGFua2luZyIsImlzT2JqZWN0IiwiaXNSZWdFeHAiLCJpc0Z1bmN0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJmdXp6eUxpbmsiLCJmdXp6eUVtYWlsIiwiZnV6enlJUCIsImlzT3B0aW9uc09iaiIsInJlZHVjZSIsImFjYyIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJyZSIsImh0dHAiLCJzcmNfYXV0aCIsInNyY19ob3N0X3BvcnRfc3RyaWN0Iiwic3JjX3BhdGgiLCJub19odHRwIiwic3JjX2RvbWFpbiIsInNyY19kb21haW5fcm9vdCIsInNyY19wb3J0Iiwic3JjX2hvc3RfdGVybWluYXRvciIsIm1haWx0byIsInNyY19lbWFpbF9uYW1lIiwic3JjX2hvc3Rfc3RyaWN0IiwidGxkc18yY2hfc3JjX3JlIiwidGxkc19kZWZhdWx0IiwicmVzZXRTY2FuQ2FjaGUiLCJfX2luZGV4X18iLCJfX3RleHRfY2FjaGVfXyIsImNyZWF0ZVZhbGlkYXRvciIsImNyZWF0ZU5vcm1hbGl6ZXIiLCJub3JtYWxpemUiLCJfX29wdHNfXyIsInRsZHMiLCJfX3RsZHNfXyIsIm9uQ29tcGlsZSIsIl9fdGxkc19yZXBsYWNlZF9fIiwic3JjX3huIiwic3JjX3RsZHMiLCJ1bnRwbCIsInRwbCIsImVtYWlsX2Z1enp5IiwidHBsX2VtYWlsX2Z1enp5IiwibGlua19mdXp6eSIsInRwbF9saW5rX2Z1enp5IiwibGlua19ub19pcF9mdXp6eSIsInRwbF9saW5rX25vX2lwX2Z1enp5IiwiaG9zdF9mdXp6eV90ZXN0IiwidHBsX2hvc3RfZnV6enlfdGVzdCIsImFsaWFzZXMiLCJfX2NvbXBpbGVkX18iLCJzY2hlbWFFcnJvciIsInZhbCIsIl9fc2NoZW1hc19fIiwiY29tcGlsZWQiLCJhbGlhcyIsInNsaXN0Iiwic2NoZW1hX3Rlc3QiLCJzcmNfWlBDYyIsInNjaGVtYV9zZWFyY2giLCJNYXRjaCIsInNoaWZ0IiwiX19sYXN0X2luZGV4X18iLCJfX3NjaGVtYV9fIiwicmF3IiwiY3JlYXRlTWF0Y2giLCJzY2hlbWFzIiwiYWRkIiwiZGVmaW5pdGlvbiIsIm0iLCJtbCIsIm1lIiwidGxkX3BvcyIsImF0X3BvcyIsInRlc3RTY2hlbWFBdCIsImtlZXBPbGQiLCJzb3J0IiwiZWwiLCJhcnIiLCJyZXZlcnNlIiwib3B0cyIsInNyY19BbnkiLCJzcmNfQ2MiLCJzcmNfWiIsInNyY19QIiwic3JjX1pDYyIsInRleHRfc2VwYXJhdG9ycyIsInNyY19wc2V1ZG9fbGV0dGVyIiwic3JjX2lwNCIsInNyY19ob3N0IiwidHBsX2hvc3RfZnV6enkiLCJ0cGxfaG9zdF9ub19pcF9mdXp6eSIsInRwbF9ob3N0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QiLCJyb290IiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwiZmxvb3IiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJSYW5nZUVycm9yIiwiYXJyYXkiLCJtYXBEb21haW4iLCJwYXJ0cyIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwib3V0IiwibiIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJ3IiwiYmFzZU1pbnVzVCIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsImRlZmluZSIsInRhZ0V4cHIiLCJhdHRyaWJ1dGVzIiwiY3VybHlBdHRycyIsIm9wZW5pbmciLCJsaSIsInVsIiwib2wiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJhIiwic2VsZkNsb3NpbmciLCJvbWlzc2lvbnMiLCJjb250ZW50cyIsInR5cGVzIiwiaXNPcGVuZXIiLCJzcHVzaCIsImZpbmRQYXJlbnQiLCJhcHBseVRvVG9rZW4iLCJjdXJseUlubGluZSIsImxhc3RUZXh0IiwiY2hpbGQiLCJkZXB0aCIsInRyaW1SaWdodCIsInRhcmdldHMiLCJ0YXJnZXQiLCJhdHRyIiwidG9kbyIsImFwcGVuZCIsInNldEF0dHIiLCJmYWN0b3J5IiwiZ2xvYmFsT2JqZWN0IiwiaGxqcyIsImFtZCIsIkFycmF5UHJvdG8iLCJvYmplY3RLZXlzIiwibGFuZ3VhZ2VzIiwibm9IaWdobGlnaHRSZSIsImxhbmd1YWdlUHJlZml4UmUiLCJmaXhNYXJrdXBSZSIsInNwYW5FbmRUYWciLCJjbGFzc1ByZWZpeCIsInRhYlJlcGxhY2UiLCJ1c2VCUiIsInVuZGVmaW5lZCIsIm5vZGUiLCJub2RlTmFtZSIsInRlc3RSZSIsImxleGVtZSIsImlzTm90SGlnaGxpZ2h0ZWQiLCJsYW5ndWFnZSIsImJsb2NrTGFuZ3VhZ2UiLCJjbGFzc2VzIiwicGFyZW50Tm9kZSIsImdldExhbmd1YWdlIiwiaW5oZXJpdCIsIm9iamVjdHMiLCJub2RlU3RyZWFtIiwiX25vZGVTdHJlYW0iLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJub2RlVmFsdWUiLCJldmVudCIsIm1lcmdlU3RyZWFtcyIsIm9yaWdpbmFsIiwicHJvY2Vzc2VkIiwibm9kZVN0YWNrIiwic2VsZWN0U3RyZWFtIiwiYXR0cl9zdHIiLCJzdHJlYW0iLCJleHBhbmRfbW9kZSIsIm1vZGUiLCJ2YXJpYW50cyIsImNhY2hlZF92YXJpYW50cyIsInZhcmlhbnQiLCJlbmRzV2l0aFBhcmVudCIsImNvbXBpbGVMYW5ndWFnZSIsInJlU3RyIiwibGFuZ1JlIiwiY2FzZV9pbnNlbnNpdGl2ZSIsImNvbXBpbGVNb2RlIiwia2V5d29yZHMiLCJiZWdpbktleXdvcmRzIiwiY29tcGlsZWRfa2V5d29yZHMiLCJmbGF0dGVuIiwia3ciLCJwYWlyIiwibGV4ZW1lc1JlIiwibGV4ZW1lcyIsImJlZ2luUmUiLCJlbmRSZSIsInRlcm1pbmF0b3JfZW5kIiwiaWxsZWdhbCIsImlsbGVnYWxSZSIsInJlbGV2YW5jZSIsImNvbnRhaW5zIiwic3RhcnRzIiwidGVybWluYXRvcnMiLCJCb29sZWFuIiwiaWdub3JlX2lsbGVnYWxzIiwiY29udGludWF0aW9uIiwic3ViTW9kZSIsImVuZE9mTW9kZSIsImVuZHNQYXJlbnQiLCJpc0lsbGVnYWwiLCJrZXl3b3JkTWF0Y2giLCJtYXRjaF9zdHIiLCJidWlsZFNwYW4iLCJjbGFzc25hbWUiLCJpbnNpZGVTcGFuIiwibGVhdmVPcGVuIiwibm9QcmVmaXgiLCJvcGVuU3BhbiIsImNsb3NlU3BhbiIsInByb2Nlc3NLZXl3b3JkcyIsImtleXdvcmRfbWF0Y2giLCJsYXN0X2luZGV4IiwidG9wIiwibW9kZV9idWZmZXIiLCJwcm9jZXNzU3ViTGFuZ3VhZ2UiLCJleHBsaWNpdCIsInN1Ykxhbmd1YWdlIiwiY29udGludWF0aW9ucyIsImhpZ2hsaWdodEF1dG8iLCJwcm9jZXNzQnVmZmVyIiwic3RhcnROZXdNb2RlIiwiY3JlYXRlIiwicHJvY2Vzc0xleGVtZSIsImJ1ZmZlciIsIm5ld19tb2RlIiwic2tpcCIsImV4Y2x1ZGVCZWdpbiIsInJldHVybkJlZ2luIiwiZW5kX21vZGUiLCJvcmlnaW4iLCJyZXR1cm5FbmQiLCJleGNsdWRlRW5kIiwiY3VycmVudCIsIm1lc3NhZ2UiLCJsYW5ndWFnZVN1YnNldCIsInNlY29uZF9iZXN0IiwiZml4TWFya3VwIiwicDEiLCJidWlsZENsYXNzTmFtZSIsInByZXZDbGFzc05hbWUiLCJjdXJyZW50TGFuZyIsInJlc3VsdExhbmciLCJvcmlnaW5hbFN0cmVhbSIsInJlc3VsdE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidXNlcl9vcHRpb25zIiwiaW5pdEhpZ2hsaWdodGluZyIsImNhbGxlZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpbml0SGlnaGxpZ2h0aW5nT25Mb2FkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxhbmciLCJsaXN0TGFuZ3VhZ2VzIiwiSURFTlRfUkUiLCJVTkRFUlNDT1JFX0lERU5UX1JFIiwiTlVNQkVSX1JFIiwiQ19OVU1CRVJfUkUiLCJCSU5BUllfTlVNQkVSX1JFIiwiUkVfU1RBUlRFUlNfUkUiLCJCQUNLU0xBU0hfRVNDQVBFIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiUEhSQVNBTF9XT1JEU19NT0RFIiwiQ09NTUVOVCIsImluaGVyaXRzIiwiQ19MSU5FX0NPTU1FTlRfTU9ERSIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwiSEFTSF9DT01NRU5UX01PREUiLCJOVU1CRVJfTU9ERSIsIkNfTlVNQkVSX01PREUiLCJCSU5BUllfTlVNQkVSX01PREUiLCJDU1NfTlVNQkVSX01PREUiLCJSRUdFWFBfTU9ERSIsIlRJVExFX01PREUiLCJVTkRFUlNDT1JFX1RJVExFX01PREUiLCJNRVRIT0RfR1VBUkQiLCJLRVlXT1JEUyIsImtleXdvcmQiLCJsaXRlcmFsIiwiYnVpbHRfaW4iLCJFWFBSRVNTSU9OUyIsIk5VTUJFUiIsIlNVQlNUIiwiVEVNUExBVEVfU1RSSU5HIiwiUEFSQU1TX0NPTlRBSU5TIiwiUlVMRSIsIlhNTF9JREVOVF9SRSIsIlRBR19JTlRFUk5BTFMiLCJWQVIiLCJRVU9URV9TVFJJTkciLCJBUE9TX1NUUklORyIsIl8iLCIkYm9yZGVyIiwiX3VwZGF0ZUJvcmRlciIsIiRuYXYiLCJ3aWR0aCIsImxlZnQiLCJwb3NpdGlvbiIsIm91dGVyV2lkdGgiLCJhZGRDbGFzcyIsImNzcyIsImxheW91dCIsIl9vYmoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBS0lBLE0scUJBQVM7QUFD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d0JBQXdCLEdBQUcsMENBQTBDLHFCQUFxQiwyQkFBMkIsZ0JBQWdCLEdBQUcsZ0RBQWdELHFCQUFxQixHQUFHLHNDQUFzQyxrQkFBa0IsbUJBQW1CLGtCQUFrQixxQkFBcUIsR0FBRyxxQ0FBcUMsWUFBWSxHQUFHLHdDQUF3QyxpQkFBaUIsR0FBRyxnQ0FBZ0Msd0JBQXdCLG9CQUFvQixHQUFHLG1DQUFtQyxtQkFBbUIsZ0JBQWdCLEdBQUcsbUNBQW1DLG1CQUFtQixxQkFBcUIsb0JBQW9CLEdBQUcsNkJBQTZCLGtCQUFrQix3QkFBd0IsNEJBQTRCLHFCQUFxQixHQUFHLG1DQUFtQyxpQkFBaUIsR0FBRyx1Q0FBdUMsaUJBQWlCLEdBQUcsd0NBQXdDLHFCQUFxQixHQUFHLHFDQUFxQyxpQkFBaUIsaUJBQWlCLHFCQUFxQix1QkFBdUIsa0JBQWtCLEdBQUcsb0NBQW9DLGdCQUFnQixtQkFBbUIsd0JBQXdCLEdBQUcscUNBQXFDLHFCQUFxQixrQkFBa0IsR0FBRyxvQ0FBb0MsbUJBQW1CLG1CQUFtQixHQUFHOztBQUV2bUciLCJmaWxlIjoic3RhdGljL2NodW5rLzlkM2RkMjYzOGUxY2MzOTk2ZmE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vaW5kZXgudmR0JztcbmltcG9ydCBjc3MgZnJvbSAnLi9pbmRleC5zdHlsJztcbmltcG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZTsgfVxuXG4gICAgX21vdW50KCkge1xuICAgICAgICBzdXBlci5fbW91bnQoKTtcbiAgICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGNvbnN0ICRtZHMgPSAkZWxlbWVudC5maW5kKCdzY3JpcHRbdHlwZT1cInRleHQvbWRcIl0nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkbWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgJG1kID0gJCgkbWRzW2ldKTtcbiAgICAgICAgICAgIGxldCBtZCA9ICRtZC50ZXh0KCk7XG4gICAgICAgICAgICBsZXQgaHRtbCA9IG1hcmtlZC5yZW5kZXIobWQpO1xuICAgICAgICAgICAgLy8gJG1kLnJlcGxhY2VXaXRoKCQoaHRtbCkpO1xuICAgICAgICAgICAgJG1kLm5leHQoJy5jb2RlJykuaHRtbChodG1sKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkY29kZXMgPSAkZWxlbWVudC5maW5kKCdwcmUgY29kZScpO1xuICAgICAgICBsZXQgdGVtcGxhdGU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgJGNvZGUgPSAkKCRjb2Rlc1tpXSk7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICRjb2RlLnRleHQoKTtcbiAgICAgICAgICAgIGlmICgkY29kZS5oYXNDbGFzcygnbGFuZ3VhZ2UtaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBJbnRhY3QuVmR0LmNvbXBpbGUoY29kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRjb2RlLmhhc0NsYXNzKCdsYW5ndWFnZS1jc3MnKSkge1xuICAgICAgICAgICAgICAgICRjb2RlLnBhcmVudCgpLmFmdGVyKGA8c3R5bGU+JHtjb2RlfTwvc3R5bGU+YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRjb2RlLmhhc0NsYXNzKCdsYW5ndWFnZS1qcycpKSB7XG4gICAgICAgICAgICAgICAgZXZhbChjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhpZ2hsaWdodC5oaWdobGlnaHRCbG9jaygkY29kZVswXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWdlcy9pbmRleC9pbmRleC5qcyIsIi8vIFV0aWxpdGllc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIFJlbW92ZSBlbGVtZW50IGZyb20gYXJyYXkgYW5kIHB1dCBhbm90aGVyIGFycmF5IGF0IHRob3NlIHBvc2l0aW9uLlxuLy8gVXNlZnVsIGZvciBzb21lIG9wZXJhdGlvbnMgd2l0aCB0b2tlbnNcbmZ1bmN0aW9uIGFycmF5UmVwbGFjZUF0KHNyYywgcG9zLCBuZXdFbGVtZW50cykge1xuICByZXR1cm4gW10uY29uY2F0KHNyYy5zbGljZSgwLCBwb3MpLCBuZXdFbGVtZW50cywgc3JjLnNsaWNlKHBvcyArIDEpKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNWYWxpZEVudGl0eUNvZGUoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICAvLyBicm9rZW4gc2VxdWVuY2VcbiAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBuZXZlciB1c2VkXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKChjICYgMHhGRkZGKSA9PT0gMHhGRkZGIHx8IChjICYgMHhGRkZGKSA9PT0gMHhGRkZFKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBjb250cm9sIGNvZGVzXG4gIGlmIChjID49IDB4MDAgJiYgYyA8PSAweDA4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA9PT0gMHgwQikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHgwRSAmJiBjIDw9IDB4MUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4N0YgJiYgYyA8PSAweDlGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBvdXQgb2YgcmFuZ2VcbiAgaWYgKGMgPiAweDEwRkZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICBpZiAoYyA+IDB4ZmZmZikge1xuICAgIGMgLT0gMHgxMDAwMDtcbiAgICB2YXIgc3Vycm9nYXRlMSA9IDB4ZDgwMCArIChjID4+IDEwKSxcbiAgICAgICAgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjICYgMHgzZmYpO1xuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc3Vycm9nYXRlMSwgc3Vycm9nYXRlMik7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG59XG5cblxudmFyIFVORVNDQVBFX01EX1JFICA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dKS9nO1xudmFyIEVOVElUWV9SRSAgICAgICA9IC8mKFthLXojXVthLXowLTldezEsMzF9KTsvZ2k7XG52YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKTtcblxudmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG5cbnZhciBlbnRpdGllcyA9IHJlcXVpcmUoJy4vZW50aXRpZXMnKTtcblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIG5hbWUpIHtcbiAgdmFyIGNvZGUgPSAwO1xuXG4gIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGVudGl0aWVzW25hbWVdO1xuICB9XG5cbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMy8qICMgKi8gJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgY29kZSA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxuICAgIDpcbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMSksIDEwKTtcbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcbiAgLy8gaGVyZSB0byBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAvLyBtZW1iZXJzIChtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwibW9kdWxlLmV4cG9ydHM9L1shLSMlLVxcKiwtLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0NFxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODA1W1xcdURDNEItXFx1REM0RlxcdURDNUJcXHVEQzVEXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURFNjAtXFx1REU2Q1xcdURGM0MtXFx1REYzRV18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9yZ2FwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcbiAgICoqL1xuICB0aGlzLmluZm8gICAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21ldGEgLT4gT2JqZWN0XG4gICAqXG4gICAqIEEgcGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgYW4gYXJiaXRyYXJ5IGRhdGFcbiAgICoqL1xuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZTtcblxuICAvKipcbiAgICogVG9rZW4jaGlkZGVuIC0+IEJvb2xlYW5cbiAgICpcbiAgICogSWYgaXQncyB0cnVlLCBpZ25vcmUgdGhpcyBlbGVtZW50IHdoZW4gcmVuZGVyaW5nLiBVc2VkIGZvciB0aWdodCBsaXN0c1xuICAgKiB0byBoaWRlIHBhcmFncmFwaHMuXG4gICAqKi9cbiAgdGhpcy5oaWRkZW4gICA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxuICpcbiAqIFNlYXJjaCBhdHRyaWJ1dGUgaW5kZXggYnkgbmFtZS5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICB2YXIgYXR0cnMsIGksIGxlbjtcblxuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xOyB9XG5cbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRycy5wdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSxcbiAgICAgIGF0dHJEYXRhID0gWyBuYW1lLCB2YWx1ZSBdO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyR2V0KG5hbWUpXG4gKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhdHRyaWJ1dGUgYG5hbWVgLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCB2YWx1ZSA9IG51bGw7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySm9pbihuYW1lLCB2YWx1ZSlcbiAqXG4gKiBKb2luIHZhbHVlIHRvIGV4aXN0aW5nIGF0dHJpYnV0ZSB2aWEgc3BhY2UuIE9yIGNyZWF0ZSBuZXcgYXR0cmlidXRlIGlmIG5vdFxuICogZXhpc3RzLiBVc2VmdWwgdG8gb3BlcmF0ZSB3aXRoIHRva2VuIGNsYXNzZXMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckpvaW4gPSBmdW5jdGlvbiBhdHRySm9pbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKFsgbmFtZSwgdmFsdWUgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWU7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCIvLyBIVE1MNSBlbnRpdGllcyBtYXA6IHsgbmFtZSAtPiB1dGYxNnN0cmluZyB9XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBxdW90ZXM6MCovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21kdXJsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHgxRlxceDdGLVxceDlGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcblxudmFyIHVucXVvdGVkICAgICAgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG5cbnZhciBhdHRyX3ZhbHVlICA9ICcoPzonICsgdW5xdW90ZWQgKyAnfCcgKyBzaW5nbGVfcXVvdGVkICsgJ3wnICsgZG91YmxlX3F1b3RlZCArICcpJztcblxudmFyIGF0dHJpYnV0ZSAgID0gJyg/OlxcXFxzKycgKyBhdHRyX25hbWUgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyX3ZhbHVlICsgJyk/KSc7XG5cbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xuXG52YXIgY2xvc2VfdGFnICAgPSAnPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj4nO1xudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIHByb2Nlc3NpbmcgID0gJzxbP10uKj9bP10+JztcbnZhciBkZWNsYXJhdGlvbiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgY2RhdGEgICAgICAgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcblxudmFyIEhUTUxfVEFHX1JFID0gbmV3IFJlZ0V4cCgnXig/OicgKyBvcGVuX3RhZyArICd8JyArIGNsb3NlX3RhZyArICd8JyArIGNvbW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgcHJvY2Vzc2luZyArICd8JyArIGRlY2xhcmF0aW9uICsgJ3wnICsgY2RhdGEgKyAnKScpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJyknKTtcblxubW9kdWxlLmV4cG9ydHMuSFRNTF9UQUdfUkUgPSBIVE1MX1RBR19SRTtcbm1vZHVsZS5leHBvcnRzLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIi8vIH5+c3RyaWtlIHRocm91Z2h+flxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLCBsZW4sIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICBsZW4gPSBzY2FubmVkLmxlbmd0aDtcbiAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgaWYgKGxlbiA8IDIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGxlbiAlIDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2g7XG4gICAgbGVuLS07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2ggKyBjaDtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgIGp1bXA6ICAgaSxcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuICAgICAgZW5kOiAgICAtMSxcbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3Nfb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3NfY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0uY29udGVudCA9PT0gJ34nKSB7XG5cbiAgICAgIGxvbmVNYXJrZXJzLnB1c2goZW5kRGVsaW0udG9rZW4gLSAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIG1hcmtlciBzZXF1ZW5jZSBoYXMgYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCdzIHNwbGl0dGVkXG4gIC8vIGxpa2UgdGhpczogYH5+fn5+YCAtPiBgfmAgKyBgfn5gICsgYH5+YCwgbGVhdmluZyBvbmUgbWFya2VyIGF0IHRoZVxuICAvLyBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gIC8vXG4gIC8vIFNvLCB3ZSBoYXZlIHRvIG1vdmUgYWxsIHRob3NlIG1hcmtlcnMgYWZ0ZXIgc3Vic2VxdWVudCBzX2Nsb3NlIHRhZ3MuXG4gIC8vXG4gIHdoaWxlIChsb25lTWFya2Vycy5sZW5ndGgpIHtcbiAgICBpID0gbG9uZU1hcmtlcnMucG9wKCk7XG4gICAgaiA9IGkgKyAxO1xuXG4gICAgd2hpbGUgKGogPCBzdGF0ZS50b2tlbnMubGVuZ3RoICYmIHN0YXRlLnRva2Vuc1tqXS50eXBlID09PSAnc19jbG9zZScpIHtcbiAgICAgIGorKztcbiAgICB9XG5cbiAgICBqLS07XG5cbiAgICBpZiAoaSAhPT0gaikge1xuICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbal07XG4gICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICBzdGF0ZS50b2tlbnNbaV0gPSB0b2tlbjtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwiLy8gUHJvY2VzcyAqdGhpcyogYW5kIF90aGF0X1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbixcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg1RiAvKiBfICovICYmIG1hcmtlciAhPT0gMHgyQSAvKiAqICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgbWFya2VyID09PSAweDJBKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2Nhbm5lZC5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgLy8gQ2hhciBjb2RlIG9mIHRoZSBzdGFydGluZyBtYXJrZXIgKG51bWJlcikuXG4gICAgICAvL1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG5cbiAgICAgIC8vIFRvdGFsIGxlbmd0aCBvZiB0aGVzZSBzZXJpZXMgb2YgZGVsaW1pdGVycy5cbiAgICAgIC8vXG4gICAgICBsZW5ndGg6IHNjYW5uZWQubGVuZ3RoLFxuXG4gICAgICAvLyBBbiBhbW91bnQgb2YgY2hhcmFjdGVycyBiZWZvcmUgdGhpcyBvbmUgdGhhdCdzIGVxdWl2YWxlbnQgdG9cbiAgICAgIC8vIGN1cnJlbnQgb25lLiBJbiBwbGFpbiBFbmdsaXNoOiBpZiB0aGlzIGRlbGltaXRlciBkb2VzIG5vdCBvcGVuXG4gICAgICAvLyBhbiBlbXBoYXNpcywgbmVpdGhlciBkbyBwcmV2aW91cyBganVtcGAgY2hhcmFjdGVycy5cbiAgICAgIC8vXG4gICAgICAvLyBVc2VkIHRvIHNraXAgc2VxdWVuY2VzIGxpa2UgXCIqKioqKlwiIGluIG9uZSBzdGVwLCBmb3IgMXN0IGFzdGVyaXNrXG4gICAgICAvLyB2YWx1ZSB3aWxsIGJlIDAsIGZvciAybmQgaXQncyAxIGFuZCBzbyBvbi5cbiAgICAgIC8vXG4gICAgICBqdW1wOiAgIGksXG5cbiAgICAgIC8vIEEgcG9zaXRpb24gb2YgdGhlIHRva2VuIHRoaXMgZGVsaW1pdGVyIGNvcnJlc3BvbmRzIHRvLlxuICAgICAgLy9cbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG5cbiAgICAgIC8vIFRva2VuIGxldmVsLlxuICAgICAgLy9cbiAgICAgIGxldmVsOiAgc3RhdGUubGV2ZWwsXG5cbiAgICAgIC8vIElmIHRoaXMgZGVsaW1pdGVyIGlzIG1hdGNoZWQgYXMgYSB2YWxpZCBvcGVuZXIsIGBlbmRgIHdpbGwgYmVcbiAgICAgIC8vIGVxdWFsIHRvIGl0cyBwb3NpdGlvbiwgb3RoZXJ3aXNlIGl0J3MgYC0xYC5cbiAgICAgIC8vXG4gICAgICBlbmQ6ICAgIC0xLFxuXG4gICAgICAvLyBCb29sZWFuIGZsYWdzIHRoYXQgZGV0ZXJtaW5lIGlmIHRoaXMgZGVsaW1pdGVyIGNvdWxkIG9wZW4gb3IgY2xvc2VcbiAgICAgIC8vIGFuIGVtcGhhc2lzLlxuICAgICAgLy9cbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUpIHtcbiAgdmFyIGksXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGNoLFxuICAgICAgaXNTdHJvbmcsXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDVGLyogXyAqLyAmJiBzdGFydERlbGltLm1hcmtlciAhPT0gMHgyQS8qICogKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3Mgb25seSBvcGVuaW5nIG1hcmtlcnNcbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgLy8gSWYgdGhlIG5leHQgZGVsaW1pdGVyIGhhcyB0aGUgc2FtZSBtYXJrZXIgYW5kIGlzIGFkamFjZW50IHRvIHRoaXMgb25lLFxuICAgIC8vIG1lcmdlIHRob3NlIGludG8gb25lIHN0cm9uZyBkZWxpbWl0ZXIuXG4gICAgLy9cbiAgICAvLyBgPGVtPjxlbT53aGF0ZXZlcjwvZW0+PC9lbT5gIC0+IGA8c3Ryb25nPndoYXRldmVyPC9zdHJvbmc+YFxuICAgIC8vXG4gICAgaXNTdHJvbmcgPSBpICsgMSA8IG1heCAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpICsgMV0uZW5kID09PSBzdGFydERlbGltLmVuZCAtIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLnRva2VuID09PSBzdGFydERlbGltLnRva2VuICsgMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCAtIDFdLnRva2VuID09PSBlbmREZWxpbS50b2tlbiAtIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSArIDFdLm1hcmtlciA9PT0gc3RhcnREZWxpbS5tYXJrZXI7XG5cbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX29wZW4nIDogJ2VtX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19jbG9zZScgOiAnZW1fY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChpc1N0cm9uZykge1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbaSArIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCAtIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MpIHtcbmlmIChtb2R1bGUuaG90KSB7XG4gICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgZGF0YS52ZHQgPSBfX3RoaXM7XG4gICAgICAgIGRhdGEuaXNQYXJlbnQgPSBfX3RoaXMuZGF0YSAhPT0gb2JqO1xuICAgIH0pXG59XG5cbl9WZHQgfHwgKF9WZHQgPSBWZHQpO1xub2JqIHx8IChvYmogPSB7fSk7XG5ibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbnZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG5fX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsXG5fX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG5fc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbl9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbnNlbGYgPSB0aGlzLmRhdGEsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9IHNlbGYgJiYgc2VsZi5fcGFyZW50VGVtcGxhdGVcbmNvbnN0IG5hdiA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAn5pWZ56iLJyxcbiAgICAgICAgaHJlZjogJ2RvY3VtZW50J1xuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0FQSScsXG4gICAgICAgIGhyZWY6ICdhcGknXG4gICAgfSxcbiAgICAvLyB7XG4gICAgICAgIC8vIHRpdGxlOiAn56S65L6LJyxcbiAgICAgICAgLy8gaHJlZjogJ2V4YW1wbGVzJ1xuICAgIC8vIH1cbl1cbnJldHVybiBoKCdkaXYnLCBudWxsLCBbaCgnZGl2JywgbnVsbCwgaCgnaGVhZGVyJywgbnVsbCwgKF9ibG9ja3MuaGVhZGVyID0gZnVuY3Rpb24ocGFyZW50KSB7cmV0dXJuIFtoKCdhJywgeydocmVmJzogJyMvJ30sICdJbnRhY3QnLCAnbG9nbycpLCBoKCduYXYnLCBudWxsLCBbX1ZkdC51dGlscy5tYXAoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW25hdl1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbnJldHVybiBoKCdhJywgeydocmVmJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW2AjLyR7dmFsdWUuaHJlZn1gXVswXX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCh0aGlzKX0sIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIFt2YWx1ZS50aXRsZV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcyksIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdmFsdWUuaHJlZiA9PT0gc2NvcGUubmF2SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfV1bMF19IGNhdGNoKGUpIHtfZShlKX19LmNhbGwodGhpcykpKTtcbn0sIHRoaXMpLCBoKCdkaXYnLCBudWxsLCBudWxsLCAnYm9yZGVyJyldKV07fSkgJiYgKF9fYmxvY2tzLmhlYWRlciA9IGZ1bmN0aW9uKHBhcmVudCkge1xudmFyIHNlbGYgPSB0aGlzO1xucmV0dXJuIGJsb2Nrcy5oZWFkZXIgPyBibG9ja3MuaGVhZGVyLmNhbGwodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gX2Jsb2Nrcy5oZWFkZXIuY2FsbChzZWxmLCBwYXJlbnQpO1xufSkgOiBfYmxvY2tzLmhlYWRlci5jYWxsKHRoaXMsIHBhcmVudCk7XG59KSAmJiBfX2Jsb2Nrcy5oZWFkZXIuY2FsbCh0aGlzKSksICdoZWFkZXItd3JhcHBlcicpLCBoKCdkaXYnLCBudWxsLCAoX2Jsb2Nrcy5jb250ZW50ID0gZnVuY3Rpb24ocGFyZW50KSB7cmV0dXJuIG51bGw7fSkgJiYgKF9fYmxvY2tzLmNvbnRlbnQgPSBmdW5jdGlvbihwYXJlbnQpIHtcbnZhciBzZWxmID0gdGhpcztcbnJldHVybiBibG9ja3MuY29udGVudCA/IGJsb2Nrcy5jb250ZW50LmNhbGwodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gX2Jsb2Nrcy5jb250ZW50LmNhbGwoc2VsZiwgcGFyZW50KTtcbn0pIDogX2Jsb2Nrcy5jb250ZW50LmNhbGwodGhpcywgcGFyZW50KTtcbn0pICYmIF9fYmxvY2tzLmNvbnRlbnQuY2FsbCh0aGlzKSwgJ2NvbnRlbnQtd3JhcHBlcicpXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiBbJ21haW4td3JhcHBlciAnICsgKHNjb3BlLmNsYXNzTmFtZSB8fCAnJyldWzBdfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKHRoaXMpKSlcbn1cbmlmIChtb2R1bGUuaG90KSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKTtcbiAgICB2YXIgdmR0ID0gbW9kdWxlLmhvdC5kYXRhICYmIG1vZHVsZS5ob3QuZGF0YS52ZHRcbiAgICBpZiAodmR0KSB7XG4gICAgICAgIGlmICghbW9kdWxlLmhvdC5kYXRhLmlzUGFyZW50KSB7XG4gICAgICAgICAgICB2ZHQudGVtcGxhdGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICB2ZHQudXBkYXRlKCk7XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL2xheW91dC52ZHQiLCJpbXBvcnQgTWFya2Rvd25JdCBmcm9tICdtYXJrZG93bi1pdCc7XG5pbXBvcnQgTWFya2Rvd25JdERlY29yYXRlIGZyb20gJ21hcmtkb3duLWl0LWRlY29yYXRlJztcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQnO1xuaW1wb3J0IGxKYXZhc2NyaXB0IGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQnO1xuaW1wb3J0IGxDc3MgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzJztcbmltcG9ydCBsWG1sIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbCc7XG5pbXBvcnQgbEJhc2ggZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaCc7XG5cbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdiYXNoJywgbEJhc2gpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2NzcycsIGxDc3MpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmFzY3JpcHQnLCBsSmF2YXNjcmlwdCk7XG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgneG1sJywgbFhtbCk7XG5cbndpbmRvdy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbmNvbnN0IG1hcmtlZCA9IE1hcmtkb3duSXQoe1xuICAgIGh0bWw6IHRydWUsXG4gICAgYnJlYWtzOiBmYWxzZSBcbn0pLnVzZShNYXJrZG93bkl0RGVjb3JhdGUpO1xuLy8g5Y675o6J5q616JC9c29mdGJyZWFrXG5tYXJrZWQucmVuZGVyZXIucnVsZXMuc29mdGJyZWFrID0gKCkgPT4gJyc7XG5cbmV4cG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvaW5kZXguanMiLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJBYWN1dGVcIjpcIsOBXCIsXCJhYWN1dGVcIjpcIsOhXCIsXCJBYnJldmVcIjpcIsSCXCIsXCJhYnJldmVcIjpcIsSDXCIsXCJhY1wiOlwi4oi+XCIsXCJhY2RcIjpcIuKIv1wiLFwiYWNFXCI6XCLiiL7Ms1wiLFwiQWNpcmNcIjpcIsOCXCIsXCJhY2lyY1wiOlwiw6JcIixcImFjdXRlXCI6XCLCtFwiLFwiQWN5XCI6XCLQkFwiLFwiYWN5XCI6XCLQsFwiLFwiQUVsaWdcIjpcIsOGXCIsXCJhZWxpZ1wiOlwiw6ZcIixcImFmXCI6XCLigaFcIixcIkFmclwiOlwi8J2UhFwiLFwiYWZyXCI6XCLwnZSeXCIsXCJBZ3JhdmVcIjpcIsOAXCIsXCJhZ3JhdmVcIjpcIsOgXCIsXCJhbGVmc3ltXCI6XCLihLVcIixcImFsZXBoXCI6XCLihLVcIixcIkFscGhhXCI6XCLOkVwiLFwiYWxwaGFcIjpcIs6xXCIsXCJBbWFjclwiOlwixIBcIixcImFtYWNyXCI6XCLEgVwiLFwiYW1hbGdcIjpcIuKov1wiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcImFuZGFuZFwiOlwi4qmVXCIsXCJBbmRcIjpcIuKpk1wiLFwiYW5kXCI6XCLiiKdcIixcImFuZGRcIjpcIuKpnFwiLFwiYW5kc2xvcGVcIjpcIuKpmFwiLFwiYW5kdlwiOlwi4qmaXCIsXCJhbmdcIjpcIuKIoFwiLFwiYW5nZVwiOlwi4qakXCIsXCJhbmdsZVwiOlwi4oigXCIsXCJhbmdtc2RhYVwiOlwi4qaoXCIsXCJhbmdtc2RhYlwiOlwi4qapXCIsXCJhbmdtc2RhY1wiOlwi4qaqXCIsXCJhbmdtc2RhZFwiOlwi4qarXCIsXCJhbmdtc2RhZVwiOlwi4qasXCIsXCJhbmdtc2RhZlwiOlwi4qatXCIsXCJhbmdtc2RhZ1wiOlwi4qauXCIsXCJhbmdtc2RhaFwiOlwi4qavXCIsXCJhbmdtc2RcIjpcIuKIoVwiLFwiYW5ncnRcIjpcIuKIn1wiLFwiYW5ncnR2YlwiOlwi4oq+XCIsXCJhbmdydHZiZFwiOlwi4qadXCIsXCJhbmdzcGhcIjpcIuKIolwiLFwiYW5nc3RcIjpcIsOFXCIsXCJhbmd6YXJyXCI6XCLijbxcIixcIkFvZ29uXCI6XCLEhFwiLFwiYW9nb25cIjpcIsSFXCIsXCJBb3BmXCI6XCLwnZS4XCIsXCJhb3BmXCI6XCLwnZWSXCIsXCJhcGFjaXJcIjpcIuKpr1wiLFwiYXBcIjpcIuKJiFwiLFwiYXBFXCI6XCLiqbBcIixcImFwZVwiOlwi4omKXCIsXCJhcGlkXCI6XCLiiYtcIixcImFwb3NcIjpcIidcIixcIkFwcGx5RnVuY3Rpb25cIjpcIuKBoVwiLFwiYXBwcm94XCI6XCLiiYhcIixcImFwcHJveGVxXCI6XCLiiYpcIixcIkFyaW5nXCI6XCLDhVwiLFwiYXJpbmdcIjpcIsOlXCIsXCJBc2NyXCI6XCLwnZKcXCIsXCJhc2NyXCI6XCLwnZK2XCIsXCJBc3NpZ25cIjpcIuKJlFwiLFwiYXN0XCI6XCIqXCIsXCJhc3ltcFwiOlwi4omIXCIsXCJhc3ltcGVxXCI6XCLiiY1cIixcIkF0aWxkZVwiOlwiw4NcIixcImF0aWxkZVwiOlwiw6NcIixcIkF1bWxcIjpcIsOEXCIsXCJhdW1sXCI6XCLDpFwiLFwiYXdjb25pbnRcIjpcIuKIs1wiLFwiYXdpbnRcIjpcIuKokVwiLFwiYmFja2NvbmdcIjpcIuKJjFwiLFwiYmFja2Vwc2lsb25cIjpcIs+2XCIsXCJiYWNrcHJpbWVcIjpcIuKAtVwiLFwiYmFja3NpbVwiOlwi4oi9XCIsXCJiYWNrc2ltZXFcIjpcIuKLjVwiLFwiQmFja3NsYXNoXCI6XCLiiJZcIixcIkJhcnZcIjpcIuKrp1wiLFwiYmFydmVlXCI6XCLiir1cIixcImJhcndlZFwiOlwi4oyFXCIsXCJCYXJ3ZWRcIjpcIuKMhlwiLFwiYmFyd2VkZ2VcIjpcIuKMhVwiLFwiYmJya1wiOlwi4o61XCIsXCJiYnJrdGJya1wiOlwi4o62XCIsXCJiY29uZ1wiOlwi4omMXCIsXCJCY3lcIjpcItCRXCIsXCJiY3lcIjpcItCxXCIsXCJiZHF1b1wiOlwi4oCeXCIsXCJiZWNhdXNcIjpcIuKItVwiLFwiYmVjYXVzZVwiOlwi4oi1XCIsXCJCZWNhdXNlXCI6XCLiiLVcIixcImJlbXB0eXZcIjpcIuKmsFwiLFwiYmVwc2lcIjpcIs+2XCIsXCJiZXJub3VcIjpcIuKErFwiLFwiQmVybm91bGxpc1wiOlwi4oSsXCIsXCJCZXRhXCI6XCLOklwiLFwiYmV0YVwiOlwizrJcIixcImJldGhcIjpcIuKEtlwiLFwiYmV0d2VlblwiOlwi4omsXCIsXCJCZnJcIjpcIvCdlIVcIixcImJmclwiOlwi8J2Un1wiLFwiYmlnY2FwXCI6XCLii4JcIixcImJpZ2NpcmNcIjpcIuKXr1wiLFwiYmlnY3VwXCI6XCLii4NcIixcImJpZ29kb3RcIjpcIuKogFwiLFwiYmlnb3BsdXNcIjpcIuKogVwiLFwiYmlnb3RpbWVzXCI6XCLiqIJcIixcImJpZ3NxY3VwXCI6XCLiqIZcIixcImJpZ3N0YXJcIjpcIuKYhVwiLFwiYmlndHJpYW5nbGVkb3duXCI6XCLilr1cIixcImJpZ3RyaWFuZ2xldXBcIjpcIuKWs1wiLFwiYmlndXBsdXNcIjpcIuKohFwiLFwiYmlndmVlXCI6XCLii4FcIixcImJpZ3dlZGdlXCI6XCLii4BcIixcImJrYXJvd1wiOlwi4qSNXCIsXCJibGFja2xvemVuZ2VcIjpcIuKnq1wiLFwiYmxhY2tzcXVhcmVcIjpcIuKWqlwiLFwiYmxhY2t0cmlhbmdsZVwiOlwi4pa0XCIsXCJibGFja3RyaWFuZ2xlZG93blwiOlwi4pa+XCIsXCJibGFja3RyaWFuZ2xlbGVmdFwiOlwi4peCXCIsXCJibGFja3RyaWFuZ2xlcmlnaHRcIjpcIuKWuFwiLFwiYmxhbmtcIjpcIuKQo1wiLFwiYmxrMTJcIjpcIuKWklwiLFwiYmxrMTRcIjpcIuKWkVwiLFwiYmxrMzRcIjpcIuKWk1wiLFwiYmxvY2tcIjpcIuKWiFwiLFwiYm5lXCI6XCI94oOlXCIsXCJibmVxdWl2XCI6XCLiiaHig6VcIixcImJOb3RcIjpcIuKrrVwiLFwiYm5vdFwiOlwi4oyQXCIsXCJCb3BmXCI6XCLwnZS5XCIsXCJib3BmXCI6XCLwnZWTXCIsXCJib3RcIjpcIuKKpVwiLFwiYm90dG9tXCI6XCLiiqVcIixcImJvd3RpZVwiOlwi4ouIXCIsXCJib3hib3hcIjpcIuKniVwiLFwiYm94ZGxcIjpcIuKUkFwiLFwiYm94ZExcIjpcIuKVlVwiLFwiYm94RGxcIjpcIuKVllwiLFwiYm94RExcIjpcIuKVl1wiLFwiYm94ZHJcIjpcIuKUjFwiLFwiYm94ZFJcIjpcIuKVklwiLFwiYm94RHJcIjpcIuKVk1wiLFwiYm94RFJcIjpcIuKVlFwiLFwiYm94aFwiOlwi4pSAXCIsXCJib3hIXCI6XCLilZBcIixcImJveGhkXCI6XCLilKxcIixcImJveEhkXCI6XCLilaRcIixcImJveGhEXCI6XCLilaVcIixcImJveEhEXCI6XCLilaZcIixcImJveGh1XCI6XCLilLRcIixcImJveEh1XCI6XCLiladcIixcImJveGhVXCI6XCLilahcIixcImJveEhVXCI6XCLilalcIixcImJveG1pbnVzXCI6XCLiip9cIixcImJveHBsdXNcIjpcIuKKnlwiLFwiYm94dGltZXNcIjpcIuKKoFwiLFwiYm94dWxcIjpcIuKUmFwiLFwiYm94dUxcIjpcIuKVm1wiLFwiYm94VWxcIjpcIuKVnFwiLFwiYm94VUxcIjpcIuKVnVwiLFwiYm94dXJcIjpcIuKUlFwiLFwiYm94dVJcIjpcIuKVmFwiLFwiYm94VXJcIjpcIuKVmVwiLFwiYm94VVJcIjpcIuKVmlwiLFwiYm94dlwiOlwi4pSCXCIsXCJib3hWXCI6XCLilZFcIixcImJveHZoXCI6XCLilLxcIixcImJveHZIXCI6XCLilapcIixcImJveFZoXCI6XCLilatcIixcImJveFZIXCI6XCLilaxcIixcImJveHZsXCI6XCLilKRcIixcImJveHZMXCI6XCLilaFcIixcImJveFZsXCI6XCLilaJcIixcImJveFZMXCI6XCLilaNcIixcImJveHZyXCI6XCLilJxcIixcImJveHZSXCI6XCLilZ5cIixcImJveFZyXCI6XCLilZ9cIixcImJveFZSXCI6XCLilaBcIixcImJwcmltZVwiOlwi4oC1XCIsXCJicmV2ZVwiOlwiy5hcIixcIkJyZXZlXCI6XCLLmFwiLFwiYnJ2YmFyXCI6XCLCplwiLFwiYnNjclwiOlwi8J2St1wiLFwiQnNjclwiOlwi4oSsXCIsXCJic2VtaVwiOlwi4oGPXCIsXCJic2ltXCI6XCLiiL1cIixcImJzaW1lXCI6XCLii41cIixcImJzb2xiXCI6XCLip4VcIixcImJzb2xcIjpcIlxcXFxcIixcImJzb2xoc3ViXCI6XCLin4hcIixcImJ1bGxcIjpcIuKAolwiLFwiYnVsbGV0XCI6XCLigKJcIixcImJ1bXBcIjpcIuKJjlwiLFwiYnVtcEVcIjpcIuKqrlwiLFwiYnVtcGVcIjpcIuKJj1wiLFwiQnVtcGVxXCI6XCLiiY5cIixcImJ1bXBlcVwiOlwi4omPXCIsXCJDYWN1dGVcIjpcIsSGXCIsXCJjYWN1dGVcIjpcIsSHXCIsXCJjYXBhbmRcIjpcIuKphFwiLFwiY2FwYnJjdXBcIjpcIuKpiVwiLFwiY2FwY2FwXCI6XCLiqYtcIixcImNhcFwiOlwi4oipXCIsXCJDYXBcIjpcIuKLklwiLFwiY2FwY3VwXCI6XCLiqYdcIixcImNhcGRvdFwiOlwi4qmAXCIsXCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOlwi4oWFXCIsXCJjYXBzXCI6XCLiiKnvuIBcIixcImNhcmV0XCI6XCLigYFcIixcImNhcm9uXCI6XCLLh1wiLFwiQ2F5bGV5c1wiOlwi4oStXCIsXCJjY2Fwc1wiOlwi4qmNXCIsXCJDY2Fyb25cIjpcIsSMXCIsXCJjY2Fyb25cIjpcIsSNXCIsXCJDY2VkaWxcIjpcIsOHXCIsXCJjY2VkaWxcIjpcIsOnXCIsXCJDY2lyY1wiOlwixIhcIixcImNjaXJjXCI6XCLEiVwiLFwiQ2NvbmludFwiOlwi4oiwXCIsXCJjY3Vwc1wiOlwi4qmMXCIsXCJjY3Vwc3NtXCI6XCLiqZBcIixcIkNkb3RcIjpcIsSKXCIsXCJjZG90XCI6XCLEi1wiLFwiY2VkaWxcIjpcIsK4XCIsXCJDZWRpbGxhXCI6XCLCuFwiLFwiY2VtcHR5dlwiOlwi4qayXCIsXCJjZW50XCI6XCLColwiLFwiY2VudGVyZG90XCI6XCLCt1wiLFwiQ2VudGVyRG90XCI6XCLCt1wiLFwiY2ZyXCI6XCLwnZSgXCIsXCJDZnJcIjpcIuKErVwiLFwiQ0hjeVwiOlwi0KdcIixcImNoY3lcIjpcItGHXCIsXCJjaGVja1wiOlwi4pyTXCIsXCJjaGVja21hcmtcIjpcIuKck1wiLFwiQ2hpXCI6XCLOp1wiLFwiY2hpXCI6XCLPh1wiLFwiY2lyY1wiOlwiy4ZcIixcImNpcmNlcVwiOlwi4omXXCIsXCJjaXJjbGVhcnJvd2xlZnRcIjpcIuKGulwiLFwiY2lyY2xlYXJyb3dyaWdodFwiOlwi4oa7XCIsXCJjaXJjbGVkYXN0XCI6XCLiiptcIixcImNpcmNsZWRjaXJjXCI6XCLiippcIixcImNpcmNsZWRkYXNoXCI6XCLiip1cIixcIkNpcmNsZURvdFwiOlwi4oqZXCIsXCJjaXJjbGVkUlwiOlwiwq5cIixcImNpcmNsZWRTXCI6XCLik4hcIixcIkNpcmNsZU1pbnVzXCI6XCLiipZcIixcIkNpcmNsZVBsdXNcIjpcIuKKlVwiLFwiQ2lyY2xlVGltZXNcIjpcIuKKl1wiLFwiY2lyXCI6XCLil4tcIixcImNpckVcIjpcIuKng1wiLFwiY2lyZVwiOlwi4omXXCIsXCJjaXJmbmludFwiOlwi4qiQXCIsXCJjaXJtaWRcIjpcIuKrr1wiLFwiY2lyc2NpclwiOlwi4qeCXCIsXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIslwiLFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCLigJ1cIixcIkNsb3NlQ3VybHlRdW90ZVwiOlwi4oCZXCIsXCJjbHVic1wiOlwi4pmjXCIsXCJjbHVic3VpdFwiOlwi4pmjXCIsXCJjb2xvblwiOlwiOlwiLFwiQ29sb25cIjpcIuKIt1wiLFwiQ29sb25lXCI6XCLiqbRcIixcImNvbG9uZVwiOlwi4omUXCIsXCJjb2xvbmVxXCI6XCLiiZRcIixcImNvbW1hXCI6XCIsXCIsXCJjb21tYXRcIjpcIkBcIixcImNvbXBcIjpcIuKIgVwiLFwiY29tcGZuXCI6XCLiiJhcIixcImNvbXBsZW1lbnRcIjpcIuKIgVwiLFwiY29tcGxleGVzXCI6XCLihIJcIixcImNvbmdcIjpcIuKJhVwiLFwiY29uZ2RvdFwiOlwi4qmtXCIsXCJDb25ncnVlbnRcIjpcIuKJoVwiLFwiY29uaW50XCI6XCLiiK5cIixcIkNvbmludFwiOlwi4oivXCIsXCJDb250b3VySW50ZWdyYWxcIjpcIuKIrlwiLFwiY29wZlwiOlwi8J2VlFwiLFwiQ29wZlwiOlwi4oSCXCIsXCJjb3Byb2RcIjpcIuKIkFwiLFwiQ29wcm9kdWN0XCI6XCLiiJBcIixcImNvcHlcIjpcIsKpXCIsXCJDT1BZXCI6XCLCqVwiLFwiY29weXNyXCI6XCLihJdcIixcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIs1wiLFwiY3JhcnJcIjpcIuKGtVwiLFwiY3Jvc3NcIjpcIuKcl1wiLFwiQ3Jvc3NcIjpcIuKor1wiLFwiQ3NjclwiOlwi8J2SnlwiLFwiY3NjclwiOlwi8J2SuFwiLFwiY3N1YlwiOlwi4quPXCIsXCJjc3ViZVwiOlwi4quRXCIsXCJjc3VwXCI6XCLiq5BcIixcImNzdXBlXCI6XCLiq5JcIixcImN0ZG90XCI6XCLii69cIixcImN1ZGFycmxcIjpcIuKkuFwiLFwiY3VkYXJyclwiOlwi4qS1XCIsXCJjdWVwclwiOlwi4oueXCIsXCJjdWVzY1wiOlwi4oufXCIsXCJjdWxhcnJcIjpcIuKGtlwiLFwiY3VsYXJycFwiOlwi4qS9XCIsXCJjdXBicmNhcFwiOlwi4qmIXCIsXCJjdXBjYXBcIjpcIuKphlwiLFwiQ3VwQ2FwXCI6XCLiiY1cIixcImN1cFwiOlwi4oiqXCIsXCJDdXBcIjpcIuKLk1wiLFwiY3VwY3VwXCI6XCLiqYpcIixcImN1cGRvdFwiOlwi4oqNXCIsXCJjdXBvclwiOlwi4qmFXCIsXCJjdXBzXCI6XCLiiKrvuIBcIixcImN1cmFyclwiOlwi4oa3XCIsXCJjdXJhcnJtXCI6XCLipLxcIixcImN1cmx5ZXFwcmVjXCI6XCLii55cIixcImN1cmx5ZXFzdWNjXCI6XCLii59cIixcImN1cmx5dmVlXCI6XCLii45cIixcImN1cmx5d2VkZ2VcIjpcIuKLj1wiLFwiY3VycmVuXCI6XCLCpFwiLFwiY3VydmVhcnJvd2xlZnRcIjpcIuKGtlwiLFwiY3VydmVhcnJvd3JpZ2h0XCI6XCLihrdcIixcImN1dmVlXCI6XCLii45cIixcImN1d2VkXCI6XCLii49cIixcImN3Y29uaW50XCI6XCLiiLJcIixcImN3aW50XCI6XCLiiLFcIixcImN5bGN0eVwiOlwi4oytXCIsXCJkYWdnZXJcIjpcIuKAoFwiLFwiRGFnZ2VyXCI6XCLigKFcIixcImRhbGV0aFwiOlwi4oS4XCIsXCJkYXJyXCI6XCLihpNcIixcIkRhcnJcIjpcIuKGoVwiLFwiZEFyclwiOlwi4oeTXCIsXCJkYXNoXCI6XCLigJBcIixcIkRhc2h2XCI6XCLiq6RcIixcImRhc2h2XCI6XCLiiqNcIixcImRia2Fyb3dcIjpcIuKkj1wiLFwiZGJsYWNcIjpcIsudXCIsXCJEY2Fyb25cIjpcIsSOXCIsXCJkY2Fyb25cIjpcIsSPXCIsXCJEY3lcIjpcItCUXCIsXCJkY3lcIjpcItC0XCIsXCJkZGFnZ2VyXCI6XCLigKFcIixcImRkYXJyXCI6XCLih4pcIixcIkREXCI6XCLihYVcIixcImRkXCI6XCLihYZcIixcIkREb3RyYWhkXCI6XCLipJFcIixcImRkb3RzZXFcIjpcIuKpt1wiLFwiZGVnXCI6XCLCsFwiLFwiRGVsXCI6XCLiiIdcIixcIkRlbHRhXCI6XCLOlFwiLFwiZGVsdGFcIjpcIs60XCIsXCJkZW1wdHl2XCI6XCLiprFcIixcImRmaXNodFwiOlwi4qW/XCIsXCJEZnJcIjpcIvCdlIdcIixcImRmclwiOlwi8J2UoVwiLFwiZEhhclwiOlwi4qWlXCIsXCJkaGFybFwiOlwi4oeDXCIsXCJkaGFyclwiOlwi4oeCXCIsXCJEaWFjcml0aWNhbEFjdXRlXCI6XCLCtFwiLFwiRGlhY3JpdGljYWxEb3RcIjpcIsuZXCIsXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6XCLLnVwiLFwiRGlhY3JpdGljYWxHcmF2ZVwiOlwiYFwiLFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiy5xcIixcImRpYW1cIjpcIuKLhFwiLFwiZGlhbW9uZFwiOlwi4ouEXCIsXCJEaWFtb25kXCI6XCLii4RcIixcImRpYW1vbmRzdWl0XCI6XCLimaZcIixcImRpYW1zXCI6XCLimaZcIixcImRpZVwiOlwiwqhcIixcIkRpZmZlcmVudGlhbERcIjpcIuKFhlwiLFwiZGlnYW1tYVwiOlwiz51cIixcImRpc2luXCI6XCLii7JcIixcImRpdlwiOlwiw7dcIixcImRpdmlkZVwiOlwiw7dcIixcImRpdmlkZW9udGltZXNcIjpcIuKLh1wiLFwiZGl2b254XCI6XCLii4dcIixcIkRKY3lcIjpcItCCXCIsXCJkamN5XCI6XCLRklwiLFwiZGxjb3JuXCI6XCLijJ5cIixcImRsY3JvcFwiOlwi4oyNXCIsXCJkb2xsYXJcIjpcIiRcIixcIkRvcGZcIjpcIvCdlLtcIixcImRvcGZcIjpcIvCdlZVcIixcIkRvdFwiOlwiwqhcIixcImRvdFwiOlwiy5lcIixcIkRvdERvdFwiOlwi4oOcXCIsXCJkb3RlcVwiOlwi4omQXCIsXCJkb3RlcWRvdFwiOlwi4omRXCIsXCJEb3RFcXVhbFwiOlwi4omQXCIsXCJkb3RtaW51c1wiOlwi4oi4XCIsXCJkb3RwbHVzXCI6XCLiiJRcIixcImRvdHNxdWFyZVwiOlwi4oqhXCIsXCJkb3VibGViYXJ3ZWRnZVwiOlwi4oyGXCIsXCJEb3VibGVDb250b3VySW50ZWdyYWxcIjpcIuKIr1wiLFwiRG91YmxlRG90XCI6XCLCqFwiLFwiRG91YmxlRG93bkFycm93XCI6XCLih5NcIixcIkRvdWJsZUxlZnRBcnJvd1wiOlwi4oeQXCIsXCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOlwi4oeUXCIsXCJEb3VibGVMZWZ0VGVlXCI6XCLiq6RcIixcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjpcIuKfuFwiLFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7pcIixcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCLin7lcIixcIkRvdWJsZVJpZ2h0QXJyb3dcIjpcIuKHklwiLFwiRG91YmxlUmlnaHRUZWVcIjpcIuKKqFwiLFwiRG91YmxlVXBBcnJvd1wiOlwi4oeRXCIsXCJEb3VibGVVcERvd25BcnJvd1wiOlwi4oeVXCIsXCJEb3VibGVWZXJ0aWNhbEJhclwiOlwi4oilXCIsXCJEb3duQXJyb3dCYXJcIjpcIuKkk1wiLFwiZG93bmFycm93XCI6XCLihpNcIixcIkRvd25BcnJvd1wiOlwi4oaTXCIsXCJEb3duYXJyb3dcIjpcIuKHk1wiLFwiRG93bkFycm93VXBBcnJvd1wiOlwi4oe1XCIsXCJEb3duQnJldmVcIjpcIsyRXCIsXCJkb3duZG93bmFycm93c1wiOlwi4oeKXCIsXCJkb3duaGFycG9vbmxlZnRcIjpcIuKHg1wiLFwiZG93bmhhcnBvb25yaWdodFwiOlwi4oeCXCIsXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCLipZBcIixcIkRvd25MZWZ0VGVlVmVjdG9yXCI6XCLipZ5cIixcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCLipZZcIixcIkRvd25MZWZ0VmVjdG9yXCI6XCLihr1cIixcIkRvd25SaWdodFRlZVZlY3RvclwiOlwi4qWfXCIsXCJEb3duUmlnaHRWZWN0b3JCYXJcIjpcIuKll1wiLFwiRG93blJpZ2h0VmVjdG9yXCI6XCLih4FcIixcIkRvd25UZWVBcnJvd1wiOlwi4oanXCIsXCJEb3duVGVlXCI6XCLiiqRcIixcImRyYmthcm93XCI6XCLipJBcIixcImRyY29yblwiOlwi4oyfXCIsXCJkcmNyb3BcIjpcIuKMjFwiLFwiRHNjclwiOlwi8J2Sn1wiLFwiZHNjclwiOlwi8J2SuVwiLFwiRFNjeVwiOlwi0IVcIixcImRzY3lcIjpcItGVXCIsXCJkc29sXCI6XCLip7ZcIixcIkRzdHJva1wiOlwixJBcIixcImRzdHJva1wiOlwixJFcIixcImR0ZG90XCI6XCLii7FcIixcImR0cmlcIjpcIuKWv1wiLFwiZHRyaWZcIjpcIuKWvlwiLFwiZHVhcnJcIjpcIuKHtVwiLFwiZHVoYXJcIjpcIuKlr1wiLFwiZHdhbmdsZVwiOlwi4qamXCIsXCJEWmN5XCI6XCLQj1wiLFwiZHpjeVwiOlwi0Z9cIixcImR6aWdyYXJyXCI6XCLin79cIixcIkVhY3V0ZVwiOlwiw4lcIixcImVhY3V0ZVwiOlwiw6lcIixcImVhc3RlclwiOlwi4qmuXCIsXCJFY2Fyb25cIjpcIsSaXCIsXCJlY2Fyb25cIjpcIsSbXCIsXCJFY2lyY1wiOlwiw4pcIixcImVjaXJjXCI6XCLDqlwiLFwiZWNpclwiOlwi4omWXCIsXCJlY29sb25cIjpcIuKJlVwiLFwiRWN5XCI6XCLQrVwiLFwiZWN5XCI6XCLRjVwiLFwiZUREb3RcIjpcIuKpt1wiLFwiRWRvdFwiOlwixJZcIixcImVkb3RcIjpcIsSXXCIsXCJlRG90XCI6XCLiiZFcIixcImVlXCI6XCLihYdcIixcImVmRG90XCI6XCLiiZJcIixcIkVmclwiOlwi8J2UiFwiLFwiZWZyXCI6XCLwnZSiXCIsXCJlZ1wiOlwi4qqaXCIsXCJFZ3JhdmVcIjpcIsOIXCIsXCJlZ3JhdmVcIjpcIsOoXCIsXCJlZ3NcIjpcIuKqllwiLFwiZWdzZG90XCI6XCLiqphcIixcImVsXCI6XCLiqplcIixcIkVsZW1lbnRcIjpcIuKIiFwiLFwiZWxpbnRlcnNcIjpcIuKPp1wiLFwiZWxsXCI6XCLihJNcIixcImVsc1wiOlwi4qqVXCIsXCJlbHNkb3RcIjpcIuKql1wiLFwiRW1hY3JcIjpcIsSSXCIsXCJlbWFjclwiOlwixJNcIixcImVtcHR5XCI6XCLiiIVcIixcImVtcHR5c2V0XCI6XCLiiIVcIixcIkVtcHR5U21hbGxTcXVhcmVcIjpcIuKXu1wiLFwiZW1wdHl2XCI6XCLiiIVcIixcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6XCLilqtcIixcImVtc3AxM1wiOlwi4oCEXCIsXCJlbXNwMTRcIjpcIuKAhVwiLFwiZW1zcFwiOlwi4oCDXCIsXCJFTkdcIjpcIsWKXCIsXCJlbmdcIjpcIsWLXCIsXCJlbnNwXCI6XCLigIJcIixcIkVvZ29uXCI6XCLEmFwiLFwiZW9nb25cIjpcIsSZXCIsXCJFb3BmXCI6XCLwnZS8XCIsXCJlb3BmXCI6XCLwnZWWXCIsXCJlcGFyXCI6XCLii5VcIixcImVwYXJzbFwiOlwi4qejXCIsXCJlcGx1c1wiOlwi4qmxXCIsXCJlcHNpXCI6XCLOtVwiLFwiRXBzaWxvblwiOlwizpVcIixcImVwc2lsb25cIjpcIs61XCIsXCJlcHNpdlwiOlwiz7VcIixcImVxY2lyY1wiOlwi4omWXCIsXCJlcWNvbG9uXCI6XCLiiZVcIixcImVxc2ltXCI6XCLiiYJcIixcImVxc2xhbnRndHJcIjpcIuKqllwiLFwiZXFzbGFudGxlc3NcIjpcIuKqlVwiLFwiRXF1YWxcIjpcIuKptVwiLFwiZXF1YWxzXCI6XCI9XCIsXCJFcXVhbFRpbGRlXCI6XCLiiYJcIixcImVxdWVzdFwiOlwi4omfXCIsXCJFcXVpbGlicml1bVwiOlwi4oeMXCIsXCJlcXVpdlwiOlwi4omhXCIsXCJlcXVpdkREXCI6XCLiqbhcIixcImVxdnBhcnNsXCI6XCLip6VcIixcImVyYXJyXCI6XCLipbFcIixcImVyRG90XCI6XCLiiZNcIixcImVzY3JcIjpcIuKEr1wiLFwiRXNjclwiOlwi4oSwXCIsXCJlc2RvdFwiOlwi4omQXCIsXCJFc2ltXCI6XCLiqbNcIixcImVzaW1cIjpcIuKJglwiLFwiRXRhXCI6XCLOl1wiLFwiZXRhXCI6XCLOt1wiLFwiRVRIXCI6XCLDkFwiLFwiZXRoXCI6XCLDsFwiLFwiRXVtbFwiOlwiw4tcIixcImV1bWxcIjpcIsOrXCIsXCJldXJvXCI6XCLigqxcIixcImV4Y2xcIjpcIiFcIixcImV4aXN0XCI6XCLiiINcIixcIkV4aXN0c1wiOlwi4oiDXCIsXCJleHBlY3RhdGlvblwiOlwi4oSwXCIsXCJleHBvbmVudGlhbGVcIjpcIuKFh1wiLFwiRXhwb25lbnRpYWxFXCI6XCLihYdcIixcImZhbGxpbmdkb3RzZXFcIjpcIuKJklwiLFwiRmN5XCI6XCLQpFwiLFwiZmN5XCI6XCLRhFwiLFwiZmVtYWxlXCI6XCLimYBcIixcImZmaWxpZ1wiOlwi76yDXCIsXCJmZmxpZ1wiOlwi76yAXCIsXCJmZmxsaWdcIjpcIu+shFwiLFwiRmZyXCI6XCLwnZSJXCIsXCJmZnJcIjpcIvCdlKNcIixcImZpbGlnXCI6XCLvrIFcIixcIkZpbGxlZFNtYWxsU3F1YXJlXCI6XCLil7xcIixcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOlwi4paqXCIsXCJmamxpZ1wiOlwiZmpcIixcImZsYXRcIjpcIuKZrVwiLFwiZmxsaWdcIjpcIu+sglwiLFwiZmx0bnNcIjpcIuKWsVwiLFwiZm5vZlwiOlwixpJcIixcIkZvcGZcIjpcIvCdlL1cIixcImZvcGZcIjpcIvCdlZdcIixcImZvcmFsbFwiOlwi4oiAXCIsXCJGb3JBbGxcIjpcIuKIgFwiLFwiZm9ya1wiOlwi4ouUXCIsXCJmb3JrdlwiOlwi4quZXCIsXCJGb3VyaWVydHJmXCI6XCLihLFcIixcImZwYXJ0aW50XCI6XCLiqI1cIixcImZyYWMxMlwiOlwiwr1cIixcImZyYWMxM1wiOlwi4oWTXCIsXCJmcmFjMTRcIjpcIsK8XCIsXCJmcmFjMTVcIjpcIuKFlVwiLFwiZnJhYzE2XCI6XCLihZlcIixcImZyYWMxOFwiOlwi4oWbXCIsXCJmcmFjMjNcIjpcIuKFlFwiLFwiZnJhYzI1XCI6XCLihZZcIixcImZyYWMzNFwiOlwiwr5cIixcImZyYWMzNVwiOlwi4oWXXCIsXCJmcmFjMzhcIjpcIuKFnFwiLFwiZnJhYzQ1XCI6XCLihZhcIixcImZyYWM1NlwiOlwi4oWaXCIsXCJmcmFjNThcIjpcIuKFnVwiLFwiZnJhYzc4XCI6XCLihZ5cIixcImZyYXNsXCI6XCLigYRcIixcImZyb3duXCI6XCLijKJcIixcImZzY3JcIjpcIvCdkrtcIixcIkZzY3JcIjpcIuKEsVwiLFwiZ2FjdXRlXCI6XCLHtVwiLFwiR2FtbWFcIjpcIs6TXCIsXCJnYW1tYVwiOlwizrNcIixcIkdhbW1hZFwiOlwiz5xcIixcImdhbW1hZFwiOlwiz51cIixcImdhcFwiOlwi4qqGXCIsXCJHYnJldmVcIjpcIsSeXCIsXCJnYnJldmVcIjpcIsSfXCIsXCJHY2VkaWxcIjpcIsSiXCIsXCJHY2lyY1wiOlwixJxcIixcImdjaXJjXCI6XCLEnVwiLFwiR2N5XCI6XCLQk1wiLFwiZ2N5XCI6XCLQs1wiLFwiR2RvdFwiOlwixKBcIixcImdkb3RcIjpcIsShXCIsXCJnZVwiOlwi4omlXCIsXCJnRVwiOlwi4omnXCIsXCJnRWxcIjpcIuKqjFwiLFwiZ2VsXCI6XCLii5tcIixcImdlcVwiOlwi4omlXCIsXCJnZXFxXCI6XCLiiadcIixcImdlcXNsYW50XCI6XCLiqb5cIixcImdlc2NjXCI6XCLiqqlcIixcImdlc1wiOlwi4qm+XCIsXCJnZXNkb3RcIjpcIuKqgFwiLFwiZ2VzZG90b1wiOlwi4qqCXCIsXCJnZXNkb3RvbFwiOlwi4qqEXCIsXCJnZXNsXCI6XCLii5vvuIBcIixcImdlc2xlc1wiOlwi4qqUXCIsXCJHZnJcIjpcIvCdlIpcIixcImdmclwiOlwi8J2UpFwiLFwiZ2dcIjpcIuKJq1wiLFwiR2dcIjpcIuKLmVwiLFwiZ2dnXCI6XCLii5lcIixcImdpbWVsXCI6XCLihLdcIixcIkdKY3lcIjpcItCDXCIsXCJnamN5XCI6XCLRk1wiLFwiZ2xhXCI6XCLiqqVcIixcImdsXCI6XCLiibdcIixcImdsRVwiOlwi4qqSXCIsXCJnbGpcIjpcIuKqpFwiLFwiZ25hcFwiOlwi4qqKXCIsXCJnbmFwcHJveFwiOlwi4qqKXCIsXCJnbmVcIjpcIuKqiFwiLFwiZ25FXCI6XCLiialcIixcImduZXFcIjpcIuKqiFwiLFwiZ25lcXFcIjpcIuKJqVwiLFwiZ25zaW1cIjpcIuKLp1wiLFwiR29wZlwiOlwi8J2UvlwiLFwiZ29wZlwiOlwi8J2VmFwiLFwiZ3JhdmVcIjpcImBcIixcIkdyZWF0ZXJFcXVhbFwiOlwi4omlXCIsXCJHcmVhdGVyRXF1YWxMZXNzXCI6XCLii5tcIixcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp1wiLFwiR3JlYXRlckdyZWF0ZXJcIjpcIuKqolwiLFwiR3JlYXRlckxlc3NcIjpcIuKJt1wiLFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvlwiLFwiR3JlYXRlclRpbGRlXCI6XCLiibNcIixcIkdzY3JcIjpcIvCdkqJcIixcImdzY3JcIjpcIuKEilwiLFwiZ3NpbVwiOlwi4omzXCIsXCJnc2ltZVwiOlwi4qqOXCIsXCJnc2ltbFwiOlwi4qqQXCIsXCJndGNjXCI6XCLiqqdcIixcImd0Y2lyXCI6XCLiqbpcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiR3RcIjpcIuKJq1wiLFwiZ3Rkb3RcIjpcIuKLl1wiLFwiZ3RsUGFyXCI6XCLippVcIixcImd0cXVlc3RcIjpcIuKpvFwiLFwiZ3RyYXBwcm94XCI6XCLiqoZcIixcImd0cmFyclwiOlwi4qW4XCIsXCJndHJkb3RcIjpcIuKLl1wiLFwiZ3RyZXFsZXNzXCI6XCLii5tcIixcImd0cmVxcWxlc3NcIjpcIuKqjFwiLFwiZ3RybGVzc1wiOlwi4om3XCIsXCJndHJzaW1cIjpcIuKJs1wiLFwiZ3ZlcnRuZXFxXCI6XCLiianvuIBcIixcImd2bkVcIjpcIuKJqe+4gFwiLFwiSGFjZWtcIjpcIsuHXCIsXCJoYWlyc3BcIjpcIuKAilwiLFwiaGFsZlwiOlwiwr1cIixcImhhbWlsdFwiOlwi4oSLXCIsXCJIQVJEY3lcIjpcItCqXCIsXCJoYXJkY3lcIjpcItGKXCIsXCJoYXJyY2lyXCI6XCLipYhcIixcImhhcnJcIjpcIuKGlFwiLFwiaEFyclwiOlwi4oeUXCIsXCJoYXJyd1wiOlwi4oatXCIsXCJIYXRcIjpcIl5cIixcImhiYXJcIjpcIuKEj1wiLFwiSGNpcmNcIjpcIsSkXCIsXCJoY2lyY1wiOlwixKVcIixcImhlYXJ0c1wiOlwi4pmlXCIsXCJoZWFydHN1aXRcIjpcIuKZpVwiLFwiaGVsbGlwXCI6XCLigKZcIixcImhlcmNvblwiOlwi4oq5XCIsXCJoZnJcIjpcIvCdlKVcIixcIkhmclwiOlwi4oSMXCIsXCJIaWxiZXJ0U3BhY2VcIjpcIuKEi1wiLFwiaGtzZWFyb3dcIjpcIuKkpVwiLFwiaGtzd2Fyb3dcIjpcIuKkplwiLFwiaG9hcnJcIjpcIuKHv1wiLFwiaG9tdGh0XCI6XCLiiLtcIixcImhvb2tsZWZ0YXJyb3dcIjpcIuKGqVwiLFwiaG9va3JpZ2h0YXJyb3dcIjpcIuKGqlwiLFwiaG9wZlwiOlwi8J2VmVwiLFwiSG9wZlwiOlwi4oSNXCIsXCJob3JiYXJcIjpcIuKAlVwiLFwiSG9yaXpvbnRhbExpbmVcIjpcIuKUgFwiLFwiaHNjclwiOlwi8J2SvVwiLFwiSHNjclwiOlwi4oSLXCIsXCJoc2xhc2hcIjpcIuKEj1wiLFwiSHN0cm9rXCI6XCLEplwiLFwiaHN0cm9rXCI6XCLEp1wiLFwiSHVtcERvd25IdW1wXCI6XCLiiY5cIixcIkh1bXBFcXVhbFwiOlwi4omPXCIsXCJoeWJ1bGxcIjpcIuKBg1wiLFwiaHlwaGVuXCI6XCLigJBcIixcIklhY3V0ZVwiOlwiw41cIixcImlhY3V0ZVwiOlwiw61cIixcImljXCI6XCLigaNcIixcIkljaXJjXCI6XCLDjlwiLFwiaWNpcmNcIjpcIsOuXCIsXCJJY3lcIjpcItCYXCIsXCJpY3lcIjpcItC4XCIsXCJJZG90XCI6XCLEsFwiLFwiSUVjeVwiOlwi0JVcIixcImllY3lcIjpcItC1XCIsXCJpZXhjbFwiOlwiwqFcIixcImlmZlwiOlwi4oeUXCIsXCJpZnJcIjpcIvCdlKZcIixcIklmclwiOlwi4oSRXCIsXCJJZ3JhdmVcIjpcIsOMXCIsXCJpZ3JhdmVcIjpcIsOsXCIsXCJpaVwiOlwi4oWIXCIsXCJpaWlpbnRcIjpcIuKojFwiLFwiaWlpbnRcIjpcIuKIrVwiLFwiaWluZmluXCI6XCLip5xcIixcImlpb3RhXCI6XCLihKlcIixcIklKbGlnXCI6XCLEslwiLFwiaWpsaWdcIjpcIsSzXCIsXCJJbWFjclwiOlwixKpcIixcImltYWNyXCI6XCLEq1wiLFwiaW1hZ2VcIjpcIuKEkVwiLFwiSW1hZ2luYXJ5SVwiOlwi4oWIXCIsXCJpbWFnbGluZVwiOlwi4oSQXCIsXCJpbWFncGFydFwiOlwi4oSRXCIsXCJpbWF0aFwiOlwixLFcIixcIkltXCI6XCLihJFcIixcImltb2ZcIjpcIuKKt1wiLFwiaW1wZWRcIjpcIsa1XCIsXCJJbXBsaWVzXCI6XCLih5JcIixcImluY2FyZVwiOlwi4oSFXCIsXCJpblwiOlwi4oiIXCIsXCJpbmZpblwiOlwi4oieXCIsXCJpbmZpbnRpZVwiOlwi4qedXCIsXCJpbm9kb3RcIjpcIsSxXCIsXCJpbnRjYWxcIjpcIuKKulwiLFwiaW50XCI6XCLiiKtcIixcIkludFwiOlwi4oisXCIsXCJpbnRlZ2Vyc1wiOlwi4oSkXCIsXCJJbnRlZ3JhbFwiOlwi4oirXCIsXCJpbnRlcmNhbFwiOlwi4oq6XCIsXCJJbnRlcnNlY3Rpb25cIjpcIuKLglwiLFwiaW50bGFyaGtcIjpcIuKol1wiLFwiaW50cHJvZFwiOlwi4qi8XCIsXCJJbnZpc2libGVDb21tYVwiOlwi4oGjXCIsXCJJbnZpc2libGVUaW1lc1wiOlwi4oGiXCIsXCJJT2N5XCI6XCLQgVwiLFwiaW9jeVwiOlwi0ZFcIixcIklvZ29uXCI6XCLErlwiLFwiaW9nb25cIjpcIsSvXCIsXCJJb3BmXCI6XCLwnZWAXCIsXCJpb3BmXCI6XCLwnZWaXCIsXCJJb3RhXCI6XCLOmVwiLFwiaW90YVwiOlwizrlcIixcImlwcm9kXCI6XCLiqLxcIixcImlxdWVzdFwiOlwiwr9cIixcImlzY3JcIjpcIvCdkr5cIixcIklzY3JcIjpcIuKEkFwiLFwiaXNpblwiOlwi4oiIXCIsXCJpc2luZG90XCI6XCLii7VcIixcImlzaW5FXCI6XCLii7lcIixcImlzaW5zXCI6XCLii7RcIixcImlzaW5zdlwiOlwi4ouzXCIsXCJpc2ludlwiOlwi4oiIXCIsXCJpdFwiOlwi4oGiXCIsXCJJdGlsZGVcIjpcIsSoXCIsXCJpdGlsZGVcIjpcIsSpXCIsXCJJdWtjeVwiOlwi0IZcIixcIml1a2N5XCI6XCLRllwiLFwiSXVtbFwiOlwiw49cIixcIml1bWxcIjpcIsOvXCIsXCJKY2lyY1wiOlwixLRcIixcImpjaXJjXCI6XCLEtVwiLFwiSmN5XCI6XCLQmVwiLFwiamN5XCI6XCLQuVwiLFwiSmZyXCI6XCLwnZSNXCIsXCJqZnJcIjpcIvCdlKdcIixcImptYXRoXCI6XCLIt1wiLFwiSm9wZlwiOlwi8J2VgVwiLFwiam9wZlwiOlwi8J2Vm1wiLFwiSnNjclwiOlwi8J2SpVwiLFwianNjclwiOlwi8J2Sv1wiLFwiSnNlcmN5XCI6XCLQiFwiLFwianNlcmN5XCI6XCLRmFwiLFwiSnVrY3lcIjpcItCEXCIsXCJqdWtjeVwiOlwi0ZRcIixcIkthcHBhXCI6XCLOmlwiLFwia2FwcGFcIjpcIs66XCIsXCJrYXBwYXZcIjpcIs+wXCIsXCJLY2VkaWxcIjpcIsS2XCIsXCJrY2VkaWxcIjpcIsS3XCIsXCJLY3lcIjpcItCaXCIsXCJrY3lcIjpcItC6XCIsXCJLZnJcIjpcIvCdlI5cIixcImtmclwiOlwi8J2UqFwiLFwia2dyZWVuXCI6XCLEuFwiLFwiS0hjeVwiOlwi0KVcIixcImtoY3lcIjpcItGFXCIsXCJLSmN5XCI6XCLQjFwiLFwia2pjeVwiOlwi0ZxcIixcIktvcGZcIjpcIvCdlYJcIixcImtvcGZcIjpcIvCdlZxcIixcIktzY3JcIjpcIvCdkqZcIixcImtzY3JcIjpcIvCdk4BcIixcImxBYXJyXCI6XCLih5pcIixcIkxhY3V0ZVwiOlwixLlcIixcImxhY3V0ZVwiOlwixLpcIixcImxhZW1wdHl2XCI6XCLiprRcIixcImxhZ3JhblwiOlwi4oSSXCIsXCJMYW1iZGFcIjpcIs6bXCIsXCJsYW1iZGFcIjpcIs67XCIsXCJsYW5nXCI6XCLin6hcIixcIkxhbmdcIjpcIuKfqlwiLFwibGFuZ2RcIjpcIuKmkVwiLFwibGFuZ2xlXCI6XCLin6hcIixcImxhcFwiOlwi4qqFXCIsXCJMYXBsYWNldHJmXCI6XCLihJJcIixcImxhcXVvXCI6XCLCq1wiLFwibGFycmJcIjpcIuKHpFwiLFwibGFycmJmc1wiOlwi4qSfXCIsXCJsYXJyXCI6XCLihpBcIixcIkxhcnJcIjpcIuKGnlwiLFwibEFyclwiOlwi4oeQXCIsXCJsYXJyZnNcIjpcIuKknVwiLFwibGFycmhrXCI6XCLihqlcIixcImxhcnJscFwiOlwi4oarXCIsXCJsYXJycGxcIjpcIuKkuVwiLFwibGFycnNpbVwiOlwi4qWzXCIsXCJsYXJydGxcIjpcIuKGolwiLFwibGF0YWlsXCI6XCLipJlcIixcImxBdGFpbFwiOlwi4qSbXCIsXCJsYXRcIjpcIuKqq1wiLFwibGF0ZVwiOlwi4qqtXCIsXCJsYXRlc1wiOlwi4qqt77iAXCIsXCJsYmFyclwiOlwi4qSMXCIsXCJsQmFyclwiOlwi4qSOXCIsXCJsYmJya1wiOlwi4p2yXCIsXCJsYnJhY2VcIjpcIntcIixcImxicmFja1wiOlwiW1wiLFwibGJya2VcIjpcIuKmi1wiLFwibGJya3NsZFwiOlwi4qaPXCIsXCJsYnJrc2x1XCI6XCLipo1cIixcIkxjYXJvblwiOlwixL1cIixcImxjYXJvblwiOlwixL5cIixcIkxjZWRpbFwiOlwixLtcIixcImxjZWRpbFwiOlwixLxcIixcImxjZWlsXCI6XCLijIhcIixcImxjdWJcIjpcIntcIixcIkxjeVwiOlwi0JtcIixcImxjeVwiOlwi0LtcIixcImxkY2FcIjpcIuKktlwiLFwibGRxdW9cIjpcIuKAnFwiLFwibGRxdW9yXCI6XCLigJ5cIixcImxkcmRoYXJcIjpcIuKlp1wiLFwibGRydXNoYXJcIjpcIuKli1wiLFwibGRzaFwiOlwi4oayXCIsXCJsZVwiOlwi4omkXCIsXCJsRVwiOlwi4ommXCIsXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCLin6hcIixcIkxlZnRBcnJvd0JhclwiOlwi4oekXCIsXCJsZWZ0YXJyb3dcIjpcIuKGkFwiLFwiTGVmdEFycm93XCI6XCLihpBcIixcIkxlZnRhcnJvd1wiOlwi4oeQXCIsXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCLih4ZcIixcImxlZnRhcnJvd3RhaWxcIjpcIuKGolwiLFwiTGVmdENlaWxpbmdcIjpcIuKMiFwiLFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIuKfplwiLFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIuKloVwiLFwiTGVmdERvd25WZWN0b3JCYXJcIjpcIuKlmVwiLFwiTGVmdERvd25WZWN0b3JcIjpcIuKHg1wiLFwiTGVmdEZsb29yXCI6XCLijIpcIixcImxlZnRoYXJwb29uZG93blwiOlwi4oa9XCIsXCJsZWZ0aGFycG9vbnVwXCI6XCLihrxcIixcImxlZnRsZWZ0YXJyb3dzXCI6XCLih4dcIixcImxlZnRyaWdodGFycm93XCI6XCLihpRcIixcIkxlZnRSaWdodEFycm93XCI6XCLihpRcIixcIkxlZnRyaWdodGFycm93XCI6XCLih5RcIixcImxlZnRyaWdodGFycm93c1wiOlwi4oeGXCIsXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwi4oeLXCIsXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCLihq1cIixcIkxlZnRSaWdodFZlY3RvclwiOlwi4qWOXCIsXCJMZWZ0VGVlQXJyb3dcIjpcIuKGpFwiLFwiTGVmdFRlZVwiOlwi4oqjXCIsXCJMZWZ0VGVlVmVjdG9yXCI6XCLipZpcIixcImxlZnR0aHJlZXRpbWVzXCI6XCLii4tcIixcIkxlZnRUcmlhbmdsZUJhclwiOlwi4qePXCIsXCJMZWZ0VHJpYW5nbGVcIjpcIuKKslwiLFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKKtFwiLFwiTGVmdFVwRG93blZlY3RvclwiOlwi4qWRXCIsXCJMZWZ0VXBUZWVWZWN0b3JcIjpcIuKloFwiLFwiTGVmdFVwVmVjdG9yQmFyXCI6XCLipZhcIixcIkxlZnRVcFZlY3RvclwiOlwi4oa/XCIsXCJMZWZ0VmVjdG9yQmFyXCI6XCLipZJcIixcIkxlZnRWZWN0b3JcIjpcIuKGvFwiLFwibEVnXCI6XCLiqotcIixcImxlZ1wiOlwi4ouaXCIsXCJsZXFcIjpcIuKJpFwiLFwibGVxcVwiOlwi4ommXCIsXCJsZXFzbGFudFwiOlwi4qm9XCIsXCJsZXNjY1wiOlwi4qqoXCIsXCJsZXNcIjpcIuKpvVwiLFwibGVzZG90XCI6XCLiqb9cIixcImxlc2RvdG9cIjpcIuKqgVwiLFwibGVzZG90b3JcIjpcIuKqg1wiLFwibGVzZ1wiOlwi4oua77iAXCIsXCJsZXNnZXNcIjpcIuKqk1wiLFwibGVzc2FwcHJveFwiOlwi4qqFXCIsXCJsZXNzZG90XCI6XCLii5ZcIixcImxlc3NlcWd0clwiOlwi4ouaXCIsXCJsZXNzZXFxZ3RyXCI6XCLiqotcIixcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIuKLmlwiLFwiTGVzc0Z1bGxFcXVhbFwiOlwi4ommXCIsXCJMZXNzR3JlYXRlclwiOlwi4om2XCIsXCJsZXNzZ3RyXCI6XCLiibZcIixcIkxlc3NMZXNzXCI6XCLiqqFcIixcImxlc3NzaW1cIjpcIuKJslwiLFwiTGVzc1NsYW50RXF1YWxcIjpcIuKpvVwiLFwiTGVzc1RpbGRlXCI6XCLiibJcIixcImxmaXNodFwiOlwi4qW8XCIsXCJsZmxvb3JcIjpcIuKMilwiLFwiTGZyXCI6XCLwnZSPXCIsXCJsZnJcIjpcIvCdlKlcIixcImxnXCI6XCLiibZcIixcImxnRVwiOlwi4qqRXCIsXCJsSGFyXCI6XCLipaJcIixcImxoYXJkXCI6XCLihr1cIixcImxoYXJ1XCI6XCLihrxcIixcImxoYXJ1bFwiOlwi4qWqXCIsXCJsaGJsa1wiOlwi4paEXCIsXCJMSmN5XCI6XCLQiVwiLFwibGpjeVwiOlwi0ZlcIixcImxsYXJyXCI6XCLih4dcIixcImxsXCI6XCLiiapcIixcIkxsXCI6XCLii5hcIixcImxsY29ybmVyXCI6XCLijJ5cIixcIkxsZWZ0YXJyb3dcIjpcIuKHmlwiLFwibGxoYXJkXCI6XCLipatcIixcImxsdHJpXCI6XCLil7pcIixcIkxtaWRvdFwiOlwixL9cIixcImxtaWRvdFwiOlwixYBcIixcImxtb3VzdGFjaGVcIjpcIuKOsFwiLFwibG1vdXN0XCI6XCLijrBcIixcImxuYXBcIjpcIuKqiVwiLFwibG5hcHByb3hcIjpcIuKqiVwiLFwibG5lXCI6XCLiqodcIixcImxuRVwiOlwi4omoXCIsXCJsbmVxXCI6XCLiqodcIixcImxuZXFxXCI6XCLiiahcIixcImxuc2ltXCI6XCLii6ZcIixcImxvYW5nXCI6XCLin6xcIixcImxvYXJyXCI6XCLih71cIixcImxvYnJrXCI6XCLin6ZcIixcImxvbmdsZWZ0YXJyb3dcIjpcIuKftVwiLFwiTG9uZ0xlZnRBcnJvd1wiOlwi4p+1XCIsXCJMb25nbGVmdGFycm93XCI6XCLin7hcIixcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+3XCIsXCJMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKft1wiLFwiTG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7pcIixcImxvbmdtYXBzdG9cIjpcIuKfvFwiLFwibG9uZ3JpZ2h0YXJyb3dcIjpcIuKftlwiLFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIuKftlwiLFwiTG9uZ3JpZ2h0YXJyb3dcIjpcIuKfuVwiLFwibG9vcGFycm93bGVmdFwiOlwi4oarXCIsXCJsb29wYXJyb3dyaWdodFwiOlwi4oasXCIsXCJsb3BhclwiOlwi4qaFXCIsXCJMb3BmXCI6XCLwnZWDXCIsXCJsb3BmXCI6XCLwnZWdXCIsXCJsb3BsdXNcIjpcIuKorVwiLFwibG90aW1lc1wiOlwi4qi0XCIsXCJsb3dhc3RcIjpcIuKIl1wiLFwibG93YmFyXCI6XCJfXCIsXCJMb3dlckxlZnRBcnJvd1wiOlwi4oaZXCIsXCJMb3dlclJpZ2h0QXJyb3dcIjpcIuKGmFwiLFwibG96XCI6XCLil4pcIixcImxvemVuZ2VcIjpcIuKXilwiLFwibG96ZlwiOlwi4qerXCIsXCJscGFyXCI6XCIoXCIsXCJscGFybHRcIjpcIuKmk1wiLFwibHJhcnJcIjpcIuKHhlwiLFwibHJjb3JuZXJcIjpcIuKMn1wiLFwibHJoYXJcIjpcIuKHi1wiLFwibHJoYXJkXCI6XCLipa1cIixcImxybVwiOlwi4oCOXCIsXCJscnRyaVwiOlwi4oq/XCIsXCJsc2FxdW9cIjpcIuKAuVwiLFwibHNjclwiOlwi8J2TgVwiLFwiTHNjclwiOlwi4oSSXCIsXCJsc2hcIjpcIuKGsFwiLFwiTHNoXCI6XCLihrBcIixcImxzaW1cIjpcIuKJslwiLFwibHNpbWVcIjpcIuKqjVwiLFwibHNpbWdcIjpcIuKqj1wiLFwibHNxYlwiOlwiW1wiLFwibHNxdW9cIjpcIuKAmFwiLFwibHNxdW9yXCI6XCLigJpcIixcIkxzdHJva1wiOlwixYFcIixcImxzdHJva1wiOlwixYJcIixcImx0Y2NcIjpcIuKqplwiLFwibHRjaXJcIjpcIuKpuVwiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJMdFwiOlwi4omqXCIsXCJsdGRvdFwiOlwi4ouWXCIsXCJsdGhyZWVcIjpcIuKLi1wiLFwibHRpbWVzXCI6XCLii4lcIixcImx0bGFyclwiOlwi4qW2XCIsXCJsdHF1ZXN0XCI6XCLiqbtcIixcImx0cmlcIjpcIuKXg1wiLFwibHRyaWVcIjpcIuKKtFwiLFwibHRyaWZcIjpcIuKXglwiLFwibHRyUGFyXCI6XCLippZcIixcImx1cmRzaGFyXCI6XCLipYpcIixcImx1cnVoYXJcIjpcIuKlplwiLFwibHZlcnRuZXFxXCI6XCLiiajvuIBcIixcImx2bkVcIjpcIuKJqO+4gFwiLFwibWFjclwiOlwiwq9cIixcIm1hbGVcIjpcIuKZglwiLFwibWFsdFwiOlwi4pygXCIsXCJtYWx0ZXNlXCI6XCLinKBcIixcIk1hcFwiOlwi4qSFXCIsXCJtYXBcIjpcIuKGplwiLFwibWFwc3RvXCI6XCLihqZcIixcIm1hcHN0b2Rvd25cIjpcIuKGp1wiLFwibWFwc3RvbGVmdFwiOlwi4oakXCIsXCJtYXBzdG91cFwiOlwi4oalXCIsXCJtYXJrZXJcIjpcIuKWrlwiLFwibWNvbW1hXCI6XCLiqKlcIixcIk1jeVwiOlwi0JxcIixcIm1jeVwiOlwi0LxcIixcIm1kYXNoXCI6XCLigJRcIixcIm1ERG90XCI6XCLiiLpcIixcIm1lYXN1cmVkYW5nbGVcIjpcIuKIoVwiLFwiTWVkaXVtU3BhY2VcIjpcIuKBn1wiLFwiTWVsbGludHJmXCI6XCLihLNcIixcIk1mclwiOlwi8J2UkFwiLFwibWZyXCI6XCLwnZSqXCIsXCJtaG9cIjpcIuKEp1wiLFwibWljcm9cIjpcIsK1XCIsXCJtaWRhc3RcIjpcIipcIixcIm1pZGNpclwiOlwi4quwXCIsXCJtaWRcIjpcIuKIo1wiLFwibWlkZG90XCI6XCLCt1wiLFwibWludXNiXCI6XCLiip9cIixcIm1pbnVzXCI6XCLiiJJcIixcIm1pbnVzZFwiOlwi4oi4XCIsXCJtaW51c2R1XCI6XCLiqKpcIixcIk1pbnVzUGx1c1wiOlwi4oiTXCIsXCJtbGNwXCI6XCLiq5tcIixcIm1sZHJcIjpcIuKAplwiLFwibW5wbHVzXCI6XCLiiJNcIixcIm1vZGVsc1wiOlwi4oqnXCIsXCJNb3BmXCI6XCLwnZWEXCIsXCJtb3BmXCI6XCLwnZWeXCIsXCJtcFwiOlwi4oiTXCIsXCJtc2NyXCI6XCLwnZOCXCIsXCJNc2NyXCI6XCLihLNcIixcIm1zdHBvc1wiOlwi4oi+XCIsXCJNdVwiOlwizpxcIixcIm11XCI6XCLOvFwiLFwibXVsdGltYXBcIjpcIuKKuFwiLFwibXVtYXBcIjpcIuKKuFwiLFwibmFibGFcIjpcIuKIh1wiLFwiTmFjdXRlXCI6XCLFg1wiLFwibmFjdXRlXCI6XCLFhFwiLFwibmFuZ1wiOlwi4oig4oOSXCIsXCJuYXBcIjpcIuKJiVwiLFwibmFwRVwiOlwi4qmwzLhcIixcIm5hcGlkXCI6XCLiiYvMuFwiLFwibmFwb3NcIjpcIsWJXCIsXCJuYXBwcm94XCI6XCLiiYlcIixcIm5hdHVyYWxcIjpcIuKZrlwiLFwibmF0dXJhbHNcIjpcIuKElVwiLFwibmF0dXJcIjpcIuKZrlwiLFwibmJzcFwiOlwiwqBcIixcIm5idW1wXCI6XCLiiY7MuFwiLFwibmJ1bXBlXCI6XCLiiY/MuFwiLFwibmNhcFwiOlwi4qmDXCIsXCJOY2Fyb25cIjpcIsWHXCIsXCJuY2Fyb25cIjpcIsWIXCIsXCJOY2VkaWxcIjpcIsWFXCIsXCJuY2VkaWxcIjpcIsWGXCIsXCJuY29uZ1wiOlwi4omHXCIsXCJuY29uZ2RvdFwiOlwi4qmtzLhcIixcIm5jdXBcIjpcIuKpglwiLFwiTmN5XCI6XCLQnVwiLFwibmN5XCI6XCLQvVwiLFwibmRhc2hcIjpcIuKAk1wiLFwibmVhcmhrXCI6XCLipKRcIixcIm5lYXJyXCI6XCLihpdcIixcIm5lQXJyXCI6XCLih5dcIixcIm5lYXJyb3dcIjpcIuKGl1wiLFwibmVcIjpcIuKJoFwiLFwibmVkb3RcIjpcIuKJkMy4XCIsXCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjpcIuKAi1wiLFwibmVxdWl2XCI6XCLiiaJcIixcIm5lc2VhclwiOlwi4qSoXCIsXCJuZXNpbVwiOlwi4omCzLhcIixcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiiatcIixcIk5lc3RlZExlc3NMZXNzXCI6XCLiiapcIixcIk5ld0xpbmVcIjpcIlxcblwiLFwibmV4aXN0XCI6XCLiiIRcIixcIm5leGlzdHNcIjpcIuKIhFwiLFwiTmZyXCI6XCLwnZSRXCIsXCJuZnJcIjpcIvCdlKtcIixcIm5nRVwiOlwi4omnzLhcIixcIm5nZVwiOlwi4omxXCIsXCJuZ2VxXCI6XCLiibFcIixcIm5nZXFxXCI6XCLiiafMuFwiLFwibmdlcXNsYW50XCI6XCLiqb7MuFwiLFwibmdlc1wiOlwi4qm+zLhcIixcIm5HZ1wiOlwi4ouZzLhcIixcIm5nc2ltXCI6XCLiibVcIixcIm5HdFwiOlwi4omr4oOSXCIsXCJuZ3RcIjpcIuKJr1wiLFwibmd0clwiOlwi4omvXCIsXCJuR3R2XCI6XCLiiavMuFwiLFwibmhhcnJcIjpcIuKGrlwiLFwibmhBcnJcIjpcIuKHjlwiLFwibmhwYXJcIjpcIuKrslwiLFwibmlcIjpcIuKIi1wiLFwibmlzXCI6XCLii7xcIixcIm5pc2RcIjpcIuKLulwiLFwibml2XCI6XCLiiItcIixcIk5KY3lcIjpcItCKXCIsXCJuamN5XCI6XCLRmlwiLFwibmxhcnJcIjpcIuKGmlwiLFwibmxBcnJcIjpcIuKHjVwiLFwibmxkclwiOlwi4oClXCIsXCJubEVcIjpcIuKJpsy4XCIsXCJubGVcIjpcIuKJsFwiLFwibmxlZnRhcnJvd1wiOlwi4oaaXCIsXCJuTGVmdGFycm93XCI6XCLih41cIixcIm5sZWZ0cmlnaHRhcnJvd1wiOlwi4oauXCIsXCJuTGVmdHJpZ2h0YXJyb3dcIjpcIuKHjlwiLFwibmxlcVwiOlwi4omwXCIsXCJubGVxcVwiOlwi4ommzLhcIixcIm5sZXFzbGFudFwiOlwi4qm9zLhcIixcIm5sZXNcIjpcIuKpvcy4XCIsXCJubGVzc1wiOlwi4omuXCIsXCJuTGxcIjpcIuKLmMy4XCIsXCJubHNpbVwiOlwi4om0XCIsXCJuTHRcIjpcIuKJquKDklwiLFwibmx0XCI6XCLiia5cIixcIm5sdHJpXCI6XCLii6pcIixcIm5sdHJpZVwiOlwi4ousXCIsXCJuTHR2XCI6XCLiiarMuFwiLFwibm1pZFwiOlwi4oikXCIsXCJOb0JyZWFrXCI6XCLigaBcIixcIk5vbkJyZWFraW5nU3BhY2VcIjpcIsKgXCIsXCJub3BmXCI6XCLwnZWfXCIsXCJOb3BmXCI6XCLihJVcIixcIk5vdFwiOlwi4qusXCIsXCJub3RcIjpcIsKsXCIsXCJOb3RDb25ncnVlbnRcIjpcIuKJolwiLFwiTm90Q3VwQ2FwXCI6XCLiia1cIixcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKZcIixcIk5vdEVsZW1lbnRcIjpcIuKIiVwiLFwiTm90RXF1YWxcIjpcIuKJoFwiLFwiTm90RXF1YWxUaWxkZVwiOlwi4omCzLhcIixcIk5vdEV4aXN0c1wiOlwi4oiEXCIsXCJOb3RHcmVhdGVyXCI6XCLiia9cIixcIk5vdEdyZWF0ZXJFcXVhbFwiOlwi4omxXCIsXCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiafMuFwiLFwiTm90R3JlYXRlckdyZWF0ZXJcIjpcIuKJq8y4XCIsXCJOb3RHcmVhdGVyTGVzc1wiOlwi4om5XCIsXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+zLhcIixcIk5vdEdyZWF0ZXJUaWxkZVwiOlwi4om1XCIsXCJOb3RIdW1wRG93bkh1bXBcIjpcIuKJjsy4XCIsXCJOb3RIdW1wRXF1YWxcIjpcIuKJj8y4XCIsXCJub3RpblwiOlwi4oiJXCIsXCJub3RpbmRvdFwiOlwi4ou1zLhcIixcIm5vdGluRVwiOlwi4ou5zLhcIixcIm5vdGludmFcIjpcIuKIiVwiLFwibm90aW52YlwiOlwi4ou3XCIsXCJub3RpbnZjXCI6XCLii7ZcIixcIk5vdExlZnRUcmlhbmdsZUJhclwiOlwi4qePzLhcIixcIk5vdExlZnRUcmlhbmdsZVwiOlwi4ouqXCIsXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4ousXCIsXCJOb3RMZXNzXCI6XCLiia5cIixcIk5vdExlc3NFcXVhbFwiOlwi4omwXCIsXCJOb3RMZXNzR3JlYXRlclwiOlwi4om4XCIsXCJOb3RMZXNzTGVzc1wiOlwi4omqzLhcIixcIk5vdExlc3NTbGFudEVxdWFsXCI6XCLiqb3MuFwiLFwiTm90TGVzc1RpbGRlXCI6XCLiibRcIixcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiqqLMuFwiLFwiTm90TmVzdGVkTGVzc0xlc3NcIjpcIuKqocy4XCIsXCJub3RuaVwiOlwi4oiMXCIsXCJub3RuaXZhXCI6XCLiiIxcIixcIm5vdG5pdmJcIjpcIuKLvlwiLFwibm90bml2Y1wiOlwi4ou9XCIsXCJOb3RQcmVjZWRlc1wiOlwi4oqAXCIsXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCLiqq/MuFwiLFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6XCLii6BcIixcIk5vdFJldmVyc2VFbGVtZW50XCI6XCLiiIxcIixcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkMy4XCIsXCJOb3RSaWdodFRyaWFuZ2xlXCI6XCLii6tcIixcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4outXCIsXCJOb3RTcXVhcmVTdWJzZXRcIjpcIuKKj8y4XCIsXCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4ouiXCIsXCJOb3RTcXVhcmVTdXBlcnNldFwiOlwi4oqQzLhcIixcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKLo1wiLFwiTm90U3Vic2V0XCI6XCLiioLig5JcIixcIk5vdFN1YnNldEVxdWFsXCI6XCLiiohcIixcIk5vdFN1Y2NlZWRzXCI6XCLiioFcIixcIk5vdFN1Y2NlZWRzRXF1YWxcIjpcIuKqsMy4XCIsXCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKLoVwiLFwiTm90U3VjY2VlZHNUaWxkZVwiOlwi4om/zLhcIixcIk5vdFN1cGVyc2V0XCI6XCLiioPig5JcIixcIk5vdFN1cGVyc2V0RXF1YWxcIjpcIuKKiVwiLFwiTm90VGlsZGVcIjpcIuKJgVwiLFwiTm90VGlsZGVFcXVhbFwiOlwi4omEXCIsXCJOb3RUaWxkZUZ1bGxFcXVhbFwiOlwi4omHXCIsXCJOb3RUaWxkZVRpbGRlXCI6XCLiiYlcIixcIk5vdFZlcnRpY2FsQmFyXCI6XCLiiKRcIixcIm5wYXJhbGxlbFwiOlwi4oimXCIsXCJucGFyXCI6XCLiiKZcIixcIm5wYXJzbFwiOlwi4qu94oOlXCIsXCJucGFydFwiOlwi4oiCzLhcIixcIm5wb2xpbnRcIjpcIuKolFwiLFwibnByXCI6XCLiioBcIixcIm5wcmN1ZVwiOlwi4ougXCIsXCJucHJlY1wiOlwi4oqAXCIsXCJucHJlY2VxXCI6XCLiqq/MuFwiLFwibnByZVwiOlwi4qqvzLhcIixcIm5yYXJyY1wiOlwi4qSzzLhcIixcIm5yYXJyXCI6XCLihptcIixcIm5yQXJyXCI6XCLih49cIixcIm5yYXJyd1wiOlwi4oadzLhcIixcIm5yaWdodGFycm93XCI6XCLihptcIixcIm5SaWdodGFycm93XCI6XCLih49cIixcIm5ydHJpXCI6XCLii6tcIixcIm5ydHJpZVwiOlwi4outXCIsXCJuc2NcIjpcIuKKgVwiLFwibnNjY3VlXCI6XCLii6FcIixcIm5zY2VcIjpcIuKqsMy4XCIsXCJOc2NyXCI6XCLwnZKpXCIsXCJuc2NyXCI6XCLwnZODXCIsXCJuc2hvcnRtaWRcIjpcIuKIpFwiLFwibnNob3J0cGFyYWxsZWxcIjpcIuKIplwiLFwibnNpbVwiOlwi4omBXCIsXCJuc2ltZVwiOlwi4omEXCIsXCJuc2ltZXFcIjpcIuKJhFwiLFwibnNtaWRcIjpcIuKIpFwiLFwibnNwYXJcIjpcIuKIplwiLFwibnNxc3ViZVwiOlwi4ouiXCIsXCJuc3FzdXBlXCI6XCLii6NcIixcIm5zdWJcIjpcIuKKhFwiLFwibnN1YkVcIjpcIuKrhcy4XCIsXCJuc3ViZVwiOlwi4oqIXCIsXCJuc3Vic2V0XCI6XCLiioLig5JcIixcIm5zdWJzZXRlcVwiOlwi4oqIXCIsXCJuc3Vic2V0ZXFxXCI6XCLiq4XMuFwiLFwibnN1Y2NcIjpcIuKKgVwiLFwibnN1Y2NlcVwiOlwi4qqwzLhcIixcIm5zdXBcIjpcIuKKhVwiLFwibnN1cEVcIjpcIuKrhsy4XCIsXCJuc3VwZVwiOlwi4oqJXCIsXCJuc3Vwc2V0XCI6XCLiioPig5JcIixcIm5zdXBzZXRlcVwiOlwi4oqJXCIsXCJuc3Vwc2V0ZXFxXCI6XCLiq4bMuFwiLFwibnRnbFwiOlwi4om5XCIsXCJOdGlsZGVcIjpcIsORXCIsXCJudGlsZGVcIjpcIsOxXCIsXCJudGxnXCI6XCLiibhcIixcIm50cmlhbmdsZWxlZnRcIjpcIuKLqlwiLFwibnRyaWFuZ2xlbGVmdGVxXCI6XCLii6xcIixcIm50cmlhbmdsZXJpZ2h0XCI6XCLii6tcIixcIm50cmlhbmdsZXJpZ2h0ZXFcIjpcIuKLrVwiLFwiTnVcIjpcIs6dXCIsXCJudVwiOlwizr1cIixcIm51bVwiOlwiI1wiLFwibnVtZXJvXCI6XCLihJZcIixcIm51bXNwXCI6XCLigIdcIixcIm52YXBcIjpcIuKJjeKDklwiLFwibnZkYXNoXCI6XCLiiqxcIixcIm52RGFzaFwiOlwi4oqtXCIsXCJuVmRhc2hcIjpcIuKKrlwiLFwiblZEYXNoXCI6XCLiiq9cIixcIm52Z2VcIjpcIuKJpeKDklwiLFwibnZndFwiOlwiPuKDklwiLFwibnZIYXJyXCI6XCLipIRcIixcIm52aW5maW5cIjpcIuKnnlwiLFwibnZsQXJyXCI6XCLipIJcIixcIm52bGVcIjpcIuKJpOKDklwiLFwibnZsdFwiOlwiPOKDklwiLFwibnZsdHJpZVwiOlwi4oq04oOSXCIsXCJudnJBcnJcIjpcIuKkg1wiLFwibnZydHJpZVwiOlwi4oq14oOSXCIsXCJudnNpbVwiOlwi4oi84oOSXCIsXCJud2FyaGtcIjpcIuKko1wiLFwibndhcnJcIjpcIuKGllwiLFwibndBcnJcIjpcIuKHllwiLFwibndhcnJvd1wiOlwi4oaWXCIsXCJud25lYXJcIjpcIuKkp1wiLFwiT2FjdXRlXCI6XCLDk1wiLFwib2FjdXRlXCI6XCLDs1wiLFwib2FzdFwiOlwi4oqbXCIsXCJPY2lyY1wiOlwiw5RcIixcIm9jaXJjXCI6XCLDtFwiLFwib2NpclwiOlwi4oqaXCIsXCJPY3lcIjpcItCeXCIsXCJvY3lcIjpcItC+XCIsXCJvZGFzaFwiOlwi4oqdXCIsXCJPZGJsYWNcIjpcIsWQXCIsXCJvZGJsYWNcIjpcIsWRXCIsXCJvZGl2XCI6XCLiqLhcIixcIm9kb3RcIjpcIuKKmVwiLFwib2Rzb2xkXCI6XCLiprxcIixcIk9FbGlnXCI6XCLFklwiLFwib2VsaWdcIjpcIsWTXCIsXCJvZmNpclwiOlwi4qa/XCIsXCJPZnJcIjpcIvCdlJJcIixcIm9mclwiOlwi8J2UrFwiLFwib2dvblwiOlwiy5tcIixcIk9ncmF2ZVwiOlwiw5JcIixcIm9ncmF2ZVwiOlwiw7JcIixcIm9ndFwiOlwi4qeBXCIsXCJvaGJhclwiOlwi4qa1XCIsXCJvaG1cIjpcIs6pXCIsXCJvaW50XCI6XCLiiK5cIixcIm9sYXJyXCI6XCLihrpcIixcIm9sY2lyXCI6XCLipr5cIixcIm9sY3Jvc3NcIjpcIuKmu1wiLFwib2xpbmVcIjpcIuKAvlwiLFwib2x0XCI6XCLip4BcIixcIk9tYWNyXCI6XCLFjFwiLFwib21hY3JcIjpcIsWNXCIsXCJPbWVnYVwiOlwizqlcIixcIm9tZWdhXCI6XCLPiVwiLFwiT21pY3JvblwiOlwizp9cIixcIm9taWNyb25cIjpcIs6/XCIsXCJvbWlkXCI6XCLiprZcIixcIm9taW51c1wiOlwi4oqWXCIsXCJPb3BmXCI6XCLwnZWGXCIsXCJvb3BmXCI6XCLwnZWgXCIsXCJvcGFyXCI6XCLiprdcIixcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6XCLigJxcIixcIk9wZW5DdXJseVF1b3RlXCI6XCLigJhcIixcIm9wZXJwXCI6XCLiprlcIixcIm9wbHVzXCI6XCLiipVcIixcIm9yYXJyXCI6XCLihrtcIixcIk9yXCI6XCLiqZRcIixcIm9yXCI6XCLiiKhcIixcIm9yZFwiOlwi4qmdXCIsXCJvcmRlclwiOlwi4oS0XCIsXCJvcmRlcm9mXCI6XCLihLRcIixcIm9yZGZcIjpcIsKqXCIsXCJvcmRtXCI6XCLCulwiLFwib3JpZ29mXCI6XCLiirZcIixcIm9yb3JcIjpcIuKpllwiLFwib3JzbG9wZVwiOlwi4qmXXCIsXCJvcnZcIjpcIuKpm1wiLFwib1NcIjpcIuKTiFwiLFwiT3NjclwiOlwi8J2SqlwiLFwib3NjclwiOlwi4oS0XCIsXCJPc2xhc2hcIjpcIsOYXCIsXCJvc2xhc2hcIjpcIsO4XCIsXCJvc29sXCI6XCLiiphcIixcIk90aWxkZVwiOlwiw5VcIixcIm90aWxkZVwiOlwiw7VcIixcIm90aW1lc2FzXCI6XCLiqLZcIixcIk90aW1lc1wiOlwi4qi3XCIsXCJvdGltZXNcIjpcIuKKl1wiLFwiT3VtbFwiOlwiw5ZcIixcIm91bWxcIjpcIsO2XCIsXCJvdmJhclwiOlwi4oy9XCIsXCJPdmVyQmFyXCI6XCLigL5cIixcIk92ZXJCcmFjZVwiOlwi4o+eXCIsXCJPdmVyQnJhY2tldFwiOlwi4o60XCIsXCJPdmVyUGFyZW50aGVzaXNcIjpcIuKPnFwiLFwicGFyYVwiOlwiwrZcIixcInBhcmFsbGVsXCI6XCLiiKVcIixcInBhclwiOlwi4oilXCIsXCJwYXJzaW1cIjpcIuKrs1wiLFwicGFyc2xcIjpcIuKrvVwiLFwicGFydFwiOlwi4oiCXCIsXCJQYXJ0aWFsRFwiOlwi4oiCXCIsXCJQY3lcIjpcItCfXCIsXCJwY3lcIjpcItC/XCIsXCJwZXJjbnRcIjpcIiVcIixcInBlcmlvZFwiOlwiLlwiLFwicGVybWlsXCI6XCLigLBcIixcInBlcnBcIjpcIuKKpVwiLFwicGVydGVua1wiOlwi4oCxXCIsXCJQZnJcIjpcIvCdlJNcIixcInBmclwiOlwi8J2UrVwiLFwiUGhpXCI6XCLOplwiLFwicGhpXCI6XCLPhlwiLFwicGhpdlwiOlwiz5VcIixcInBobW1hdFwiOlwi4oSzXCIsXCJwaG9uZVwiOlwi4piOXCIsXCJQaVwiOlwizqBcIixcInBpXCI6XCLPgFwiLFwicGl0Y2hmb3JrXCI6XCLii5RcIixcInBpdlwiOlwiz5ZcIixcInBsYW5ja1wiOlwi4oSPXCIsXCJwbGFuY2toXCI6XCLihI5cIixcInBsYW5rdlwiOlwi4oSPXCIsXCJwbHVzYWNpclwiOlwi4qijXCIsXCJwbHVzYlwiOlwi4oqeXCIsXCJwbHVzY2lyXCI6XCLiqKJcIixcInBsdXNcIjpcIitcIixcInBsdXNkb1wiOlwi4oiUXCIsXCJwbHVzZHVcIjpcIuKopVwiLFwicGx1c2VcIjpcIuKpslwiLFwiUGx1c01pbnVzXCI6XCLCsVwiLFwicGx1c21uXCI6XCLCsVwiLFwicGx1c3NpbVwiOlwi4qimXCIsXCJwbHVzdHdvXCI6XCLiqKdcIixcInBtXCI6XCLCsVwiLFwiUG9pbmNhcmVwbGFuZVwiOlwi4oSMXCIsXCJwb2ludGludFwiOlwi4qiVXCIsXCJwb3BmXCI6XCLwnZWhXCIsXCJQb3BmXCI6XCLihJlcIixcInBvdW5kXCI6XCLCo1wiLFwicHJhcFwiOlwi4qq3XCIsXCJQclwiOlwi4qq7XCIsXCJwclwiOlwi4om6XCIsXCJwcmN1ZVwiOlwi4om8XCIsXCJwcmVjYXBwcm94XCI6XCLiqrdcIixcInByZWNcIjpcIuKJulwiLFwicHJlY2N1cmx5ZXFcIjpcIuKJvFwiLFwiUHJlY2VkZXNcIjpcIuKJulwiLFwiUHJlY2VkZXNFcXVhbFwiOlwi4qqvXCIsXCJQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKJvFwiLFwiUHJlY2VkZXNUaWxkZVwiOlwi4om+XCIsXCJwcmVjZXFcIjpcIuKqr1wiLFwicHJlY25hcHByb3hcIjpcIuKquVwiLFwicHJlY25lcXFcIjpcIuKqtVwiLFwicHJlY25zaW1cIjpcIuKLqFwiLFwicHJlXCI6XCLiqq9cIixcInByRVwiOlwi4qqzXCIsXCJwcmVjc2ltXCI6XCLiib5cIixcInByaW1lXCI6XCLigLJcIixcIlByaW1lXCI6XCLigLNcIixcInByaW1lc1wiOlwi4oSZXCIsXCJwcm5hcFwiOlwi4qq5XCIsXCJwcm5FXCI6XCLiqrVcIixcInBybnNpbVwiOlwi4ouoXCIsXCJwcm9kXCI6XCLiiI9cIixcIlByb2R1Y3RcIjpcIuKIj1wiLFwicHJvZmFsYXJcIjpcIuKMrlwiLFwicHJvZmxpbmVcIjpcIuKMklwiLFwicHJvZnN1cmZcIjpcIuKMk1wiLFwicHJvcFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uYWxcIjpcIuKInVwiLFwiUHJvcG9ydGlvblwiOlwi4oi3XCIsXCJwcm9wdG9cIjpcIuKInVwiLFwicHJzaW1cIjpcIuKJvlwiLFwicHJ1cmVsXCI6XCLiirBcIixcIlBzY3JcIjpcIvCdkqtcIixcInBzY3JcIjpcIvCdk4VcIixcIlBzaVwiOlwizqhcIixcInBzaVwiOlwiz4hcIixcInB1bmNzcFwiOlwi4oCIXCIsXCJRZnJcIjpcIvCdlJRcIixcInFmclwiOlwi8J2UrlwiLFwicWludFwiOlwi4qiMXCIsXCJxb3BmXCI6XCLwnZWiXCIsXCJRb3BmXCI6XCLihJpcIixcInFwcmltZVwiOlwi4oGXXCIsXCJRc2NyXCI6XCLwnZKsXCIsXCJxc2NyXCI6XCLwnZOGXCIsXCJxdWF0ZXJuaW9uc1wiOlwi4oSNXCIsXCJxdWF0aW50XCI6XCLiqJZcIixcInF1ZXN0XCI6XCI/XCIsXCJxdWVzdGVxXCI6XCLiiZ9cIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJBYXJyXCI6XCLih5tcIixcInJhY2VcIjpcIuKIvcyxXCIsXCJSYWN1dGVcIjpcIsWUXCIsXCJyYWN1dGVcIjpcIsWVXCIsXCJyYWRpY1wiOlwi4oiaXCIsXCJyYWVtcHR5dlwiOlwi4qazXCIsXCJyYW5nXCI6XCLin6lcIixcIlJhbmdcIjpcIuKfq1wiLFwicmFuZ2RcIjpcIuKmklwiLFwicmFuZ2VcIjpcIuKmpVwiLFwicmFuZ2xlXCI6XCLin6lcIixcInJhcXVvXCI6XCLCu1wiLFwicmFycmFwXCI6XCLipbVcIixcInJhcnJiXCI6XCLih6VcIixcInJhcnJiZnNcIjpcIuKkoFwiLFwicmFycmNcIjpcIuKks1wiLFwicmFyclwiOlwi4oaSXCIsXCJSYXJyXCI6XCLihqBcIixcInJBcnJcIjpcIuKHklwiLFwicmFycmZzXCI6XCLipJ5cIixcInJhcnJoa1wiOlwi4oaqXCIsXCJyYXJybHBcIjpcIuKGrFwiLFwicmFycnBsXCI6XCLipYVcIixcInJhcnJzaW1cIjpcIuKltFwiLFwiUmFycnRsXCI6XCLipJZcIixcInJhcnJ0bFwiOlwi4oajXCIsXCJyYXJyd1wiOlwi4oadXCIsXCJyYXRhaWxcIjpcIuKkmlwiLFwickF0YWlsXCI6XCLipJxcIixcInJhdGlvXCI6XCLiiLZcIixcInJhdGlvbmFsc1wiOlwi4oSaXCIsXCJyYmFyclwiOlwi4qSNXCIsXCJyQmFyclwiOlwi4qSPXCIsXCJSQmFyclwiOlwi4qSQXCIsXCJyYmJya1wiOlwi4p2zXCIsXCJyYnJhY2VcIjpcIn1cIixcInJicmFja1wiOlwiXVwiLFwicmJya2VcIjpcIuKmjFwiLFwicmJya3NsZFwiOlwi4qaOXCIsXCJyYnJrc2x1XCI6XCLippBcIixcIlJjYXJvblwiOlwixZhcIixcInJjYXJvblwiOlwixZlcIixcIlJjZWRpbFwiOlwixZZcIixcInJjZWRpbFwiOlwixZdcIixcInJjZWlsXCI6XCLijIlcIixcInJjdWJcIjpcIn1cIixcIlJjeVwiOlwi0KBcIixcInJjeVwiOlwi0YBcIixcInJkY2FcIjpcIuKkt1wiLFwicmRsZGhhclwiOlwi4qWpXCIsXCJyZHF1b1wiOlwi4oCdXCIsXCJyZHF1b3JcIjpcIuKAnVwiLFwicmRzaFwiOlwi4oazXCIsXCJyZWFsXCI6XCLihJxcIixcInJlYWxpbmVcIjpcIuKEm1wiLFwicmVhbHBhcnRcIjpcIuKEnFwiLFwicmVhbHNcIjpcIuKEnVwiLFwiUmVcIjpcIuKEnFwiLFwicmVjdFwiOlwi4patXCIsXCJyZWdcIjpcIsKuXCIsXCJSRUdcIjpcIsKuXCIsXCJSZXZlcnNlRWxlbWVudFwiOlwi4oiLXCIsXCJSZXZlcnNlRXF1aWxpYnJpdW1cIjpcIuKHi1wiLFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjpcIuKlr1wiLFwicmZpc2h0XCI6XCLipb1cIixcInJmbG9vclwiOlwi4oyLXCIsXCJyZnJcIjpcIvCdlK9cIixcIlJmclwiOlwi4oScXCIsXCJySGFyXCI6XCLipaRcIixcInJoYXJkXCI6XCLih4FcIixcInJoYXJ1XCI6XCLih4BcIixcInJoYXJ1bFwiOlwi4qWsXCIsXCJSaG9cIjpcIs6hXCIsXCJyaG9cIjpcIs+BXCIsXCJyaG92XCI6XCLPsVwiLFwiUmlnaHRBbmdsZUJyYWNrZXRcIjpcIuKfqVwiLFwiUmlnaHRBcnJvd0JhclwiOlwi4oelXCIsXCJyaWdodGFycm93XCI6XCLihpJcIixcIlJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiUmlnaHRhcnJvd1wiOlwi4oeSXCIsXCJSaWdodEFycm93TGVmdEFycm93XCI6XCLih4RcIixcInJpZ2h0YXJyb3d0YWlsXCI6XCLihqNcIixcIlJpZ2h0Q2VpbGluZ1wiOlwi4oyJXCIsXCJSaWdodERvdWJsZUJyYWNrZXRcIjpcIuKfp1wiLFwiUmlnaHREb3duVGVlVmVjdG9yXCI6XCLipZ1cIixcIlJpZ2h0RG93blZlY3RvckJhclwiOlwi4qWVXCIsXCJSaWdodERvd25WZWN0b3JcIjpcIuKHglwiLFwiUmlnaHRGbG9vclwiOlwi4oyLXCIsXCJyaWdodGhhcnBvb25kb3duXCI6XCLih4FcIixcInJpZ2h0aGFycG9vbnVwXCI6XCLih4BcIixcInJpZ2h0bGVmdGFycm93c1wiOlwi4oeEXCIsXCJyaWdodGxlZnRoYXJwb29uc1wiOlwi4oeMXCIsXCJyaWdodHJpZ2h0YXJyb3dzXCI6XCLih4lcIixcInJpZ2h0c3F1aWdhcnJvd1wiOlwi4oadXCIsXCJSaWdodFRlZUFycm93XCI6XCLihqZcIixcIlJpZ2h0VGVlXCI6XCLiiqJcIixcIlJpZ2h0VGVlVmVjdG9yXCI6XCLipZtcIixcInJpZ2h0dGhyZWV0aW1lc1wiOlwi4ouMXCIsXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5BcIixcIlJpZ2h0VHJpYW5nbGVcIjpcIuKKs1wiLFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLiirVcIixcIlJpZ2h0VXBEb3duVmVjdG9yXCI6XCLipY9cIixcIlJpZ2h0VXBUZWVWZWN0b3JcIjpcIuKlnFwiLFwiUmlnaHRVcFZlY3RvckJhclwiOlwi4qWUXCIsXCJSaWdodFVwVmVjdG9yXCI6XCLihr5cIixcIlJpZ2h0VmVjdG9yQmFyXCI6XCLipZNcIixcIlJpZ2h0VmVjdG9yXCI6XCLih4BcIixcInJpbmdcIjpcIsuaXCIsXCJyaXNpbmdkb3RzZXFcIjpcIuKJk1wiLFwicmxhcnJcIjpcIuKHhFwiLFwicmxoYXJcIjpcIuKHjFwiLFwicmxtXCI6XCLigI9cIixcInJtb3VzdGFjaGVcIjpcIuKOsVwiLFwicm1vdXN0XCI6XCLijrFcIixcInJubWlkXCI6XCLiq65cIixcInJvYW5nXCI6XCLin61cIixcInJvYXJyXCI6XCLih75cIixcInJvYnJrXCI6XCLin6dcIixcInJvcGFyXCI6XCLipoZcIixcInJvcGZcIjpcIvCdlaNcIixcIlJvcGZcIjpcIuKEnVwiLFwicm9wbHVzXCI6XCLiqK5cIixcInJvdGltZXNcIjpcIuKotVwiLFwiUm91bmRJbXBsaWVzXCI6XCLipbBcIixcInJwYXJcIjpcIilcIixcInJwYXJndFwiOlwi4qaUXCIsXCJycHBvbGludFwiOlwi4qiSXCIsXCJycmFyclwiOlwi4oeJXCIsXCJScmlnaHRhcnJvd1wiOlwi4oebXCIsXCJyc2FxdW9cIjpcIuKAulwiLFwicnNjclwiOlwi8J2Th1wiLFwiUnNjclwiOlwi4oSbXCIsXCJyc2hcIjpcIuKGsVwiLFwiUnNoXCI6XCLihrFcIixcInJzcWJcIjpcIl1cIixcInJzcXVvXCI6XCLigJlcIixcInJzcXVvclwiOlwi4oCZXCIsXCJydGhyZWVcIjpcIuKLjFwiLFwicnRpbWVzXCI6XCLii4pcIixcInJ0cmlcIjpcIuKWuVwiLFwicnRyaWVcIjpcIuKKtVwiLFwicnRyaWZcIjpcIuKWuFwiLFwicnRyaWx0cmlcIjpcIuKnjlwiLFwiUnVsZURlbGF5ZWRcIjpcIuKntFwiLFwicnVsdWhhclwiOlwi4qWoXCIsXCJyeFwiOlwi4oSeXCIsXCJTYWN1dGVcIjpcIsWaXCIsXCJzYWN1dGVcIjpcIsWbXCIsXCJzYnF1b1wiOlwi4oCaXCIsXCJzY2FwXCI6XCLiqrhcIixcIlNjYXJvblwiOlwixaBcIixcInNjYXJvblwiOlwixaFcIixcIlNjXCI6XCLiqrxcIixcInNjXCI6XCLiibtcIixcInNjY3VlXCI6XCLiib1cIixcInNjZVwiOlwi4qqwXCIsXCJzY0VcIjpcIuKqtFwiLFwiU2NlZGlsXCI6XCLFnlwiLFwic2NlZGlsXCI6XCLFn1wiLFwiU2NpcmNcIjpcIsWcXCIsXCJzY2lyY1wiOlwixZ1cIixcInNjbmFwXCI6XCLiqrpcIixcInNjbkVcIjpcIuKqtlwiLFwic2Nuc2ltXCI6XCLii6lcIixcInNjcG9saW50XCI6XCLiqJNcIixcInNjc2ltXCI6XCLiib9cIixcIlNjeVwiOlwi0KFcIixcInNjeVwiOlwi0YFcIixcInNkb3RiXCI6XCLiiqFcIixcInNkb3RcIjpcIuKLhVwiLFwic2RvdGVcIjpcIuKpplwiLFwic2VhcmhrXCI6XCLipKVcIixcInNlYXJyXCI6XCLihphcIixcInNlQXJyXCI6XCLih5hcIixcInNlYXJyb3dcIjpcIuKGmFwiLFwic2VjdFwiOlwiwqdcIixcInNlbWlcIjpcIjtcIixcInNlc3dhclwiOlwi4qSpXCIsXCJzZXRtaW51c1wiOlwi4oiWXCIsXCJzZXRtblwiOlwi4oiWXCIsXCJzZXh0XCI6XCLinLZcIixcIlNmclwiOlwi8J2UllwiLFwic2ZyXCI6XCLwnZSwXCIsXCJzZnJvd25cIjpcIuKMolwiLFwic2hhcnBcIjpcIuKZr1wiLFwiU0hDSGN5XCI6XCLQqVwiLFwic2hjaGN5XCI6XCLRiVwiLFwiU0hjeVwiOlwi0KhcIixcInNoY3lcIjpcItGIXCIsXCJTaG9ydERvd25BcnJvd1wiOlwi4oaTXCIsXCJTaG9ydExlZnRBcnJvd1wiOlwi4oaQXCIsXCJzaG9ydG1pZFwiOlwi4oijXCIsXCJzaG9ydHBhcmFsbGVsXCI6XCLiiKVcIixcIlNob3J0UmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJTaG9ydFVwQXJyb3dcIjpcIuKGkVwiLFwic2h5XCI6XCLCrVwiLFwiU2lnbWFcIjpcIs6jXCIsXCJzaWdtYVwiOlwiz4NcIixcInNpZ21hZlwiOlwiz4JcIixcInNpZ21hdlwiOlwiz4JcIixcInNpbVwiOlwi4oi8XCIsXCJzaW1kb3RcIjpcIuKpqlwiLFwic2ltZVwiOlwi4omDXCIsXCJzaW1lcVwiOlwi4omDXCIsXCJzaW1nXCI6XCLiqp5cIixcInNpbWdFXCI6XCLiqqBcIixcInNpbWxcIjpcIuKqnVwiLFwic2ltbEVcIjpcIuKqn1wiLFwic2ltbmVcIjpcIuKJhlwiLFwic2ltcGx1c1wiOlwi4qikXCIsXCJzaW1yYXJyXCI6XCLipbJcIixcInNsYXJyXCI6XCLihpBcIixcIlNtYWxsQ2lyY2xlXCI6XCLiiJhcIixcInNtYWxsc2V0bWludXNcIjpcIuKIllwiLFwic21hc2hwXCI6XCLiqLNcIixcInNtZXBhcnNsXCI6XCLip6RcIixcInNtaWRcIjpcIuKIo1wiLFwic21pbGVcIjpcIuKMo1wiLFwic210XCI6XCLiqqpcIixcInNtdGVcIjpcIuKqrFwiLFwic210ZXNcIjpcIuKqrO+4gFwiLFwiU09GVGN5XCI6XCLQrFwiLFwic29mdGN5XCI6XCLRjFwiLFwic29sYmFyXCI6XCLijL9cIixcInNvbGJcIjpcIuKnhFwiLFwic29sXCI6XCIvXCIsXCJTb3BmXCI6XCLwnZWKXCIsXCJzb3BmXCI6XCLwnZWkXCIsXCJzcGFkZXNcIjpcIuKZoFwiLFwic3BhZGVzdWl0XCI6XCLimaBcIixcInNwYXJcIjpcIuKIpVwiLFwic3FjYXBcIjpcIuKKk1wiLFwic3FjYXBzXCI6XCLiipPvuIBcIixcInNxY3VwXCI6XCLiipRcIixcInNxY3Vwc1wiOlwi4oqU77iAXCIsXCJTcXJ0XCI6XCLiiJpcIixcInNxc3ViXCI6XCLiio9cIixcInNxc3ViZVwiOlwi4oqRXCIsXCJzcXN1YnNldFwiOlwi4oqPXCIsXCJzcXN1YnNldGVxXCI6XCLiipFcIixcInNxc3VwXCI6XCLiipBcIixcInNxc3VwZVwiOlwi4oqSXCIsXCJzcXN1cHNldFwiOlwi4oqQXCIsXCJzcXN1cHNldGVxXCI6XCLiipJcIixcInNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlSW50ZXJzZWN0aW9uXCI6XCLiipNcIixcIlNxdWFyZVN1YnNldFwiOlwi4oqPXCIsXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4oqRXCIsXCJTcXVhcmVTdXBlcnNldFwiOlwi4oqQXCIsXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLiipJcIixcIlNxdWFyZVVuaW9uXCI6XCLiipRcIixcInNxdWFyZlwiOlwi4paqXCIsXCJzcXVcIjpcIuKWoVwiLFwic3F1ZlwiOlwi4paqXCIsXCJzcmFyclwiOlwi4oaSXCIsXCJTc2NyXCI6XCLwnZKuXCIsXCJzc2NyXCI6XCLwnZOIXCIsXCJzc2V0bW5cIjpcIuKIllwiLFwic3NtaWxlXCI6XCLijKNcIixcInNzdGFyZlwiOlwi4ouGXCIsXCJTdGFyXCI6XCLii4ZcIixcInN0YXJcIjpcIuKYhlwiLFwic3RhcmZcIjpcIuKYhVwiLFwic3RyYWlnaHRlcHNpbG9uXCI6XCLPtVwiLFwic3RyYWlnaHRwaGlcIjpcIs+VXCIsXCJzdHJuc1wiOlwiwq9cIixcInN1YlwiOlwi4oqCXCIsXCJTdWJcIjpcIuKLkFwiLFwic3ViZG90XCI6XCLiqr1cIixcInN1YkVcIjpcIuKrhVwiLFwic3ViZVwiOlwi4oqGXCIsXCJzdWJlZG90XCI6XCLiq4NcIixcInN1Ym11bHRcIjpcIuKrgVwiLFwic3VibkVcIjpcIuKri1wiLFwic3VibmVcIjpcIuKKilwiLFwic3VicGx1c1wiOlwi4qq/XCIsXCJzdWJyYXJyXCI6XCLipblcIixcInN1YnNldFwiOlwi4oqCXCIsXCJTdWJzZXRcIjpcIuKLkFwiLFwic3Vic2V0ZXFcIjpcIuKKhlwiLFwic3Vic2V0ZXFxXCI6XCLiq4VcIixcIlN1YnNldEVxdWFsXCI6XCLiioZcIixcInN1YnNldG5lcVwiOlwi4oqKXCIsXCJzdWJzZXRuZXFxXCI6XCLiq4tcIixcInN1YnNpbVwiOlwi4quHXCIsXCJzdWJzdWJcIjpcIuKrlVwiLFwic3Vic3VwXCI6XCLiq5NcIixcInN1Y2NhcHByb3hcIjpcIuKquFwiLFwic3VjY1wiOlwi4om7XCIsXCJzdWNjY3VybHllcVwiOlwi4om9XCIsXCJTdWNjZWVkc1wiOlwi4om7XCIsXCJTdWNjZWVkc0VxdWFsXCI6XCLiqrBcIixcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4om9XCIsXCJTdWNjZWVkc1RpbGRlXCI6XCLiib9cIixcInN1Y2NlcVwiOlwi4qqwXCIsXCJzdWNjbmFwcHJveFwiOlwi4qq6XCIsXCJzdWNjbmVxcVwiOlwi4qq2XCIsXCJzdWNjbnNpbVwiOlwi4oupXCIsXCJzdWNjc2ltXCI6XCLiib9cIixcIlN1Y2hUaGF0XCI6XCLiiItcIixcInN1bVwiOlwi4oiRXCIsXCJTdW1cIjpcIuKIkVwiLFwic3VuZ1wiOlwi4pmqXCIsXCJzdXAxXCI6XCLCuVwiLFwic3VwMlwiOlwiwrJcIixcInN1cDNcIjpcIsKzXCIsXCJzdXBcIjpcIuKKg1wiLFwiU3VwXCI6XCLii5FcIixcInN1cGRvdFwiOlwi4qq+XCIsXCJzdXBkc3ViXCI6XCLiq5hcIixcInN1cEVcIjpcIuKrhlwiLFwic3VwZVwiOlwi4oqHXCIsXCJzdXBlZG90XCI6XCLiq4RcIixcIlN1cGVyc2V0XCI6XCLiioNcIixcIlN1cGVyc2V0RXF1YWxcIjpcIuKKh1wiLFwic3VwaHNvbFwiOlwi4p+JXCIsXCJzdXBoc3ViXCI6XCLiq5dcIixcInN1cGxhcnJcIjpcIuKlu1wiLFwic3VwbXVsdFwiOlwi4quCXCIsXCJzdXBuRVwiOlwi4quMXCIsXCJzdXBuZVwiOlwi4oqLXCIsXCJzdXBwbHVzXCI6XCLiq4BcIixcInN1cHNldFwiOlwi4oqDXCIsXCJTdXBzZXRcIjpcIuKLkVwiLFwic3Vwc2V0ZXFcIjpcIuKKh1wiLFwic3Vwc2V0ZXFxXCI6XCLiq4ZcIixcInN1cHNldG5lcVwiOlwi4oqLXCIsXCJzdXBzZXRuZXFxXCI6XCLiq4xcIixcInN1cHNpbVwiOlwi4quIXCIsXCJzdXBzdWJcIjpcIuKrlFwiLFwic3Vwc3VwXCI6XCLiq5ZcIixcInN3YXJoa1wiOlwi4qSmXCIsXCJzd2FyclwiOlwi4oaZXCIsXCJzd0FyclwiOlwi4oeZXCIsXCJzd2Fycm93XCI6XCLihplcIixcInN3bndhclwiOlwi4qSqXCIsXCJzemxpZ1wiOlwiw59cIixcIlRhYlwiOlwiXFx0XCIsXCJ0YXJnZXRcIjpcIuKMllwiLFwiVGF1XCI6XCLOpFwiLFwidGF1XCI6XCLPhFwiLFwidGJya1wiOlwi4o60XCIsXCJUY2Fyb25cIjpcIsWkXCIsXCJ0Y2Fyb25cIjpcIsWlXCIsXCJUY2VkaWxcIjpcIsWiXCIsXCJ0Y2VkaWxcIjpcIsWjXCIsXCJUY3lcIjpcItCiXCIsXCJ0Y3lcIjpcItGCXCIsXCJ0ZG90XCI6XCLig5tcIixcInRlbHJlY1wiOlwi4oyVXCIsXCJUZnJcIjpcIvCdlJdcIixcInRmclwiOlwi8J2UsVwiLFwidGhlcmU0XCI6XCLiiLRcIixcInRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGVyZWZvcmVcIjpcIuKItFwiLFwiVGhldGFcIjpcIs6YXCIsXCJ0aGV0YVwiOlwizrhcIixcInRoZXRhc3ltXCI6XCLPkVwiLFwidGhldGF2XCI6XCLPkVwiLFwidGhpY2thcHByb3hcIjpcIuKJiFwiLFwidGhpY2tzaW1cIjpcIuKIvFwiLFwiVGhpY2tTcGFjZVwiOlwi4oGf4oCKXCIsXCJUaGluU3BhY2VcIjpcIuKAiVwiLFwidGhpbnNwXCI6XCLigIlcIixcInRoa2FwXCI6XCLiiYhcIixcInRoa3NpbVwiOlwi4oi8XCIsXCJUSE9STlwiOlwiw55cIixcInRob3JuXCI6XCLDvlwiLFwidGlsZGVcIjpcIsucXCIsXCJUaWxkZVwiOlwi4oi8XCIsXCJUaWxkZUVxdWFsXCI6XCLiiYNcIixcIlRpbGRlRnVsbEVxdWFsXCI6XCLiiYVcIixcIlRpbGRlVGlsZGVcIjpcIuKJiFwiLFwidGltZXNiYXJcIjpcIuKosVwiLFwidGltZXNiXCI6XCLiiqBcIixcInRpbWVzXCI6XCLDl1wiLFwidGltZXNkXCI6XCLiqLBcIixcInRpbnRcIjpcIuKIrVwiLFwidG9lYVwiOlwi4qSoXCIsXCJ0b3Bib3RcIjpcIuKMtlwiLFwidG9wY2lyXCI6XCLiq7FcIixcInRvcFwiOlwi4oqkXCIsXCJUb3BmXCI6XCLwnZWLXCIsXCJ0b3BmXCI6XCLwnZWlXCIsXCJ0b3Bmb3JrXCI6XCLiq5pcIixcInRvc2FcIjpcIuKkqVwiLFwidHByaW1lXCI6XCLigLRcIixcInRyYWRlXCI6XCLihKJcIixcIlRSQURFXCI6XCLihKJcIixcInRyaWFuZ2xlXCI6XCLilrVcIixcInRyaWFuZ2xlZG93blwiOlwi4pa/XCIsXCJ0cmlhbmdsZWxlZnRcIjpcIuKXg1wiLFwidHJpYW5nbGVsZWZ0ZXFcIjpcIuKKtFwiLFwidHJpYW5nbGVxXCI6XCLiiZxcIixcInRyaWFuZ2xlcmlnaHRcIjpcIuKWuVwiLFwidHJpYW5nbGVyaWdodGVxXCI6XCLiirVcIixcInRyaWRvdFwiOlwi4pesXCIsXCJ0cmllXCI6XCLiiZxcIixcInRyaW1pbnVzXCI6XCLiqLpcIixcIlRyaXBsZURvdFwiOlwi4oObXCIsXCJ0cmlwbHVzXCI6XCLiqLlcIixcInRyaXNiXCI6XCLip41cIixcInRyaXRpbWVcIjpcIuKou1wiLFwidHJwZXppdW1cIjpcIuKPolwiLFwiVHNjclwiOlwi8J2Sr1wiLFwidHNjclwiOlwi8J2TiVwiLFwiVFNjeVwiOlwi0KZcIixcInRzY3lcIjpcItGGXCIsXCJUU0hjeVwiOlwi0ItcIixcInRzaGN5XCI6XCLRm1wiLFwiVHN0cm9rXCI6XCLFplwiLFwidHN0cm9rXCI6XCLFp1wiLFwidHdpeHRcIjpcIuKJrFwiLFwidHdvaGVhZGxlZnRhcnJvd1wiOlwi4oaeXCIsXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwi4oagXCIsXCJVYWN1dGVcIjpcIsOaXCIsXCJ1YWN1dGVcIjpcIsO6XCIsXCJ1YXJyXCI6XCLihpFcIixcIlVhcnJcIjpcIuKGn1wiLFwidUFyclwiOlwi4oeRXCIsXCJVYXJyb2NpclwiOlwi4qWJXCIsXCJVYnJjeVwiOlwi0I5cIixcInVicmN5XCI6XCLRnlwiLFwiVWJyZXZlXCI6XCLFrFwiLFwidWJyZXZlXCI6XCLFrVwiLFwiVWNpcmNcIjpcIsObXCIsXCJ1Y2lyY1wiOlwiw7tcIixcIlVjeVwiOlwi0KNcIixcInVjeVwiOlwi0YNcIixcInVkYXJyXCI6XCLih4VcIixcIlVkYmxhY1wiOlwixbBcIixcInVkYmxhY1wiOlwixbFcIixcInVkaGFyXCI6XCLipa5cIixcInVmaXNodFwiOlwi4qW+XCIsXCJVZnJcIjpcIvCdlJhcIixcInVmclwiOlwi8J2UslwiLFwiVWdyYXZlXCI6XCLDmVwiLFwidWdyYXZlXCI6XCLDuVwiLFwidUhhclwiOlwi4qWjXCIsXCJ1aGFybFwiOlwi4oa/XCIsXCJ1aGFyclwiOlwi4oa+XCIsXCJ1aGJsa1wiOlwi4paAXCIsXCJ1bGNvcm5cIjpcIuKMnFwiLFwidWxjb3JuZXJcIjpcIuKMnFwiLFwidWxjcm9wXCI6XCLijI9cIixcInVsdHJpXCI6XCLil7hcIixcIlVtYWNyXCI6XCLFqlwiLFwidW1hY3JcIjpcIsWrXCIsXCJ1bWxcIjpcIsKoXCIsXCJVbmRlckJhclwiOlwiX1wiLFwiVW5kZXJCcmFjZVwiOlwi4o+fXCIsXCJVbmRlckJyYWNrZXRcIjpcIuKOtVwiLFwiVW5kZXJQYXJlbnRoZXNpc1wiOlwi4o+dXCIsXCJVbmlvblwiOlwi4ouDXCIsXCJVbmlvblBsdXNcIjpcIuKKjlwiLFwiVW9nb25cIjpcIsWyXCIsXCJ1b2dvblwiOlwixbNcIixcIlVvcGZcIjpcIvCdlYxcIixcInVvcGZcIjpcIvCdlaZcIixcIlVwQXJyb3dCYXJcIjpcIuKkklwiLFwidXBhcnJvd1wiOlwi4oaRXCIsXCJVcEFycm93XCI6XCLihpFcIixcIlVwYXJyb3dcIjpcIuKHkVwiLFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwi4oeFXCIsXCJ1cGRvd25hcnJvd1wiOlwi4oaVXCIsXCJVcERvd25BcnJvd1wiOlwi4oaVXCIsXCJVcGRvd25hcnJvd1wiOlwi4oeVXCIsXCJVcEVxdWlsaWJyaXVtXCI6XCLipa5cIixcInVwaGFycG9vbmxlZnRcIjpcIuKGv1wiLFwidXBoYXJwb29ucmlnaHRcIjpcIuKGvlwiLFwidXBsdXNcIjpcIuKKjlwiLFwiVXBwZXJMZWZ0QXJyb3dcIjpcIuKGllwiLFwiVXBwZXJSaWdodEFycm93XCI6XCLihpdcIixcInVwc2lcIjpcIs+FXCIsXCJVcHNpXCI6XCLPklwiLFwidXBzaWhcIjpcIs+SXCIsXCJVcHNpbG9uXCI6XCLOpVwiLFwidXBzaWxvblwiOlwiz4VcIixcIlVwVGVlQXJyb3dcIjpcIuKGpVwiLFwiVXBUZWVcIjpcIuKKpVwiLFwidXB1cGFycm93c1wiOlwi4oeIXCIsXCJ1cmNvcm5cIjpcIuKMnVwiLFwidXJjb3JuZXJcIjpcIuKMnVwiLFwidXJjcm9wXCI6XCLijI5cIixcIlVyaW5nXCI6XCLFrlwiLFwidXJpbmdcIjpcIsWvXCIsXCJ1cnRyaVwiOlwi4pe5XCIsXCJVc2NyXCI6XCLwnZKwXCIsXCJ1c2NyXCI6XCLwnZOKXCIsXCJ1dGRvdFwiOlwi4ouwXCIsXCJVdGlsZGVcIjpcIsWoXCIsXCJ1dGlsZGVcIjpcIsWpXCIsXCJ1dHJpXCI6XCLilrVcIixcInV0cmlmXCI6XCLilrRcIixcInV1YXJyXCI6XCLih4hcIixcIlV1bWxcIjpcIsOcXCIsXCJ1dW1sXCI6XCLDvFwiLFwidXdhbmdsZVwiOlwi4qanXCIsXCJ2YW5ncnRcIjpcIuKmnFwiLFwidmFyZXBzaWxvblwiOlwiz7VcIixcInZhcmthcHBhXCI6XCLPsFwiLFwidmFybm90aGluZ1wiOlwi4oiFXCIsXCJ2YXJwaGlcIjpcIs+VXCIsXCJ2YXJwaVwiOlwiz5ZcIixcInZhcnByb3B0b1wiOlwi4oidXCIsXCJ2YXJyXCI6XCLihpVcIixcInZBcnJcIjpcIuKHlVwiLFwidmFycmhvXCI6XCLPsVwiLFwidmFyc2lnbWFcIjpcIs+CXCIsXCJ2YXJzdWJzZXRuZXFcIjpcIuKKiu+4gFwiLFwidmFyc3Vic2V0bmVxcVwiOlwi4quL77iAXCIsXCJ2YXJzdXBzZXRuZXFcIjpcIuKKi++4gFwiLFwidmFyc3Vwc2V0bmVxcVwiOlwi4quM77iAXCIsXCJ2YXJ0aGV0YVwiOlwiz5FcIixcInZhcnRyaWFuZ2xlbGVmdFwiOlwi4oqyXCIsXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCLiirNcIixcInZCYXJcIjpcIuKrqFwiLFwiVmJhclwiOlwi4qurXCIsXCJ2QmFydlwiOlwi4qupXCIsXCJWY3lcIjpcItCSXCIsXCJ2Y3lcIjpcItCyXCIsXCJ2ZGFzaFwiOlwi4oqiXCIsXCJ2RGFzaFwiOlwi4oqoXCIsXCJWZGFzaFwiOlwi4oqpXCIsXCJWRGFzaFwiOlwi4oqrXCIsXCJWZGFzaGxcIjpcIuKrplwiLFwidmVlYmFyXCI6XCLiirtcIixcInZlZVwiOlwi4oioXCIsXCJWZWVcIjpcIuKLgVwiLFwidmVlZXFcIjpcIuKJmlwiLFwidmVsbGlwXCI6XCLii65cIixcInZlcmJhclwiOlwifFwiLFwiVmVyYmFyXCI6XCLigJZcIixcInZlcnRcIjpcInxcIixcIlZlcnRcIjpcIuKAllwiLFwiVmVydGljYWxCYXJcIjpcIuKIo1wiLFwiVmVydGljYWxMaW5lXCI6XCJ8XCIsXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwi4p2YXCIsXCJWZXJ0aWNhbFRpbGRlXCI6XCLiiYBcIixcIlZlcnlUaGluU3BhY2VcIjpcIuKAilwiLFwiVmZyXCI6XCLwnZSZXCIsXCJ2ZnJcIjpcIvCdlLNcIixcInZsdHJpXCI6XCLiirJcIixcInZuc3ViXCI6XCLiioLig5JcIixcInZuc3VwXCI6XCLiioPig5JcIixcIlZvcGZcIjpcIvCdlY1cIixcInZvcGZcIjpcIvCdladcIixcInZwcm9wXCI6XCLiiJ1cIixcInZydHJpXCI6XCLiirNcIixcIlZzY3JcIjpcIvCdkrFcIixcInZzY3JcIjpcIvCdk4tcIixcInZzdWJuRVwiOlwi4quL77iAXCIsXCJ2c3VibmVcIjpcIuKKiu+4gFwiLFwidnN1cG5FXCI6XCLiq4zvuIBcIixcInZzdXBuZVwiOlwi4oqL77iAXCIsXCJWdmRhc2hcIjpcIuKKqlwiLFwidnppZ3phZ1wiOlwi4qaaXCIsXCJXY2lyY1wiOlwixbRcIixcIndjaXJjXCI6XCLFtVwiLFwid2VkYmFyXCI6XCLiqZ9cIixcIndlZGdlXCI6XCLiiKdcIixcIldlZGdlXCI6XCLii4BcIixcIndlZGdlcVwiOlwi4omZXCIsXCJ3ZWllcnBcIjpcIuKEmFwiLFwiV2ZyXCI6XCLwnZSaXCIsXCJ3ZnJcIjpcIvCdlLRcIixcIldvcGZcIjpcIvCdlY5cIixcIndvcGZcIjpcIvCdlahcIixcIndwXCI6XCLihJhcIixcIndyXCI6XCLiiYBcIixcIndyZWF0aFwiOlwi4omAXCIsXCJXc2NyXCI6XCLwnZKyXCIsXCJ3c2NyXCI6XCLwnZOMXCIsXCJ4Y2FwXCI6XCLii4JcIixcInhjaXJjXCI6XCLil69cIixcInhjdXBcIjpcIuKLg1wiLFwieGR0cmlcIjpcIuKWvVwiLFwiWGZyXCI6XCLwnZSbXCIsXCJ4ZnJcIjpcIvCdlLVcIixcInhoYXJyXCI6XCLin7dcIixcInhoQXJyXCI6XCLin7pcIixcIlhpXCI6XCLOnlwiLFwieGlcIjpcIs6+XCIsXCJ4bGFyclwiOlwi4p+1XCIsXCJ4bEFyclwiOlwi4p+4XCIsXCJ4bWFwXCI6XCLin7xcIixcInhuaXNcIjpcIuKLu1wiLFwieG9kb3RcIjpcIuKogFwiLFwiWG9wZlwiOlwi8J2Vj1wiLFwieG9wZlwiOlwi8J2VqVwiLFwieG9wbHVzXCI6XCLiqIFcIixcInhvdGltZVwiOlwi4qiCXCIsXCJ4cmFyclwiOlwi4p+2XCIsXCJ4ckFyclwiOlwi4p+5XCIsXCJYc2NyXCI6XCLwnZKzXCIsXCJ4c2NyXCI6XCLwnZONXCIsXCJ4c3FjdXBcIjpcIuKohlwiLFwieHVwbHVzXCI6XCLiqIRcIixcInh1dHJpXCI6XCLilrNcIixcInh2ZWVcIjpcIuKLgVwiLFwieHdlZGdlXCI6XCLii4BcIixcIllhY3V0ZVwiOlwiw51cIixcInlhY3V0ZVwiOlwiw71cIixcIllBY3lcIjpcItCvXCIsXCJ5YWN5XCI6XCLRj1wiLFwiWWNpcmNcIjpcIsW2XCIsXCJ5Y2lyY1wiOlwixbdcIixcIlljeVwiOlwi0KtcIixcInljeVwiOlwi0YtcIixcInllblwiOlwiwqVcIixcIllmclwiOlwi8J2UnFwiLFwieWZyXCI6XCLwnZS2XCIsXCJZSWN5XCI6XCLQh1wiLFwieWljeVwiOlwi0ZdcIixcIllvcGZcIjpcIvCdlZBcIixcInlvcGZcIjpcIvCdlapcIixcIllzY3JcIjpcIvCdkrRcIixcInlzY3JcIjpcIvCdk45cIixcIllVY3lcIjpcItCuXCIsXCJ5dWN5XCI6XCLRjlwiLFwieXVtbFwiOlwiw79cIixcIll1bWxcIjpcIsW4XCIsXCJaYWN1dGVcIjpcIsW5XCIsXCJ6YWN1dGVcIjpcIsW6XCIsXCJaY2Fyb25cIjpcIsW9XCIsXCJ6Y2Fyb25cIjpcIsW+XCIsXCJaY3lcIjpcItCXXCIsXCJ6Y3lcIjpcItC3XCIsXCJaZG90XCI6XCLFu1wiLFwiemRvdFwiOlwixbxcIixcInplZXRyZlwiOlwi4oSoXCIsXCJaZXJvV2lkdGhTcGFjZVwiOlwi4oCLXCIsXCJaZXRhXCI6XCLOllwiLFwiemV0YVwiOlwizrZcIixcInpmclwiOlwi8J2Ut1wiLFwiWmZyXCI6XCLihKhcIixcIlpIY3lcIjpcItCWXCIsXCJ6aGN5XCI6XCLQtlwiLFwiemlncmFyclwiOlwi4oedXCIsXCJ6b3BmXCI6XCLwnZWrXCIsXCJab3BmXCI6XCLihKRcIixcIlpzY3JcIjpcIvCdkrVcIixcInpzY3JcIjpcIvCdk49cIixcInp3alwiOlwi4oCNXCIsXCJ6d25qXCI6XCLigIxcIn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9lbmNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgY2FjaGUucHVzaChjaCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIERlY29kZSBwZXJjZW50LWVuY29kZWQgc3RyaW5nLlxuLy9cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgdmFyIGNhY2hlO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xuICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBiMSA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMSwgaSArIDMpLCAxNik7XG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEUwKSA9PT0gMHhDMCAmJiAoaSArIDMgPCBsKSkge1xuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGMCkgPT09IDB4RTAgJiYgKGkgKyA2IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxMikgJiAweEYwMDApIHwgKChiMiA8PCA2KSAmIDB4RkMwKSB8IChiMyAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODAwIHx8IChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxOCkgJiAweDFDMDAwMCkgfCAoKGIyIDw8IDEyKSAmIDB4M0YwMDApIHwgKChiMyA8PCA2KSAmIDB4RkMwKSB8IChiNCAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKGNociA+PiAxMCksIDB4REMwMCArIChjaHIgJiAweDNGRikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJ1xcdWZmZmQnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5cbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XG5kZWNvZGUuY29tcG9uZW50Q2hhcnMgPSAnJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9kZWNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdCh1cmwpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHJlc3VsdCArPSB1cmwucHJvdG9jb2wgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2xhc2hlcyA/ICcvLycgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyAnQCcgOiAnJztcblxuICBpZiAodXJsLmhvc3RuYW1lICYmIHVybC5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgLy8gaXB2NiBhZGRyZXNzXG4gICAgcmVzdWx0ICs9ICdbJyArIHVybC5ob3N0bmFtZSArICddJztcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5wYXRobmFtZSB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zZWFyY2ggfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuaGFzaCB8fCAnJztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9mb3JtYXQuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9wYXJzZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5BbnkgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jyk7XG5leHBvcnRzLkNjICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DYy9yZWdleCcpO1xuZXhwb3J0cy5DZiAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2YvcmVnZXgnKTtcbmV4cG9ydHMuUCAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1AvcmVnZXgnKTtcbmV4cG9ydHMuWiAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1ovcmVnZXgnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRcXHVEQ0JEfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcbid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnRzLnBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2xhYmVsJyk7XG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG5leHBvcnRzLnBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX3RpdGxlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCIvLyBQYXJzZSBsaW5rIGxhYmVsXG4vL1xuLy8gdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIChcIltcIikgYWxyZWFkeSBtYXRjaGVzO1xuLy8gcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbFxuLy9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQsIGRpc2FibGVOZXN0ZWQpIHtcbiAgdmFyIGxldmVsLCBmb3VuZCwgbWFya2VyLCBwcmV2UG9zLFxuICAgICAgbGFiZWxFbmQgPSAtMSxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcztcblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gIGxldmVsID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKTtcbiAgICBpZiAobWFya2VyID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2UG9zID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgaWYgKHByZXZQb3MgPT09IHN0YXRlLnBvcyAtIDEpIHtcbiAgICAgICAgLy8gaW5jcmVhc2UgbGV2ZWwgaWYgd2UgZmluZCB0ZXh0IGBbYCwgd2hpY2ggaXMgbm90IGEgcGFydCBvZiBhbnkgdG9rZW5cbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH0gZWxzZSBpZiAoZGlzYWJsZU5lc3RlZCkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHtcbiAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvcztcblxuICByZXR1cm4gbGFiZWxFbmQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1NwYWNlICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsIGxldmVsLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8gfHwgaXNTcGFjZShjb2RlKSkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBhc2NpaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDB4MjAgfHwgY29kZSA9PT0gMHg3RikgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgaWYgKGxldmVsID4gMSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwiLy8gUGFyc2UgbGluayB0aXRsZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsXG4gICAgICBtYXJrZXIsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBtYXJrZXIgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4MjIgLyogXCIgKi8gJiYgbWFya2VyICE9PSAweDI3IC8qICcgKi8gJiYgbWFya2VyICE9PSAweDI4IC8qICggKi8pIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHBvcysrO1xuXG4gIC8vIGlmIG9wZW5pbmcgbWFya2VyIGlzIFwiKFwiLCBzd2l0Y2ggaXQgdG8gY2xvc2luZyBtYXJrZXIgXCIpXCJcbiAgaWYgKG1hcmtlciA9PT0gMHgyOCkgeyBtYXJrZXIgPSAweDI5OyB9XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xudmFyIGVzY2FwZUh0bWwgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuZXNjYXBlSHRtbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+Jztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXG4gICAgICBpbmZvID0gdG9rZW4uaW5mbyA/IHVuZXNjYXBlQWxsKHRva2VuLmluZm8pLnRyaW0oKSA6ICcnLFxuICAgICAgbGFuZ05hbWUgPSAnJyxcbiAgICAgIGhpZ2hsaWdodGVkLCBpLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBsYW5nTmFtZSA9IGluZm8uc3BsaXQoL1xccysvZylbMF07XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtb2RpZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuY2xvbmUoKSBmb3IgdG9rZW4gYW5kIHNpbXBsaWZ5IHRoaXMgcGFydCwgYnV0XG4gIC8vIG5vdyB3ZSBwcmVmZXIgdG8ga2VlcCB0aGluZ3MgbG9jYWwuXG4gIGlmIChpbmZvKSB7XG4gICAgaSAgICAgICAgPSB0b2tlbi5hdHRySW5kZXgoJ2NsYXNzJyk7XG4gICAgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdG1wQXR0cnMucHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBBdHRyc1tpXVsxXSArPSAnICcgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH07XG5cbiAgICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyAnPidcbiAgICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuXG4gIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG5cbiAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5kZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5kZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcblxuICAvKipcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XG4gICAqXG4gICAqIENvbnRhaW5zIHJlbmRlciBydWxlcyBmb3IgdG9rZW5zLiBDYW4gYmUgdXBkYXRlZCBhbmQgZXh0ZW5kZWQuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPC9iPic7IH07XG4gICAqXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlZCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XG4gICAqICAgLy8gLi4uXG4gICAqICAgcmV0dXJuIHJlbmRlcmVkSFRNTDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcylcbiAgICogZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlcyA9IGFzc2lnbih7fSwgZGVmYXVsdF9ydWxlcyk7XG59XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJBdHRycyh0b2tlbikgLT4gU3RyaW5nXG4gKlxuICogUmVuZGVyIHRva2VuIGF0dHJpYnV0ZXMgdG8gc3RyaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcbiAgdmFyIGksIGwsIHJlc3VsdDtcblxuICBpZiAoIXRva2VuLmF0dHJzKSB7IHJldHVybiAnJzsgfVxuXG4gIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbi5hdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyAnICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVswXSkgKyAnPVwiJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMV0pICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvZiB0b2tlbnNcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICpcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXG4gKiBpbiBbW1JlbmRlcmVyI3J1bGVzXV0uXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICB2YXIgbmV4dFRva2VuLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBuZWVkTGYgPSBmYWxzZSxcbiAgICAgIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gVGlnaHQgbGlzdCBwYXJhZ3JhcGhzXG4gIGlmICh0b2tlbi5oaWRkZW4pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBJbnNlcnQgYSBuZXdsaW5lIGJldHdlZW4gaGlkZGVuIHBhcmFncmFwaCBhbmQgc3Vic2VxdWVudCBvcGVuaW5nXG4gIC8vIGJsb2NrLWxldmVsIHRhZy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGhlcmUgd2Ugc2hvdWxkIGluc2VydCBhIG5ld2xpbmUgYmVmb3JlIGJsb2NrcXVvdGU6XG4gIC8vICAtIGFcbiAgLy8gICAgPlxuICAvL1xuICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBBZGQgdG9rZW4gbmFtZSwgZS5nLiBgPGltZ2BcbiAgcmVzdWx0ICs9ICh0b2tlbi5uZXN0aW5nID09PSAtMSA/ICc8LycgOiAnPCcpICsgdG9rZW4udGFnO1xuXG4gIC8vIEVuY29kZSBhdHRyaWJ1dGVzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiYFxuICByZXN1bHQgKz0gdGhpcy5yZW5kZXJBdHRycyh0b2tlbik7XG5cbiAgLy8gQWRkIGEgc2xhc2ggZm9yIHNlbGYtY2xvc2luZyB0YWdzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiIC9gXG4gIGlmICh0b2tlbi5uZXN0aW5nID09PSAwICYmIG9wdGlvbnMueGh0bWxPdXQpIHtcbiAgICByZXN1bHQgKz0gJyAvJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xuICBpZiAodG9rZW4uYmxvY2spIHtcbiAgICBuZWVkTGYgPSB0cnVlO1xuXG4gICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgIGlmIChpZHggKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XG5cbiAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAnaW5saW5lJyB8fCBuZXh0VG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gQmxvY2stbGV2ZWwgdGFnIGNvbnRhaW5pbmcgYW4gaW5saW5lIHRhZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLm5lc3RpbmcgPT09IC0xICYmIG5leHRUb2tlbi50YWcgPT09IHRva2VuLnRhZykge1xuICAgICAgICAgIC8vIE9wZW5pbmcgdGFnICsgY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgdHlwZS4gRS5nLiBgPGxpPjwvbGk+YC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ICs9IG5lZWRMZiA/ICc+XFxuJyA6ICc+JztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZSh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGhlIHNhbWUgYXMgW1tSZW5kZXJlci5yZW5kZXJdXSwgYnV0IGZvciBzaW5nbGUgdG9rZW4gb2YgYGlubGluZWAgdHlwZS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFNwZWNpYWwga2x1ZGdlIGZvciBpbWFnZSBgYWx0YCBhdHRyaWJ1dGVzIHRvIGNvbmZvcm0gQ29tbW9uTWFyayBzcGVjLlxuICogRG9uJ3QgdHJ5IHRvIHVzZSBpdCEgU3BlYyByZXF1aXJlcyB0byBzaG93IGBhbHRgIGNvbnRlbnQgd2l0aCBzdHJpcHBlZCBtYXJrdXAsXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmVBc1RleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzdWx0ICs9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXIodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcbiAqIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgaSwgbGVuLCB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3Rva2Vuc1tpXS50eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIENvcmVcbiAqXG4gKiBUb3AtbGV2ZWwgcnVsZXMgZXhlY3V0b3IuIEdsdWVzIGJsb2NrL2lubGluZSBwYXJzZXJzIGFuZCBkb2VzIGludGVybWVkaWF0ZVxuICogdHJhbnNmb3JtYXRpb25zLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnbm9ybWFsaXplJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbm9ybWFsaXplJykgICAgICBdLFxuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXG4gIFsgJ2lubGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2lubGluZScpICAgICAgICAgXSxcbiAgWyAnbGlua2lmeScsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbGlua2lmeScpICAgICAgICBdLFxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXG4gIFsgJ3NtYXJ0cXVvdGVzJywgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzJykgICAgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBDb3JlKClcbiAqKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG4gIC8qKlxuICAgKiBDb3JlI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGNvcmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ29yZS5wcm9jZXNzKHN0YXRlKVxuICpcbiAqIEV4ZWN1dGVzIGNvcmUgY2hhaW4gcnVsZXMuXG4gKiovXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBydWxlcztcblxuICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cbkNvcmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19jb3JlL3N0YXRlX2NvcmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV0/fFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcdTAwMDAvZztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgc3RyO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsICdcXHVGRkZEJyk7XG5cbiAgc3RhdGUuc3JjID0gc3RyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuICB2YXIgdG9rZW47XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyAwLCAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XG5cbiAgLy8gUGFyc2UgaW5saW5lc1xuICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRvayA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UodG9rLmNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRvay5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCIvLyBTaW1wbGUgdHlwb2dyYXBoeWMgcmVwbGFjZW1lbnRzXG4vL1xuLy8gKGMpIChDKSDihpIgwqlcbi8vICh0bSkgKFRNKSDihpIg4oSiXG4vLyAocikgKFIpIOKGkiDCrlxuLy8gKy0g4oaSIMKxXG4vLyAocCkgKFApIC0+IMKnXG4vLyAuLi4g4oaSIOKApiAoYWxzbyA/Li4uLiDihpIgPy4uLCAhLi4uLiDihpIgIS4uKVxuLy8gPz8/Pz8/Pz8g4oaSID8/PywgISEhISEg4oaSICEhISwgYCwsYCDihpIgYCxgXG4vLyAtLSDihpIgJm5kYXNoOywgLS0tIOKGkiAmbWRhc2g7XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOlxuLy8gLSBmcmFjdGlvbmFscyAxLzIsIDEvNCwgMy80IC0+IMK9LCDCvCwgwr5cbi8vIC0gbWlsdGlwbGljYXRpb24gMiB4IDQgLT4gMiDDlyA0XG5cbnZhciBSQVJFX1JFID0gL1xcKy18XFwuXFwufFxcP1xcP1xcP1xcP3whISEhfCwsfC0tLztcblxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXG4vLyBvciByb290IGNoZWNrIHdpbGwgZmFpbCBldmVyeSBzZWNvbmQgdGltZVxudmFyIFNDT1BFRF9BQkJSX1RFU1RfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pO1xuXG52YXIgU0NPUEVEX0FCQlJfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pZztcbnZhciBTQ09QRURfQUJCUiA9IHtcbiAgYzogJ8KpJyxcbiAgcjogJ8KuJyxcbiAgcDogJ8KnJyxcbiAgdG06ICfihKInXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlRm4obWF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2Vfc2NvcGVkKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgICAgICAgICAgICAvLyAuLiwgLi4uLCAuLi4uLi4uIC0+IOKAplxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbPyFdKXs0LH0vZywgJyQxJDEkMScpLnJlcGxhY2UoLyx7Mix9L2csICcsJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW4tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKFxcc3wkKS9tZywgJyQxXFx1MjAxMyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG52YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG52YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbnZhciBBUE9TVFJPUEhFID0gJ1xcdTIwMTknOyAvKiDigJkgKi9cblxuXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfaW5saW5lcyh0b2tlbnMsIHN0YXRlKSB7XG4gIHZhciBpLCB0b2tlbiwgdGV4dCwgdCwgcG9zLCBtYXgsIHRoaXNMZXZlbCwgaXRlbSwgbGFzdENoYXIsIG5leHRDaGFyLFxuICAgICAgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsXG4gICAgICBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIHN0YWNrLCBvcGVuUXVvdGUsIGNsb3NlUXVvdGU7XG5cbiAgc3RhY2sgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICB0aGlzTGV2ZWwgPSB0b2tlbnNbaV0ubGV2ZWw7XG5cbiAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgIHBvcyA9IDA7XG4gICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgIE9VVEVSOlxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIHQgPSBRVU9URV9SRS5leGVjKHRleHQpO1xuICAgICAgaWYgKCF0KSB7IGJyZWFrOyB9XG5cbiAgICAgIGNhbk9wZW4gPSBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBwb3MgPSB0LmluZGV4ICsgMTtcbiAgICAgIGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKTtcblxuICAgICAgLy8gRmluZCBwcmV2aW91cyBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIGxhc3RDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHQuaW5kZXggLSAxID49IDApIHtcbiAgICAgICAgbGFzdENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQodC5pbmRleCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIG5leHRDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gICAgICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICAgICAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gMHgyMiAvKiBcIiAqLyAmJiB0WzBdID09PSAnXCInKSB7XG4gICAgICAgIGlmIChsYXN0Q2hhciA+PSAweDMwIC8qIDAgKi8gJiYgbGFzdENoYXIgPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiAxXCJcIiAtIGNvdW50IGZpcnN0IHF1b3RlIGFzIGFuIGluY2hcbiAgICAgICAgICBjYW5DbG9zZSA9IGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xuICAgICAgICAvLyB0cmVhdCB0aGlzIGFzIHRoZSBtaWRkbGUgb2YgdGhlIHdvcmRcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdodG1sX2Jsb2NrJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9odG1sX2Jsb2NrJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCIvLyBHRk0gdGFibGUsIG5vbi1zdGFuZGFyZFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5ibGtJbmRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgcmV0dXJuIHN0YXRlLnNyYy5zdWJzdHIocG9zLCBtYXggLSBwb3MpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkU3BsaXQoc3RyKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBtYXggPSBzdHIubGVuZ3RoLFxuICAgICAgY2gsXG4gICAgICBlc2NhcGVzID0gMCxcbiAgICAgIGxhc3RQb3MgPSAwLFxuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlLFxuICAgICAgbGFzdEJhY2tUaWNrID0gMDtcblxuICBjaCAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBpZiAoY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgICBpZiAoYmFja1RpY2tlZCkge1xuICAgICAgICAvLyBtYWtlIFxcYCBjbG9zZSBjb2RlIHNlcXVlbmNlLCBidXQgbm90IG9wZW4gaXQ7XG4gICAgICAgIC8vIHRoZSByZWFzb24gaXM6IGBcXGAgaXMgY29ycmVjdCBjb2RlIGJsb2NrXG4gICAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVzICUgMiA9PT0gMCkge1xuICAgICAgICBiYWNrVGlja2VkID0gdHJ1ZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N2MvKiB8ICovICYmIChlc2NhcGVzICUgMiA9PT0gMCkgJiYgIWJhY2tUaWNrZWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICBsYXN0UG9zID0gcG9zICsgMTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4NWMvKiBcXCAqLykge1xuICAgICAgZXNjYXBlcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlc2NhcGVzID0gMDtcbiAgICB9XG5cbiAgICBwb3MrKztcblxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiB1bi1jbG9zZWQgYmFja3RpY2ssIGdvIGJhY2sgdG8ganVzdCBhZnRlclxuICAgIC8vIHRoZSBsYXN0IGJhY2t0aWNrLCBidXQgYXMgaWYgaXQgd2FzIGEgbm9ybWFsIGNoYXJhY3RlclxuICAgIGlmIChwb3MgPT09IG1heCAmJiBiYWNrVGlja2VkKSB7XG4gICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICBwb3MgPSBsYXN0QmFja1RpY2sgKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgfVxuXG4gIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsaW5lVGV4dCwgcG9zLCBpLCBuZXh0TGluZSwgY29sdW1ucywgY29sdW1uQ291bnQsIHRva2VuLFxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xuXG4gIC8vIHNob3VsZCBoYXZlIGF0IGxlYXN0IHR3byBsaW5lc1xuICBpZiAoc3RhcnRMaW5lICsgMiA+IGVuZExpbmUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnLCAnLScsICc6JyxcbiAgLy8gYW5kIG5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgYnV0IHNwYWNlcztcbiAgLy8gYmFzaWNhbGx5LCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC9eWy06fF1bLTp8XFxzXSokLyByZWdleHBcblxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgaWYgKHBvcyA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkbid0IGJlIHNtYWxsZXIgdGhhbiB0aGF0ICh0aGUgcmVzdCBvZiB0aGUgcm93cyBjYW4pXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA+IGFsaWducy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgfVxuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfY2xvc2UnLCAndGgnLCAtMSk7XG4gIH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfY2xvc2UnLCAndGhlYWQnLCAtMSk7XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGJvZHlfb3BlbicsICd0Ym9keScsIDEpO1xuICB0b2tlbi5tYXAgPSB0Ym9keUxpbmVzID0gWyBzdGFydExpbmUgKyAyLCAwIF07XG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKCk7XG4gICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKTtcbiAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgICAgfVxuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogJyc7XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX2Nsb3NlJywgJ3RkJywgLTEpO1xuICAgIH1cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB9XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGJvZHlfY2xvc2UnLCAndGJvZHknLCAtMSk7XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGFibGVfY2xvc2UnLCAndGFibGUnLCAtMSk7XG5cbiAgdGFibGVMaW5lc1sxXSA9IHRib2R5TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwiLy8gQ29kZSBibG9jayAoNCBzcGFjZXMgcGFkZGVkKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIG5leHRMaW5lLCBsYXN0LCB0b2tlbjtcblxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPCA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3QgPSBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBsYXN0ID0gbmV4dExpbmU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbGFzdDtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9ibG9jaycsICdjb2RlJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIGxhc3QsIDQgKyBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCIvLyBmZW5jZXMgKGBgYCBsYW5nLCB+fn4gbGFuZylcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLCB0b2tlbiwgbWFya3VwLFxuICAgICAgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDYwIC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgbWVtID0gcG9zO1xuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIGxlbiA9IHBvcyAtIG1lbTtcblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrdXAgPSBzdGF0ZS5zcmMuc2xpY2UobWVtLCBwb3MpO1xuICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGFkanVzdFRhYixcbiAgICAgIGNoLFxuICAgICAgaSxcbiAgICAgIGluaXRpYWwsXG4gICAgICBsLFxuICAgICAgbGFzdExpbmVFbXB0eSxcbiAgICAgIGxpbmVzLFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRCTWFya3MsXG4gICAgICBvbGRCU0NvdW50LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIHdhc091dGRlbnRlZCxcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgIHBvcysrO1xuICAgIGluaXRpYWwrKztcbiAgICBvZmZzZXQrKztcbiAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgaWYgKChzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICBwb3MrKztcbiAgICAgIGluaXRpYWwrKztcbiAgICAgIG9mZnNldCsrO1xuICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgfVxuXG4gIG9sZEJNYXJrcyA9IFsgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIG9sZEJTQ291bnQgPSBbIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICBvbGRTQ291bnQgPSBbIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICBvbGRUU2hpZnQgPSBbIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdibG9ja3F1b3RlJztcbiAgd2FzT3V0ZGVudGVkID0gZmFsc2U7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZzpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vICAgICAgLSAtIC1cbiAgLy8gICAgIGBgYFxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBvdXRkZW50ZWQsIGkuZS4gaXQncyBpbnNpZGUgbGlzdCBpdGVtIGFuZCBpbmRlbnRlZFxuICAgIC8vIGxlc3MgdGhhbiBzYWlkIGxpc3QgaXRlbTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIDEuIGFueXRoaW5nXG4gICAgLy8gICAgPiBjdXJyZW50IGJsb2NrcXVvdGVcbiAgICAvLyAyLiBjaGVja2luZyB0aGlzIGxpbmVcbiAgICAvLyBgYGBcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgd2FzT3V0ZGVudGVkID0gdHJ1ZTtcblxuICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgLy8gQ2FzZSAxOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGlzIGxpbmUgaXMgZW1wdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLyAmJiAhd2FzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuXG4gICAgICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgICAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAvLyBRdWlyayB0byBlbmZvcmNlIFwiaGFyZCB0ZXJtaW5hdGlvbiBtb2RlXCIgZm9yIHBhcmFncmFwaHM7XG4gICAgICAvLyBub3JtYWxseSBpZiB5b3UgY2FsbCBgdG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpYCxcbiAgICAgIC8vIHBhcmFncmFwaHMgd2lsbCBsb29rIGJlbG93IG5leHRMaW5lIGZvciBwYXJhZ3JhcGggY29udGludWF0aW9uLFxuICAgICAgLy8gYnV0IGlmIGJsb2NrcXVvdGUgaXMgdGVybWluYXRlZCBieSBhbm90aGVyIHRhZywgdGhleSBzaG91bGRuJ3RcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBuZXh0TGluZTtcblxuICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0ZS5ibGtJbmRlbnQgd2FzIG5vbi16ZXJvLCB3ZSBub3cgc2V0IGl0IHRvIHplcm8sXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGFsbCBvZmZzZXRzIHRvIGFwcGVhciBhc1xuICAgICAgICAvLyBpZiBpbmRlbnQgd2Fzbid0IGNoYW5nZWRcbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIi8vIEhvcml6b250YWwgcnVsZVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBjbnQsIGNoLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgLy8gQ2hlY2sgaHIgbWFya2VyXG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4NUYvKiBfICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbWFya2VycyBjYW4gYmUgbWl4ZWQgd2l0aCBzcGFjZXMsIGJ1dCB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3QgMyBvZiB0aGVtXG5cbiAgY250ID0gMTtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgIGlmIChjaCAhPT0gbWFya2VyICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoY2ggPT09IG1hcmtlcikgeyBjbnQrKzsgfVxuICB9XG5cbiAgaWYgKGNudCA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hyJywgJ2hyJywgMCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLm1hcmt1cCA9IEFycmF5KGNudCArIDEpLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkTEluZGVudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4ICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIHRoaXMgY2FzZVxuICAgICAgLy8gKGxpc3QgaXRlbSBpcyBlbXB0eSwgbGlzdCB0ZXJtaW5hdGVzIGJlZm9yZSBcImZvb1wiKTpcbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICAvLyAgIC1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgZm9vXG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgc3RhdGUubGluZSA9IE1hdGgubWluKHN0YXRlLmxpbmUgKyAyLCBlbmRMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZExJbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvL1xuICAgIC8vIFRyeSB0byBjaGVjayBpZiBsaXN0IGlzIHRlcm1pbmF0ZWQgb3IgY29udGludWVkLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIGxpc3QgaGFzIGFub3RoZXIgdHlwZVxuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VyQ2hhckNvZGUgIT09IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIEZpbmFsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3RfY2xvc2UnLCAndWwnLCAtMSk7XG4gIH1cbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWZlcmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBkZXN0RW5kUG9zLFxuICAgICAgZGVzdEVuZExpbmVObyxcbiAgICAgIGVuZExpbmUsXG4gICAgICBocmVmLFxuICAgICAgaSxcbiAgICAgIGwsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIHJlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdGl0bGUsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbXBsZSBjaGVjayB0byBxdWlja2x5IGludGVycnVwdCBzY2FuIG9uIFtsaW5rXSh1cmwpIGF0IHRoZSBzdGFydCBvZiBsaW5lLlxuICAvLyBDYW4gYmUgdXNlZnVsIG9uIHByYWN0aWNlOiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzU0XG4gIHdoaWxlICgrK3BvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVEIC8qIF0gKi8gJiZcbiAgICAgICAgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgaWYgKHBvcyArIDEgPT09IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdyZWZlcmVuY2UnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdyZWZlcmVuY2UnO1xuXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgc3RyID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuICBtYXggPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAocG9zID0gMTsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGFiZWxFbmQgPSBwb3M7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBBIC8qIFxcbiAqLykge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDIC8qIFxcICovKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcbiAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgIF5eXl5eXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KTtcbiAgaWYgKCFyZXMub2spIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHJlcy5wb3M7XG4gIGxpbmVzICs9IHJlcy5saW5lcztcblxuICAvLyBzYXZlIGN1cnNvciBzdGF0ZSwgd2UgY291bGQgcmVxdWlyZSB0byByb2xsYmFjayBsYXRlclxuICBkZXN0RW5kUG9zID0gcG9zO1xuICBkZXN0RW5kTGluZU5vID0gbGluZXM7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgc3RhcnQgPSBwb3M7XG4gIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgdGl0bGUgPSByZXMuc3RyO1xuICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgbGluZXMgKz0gcmVzLmxpbmVzO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gJyc7XG4gICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gIH1cblxuICAvLyBza2lwIHRyYWlsaW5nIHNwYWNlcyB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRpdGxlLFxuICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgdmFsaWQgcmVmZXJlbmNlIGlmIHdlIHJvbGwgYmFja1xuICAgICAgdGl0bGUgPSAnJztcbiAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIuc2xpY2UoMSwgbGFiZWxFbmQpKTtcbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIENvbW1vbk1hcmsgMC4yMCBkaXNhbGxvd3MgZW1wdHkgbGFiZWxzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUmVmZXJlbmNlIGNhbiBub3QgdGVybWluYXRlIGFueXRoaW5nLiBUaGlzIGNoZWNrIGlzIGZvciBzYWZldHkgb25seS5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgaWYqL1xuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGU6IHRpdGxlLCBocmVmOiBocmVmIH07XG4gIH1cblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgbGluZXMgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmICFpc1NwYWNlKGNoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIExldCdzIGN1dCB0YWlscyBsaWtlICcgICAgIyMjICAnIGZyb20gdGhlIGVuZCBvZiBzdHJpbmdcblxuICBtYXggPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgsIHBvcyk7XG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCIvLyBsaGVhZGluZyAoLS0tLCA9PT0pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIHBvcywgbWF4LCBsZXZlbCwgbWFya2VyLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7IC8vIHVzZSBwYXJhZ3JhcGggdG8gbWF0Y2ggdGVybWluYXRvclJ1bGVzXG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vXG4gICAgLy8gQ2hlY2sgZm9yIHVuZGVybGluZSBpbiBzZXRleHQgaGVhZGVyXG4gICAgLy9cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4MkQvKiAtICovIHx8IG1hcmtlciA9PT0gMHgzRC8qID0gKi8pIHtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgICAgICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAgICAgICBsZXZlbCA9IChtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKCFsZXZlbCkge1xuICAgIC8vIERpZG4ndCBmaW5kIHZhbGlkIHVuZGVybGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgLSAxIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuLy8gQW4gYXJyYXkgb2Ygb3BlbmluZyBhbmQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHNlcXVlbmNlcyBmb3IgaHRtbCB0YWdzLFxuLy8gbGFzdCBhcmd1bWVudCBkZWZpbmVzIHdoZXRoZXIgaXQgY2FuIHRlcm1pbmF0ZSBhIHBhcmFncmFwaCBvciBub3Rcbi8vXG52YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gIFsgL148KHNjcmlwdHxwcmV8c3R5bGUpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlKT4vaSwgdHJ1ZSBdLFxuICBbIC9ePCEtLS8sICAgICAgICAvLS0+LywgICB0cnVlIF0sXG4gIFsgL148XFw/LywgICAgICAgICAvXFw/Pi8sICAgdHJ1ZSBdLFxuICBbIC9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlIF0sXG4gIFsgL148IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cCgnXjwvPygnICsgYmxvY2tfbmFtZXMuam9pbignfCcpICsgJykoPz0oXFxcXHN8Lz8+fCQpKScsICdpJyksIC9eJC8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlIF1cbl07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgaSwgbmV4dExpbmUsIHRva2VuLCBsaW5lVGV4dCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gdHJ1ZSBpZiB0aGlzIHNlcXVlbmNlIGNhbiBiZSBhIHRlcm1pbmF0b3IsIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBIVE1MX1NFUVVFTkNFU1tpXVsyXTtcbiAgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBJZiB3ZSBhcmUgaGVyZSAtIHdlIGRldGVjdGVkIEhUTUwgYmxvY2suXG4gIC8vIExldCdzIHJvbGwgZG93biB0aWxsIGJsb2NrIGVuZC5cbiAgaWYgKCFIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKzsgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgbmV4dExpbmUgXTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwiLy8gTGlzdCBvZiB2YWxpZCBodG1sIGJsb2NrcyBuYW1lcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xuLy8gaHR0cDovL2pnbS5naXRodWIuaW8vQ29tbW9uTWFyay9zcGVjLmh0bWwjaHRtbC1ibG9ja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jhc2UnLFxuICAnYmFzZWZvbnQnLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2NhcHRpb24nLFxuICAnY2VudGVyJyxcbiAgJ2NvbCcsXG4gICdjb2xncm91cCcsXG4gICdkZCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RpYWxvZycsXG4gICdkaXInLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2ZyYW1lJyxcbiAgJ2ZyYW1lc2V0JyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hyJyxcbiAgJ2h0bWwnLFxuICAnaWZyYW1lJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdsaW5rJyxcbiAgJ21haW4nLFxuICAnbWVudScsXG4gICdtZW51aXRlbScsXG4gICdtZXRhJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdwcmUnLFxuICAnc2VjdGlvbicsXG4gICdzb3VyY2UnLFxuICAndGl0bGUnLFxuICAnc3VtbWFyeScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aXRsZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd1bCdcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIi8vIFBhcmFncmFwaFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3RhdGUsIHN0YXJ0TGluZS8qLCBlbmRMaW5lKi8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyksXG4gICAgICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnO1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9vcGVuJywgJ3AnLCAxKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwiLy8gUGFyc2VyIHN0YXRlIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBTdGF0ZUJsb2NrKHNyYywgbWQsIGVudiwgdG9rZW5zKSB7XG4gIHZhciBjaCwgcywgc3RhcnQsIHBvcywgbGVuLCBpbmRlbnQsIG9mZnNldCwgaW5kZW50X2ZvdW5kO1xuXG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG4gIHRoaXMubWQgICAgID0gbWQ7XG5cbiAgdGhpcy5lbnYgPSBlbnY7XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXG4gIHRoaXMuYk1hcmtzID0gW107ICAvLyBsaW5lIGJlZ2luIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy5lTWFya3MgPSBbXTsgIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIG9mZnNldHMgb2YgdGhlIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJzICh0YWJzIG5vdCBleHBhbmRlZClcbiAgdGhpcy5zQ291bnQgPSBbXTsgIC8vIGluZGVudHMgZm9yIGVhY2ggbGluZSAodGFicyBleHBhbmRlZClcblxuICAvLyBBbiBhbW91bnQgb2YgdmlydHVhbCBzcGFjZXMgKHRhYnMgZXhwYW5kZWQpIGJldHdlZW4gYmVnaW5uaW5nXG4gIC8vIG9mIGVhY2ggbGluZSAoYk1hcmtzKSBhbmQgcmVhbCBiZWdpbm5pbmcgb2YgdGhhdCBsaW5lLlxuICAvL1xuICAvLyBJdCBleGlzdHMgb25seSBhcyBhIGhhY2sgYmVjYXVzZSBibG9ja3F1b3RlcyBvdmVycmlkZSBiTWFya3NcbiAgLy8gbG9zaW5nIGluZm9ybWF0aW9uIGluIHRoZSBwcm9jZXNzLlxuICAvL1xuICAvLyBJdCdzIHVzZWQgb25seSB3aGVuIGV4cGFuZGluZyB0YWJzLCB5b3UgY2FuIHRoaW5rIGFib3V0IGl0IGFzXG4gIC8vIGFuIGluaXRpYWwgdGFiIGxlbmd0aCwgZS5nLiBic0NvdW50PTIxIGFwcGxpZWQgdG8gc3RyaW5nIGBcXHQxMjNgXG4gIC8vIG1lYW5zIGZpcnN0IHRhYiBzaG91bGQgYmUgZXhwYW5kZWQgdG8gNC0yMSU0ID09PSAzIHNwYWNlcy5cbiAgLy9cbiAgdGhpcy5ic0NvdW50ID0gW107XG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHdlIGFyZSBpbiBsaXN0KVxuICB0aGlzLmxpbmUgICAgICAgPSAwOyAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxuICB0aGlzLnRpZ2h0ICAgICAgPSBmYWxzZTsgIC8vIGxvb3NlL3RpZ2h0IG1vZGUgZm9yIGxpc3RzXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICAvLyBjYW4gYmUgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdyb290JywgJ3BhcmFncmFwaCcgb3IgJ3JlZmVyZW5jZSdcbiAgLy8gdXNlZCBpbiBsaXN0cyB0byBkZXRlcm1pbmUgaWYgdGhleSBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGhcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnO1xuXG4gIHRoaXMubGV2ZWwgPSAwO1xuXG4gIC8vIHJlbmRlcmVyXG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgLy8gQ3JlYXRlIGNhY2hlc1xuICAvLyBHZW5lcmF0ZSBtYXJrZXJzLlxuICBzID0gdGhpcy5zcmM7XG4gIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSBvZmZzZXQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgIGNoID0gcy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGluZGVudCsrO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBIHx8IHBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgaWYgKGNoICE9PSAweDBBKSB7IHBvcysrOyB9XG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goaW5kZW50KTtcbiAgICAgIHRoaXMuc0NvdW50LnB1c2gob2Zmc2V0KTtcbiAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggZmFrZSBlbnRyeSB0byBzaW1wbGlmeSBjYWNoZSBib3VuZHMgY2hlY2tzXG4gIHRoaXMuYk1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy50U2hpZnQucHVzaCgwKTtcbiAgdGhpcy5zQ291bnQucHVzaCgwKTtcbiAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgdGhpcy5saW5lTWF4ID0gdGhpcy5iTWFya3MubGVuZ3RoIC0gMTsgLy8gZG9uJ3QgY291bnQgbGFzdCBmYWtlIGxpbmVcbn1cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdG9rZW4uYmxvY2sgPSB0cnVlO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlcklubGluZVxuICpcbiAqIFRva2VuaXplcyBwYXJhZ3JhcGggY29udGVudC5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQYXJzZXIgcnVsZXNcblxudmFyIF9ydWxlcyA9IFtcbiAgWyAndGV4dCcsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dCcpIF0sXG4gIFsgJ25ld2xpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL25ld2xpbmUnKSBdLFxuICBbICdlc2NhcGUnLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lc2NhcGUnKSBdLFxuICBbICdiYWNrdGlja3MnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWNrdGlja3MnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykudG9rZW5pemUgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS50b2tlbml6ZSBdLFxuICBbICdsaW5rJywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9saW5rJykgXSxcbiAgWyAnaW1hZ2UnLCAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaW1hZ2UnKSBdLFxuICBbICdhdXRvbGluaycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9hdXRvbGluaycpIF0sXG4gIFsgJ2h0bWxfaW5saW5lJywgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lJykgXSxcbiAgWyAnZW50aXR5JywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW50aXR5JykgXVxuXTtcblxudmFyIF9ydWxlczIgPSBbXG4gIFsgJ2JhbGFuY2VfcGFpcnMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykucG9zdFByb2Nlc3MgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS5wb3N0UHJvY2VzcyBdLFxuICBbICd0ZXh0X2NvbGxhcHNlJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJJbmxpbmUoKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VySW5saW5lKCkge1xuICB2YXIgaTtcblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGlubGluZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyMiAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIFNlY29uZCBydWxlciB1c2VkIGZvciBwb3N0LXByb2Nlc3NpbmdcbiAgICogKGUuZy4gaW4gZW1waGFzaXMtbGlrZSBydWxlcykuXG4gICAqKi9cbiAgdGhpcy5ydWxlcjIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzMi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIyLnB1c2goX3J1bGVzMltpXVswXSwgX3J1bGVzMltpXVsxXSk7XG4gIH1cbn1cblxuXG4vLyBTa2lwIHNpbmdsZSB0b2tlbiBieSBydW5uaW5nIGFsbCBydWxlcyBpbiB2YWxpZGF0aW9uIG1vZGU7XG4vLyByZXR1cm5zIGB0cnVlYCBpZiBhbnkgcnVsZSByZXBvcnRlZCBzdWNjZXNzXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5za2lwVG9rZW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLCBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZyxcbiAgICAgIGNhY2hlID0gc3RhdGUuY2FjaGU7XG5cblxuICBpZiAodHlwZW9mIGNhY2hlW3Bvc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUucG9zID0gY2FjaGVbcG9zXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBJbmNyZW1lbnQgc3RhdGUubGV2ZWwgYW5kIGRlY3JlbWVudCBpdCBsYXRlciB0byBsaW1pdCByZWN1cnNpb24uXG4gICAgICAvLyBJdCdzIGhhcm1sZXNzIHRvIGRvIGhlcmUsIGJlY2F1c2Ugbm8gdG9rZW5zIGFyZSBjcmVhdGVkLiBCdXQgaWRlYWxseSxcbiAgICAgIC8vIHdlJ2QgbmVlZCBhIHNlcGFyYXRlIHByaXZhdGUgc3RhdGUgdmFyaWFibGUgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgIC8vXG4gICAgICBzdGF0ZS5sZXZlbCsrO1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5sZXZlbC0tO1xuXG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9vIG11Y2ggbmVzdGluZywganVzdCBza2lwIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBjYXVzZSBsaW5rcyB0byBiZWhhdmUgaW5jb3JyZWN0bHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlLFxuICAgIC8vICAgICAgIHdoZW4gYW4gYW1vdW50IG9mIGBbYCBpcyBleGFjdGx5IGVxdWFsIHRvIGBtYXhOZXN0aW5nICsgMWA6XG4gICAgLy9cbiAgICAvLyAgICAgICBbW1tbW1tbW1tbW1tbW1tbW1tbW1tmb29dKClcbiAgICAvL1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdvcmthcm91bmQgd2hlbiBDTSBzdGFuZGFyZCB3aWxsIGFsbG93IG5lc3RlZCBsaW5rc1xuICAgIC8vICAgICAgICh3ZSBjYW4gcmVwbGFjZSBpdCBieSBwcmV2ZW50aW5nIGxpbmtzIGZyb20gYmVpbmcgcGFyc2VkIGluXG4gICAgLy8gICAgICAgdmFsaWRhdGlvbiBtb2RlKVxuICAgIC8vXG4gICAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4O1xuICB9XG5cbiAgaWYgKCFvaykgeyBzdGF0ZS5wb3MrKzsgfVxuICBjYWNoZVtwb3NdID0gc3RhdGUucG9zO1xufTtcblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgZW5kID0gc3RhdGUucG9zTWF4LFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgZW5kKSB7XG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5wb3NgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2spIHtcbiAgICAgIGlmIChzdGF0ZS5wb3MgPj0gZW5kKSB7IGJyZWFrOyB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1tzdGF0ZS5wb3MrK107XG4gIH1cblxuICBpZiAoc3RhdGUucGVuZGluZykge1xuICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJJbmxpbmUucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggaW5saW5lIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBpLCBydWxlcywgbGVuO1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzdHIsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyMi5nZXRSdWxlcygnJyk7XG4gIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VySW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXdsaW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBtYXggPSBzdGF0ZS5wZW5kaW5nLmxlbmd0aCAtIDE7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyAnICBcXG4nIC0+IGhhcmRicmVha1xuICAvLyBMb29rdXAgaW4gcGVuZGluZyBjaGFycyBpcyBiYWQgcHJhY3RpY2UhIERvbid0IGNvcHkgdG8gb3RoZXIgcnVsZXMhXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcbiAgLy8gY29udmVydGlvbiB0byBmbGF0IG1vZGUuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMHgyMCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwiLy8gUHJvY2VzcyBlc2NhcGVkIGNoYXJzIGFuZCBoYXJkYnJlYWtzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG52YXIgRVNDQVBFRCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxuXG4nXFxcXCFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi0nXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHsgRVNDQVBFRFtjaC5jaGFyQ29kZUF0KDApXSA9IDE7IH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qy8qIFxcICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcysrO1xuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggPCAyNTYgJiYgRVNDQVBFRFtjaF0gIT09IDApIHtcbiAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107IH1cbiAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgICAvLyBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZXMgZnJvbSBuZXh0IGxpbmVcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICdcXFxcJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hcmtlcjtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjsgfVxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcywgdHJ1ZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBtaWdodCBoYXZlIGZvdW5kIGEgdmFsaWQgc2hvcnRjdXQgbGluaywgZGlzYWJsZSByZWZlcmVuY2UgcGFyc2luZ1xuICAgIHBhcnNlUmVmZXJlbmNlID0gZmFsc2U7XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCIvLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgY29udGVudCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVmLFxuICAgICAgcmVzLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UoXG4gICAgICBjb250ZW50LFxuICAgICAgc3RhdGUubWQsXG4gICAgICBzdGF0ZS5lbnYsXG4gICAgICB0b2tlbnMgPSBbXVxuICAgICk7XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xuICAgIHRva2VuLmF0dHJzICAgID0gYXR0cnMgPSBbIFsgJ3NyYycsIGhyZWYgXSwgWyAnYWx0JywgJycgXSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gdG9rZW5zO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKEFVVE9MSU5LX1JFLnRlc3QodGFpbCkpIHtcbiAgICBsaW5rTWF0Y2ggPSB0YWlsLm1hdGNoKEFVVE9MSU5LX1JFKTtcblxuICAgIHVybCA9IGxpbmtNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFTUFJTF9SRS50ZXN0KHRhaWwpKSB7XG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCIvLyBQcm9jZXNzIGh0bWwgZW50aXR5IC0gJiMxMjM7LCAmI3hBRjssICZxdW90OywgLi4uXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0aWVzICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL2VudGl0aWVzJyk7XG52YXIgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5oYXM7XG52YXIgaXNWYWxpZEVudGl0eUNvZGUgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1ZhbGlkRW50aXR5Q29kZTtcbnZhciBmcm9tQ29kZVBvaW50ICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmZyb21Db2RlUG9pbnQ7XG5cblxudmFyIERJR0lUQUxfUkUgPSAvXiYjKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKTsvaTtcbnZhciBOQU1FRF9SRSAgID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBjb2RlLCBtYXRjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjYvKiAmICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAxIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMyAvKiAjICovKSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgY29kZSA9IG1hdGNoWzFdWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gaXNWYWxpZEVudGl0eUNvZGUoY29kZSkgPyBmcm9tQ29kZVBvaW50KGNvZGUpIDogZnJvbUNvZGVQb2ludCgweEZGRkQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKE5BTUVEX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoaGFzKGVudGl0aWVzLCBtYXRjaFsxXSkpIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IGVudGl0aWVzW21hdGNoWzFdXTsgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICcmJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsYXN0RGVsaW0sIGN1cnJEZWxpbSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgbGFzdERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmICghbGFzdERlbGltLmNsb3NlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBqID0gaSAtIGxhc3REZWxpbS5qdW1wIC0gMTtcblxuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIGN1cnJEZWxpbSA9IGRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChjdXJyRGVsaW0ub3BlbiAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5tYXJrZXIgPT09IGxhc3REZWxpbS5tYXJrZXIgJiZcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kIDwgMCAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5sZXZlbCA9PT0gbGFzdERlbGltLmxldmVsKSB7XG5cbiAgICAgICAgLy8gdHlwZW9mcyBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBwbHVnaW5zXG4gICAgICAgIHZhciBvZGRfbWF0Y2ggPSAoY3VyckRlbGltLmNsb3NlIHx8IGxhc3REZWxpbS5vcGVuKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJEZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdERlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyRGVsaW0ubGVuZ3RoICsgbGFzdERlbGltLmxlbmd0aCkgJSAzID09PSAwO1xuXG4gICAgICAgIGlmICghb2RkX21hdGNoKSB7XG4gICAgICAgICAgbGFzdERlbGltLmp1bXAgPSBpIC0gajtcbiAgICAgICAgICBsYXN0RGVsaW0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgID0gaTtcbiAgICAgICAgICBjdXJyRGVsaW0uanVtcCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiAtPSBjdXJyRGVsaW0uanVtcCArIDE7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgaW50byBvbmUsIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRfY29sbGFwc2Uoc3RhdGUpIHtcbiAgdmFyIGN1cnIsIGxhc3QsXG4gICAgICBsZXZlbCA9IDAsXG4gICAgICB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBtYXggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGZvciAoY3VyciA9IGxhc3QgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICAvLyByZS1jYWxjdWxhdGUgbGV2ZWxzXG4gICAgbGV2ZWwgKz0gdG9rZW5zW2N1cnJdLm5lc3Rpbmc7XG4gICAgdG9rZW5zW2N1cnJdLmxldmVsID0gbGV2ZWw7XG5cbiAgICBpZiAodG9rZW5zW2N1cnJdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBjdXJyICsgMSA8IG1heCAmJlxuICAgICAgICB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuXG4gICAgICAvLyBjb2xsYXBzZSB0d28gYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyICE9PSBsYXN0KSB7IHRva2Vuc1tsYXN0XSA9IHRva2Vuc1tjdXJyXTsgfVxuXG4gICAgICBsYXN0Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICB0b2tlbnMubGVuZ3RoID0gbGFzdDtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG5cbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG5cbiAgdGhpcy5jYWNoZSA9IHt9OyAgICAgICAgLy8gU3RvcmVzIHsgc3RhcnQ6IGVuZCB9IHBhaXJzLiBVc2VmdWwgZm9yIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cblxuICB0aGlzLmRlbGltaXRlcnMgPSBbXTsgICAvLyBFbXBoYXNpcy1saWtlIGRlbGltaXRlcnNcbn1cblxuXG4vLyBGbHVzaCBwZW5kaW5nIHRleHRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbigndGV4dCcsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHRoaXMucGVuZGluZztcbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vLyBJZiBwZW5kaW5nIHRleHQgZXhpc3RzIC0gZmx1c2ggaXQgYXMgdGV4dCB0b2tlblxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xuICB9XG5cbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgICAgICAgPSBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57MiwzfVthLXpBLVowLTklL118JyArIC8vIGdpdGh1YiBoYXMgLi4uIGluIGNvbW1pdCByYW5nZSBsaW5rcy4gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgLy8gYWxsb3cgYCwsLGAgaW4gcGF0aHNcbiAgICAgICAgICAnXFxcXCEoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdKS58JyArXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XSkuJyArXG4gICAgICAgICcpKycgK1xuICAgICAgJ3xcXFxcLycgK1xuICAgICcpPyc7XG5cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10rJztcblxuICByZS5zcmNfeG4gPVxuXG4gICAgJ3huLS1bYS16MC05XFxcXC1dezEsNTl9JztcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19kb21haW4gPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAgICd8JyArXG4gICAgICAvLyBkb24ndCBhbGxvdyBgLS1gIGluIGRvbWFpbiBuYW1lcywgYmVjYXVzZTpcbiAgICAgIC8vIC0gdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBtYXJrZG93biAmbWRhc2g7IC8gJm5kYXNoO1xuICAgICAgLy8gLSBub2JvZHkgdXNlIHRob3NlIGFueXdheVxuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotKD8hLSl8JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICcpJztcblxuICByZS5zcmNfaG9zdCA9XG5cbiAgICAnKD86JyArXG4gICAgLy8gRG9uJ3QgbmVlZCBJUCBjaGVjaywgYmVjYXVzZSBkaWdpdHMgYXJlIGFscmVhZHkgYWxsb3dlZCBpbiBub3JtYWwgZG9tYWluIG5hbWVzXG4gICAgLy8gICBzcmNfaXA0ICtcbiAgICAvLyAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikqJyArIHJlLnNyY19kb21haW4vKl9yb290Ki8gKyAnKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9mdXp6eSA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfaXA0ICtcbiAgICAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgPVxuXG4gICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknO1xuXG4gIHJlLnNyY19ob3N0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcnVsZXNcblxuICAvLyBSdWRlIHRlc3QgZnV6enkgbGlua3MgYnkgaG9zdCwgZm9yIHF1aWNrIGRlbnlcbiAgcmUudHBsX2hvc3RfZnV6enlfdGVzdCA9XG5cbiAgICAnbG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OicgKyByZS5zcmNfWlBDYyArICd8PnwkKSknO1xuXG4gIHJlLnRwbF9lbWFpbF9mdXp6eSA9XG5cbiAgICAgICcoXnwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcXFxcKHwnICsgcmUuc3JjX1pDYyArICcpKCcgKyByZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCArICcpJztcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZXR1cm4gcmU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIi8vIG1hcmtkb3duLWl0IGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAxMDAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCIvLyBcIlplcm9cIiBwcmVzZXQsIHdpdGggbm90aGluZyBlbmFibGVkLiBVc2VmdWwgZm9yIG1hbnVhbCBjb25maWd1cmluZyBvZiBzaW1wbGVcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanMiLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIid1c2Ugc3RyaWN0J1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxudmFyIHRhZ0V4cHIgPSAvXjwhLS0gP1xceyg/OihbYS16MC05XSspKFxcXlswLTldKik/OiA/KT8oLiopXFx9ID8tLT5cXG4/JC9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzIChtZCkge1xuICBtZC5jb3JlLnJ1bGVyLnB1c2goJ2N1cmx5X2F0dHJpYnV0ZXMnLCBjdXJseUF0dHJzKVxufVxuXG4vKlxuICogTGlzdCBvZiB0YWcgLT4gdG9rZW4gdHlwZSBtYXBwaW5ncy4gRWcsIGA8bGk+YCBpcyBgbGlzdF9pdGVtX29wZW5gLlxuICovXG5cbnZhciBvcGVuaW5nID0ge1xuICBsaTogWydsaXN0X2l0ZW0nXSxcbiAgdWw6IFsnYnVsbGV0X2xpc3QnXSxcbiAgcDogWydwYXJhZ3JhcGgnXSxcbiAgb2w6IFsnb3JkZXJlZF9saXN0J10sXG4gIGJsb2NrcXVvdGU6IFsnYmxvY2txdW90ZSddLFxuICBoMTogWydoZWFkaW5nJ10sXG4gIGgyOiBbJ2hlYWRpbmcnXSxcbiAgaDM6IFsnaGVhZGluZyddLFxuICBoNDogWydoZWFkaW5nJ10sXG4gIGg1OiBbJ2hlYWRpbmcnXSxcbiAgaDY6IFsnaGVhZGluZyddLFxuICBhOiBbJ2xpbmsnXSxcbiAgY29kZTogWydjb2RlX2lubGluZScsICdjb2RlX2Jsb2NrJywgJ2ZlbmNlJ11cbn1cblxudmFyIHNlbGZDbG9zaW5nID0ge1xuICBocjogdHJ1ZSxcbiAgaW1hZ2U6IHRydWVcbn1cblxuLyoqXG4gKiAuLi5cbiAqL1xuXG5mdW5jdGlvbiBjdXJseUF0dHJzIChzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zXG4gIHZhciBvbWlzc2lvbnMgPSBbXVxuICB2YXIgcGFyZW50LCBtXG4gIHZhciBzdGFjayA9IHsgbGVuOiAwLCBjb250ZW50czogW10sIHR5cGVzOiB7fSB9XG5cbiAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuLCBpKSB7XG4gICAgLy8gU2F2ZSBicmVhZGNydW1icyBzbyBodG1sX2Jsb2NrIHdpbGwgcGljayBpdCB1cFxuICAgIGlmIChpc09wZW5lcih0b2tlbi50eXBlKSB8fCBzZWxmQ2xvc2luZ1t0b2tlbi50eXBlXSkge1xuICAgICAgc3B1c2goc3RhY2ssIHRva2VuKVxuICAgIH1cblxuICAgIC8vIFwiIyBIZWxsb1xcbjwhLS17LmNsYXNzbmFtZX0tLT5cIlxuICAgIC8vIC4uLnNlcXVlbmNlIG9mIFtoZWFkaW5nX29wZW4sIGlubGluZSwgaGVhZGluZ19jbG9zZSwgaHRtbF9ibG9ja11cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2h0bWxfYmxvY2snKSB7XG4gICAgICBtID0gdG9rZW4uY29udGVudC5tYXRjaCh0YWdFeHByKVxuICAgICAgaWYgKCFtKSByZXR1cm5cblxuICAgICAgcGFyZW50ID0gZmluZFBhcmVudChzdGFjaywgbVsxXSwgbVsyXSlcbiAgICAgIGlmIChwYXJlbnQgJiYgYXBwbHlUb1Rva2VuKHBhcmVudCwgbVszXSkpIHtcbiAgICAgICAgb21pc3Npb25zLnVuc2hpZnQoaSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBcIiMgSGVsbG8gPCEtLXsuY2xhc3NuYW1lfSAtLT5cIlxuICAgIC8vIHsgdHlwZTogJ2lubGluZScsIGNoaWxkcmVuOiB7IC4uLiwgJzwhLS17Li4ufS0tPicgfSB9XG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBjdXJseUlubGluZSh0b2tlbi5jaGlsZHJlbiwgc3RhY2spXG4gICAgfVxuICB9KVxuXG4gIC8vIFJlbW92ZSA8IS0tLi4uLS0+IGh0bWxfYmxvY2sgdG9rZW5zXG4gIG9taXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIHRva2Vucy5zcGxpY2UoaWR4LCAxKSB9KVxufVxuXG4vKipcbiAqIEludGVybmFsOiBjaGVja3MgaW4gYSB0b2tlbiB0eXBlIGlzIGEgYmxvY2sgb3BlbmVyXG4gKi9cblxuZnVuY3Rpb24gaXNPcGVuZXIgKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUubWF0Y2goL18ob3BlbnxzdGFydCkkLykgfHxcbiAgICB0eXBlID09PSAnZmVuY2UnIHx8IHR5cGUgPT09ICdjb2RlX2Jsb2NrJ1xufVxuXG4vKipcbiAqIEludGVybmFsOiBSdW4gdGhyb3VnaCBpbmxpbmUgYW5kIHN0dWZmXG4gKi9cblxuZnVuY3Rpb24gY3VybHlJbmxpbmUgKGNoaWxkcmVuLCBzdGFjaykge1xuICB2YXIgbGFzdFRleHQsIG0sIHBhcmVudFxuXG4gIC8vIEtlZXAgYSBsaXN0IG9mIHN1Yi10b2tlbnMgdG8gYmUgcmVtb3ZlZFxuICB2YXIgb21pc3Npb25zID0gW11cblxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgIGlmIChpc09wZW5lcihjaGlsZC50eXBlKSB8fFxuICAgICAgc2VsZkNsb3NpbmdbY2hpbGQudHlwZV0gfHxcbiAgICAgIGNoaWxkLnR5cGUgPT09ICdjb2RlX2lubGluZScpIHtcbiAgICAgIHNwdXNoKHN0YWNrLCBjaGlsZClcbiAgICB9XG5cbiAgICAvLyBEZWNvcmF0ZSB0YWdzIGFyZSBmb3VuZFxuICAgIGlmIChtID0gY2hpbGQuY29udGVudC5tYXRjaCh0YWdFeHByKSkge1xuICAgICAgdmFyIHRhZyA9IG1bMV1cbiAgICAgIHZhciBkZXB0aCA9IG1bMl1cbiAgICAgIHZhciBhdHRycyA9IG1bM11cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBjb21tZW50LCB0aGVuIHJlbW92ZSB0aGUgZXh0cmEgc3BhY2VcbiAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnQoc3RhY2ssIHRhZywgZGVwdGgpXG4gICAgICBpZiAocGFyZW50ICYmIGFwcGx5VG9Ub2tlbihwYXJlbnQsIGF0dHJzKSkge1xuICAgICAgICBvbWlzc2lvbnMudW5zaGlmdChpKVxuICAgICAgICBpZiAobGFzdFRleHQpIHRyaW1SaWdodChsYXN0VGV4dCwgJ2NvbnRlbnQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZC50eXBlID09PSAndGV4dCcpIGxhc3RUZXh0ID0gY2hpbGRcbiAgfSlcblxuICAvLyBSZW1vdmUgdGhlbSBpbiBhIHNlcGFyYXRlIHN0ZXAgc28gd2UgZG9uJ3RcbiAgb21pc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpXG4gIH0pXG59XG5cbi8qKlxuICogUHJpdmF0ZTogZ2l2ZW4gYSBsaXN0IG9mIHRva2VucyBgbGlzdGAgYW5kIGBsYXN0UGFyZW50YCwgZmluZCB0aGUgb25lIHRoYXRcbiAqIG1hdGNoZXMgYHRhZ2AuXG4gKi9cblxuZnVuY3Rpb24gZmluZFBhcmVudCAoc3RhY2ssIHRhZywgZGVwdGgpIHtcbiAgaWYgKCF0YWcpIHJldHVybiBzdGFjay5sYXN0XG5cbiAgaWYgKGRlcHRoID09PSAnXicpIHtcbiAgICBkZXB0aCA9IDFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVwdGggPT09ICdzdHJpbmcnKSB7IC8qICdeMicgKi9cbiAgICBkZXB0aCA9ICtkZXB0aC5zdWJzdHIoMSlcbiAgfSBlbHNlIHtcbiAgICBkZXB0aCA9IDBcbiAgfVxuXG4gIHZhciB0YXJnZXRzID0gb3BlbmluZ1t0YWcudG9Mb3dlckNhc2UoKV0gfHwgW3RhZy50b0xvd2VyQ2FzZSgpXVxuXG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHN0YWNrLnR5cGVzW3RhcmdldF1cbiAgfSlcblxuICB2YXIgbGlzdCA9IHN0YWNrLnR5cGVzW3RhcmdldF1cbiAgaWYgKCFsaXN0KSByZXR1cm4gLy8gQ2FuJ3QgZmluZCB0YWcgYHRhZ2BcblxuICByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDEgLSBkZXB0aF1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiB0cmltIHRoZSByaWdodFxuICovXG5cbmZ1bmN0aW9uIHRyaW1SaWdodCAob2JqLCBhdHRyKSB7XG4gIG9ialthdHRyXSA9IG9ialthdHRyXS5yZXBsYWNlKC9cXHMqJC8sICcnKVxufVxuXG4vKipcbiAqIFByaXZhdGU6IGFwcGx5IHRhZyB0byB0b2tlblxuICpcbiAqICAgICBhcHBseVRvVG9rZW4odG9rZW4sICcuY2xhc3NuYW1lJylcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRvVG9rZW4gKHRva2VuLCBhdHRycykge1xuICB2YXIgbVxuICB2YXIgdG9kbyA9IFtdXG5cbiAgd2hpbGUgKGF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKlxcLihbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyAnY2xhc3MnLCBtWzFdLCB7IGFwcGVuZDogdHJ1ZSB9IF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqIyhbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyAnaWQnLCBtWzFdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPVwiKFteXCJdKilcIi8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPScoW14nXSopJy8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPShbXiBdKikvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCAnJyBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKy8pKSB7XG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHRvZG8uZm9yRWFjaChmdW5jdGlvbiAoYXJncykgeyBzZXRBdHRyLmFwcGx5KHRoaXMsIFt0b2tlbl0uY29uY2F0KGFyZ3MpKSB9KVxuICByZXR1cm4gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHNoaWZ0ICgpIHtcbiAgICBhdHRycyA9IGF0dHJzLnN1YnN0cihtWzBdLmxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHNldHMgYW4gYXR0cmlidXRlIGBhdHRyYCB0byBgdmFsdWVgIGluIGEgdG9rZW4uIElmIGBvcHRpb25zLmFwcGVuZGBcbiAqIGlzIHRydWUsIGFwcGVuZCB0byB0aGUgb2xkIHZhbHVlIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXQuXG4gKi9cblxuZnVuY3Rpb24gc2V0QXR0ciAodG9rZW4sIGF0dHIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBpZHggPSB0b2tlbi5hdHRySW5kZXgoYXR0cilcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRva2VuLmF0dHJQdXNoKFsgYXR0ciwgdmFsdWUgXSlcbiAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgdG9rZW4uYXR0cnNbaWR4XVsxXSA9XG4gICAgICB0b2tlbi5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0b2tlbi5hdHRyc1tpZHhdWzFdID0gdmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHB1c2hlcyBhIHRva2VuIHRvIHRoZSBzdGFja1xuICovXG5cbmZ1bmN0aW9uIHNwdXNoIChzdGFjaywgdG9rZW4pIHtcbiAgdmFyIHR5cGUgPSB0b2tlbi50eXBlLnJlcGxhY2UoL18ob3BlbnxzdGFydCkkLywgJycpXG4gIGlmICghc3RhY2sudHlwZXNbdHlwZV0pIHsgc3RhY2sudHlwZXNbdHlwZV0gPSBbXSB9XG4gIHN0YWNrLnR5cGVzW3R5cGVdLnB1c2godG9rZW4pXG4gIHN0YWNrLmxhc3QgPSB0b2tlblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0LWRlY29yYXRlL2luZGV4LmpzIiwiLypcblN5bnRheCBoaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBhdXRvZGV0ZWN0aW9uLlxuaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4qL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEZpbmQgdGhlIGdsb2JhbCBvYmplY3QgZm9yIGV4cG9ydCB0byBib3RoIHRoZSBicm93c2VyIGFuZCB3ZWIgd29ya2Vycy5cbiAgdmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdyB8fFxuICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGY7XG5cbiAgLy8gU2V0dXAgaGlnaGxpZ2h0LmpzIGZvciBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLiBGaXJzdCBpcyBOb2RlLmpzIG9yXG4gIC8vIENvbW1vbkpTLlxuICBpZih0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICB9IGVsc2UgaWYoZ2xvYmFsT2JqZWN0KSB7XG4gICAgLy8gRXhwb3J0IGhsanMgZ2xvYmFsbHkgZXZlbiB3aGVuIHVzaW5nIEFNRCBmb3IgY2FzZXMgd2hlbiB0aGlzIHNjcmlwdFxuICAgIC8vIGlzIGxvYWRlZCB3aXRoIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgaGxqcy5cbiAgICBnbG9iYWxPYmplY3QuaGxqcyA9IGZhY3Rvcnkoe30pO1xuXG4gICAgLy8gRmluYWxseSByZWdpc3RlciB0aGUgZ2xvYmFsIGhsanMgd2l0aCBBTUQuXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsT2JqZWN0LmhsanM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufShmdW5jdGlvbihobGpzKSB7XG4gIC8vIENvbnZlbmllbmNlIHZhcmlhYmxlcyBmb3IgYnVpbGQtaW4gb2JqZWN0c1xuICB2YXIgQXJyYXlQcm90byA9IFtdLFxuICAgICAgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzO1xuXG4gIC8vIEdsb2JhbCBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCB3aXRoaW4gdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICB2YXIgbGFuZ3VhZ2VzID0ge30sXG4gICAgICBhbGlhc2VzICAgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgdGhyb3VnaG91dCB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIHZhciBub0hpZ2hsaWdodFJlICAgID0gL14obm8tP2hpZ2hsaWdodHxwbGFpbnx0ZXh0KSQvaSxcbiAgICAgIGxhbmd1YWdlUHJlZml4UmUgPSAvXFxibGFuZyg/OnVhZ2UpPy0oW1xcdy1dKylcXGIvaSxcbiAgICAgIGZpeE1hcmt1cFJlICAgICAgPSAvKCheKDxbXj5dKz58XFx0fCkrfCg/OlxcbikpKS9nbTtcblxuICB2YXIgc3BhbkVuZFRhZyA9ICc8L3NwYW4+JztcblxuICAvLyBHbG9iYWwgb3B0aW9ucyB1c2VkIHdoZW4gd2l0aGluIGV4dGVybmFsIEFQSXMuIFRoaXMgaXMgbW9kaWZpZWQgd2hlblxuICAvLyBjYWxsaW5nIHRoZSBgaGxqcy5jb25maWd1cmVgIGZ1bmN0aW9uLlxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjbGFzc1ByZWZpeDogJ2hsanMtJyxcbiAgICB0YWJSZXBsYWNlOiBudWxsLFxuICAgIHVzZUJSOiBmYWxzZSxcbiAgICBsYW5ndWFnZXM6IHVuZGVmaW5lZFxuICB9O1xuXG5cbiAgLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuICBmdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdFJlKHJlLCBsZXhlbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSByZSAmJiByZS5leGVjKGxleGVtZSk7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RIaWdobGlnaHRlZChsYW5ndWFnZSkge1xuICAgIHJldHVybiBub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2tMYW5ndWFnZShibG9jaykge1xuICAgIHZhciBpLCBtYXRjaCwgbGVuZ3RoLCBfY2xhc3M7XG4gICAgdmFyIGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIG1hdGNoID0gbGFuZ3VhZ2VQcmVmaXhSZS5leGVjKGNsYXNzZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIGdldExhbmd1YWdlKG1hdGNoWzFdKSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIF9jbGFzcyA9IGNsYXNzZXNbaV1cblxuICAgICAgaWYgKGlzTm90SGlnaGxpZ2h0ZWQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBfY2xhc3M7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQpIHsgIC8vIGluaGVyaXQocGFyZW50LCBvdmVycmlkZV9vYmosIG92ZXJyaWRlX29iaiwgLi4uKVxuICAgIHZhciBrZXk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGZvciAoa2V5IGluIHBhcmVudClcbiAgICAgIHJlc3VsdFtrZXldID0gcGFyZW50W2tleV07XG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgZm9yIChrZXkgaW4gb2JqKVxuICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiBTdHJlYW0gbWVyZ2luZyAqL1xuXG4gIGZ1bmN0aW9uIG5vZGVTdHJlYW0obm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAoZnVuY3Rpb24gX25vZGVTdHJlYW0obm9kZSwgb2Zmc2V0KSB7XG4gICAgICBmb3IgKHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzKVxuICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9mZnNldCA9IF9ub2RlU3RyZWFtKGNoaWxkLCBvZmZzZXQpO1xuICAgICAgICAgIC8vIFByZXZlbnQgdm9pZCBlbGVtZW50cyBmcm9tIGhhdmluZyBhbiBlbmQgdGFnIHRoYXQgd291bGQgYWN0dWFsbHlcbiAgICAgICAgICAvLyBkb3VibGUgdGhlbSBpbiB0aGUgb3V0cHV0LiBUaGVyZSBhcmUgbW9yZSB2b2lkIGVsZW1lbnRzIGluIEhUTUxcbiAgICAgICAgICAvLyBidXQgd2UgbGlzdCBvbmx5IHRob3NlIHJlYWxpc3RpY2FsbHkgZXhwZWN0ZWQgaW4gY29kZSBkaXNwbGF5LlxuICAgICAgICAgIGlmICghdGFnKGNoaWxkKS5tYXRjaCgvYnJ8aHJ8aW1nfGlucHV0LykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgZXZlbnQ6ICdzdG9wJyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgIG5vZGU6IGNoaWxkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSkobm9kZSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhvcmlnaW5hbCwgaGlnaGxpZ2h0ZWQsIHZhbHVlKSB7XG4gICAgdmFyIHByb2Nlc3NlZCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBub2RlU3RhY2sgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNlbGVjdFN0cmVhbSgpIHtcbiAgICAgIGlmICghb3JpZ2luYWwubGVuZ3RoIHx8ICFoaWdobGlnaHRlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmxlbmd0aCA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxbMF0ub2Zmc2V0ICE9PSBoaWdobGlnaHRlZFswXS5vZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbFswXS5vZmZzZXQgPCBoaWdobGlnaHRlZFswXS5vZmZzZXQpID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFRvIGF2b2lkIHN0YXJ0aW5nIHRoZSBzdHJlYW0ganVzdCBiZWZvcmUgaXQgc2hvdWxkIHN0b3AgdGhlIG9yZGVyIGlzXG4gICAgICBlbnN1cmVkIHRoYXQgb3JpZ2luYWwgYWx3YXlzIHN0YXJ0cyBmaXJzdCBhbmQgY2xvc2VzIGxhc3Q6XG5cbiAgICAgIGlmIChldmVudDEgPT0gJ3N0YXJ0JyAmJiBldmVudDIgPT0gJ3N0YXJ0JylcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICAgIHJldHVybiBoaWdobGlnaHRlZDtcbiAgICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICBpZiAoZXZlbnQxID09ICdzdG9wJyAmJiBldmVudDIgPT0gJ3N0b3AnKVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQ7XG5cbiAgICAgIC4uLiB3aGljaCBpcyBjb2xsYXBzZWQgdG86XG4gICAgICAqL1xuICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkWzBdLmV2ZW50ID09PSAnc3RhcnQnID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVuKG5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIGF0dHJfc3RyKGEpIHtyZXR1cm4gJyAnICsgYS5ub2RlTmFtZSArICc9XCInICsgZXNjYXBlKGEudmFsdWUpLnJlcGxhY2UoJ1wiJywgJyZxdW90OycpICsgJ1wiJzt9XG4gICAgICByZXN1bHQgKz0gJzwnICsgdGFnKG5vZGUpICsgQXJyYXlQcm90by5tYXAuY2FsbChub2RlLmF0dHJpYnV0ZXMsIGF0dHJfc3RyKS5qb2luKCcnKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZShub2RlKSB7XG4gICAgICByZXN1bHQgKz0gJzwvJyArIHRhZyhub2RlKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoZXZlbnQpIHtcbiAgICAgIChldmVudC5ldmVudCA9PT0gJ3N0YXJ0JyA/IG9wZW4gOiBjbG9zZSkoZXZlbnQubm9kZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9yaWdpbmFsLmxlbmd0aCB8fCBoaWdobGlnaHRlZC5sZW5ndGgpIHtcbiAgICAgIHZhciBzdHJlYW0gPSBzZWxlY3RTdHJlYW0oKTtcbiAgICAgIHJlc3VsdCArPSBlc2NhcGUodmFsdWUuc3Vic3RyaW5nKHByb2Nlc3NlZCwgc3RyZWFtWzBdLm9mZnNldCkpO1xuICAgICAgcHJvY2Vzc2VkID0gc3RyZWFtWzBdLm9mZnNldDtcbiAgICAgIGlmIChzdHJlYW0gPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIC8qXG4gICAgICAgIE9uIGFueSBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnIG9mIHRoZSBvcmlnaW5hbCBtYXJrdXAgd2UgZmlyc3QgY2xvc2VcbiAgICAgICAgdGhlIGVudGlyZSBoaWdobGlnaHRlZCBub2RlIHN0YWNrLCB0aGVuIHJlbmRlciB0aGUgb3JpZ2luYWwgdGFnIGFsb25nXG4gICAgICAgIHdpdGggYWxsIHRoZSBmb2xsb3dpbmcgb3JpZ2luYWwgdGFncyBhdCB0aGUgc2FtZSBvZmZzZXQgYW5kIHRoZW5cbiAgICAgICAgcmVvcGVuIGFsbCB0aGUgdGFncyBvbiB0aGUgaGlnaGxpZ2h0ZWQgc3RhY2suXG4gICAgICAgICovXG4gICAgICAgIG5vZGVTdGFjay5yZXZlcnNlKCkuZm9yRWFjaChjbG9zZSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICAgICAgc3RyZWFtID0gc2VsZWN0U3RyZWFtKCk7XG4gICAgICAgIH0gd2hpbGUgKHN0cmVhbSA9PT0gb3JpZ2luYWwgJiYgc3RyZWFtLmxlbmd0aCAmJiBzdHJlYW1bMF0ub2Zmc2V0ID09PSBwcm9jZXNzZWQpO1xuICAgICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2gob3Blbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyZWFtWzBdLmV2ZW50ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgbm9kZVN0YWNrLnB1c2goc3RyZWFtWzBdLm5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGUodmFsdWUuc3Vic3RyKHByb2Nlc3NlZCkpO1xuICB9XG5cbiAgLyogSW5pdGlhbGl6YXRpb24gKi9cblxuICBmdW5jdGlvbiBleHBhbmRfbW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUudmFyaWFudHMgJiYgIW1vZGUuY2FjaGVkX3ZhcmlhbnRzKSB7XG4gICAgICBtb2RlLmNhY2hlZF92YXJpYW50cyA9IG1vZGUudmFyaWFudHMubWFwKGZ1bmN0aW9uKHZhcmlhbnQpIHtcbiAgICAgICAgcmV0dXJuIGluaGVyaXQobW9kZSwge3ZhcmlhbnRzOiBudWxsfSwgdmFyaWFudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGUuY2FjaGVkX3ZhcmlhbnRzIHx8IChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIFtpbmhlcml0KG1vZGUpXSkgfHwgW21vZGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKSB7XG5cbiAgICBmdW5jdGlvbiByZVN0cihyZSkge1xuICAgICAgICByZXR1cm4gKHJlICYmIHJlLnNvdXJjZSkgfHwgcmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgICByZVN0cih2YWx1ZSksXG4gICAgICAgICdtJyArIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gJ2knIDogJycpICsgKGdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlTW9kZShtb2RlLCBwYXJlbnQpIHtcbiAgICAgIGlmIChtb2RlLmNvbXBpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBtb2RlLmNvbXBpbGVkID0gdHJ1ZTtcblxuICAgICAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICAgICAgaWYgKG1vZGUua2V5d29yZHMpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVkX2tleXdvcmRzID0ge307XG5cbiAgICAgICAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihjbGFzc05hbWUsIHN0cikge1xuICAgICAgICAgIGlmIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihrdykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBrdy5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgY29tcGlsZWRfa2V5d29yZHNbcGFpclswXV0gPSBbY2xhc3NOYW1lLCBwYWlyWzFdID8gTnVtYmVyKHBhaXJbMV0pIDogMV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlLmtleXdvcmRzID09PSAnc3RyaW5nJykgeyAvLyBzdHJpbmdcbiAgICAgICAgICBmbGF0dGVuKCdrZXl3b3JkJywgbW9kZS5rZXl3b3Jkcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0S2V5cyhtb2RlLmtleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oY2xhc3NOYW1lLCBtb2RlLmtleXdvcmRzW2NsYXNzTmFtZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUua2V5d29yZHMgPSBjb21waWxlZF9rZXl3b3JkcztcbiAgICAgIH1cbiAgICAgIG1vZGUubGV4ZW1lc1JlID0gbGFuZ1JlKG1vZGUubGV4ZW1lcyB8fCAvXFx3Ky8sIHRydWUpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChtb2RlLmJlZ2luS2V5d29yZHMpIHtcbiAgICAgICAgICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKVxcXFxiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUuYmVnaW4pXG4gICAgICAgICAgbW9kZS5iZWdpbiA9IC9cXEJ8XFxiLztcbiAgICAgICAgbW9kZS5iZWdpblJlID0gbGFuZ1JlKG1vZGUuYmVnaW4pO1xuICAgICAgICBpZiAoIW1vZGUuZW5kICYmICFtb2RlLmVuZHNXaXRoUGFyZW50KVxuICAgICAgICAgIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgICBpZiAobW9kZS5lbmQpXG4gICAgICAgICAgbW9kZS5lbmRSZSA9IGxhbmdSZShtb2RlLmVuZCk7XG4gICAgICAgIG1vZGUudGVybWluYXRvcl9lbmQgPSByZVN0cihtb2RlLmVuZCkgfHwgJyc7XG4gICAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIHBhcmVudC50ZXJtaW5hdG9yX2VuZClcbiAgICAgICAgICBtb2RlLnRlcm1pbmF0b3JfZW5kICs9IChtb2RlLmVuZCA/ICd8JyA6ICcnKSArIHBhcmVudC50ZXJtaW5hdG9yX2VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmlsbGVnYWwpXG4gICAgICAgIG1vZGUuaWxsZWdhbFJlID0gbGFuZ1JlKG1vZGUuaWxsZWdhbCk7XG4gICAgICBpZiAobW9kZS5yZWxldmFuY2UgPT0gbnVsbClcbiAgICAgICAgbW9kZS5yZWxldmFuY2UgPSAxO1xuICAgICAgaWYgKCFtb2RlLmNvbnRhaW5zKSB7XG4gICAgICAgIG1vZGUuY29udGFpbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG1vZGUuY29udGFpbnMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBtb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRfbW9kZShjID09PSAnc2VsZicgPyBtb2RlIDogYylcbiAgICAgIH0pKTtcbiAgICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaChmdW5jdGlvbihjKSB7Y29tcGlsZU1vZGUoYywgbW9kZSk7fSk7XG5cbiAgICAgIGlmIChtb2RlLnN0YXJ0cykge1xuICAgICAgICBjb21waWxlTW9kZShtb2RlLnN0YXJ0cywgcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlcm1pbmF0b3JzID1cbiAgICAgICAgbW9kZS5jb250YWlucy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjLmJlZ2luS2V5d29yZHMgPyAnXFxcXC4/KCcgKyBjLmJlZ2luICsgJylcXFxcLj8nIDogYy5iZWdpbjtcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbmNhdChbbW9kZS50ZXJtaW5hdG9yX2VuZCwgbW9kZS5pbGxlZ2FsXSlcbiAgICAgICAgLm1hcChyZVN0cilcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIG1vZGUudGVybWluYXRvcnMgPSB0ZXJtaW5hdG9ycy5sZW5ndGggPyBsYW5nUmUodGVybWluYXRvcnMuam9pbignfCcpLCB0cnVlKSA6IHtleGVjOiBmdW5jdGlvbigvKnMqLykge3JldHVybiBudWxsO319O1xuICAgIH1cblxuICAgIGNvbXBpbGVNb2RlKGxhbmd1YWdlKTtcbiAgfVxuXG4gIC8qXG4gIENvcmUgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uLiBBY2NlcHRzIGEgbGFuZ3VhZ2UgbmFtZSwgb3IgYW4gYWxpYXMsIGFuZCBhXG4gIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gIHByb3BlcnRpZXM6XG5cbiAgLSByZWxldmFuY2UgKGludClcbiAgLSB2YWx1ZSAoYW4gSFRNTCBzdHJpbmcgd2l0aCBoaWdobGlnaHRpbmcgbWFya3VwKVxuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodChuYW1lLCB2YWx1ZSwgaWdub3JlX2lsbGVnYWxzLCBjb250aW51YXRpb24pIHtcblxuICAgIGZ1bmN0aW9uIHN1Yk1vZGUobGV4ZW1lLCBtb2RlKSB7XG4gICAgICB2YXIgaSwgbGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBtb2RlLmNvbnRhaW5zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0UmUobW9kZS5jb250YWluc1tpXS5iZWdpblJlLCBsZXhlbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGUuY29udGFpbnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZk1vZGUobW9kZSwgbGV4ZW1lKSB7XG4gICAgICBpZiAodGVzdFJlKG1vZGUuZW5kUmUsIGxleGVtZSkpIHtcbiAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgIG1vZGUgPSBtb2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIGxleGVtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJbGxlZ2FsKGxleGVtZSwgbW9kZSkge1xuICAgICAgcmV0dXJuICFpZ25vcmVfaWxsZWdhbHMgJiYgdGVzdFJlKG1vZGUuaWxsZWdhbFJlLCBsZXhlbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXdvcmRNYXRjaChtb2RlLCBtYXRjaCkge1xuICAgICAgdmFyIG1hdGNoX3N0ciA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICByZXR1cm4gbW9kZS5rZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShtYXRjaF9zdHIpICYmIG1vZGUua2V5d29yZHNbbWF0Y2hfc3RyXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFNwYW4oY2xhc3NuYW1lLCBpbnNpZGVTcGFuLCBsZWF2ZU9wZW4sIG5vUHJlZml4KSB7XG4gICAgICB2YXIgY2xhc3NQcmVmaXggPSBub1ByZWZpeCA/ICcnIDogb3B0aW9ucy5jbGFzc1ByZWZpeCxcbiAgICAgICAgICBvcGVuU3BhbiAgICA9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc1ByZWZpeCxcbiAgICAgICAgICBjbG9zZVNwYW4gICA9IGxlYXZlT3BlbiA/ICcnIDogc3BhbkVuZFRhZ1xuXG4gICAgICBvcGVuU3BhbiArPSBjbGFzc25hbWUgKyAnXCI+JztcblxuICAgICAgcmV0dXJuIG9wZW5TcGFuICsgaW5zaWRlU3BhbiArIGNsb3NlU3BhbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzS2V5d29yZHMoKSB7XG4gICAgICB2YXIga2V5d29yZF9tYXRjaCwgbGFzdF9pbmRleCwgbWF0Y2gsIHJlc3VsdDtcblxuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpXG4gICAgICAgIHJldHVybiBlc2NhcGUobW9kZV9idWZmZXIpO1xuXG4gICAgICByZXN1bHQgPSAnJztcbiAgICAgIGxhc3RfaW5kZXggPSAwO1xuICAgICAgdG9wLmxleGVtZXNSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1lc1JlLmV4ZWMobW9kZV9idWZmZXIpO1xuXG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0ICs9IGVzY2FwZShtb2RlX2J1ZmZlci5zdWJzdHJpbmcobGFzdF9pbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAga2V5d29yZF9tYXRjaCA9IGtleXdvcmRNYXRjaCh0b3AsIG1hdGNoKTtcbiAgICAgICAgaWYgKGtleXdvcmRfbWF0Y2gpIHtcbiAgICAgICAgICByZWxldmFuY2UgKz0ga2V5d29yZF9tYXRjaFsxXTtcbiAgICAgICAgICByZXN1bHQgKz0gYnVpbGRTcGFuKGtleXdvcmRfbWF0Y2hbMF0sIGVzY2FwZShtYXRjaFswXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGUobWF0Y2hbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfaW5kZXggPSB0b3AubGV4ZW1lc1JlLmxhc3RJbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1lc1JlLmV4ZWMobW9kZV9idWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZShtb2RlX2J1ZmZlci5zdWJzdHIobGFzdF9pbmRleCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnO1xuICAgICAgaWYgKGV4cGxpY2l0ICYmICFsYW5ndWFnZXNbdG9wLnN1Ykxhbmd1YWdlXSkge1xuICAgICAgICByZXR1cm4gZXNjYXBlKG1vZGVfYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGV4cGxpY2l0ID9cbiAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlX2J1ZmZlciwgdHJ1ZSwgY29udGludWF0aW9uc1t0b3Auc3ViTGFuZ3VhZ2VdKSA6XG4gICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0QXV0byhtb2RlX2J1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIC8vIENvdW50aW5nIGVtYmVkZGVkIGxhbmd1YWdlIHNjb3JlIHRvd2FyZHMgdGhlIGhvc3QgbGFuZ3VhZ2UgbWF5IGJlIGRpc2FibGVkXG4gICAgICAvLyB3aXRoIHplcm9pbmcgdGhlIGNvbnRhaW5pbmcgbW9kZSByZWxldmFuY2UuIFVzZWNhc2UgaW4gcG9pbnQgaXMgTWFya2Rvd24gdGhhdFxuICAgICAgLy8gYWxsb3dzIFhNTCBldmVyeXdoZXJlIGFuZCBtYWtlcyBldmVyeSBYTUwgc25pcHBldCB0byBoYXZlIGEgbXVjaCBsYXJnZXIgTWFya2Rvd25cbiAgICAgIC8vIHNjb3JlLlxuICAgICAgaWYgKHRvcC5yZWxldmFuY2UgPiAwKSB7XG4gICAgICAgIHJlbGV2YW5jZSArPSByZXN1bHQucmVsZXZhbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGxpY2l0KSB7XG4gICAgICAgIGNvbnRpbnVhdGlvbnNbdG9wLnN1Ykxhbmd1YWdlXSA9IHJlc3VsdC50b3A7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRTcGFuKHJlc3VsdC5sYW5ndWFnZSwgcmVzdWx0LnZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0J1ZmZlcigpIHtcbiAgICAgIHJlc3VsdCArPSAodG9wLnN1Ykxhbmd1YWdlICE9IG51bGwgPyBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSA6IHByb2Nlc3NLZXl3b3JkcygpKTtcbiAgICAgIG1vZGVfYnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnROZXdNb2RlKG1vZGUpIHtcbiAgICAgIHJlc3VsdCArPSBtb2RlLmNsYXNzTmFtZT8gYnVpbGRTcGFuKG1vZGUuY2xhc3NOYW1lLCAnJywgdHJ1ZSk6ICcnO1xuICAgICAgdG9wID0gT2JqZWN0LmNyZWF0ZShtb2RlLCB7cGFyZW50OiB7dmFsdWU6IHRvcH19KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGV4ZW1lKGJ1ZmZlciwgbGV4ZW1lKSB7XG5cbiAgICAgIG1vZGVfYnVmZmVyICs9IGJ1ZmZlcjtcblxuICAgICAgaWYgKGxleGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfbW9kZSA9IHN1Yk1vZGUobGV4ZW1lLCB0b3ApO1xuICAgICAgaWYgKG5ld19tb2RlKSB7XG4gICAgICAgIGlmIChuZXdfbW9kZS5za2lwKSB7XG4gICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdfbW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICAgIGlmICghbmV3X21vZGUucmV0dXJuQmVnaW4gJiYgIW5ld19tb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0TmV3TW9kZShuZXdfbW9kZSwgbGV4ZW1lKTtcbiAgICAgICAgcmV0dXJuIG5ld19tb2RlLnJldHVybkJlZ2luID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmRfbW9kZSA9IGVuZE9mTW9kZSh0b3AsIGxleGVtZSk7XG4gICAgICBpZiAoZW5kX21vZGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRvcDtcbiAgICAgICAgaWYgKG9yaWdpbi5za2lwKSB7XG4gICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghKG9yaWdpbi5yZXR1cm5FbmQgfHwgb3JpZ2luLmV4Y2x1ZGVFbmQpKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgICBpZiAob3JpZ2luLmV4Y2x1ZGVFbmQpIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHRvcC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzcGFuRW5kVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRvcC5za2lwKSB7XG4gICAgICAgICAgICByZWxldmFuY2UgKz0gdG9wLnJlbGV2YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAodG9wICE9PSBlbmRfbW9kZS5wYXJlbnQpO1xuICAgICAgICBpZiAoZW5kX21vZGUuc3RhcnRzKSB7XG4gICAgICAgICAgc3RhcnROZXdNb2RlKGVuZF9tb2RlLnN0YXJ0cywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4ucmV0dXJuRW5kID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lsbGVnYWwobGV4ZW1lLCB0b3ApKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgbGV4ZW1lIFwiJyArIGxleGVtZSArICdcIiBmb3IgbW9kZSBcIicgKyAodG9wLmNsYXNzTmFtZSB8fCAnPHVubmFtZWQ+JykgKyAnXCInKTtcblxuICAgICAgLypcbiAgICAgIFBhcnNlciBzaG91bGQgbm90IHJlYWNoIHRoaXMgcG9pbnQgYXMgYWxsIHR5cGVzIG9mIGxleGVtZXMgc2hvdWxkIGJlIGNhdWdodFxuICAgICAgZWFybGllciwgYnV0IGlmIGl0IGRvZXMgZHVlIHRvIHNvbWUgYnVnIG1ha2Ugc3VyZSBpdCBhZHZhbmNlcyBhdCBsZWFzdCBvbmVcbiAgICAgIGNoYXJhY3RlciBmb3J3YXJkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcGluZy5cbiAgICAgICovXG4gICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICByZXR1cm4gbGV4ZW1lLmxlbmd0aCB8fCAxO1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZTogXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSk7XG4gICAgdmFyIHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBsYW5ndWFnZTtcbiAgICB2YXIgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICB2YXIgcmVzdWx0ID0gJycsIGN1cnJlbnQ7XG4gICAgZm9yKGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQgIT09IGxhbmd1YWdlOyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmNsYXNzTmFtZSkge1xuICAgICAgICByZXN1bHQgPSBidWlsZFNwYW4oY3VycmVudC5jbGFzc05hbWUsICcnLCB0cnVlKSArIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1vZGVfYnVmZmVyID0gJyc7XG4gICAgdmFyIHJlbGV2YW5jZSA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaCwgY291bnQsIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRvcC50ZXJtaW5hdG9ycy5sYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AudGVybWluYXRvcnMuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvdW50ID0gcHJvY2Vzc0xleGVtZSh2YWx1ZS5zdWJzdHJpbmcoaW5kZXgsIG1hdGNoLmluZGV4KSwgbWF0Y2hbMF0pO1xuICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgY291bnQ7XG4gICAgICB9XG4gICAgICBwcm9jZXNzTGV4ZW1lKHZhbHVlLnN1YnN0cihpbmRleCkpO1xuICAgICAgZm9yKGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQucGFyZW50OyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHsgLy8gY2xvc2UgZGFuZ2xpbmcgbW9kZXNcbiAgICAgICAgaWYgKGN1cnJlbnQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHNwYW5FbmRUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBsYW5ndWFnZTogbmFtZSxcbiAgICAgICAgdG9wOiB0b3BcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubWVzc2FnZSAmJiBlLm1lc3NhZ2UuaW5kZXhPZignSWxsZWdhbCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICBIaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24uIEFjY2VwdHMgYSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0b1xuICBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gbGFuZ3VhZ2UgKGRldGVjdGVkIGxhbmd1YWdlKVxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG4gIC0gc2Vjb25kX2Jlc3QgKG9iamVjdCB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBmb3Igc2Vjb25kLWJlc3QgaGV1cmlzdGljYWxseVxuICAgIGRldGVjdGVkIGxhbmd1YWdlLCBtYXkgYmUgYWJzZW50KVxuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG8odGV4dCwgbGFuZ3VhZ2VTdWJzZXQpIHtcbiAgICBsYW5ndWFnZVN1YnNldCA9IGxhbmd1YWdlU3Vic2V0IHx8IG9wdGlvbnMubGFuZ3VhZ2VzIHx8IG9iamVjdEtleXMobGFuZ3VhZ2VzKTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgdmFsdWU6IGVzY2FwZSh0ZXh0KVxuICAgIH07XG4gICAgdmFyIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgIGxhbmd1YWdlU3Vic2V0LmZpbHRlcihnZXRMYW5ndWFnZSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGhpZ2hsaWdodChuYW1lLCB0ZXh0LCBmYWxzZSk7XG4gICAgICBjdXJyZW50Lmxhbmd1YWdlID0gbmFtZTtcbiAgICAgIGlmIChjdXJyZW50LnJlbGV2YW5jZSA+IHNlY29uZF9iZXN0LnJlbGV2YW5jZSkge1xuICAgICAgICBzZWNvbmRfYmVzdCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5yZWxldmFuY2UgPiByZXN1bHQucmVsZXZhbmNlKSB7XG4gICAgICAgIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzZWNvbmRfYmVzdC5sYW5ndWFnZSkge1xuICAgICAgcmVzdWx0LnNlY29uZF9iZXN0ID0gc2Vjb25kX2Jlc3Q7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICBQb3N0LXByb2Nlc3Npbmcgb2YgdGhlIGhpZ2hsaWdodGVkIG1hcmt1cDpcblxuICAtIHJlcGxhY2UgVEFCcyB3aXRoIHNvbWV0aGluZyBtb3JlIHVzZWZ1bFxuICAtIHJlcGxhY2UgcmVhbCBsaW5lLWJyZWFrcyB3aXRoICc8YnI+JyBmb3Igbm9uLXByZSBjb250YWluZXJzXG5cbiAgKi9cbiAgZnVuY3Rpb24gZml4TWFya3VwKHZhbHVlKSB7XG4gICAgcmV0dXJuICEob3B0aW9ucy50YWJSZXBsYWNlIHx8IG9wdGlvbnMudXNlQlIpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHZhbHVlLnJlcGxhY2UoZml4TWFya3VwUmUsIGZ1bmN0aW9uKG1hdGNoLCBwMSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUJSICYmIG1hdGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICc8YnI+JztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFiUmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHAxLnJlcGxhY2UoL1xcdC9nLCBvcHRpb25zLnRhYlJlcGxhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lKHByZXZDbGFzc05hbWUsIGN1cnJlbnRMYW5nLCByZXN1bHRMYW5nKSB7XG4gICAgdmFyIGxhbmd1YWdlID0gY3VycmVudExhbmcgPyBhbGlhc2VzW2N1cnJlbnRMYW5nXSA6IHJlc3VsdExhbmcsXG4gICAgICAgIHJlc3VsdCAgID0gW3ByZXZDbGFzc05hbWUudHJpbSgpXTtcblxuICAgIGlmICghcHJldkNsYXNzTmFtZS5tYXRjaCgvXFxiaGxqc1xcYi8pKSB7XG4gICAgICByZXN1bHQucHVzaCgnaGxqcycpO1xuICAgIH1cblxuICAgIGlmIChwcmV2Q2xhc3NOYW1lLmluZGV4T2YobGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgcmVzdWx0LnB1c2gobGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGEgRE9NIG5vZGUgY29udGFpbmluZyBjb2RlLiBBY2NlcHRzIGEgRE9NIG5vZGUgYW5kXG4gIHR3byBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBmaXhNYXJrdXAuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEJsb2NrKGJsb2NrKSB7XG4gICAgdmFyIG5vZGUsIG9yaWdpbmFsU3RyZWFtLCByZXN1bHQsIHJlc3VsdE5vZGUsIHRleHQ7XG4gICAgdmFyIGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShibG9jayk7XG5cbiAgICBpZiAoaXNOb3RIaWdobGlnaHRlZChsYW5ndWFnZSkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLnVzZUJSKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2RpdicpO1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBibG9jay5pbm5lckhUTUwucmVwbGFjZSgvXFxuL2csICcnKS5yZXBsYWNlKC88YnJbIFxcL10qPi9nLCAnXFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBibG9jaztcbiAgICB9XG4gICAgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgcmVzdWx0ID0gbGFuZ3VhZ2UgPyBoaWdobGlnaHQobGFuZ3VhZ2UsIHRleHQsIHRydWUpIDogaGlnaGxpZ2h0QXV0byh0ZXh0KTtcblxuICAgIG9yaWdpbmFsU3RyZWFtID0gbm9kZVN0cmVhbShub2RlKTtcbiAgICBpZiAob3JpZ2luYWxTdHJlYW0ubGVuZ3RoKSB7XG4gICAgICByZXN1bHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2RpdicpO1xuICAgICAgcmVzdWx0Tm9kZS5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXN1bHQudmFsdWUgPSBtZXJnZVN0cmVhbXMob3JpZ2luYWxTdHJlYW0sIG5vZGVTdHJlYW0ocmVzdWx0Tm9kZSksIHRleHQpO1xuICAgIH1cbiAgICByZXN1bHQudmFsdWUgPSBmaXhNYXJrdXAocmVzdWx0LnZhbHVlKTtcblxuICAgIGJsb2NrLmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICBibG9jay5jbGFzc05hbWUgPSBidWlsZENsYXNzTmFtZShibG9jay5jbGFzc05hbWUsIGxhbmd1YWdlLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIGJsb2NrLnJlc3VsdCA9IHtcbiAgICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgICByZTogcmVzdWx0LnJlbGV2YW5jZVxuICAgIH07XG4gICAgaWYgKHJlc3VsdC5zZWNvbmRfYmVzdCkge1xuICAgICAgYmxvY2suc2Vjb25kX2Jlc3QgPSB7XG4gICAgICAgIGxhbmd1YWdlOiByZXN1bHQuc2Vjb25kX2Jlc3QubGFuZ3VhZ2UsXG4gICAgICAgIHJlOiByZXN1bHQuc2Vjb25kX2Jlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIFVwZGF0ZXMgaGlnaGxpZ2h0LmpzIGdsb2JhbCBvcHRpb25zIHdpdGggdmFsdWVzIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBhbiBvYmplY3QuXG4gICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZSh1c2VyX29wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gaW5oZXJpdChvcHRpb25zLCB1c2VyX29wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gYWxsIDxwcmU+PGNvZGU+Li48L2NvZGU+PC9wcmU+IGJsb2NrcyBvbiBhIHBhZ2UuXG4gICovXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmcoKSB7XG4gICAgaWYgKGluaXRIaWdobGlnaHRpbmcuY2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGluaXRIaWdobGlnaHRpbmcuY2FsbGVkID0gdHJ1ZTtcblxuICAgIHZhciBibG9ja3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgIEFycmF5UHJvdG8uZm9yRWFjaC5jYWxsKGJsb2NrcywgaGlnaGxpZ2h0QmxvY2spO1xuICB9XG5cbiAgLypcbiAgQXR0YWNoZXMgaGlnaGxpZ2h0aW5nIHRvIHRoZSBwYWdlIGxvYWQgZXZlbnQuXG4gICovXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaW5pdEhpZ2hsaWdodGluZywgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMYW5ndWFnZShuYW1lLCBsYW5ndWFnZSkge1xuICAgIHZhciBsYW5nID0gbGFuZ3VhZ2VzW25hbWVdID0gbGFuZ3VhZ2UoaGxqcyk7XG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgbGFuZy5hbGlhc2VzLmZvckVhY2goZnVuY3Rpb24oYWxpYXMpIHthbGlhc2VzW2FsaWFzXSA9IG5hbWU7fSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlzdExhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhsYW5ndWFnZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UobmFtZSkge1xuICAgIG5hbWUgPSAobmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbGFuZ3VhZ2VzW25hbWVdIHx8IGxhbmd1YWdlc1thbGlhc2VzW25hbWVdXTtcbiAgfVxuXG4gIC8qIEludGVyZmFjZSBkZWZpbml0aW9uICovXG5cbiAgaGxqcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gIGhsanMuaGlnaGxpZ2h0QXV0byA9IGhpZ2hsaWdodEF1dG87XG4gIGhsanMuZml4TWFya3VwID0gZml4TWFya3VwO1xuICBobGpzLmhpZ2hsaWdodEJsb2NrID0gaGlnaGxpZ2h0QmxvY2s7XG4gIGhsanMuY29uZmlndXJlID0gY29uZmlndXJlO1xuICBobGpzLmluaXRIaWdobGlnaHRpbmcgPSBpbml0SGlnaGxpZ2h0aW5nO1xuICBobGpzLmluaXRIaWdobGlnaHRpbmdPbkxvYWQgPSBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkO1xuICBobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UgPSByZWdpc3Rlckxhbmd1YWdlO1xuICBobGpzLmxpc3RMYW5ndWFnZXMgPSBsaXN0TGFuZ3VhZ2VzO1xuICBobGpzLmdldExhbmd1YWdlID0gZ2V0TGFuZ3VhZ2U7XG4gIGhsanMuaW5oZXJpdCA9IGluaGVyaXQ7XG5cbiAgLy8gQ29tbW9uIHJlZ2V4cHNcbiAgaGxqcy5JREVOVF9SRSA9ICdbYS16QS1aXVxcXFx3Kic7XG4gIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSA9ICdbYS16QS1aX11cXFxcdyonO1xuICBobGpzLk5VTUJFUl9SRSA9ICdcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKyk/JztcbiAgaGxqcy5DX05VTUJFUl9SRSA9ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XSt8KFxcXFxiXFxcXGQrKFxcXFwuXFxcXGQqKT98XFxcXC5cXFxcZCspKFtlRV1bLStdP1xcXFxkKyk/KSc7IC8vIDB4Li4uLCAwLi4uLCBkZWNpbWFsLCBmbG9hdFxuICBobGpzLkJJTkFSWV9OVU1CRVJfUkUgPSAnXFxcXGIoMGJbMDFdKyknOyAvLyAwYi4uLlxuICBobGpzLlJFX1NUQVJURVJTX1JFID0gJyF8IT18IT09fCV8JT18JnwmJnwmPXxcXFxcKnxcXFxcKj18XFxcXCt8XFxcXCs9fCx8LXwtPXwvPXwvfDp8O3w8PHw8PD18PD18PHw9PT18PT18PXw+Pj49fD4+PXw+PXw+Pj58Pj58PnxcXFxcP3xcXFxcW3xcXFxce3xcXFxcKHxcXFxcXnxcXFxcXj18XFxcXHx8XFxcXHw9fFxcXFx8XFxcXHx8fic7XG5cbiAgLy8gQ29tbW9uIG1vZGVzXG4gIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSA9IHtcbiAgICBiZWdpbjogJ1xcXFxcXFxcW1xcXFxzXFxcXFNdJywgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQVBPU19TVFJJTkdfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnXFwnJyxcbiAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICB9O1xuICBobGpzLlFVT1RFX1NUUklOR19NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICB9O1xuICBobGpzLlBIUkFTQUxfV09SRFNfTU9ERSA9IHtcbiAgICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xuICB9O1xuICBobGpzLkNPTU1FTlQgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCwgaW5oZXJpdHMpIHtcbiAgICB2YXIgbW9kZSA9IGhsanMuaW5oZXJpdChcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGJlZ2luOiBiZWdpbiwgZW5kOiBlbmQsXG4gICAgICAgIGNvbnRhaW5zOiBbXVxuICAgICAgfSxcbiAgICAgIGluaGVyaXRzIHx8IHt9XG4gICAgKTtcbiAgICBtb2RlLmNvbnRhaW5zLnB1c2goaGxqcy5QSFJBU0FMX1dPUkRTX01PREUpO1xuICAgIG1vZGUuY29udGFpbnMucHVzaCh7XG4gICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgYmVnaW46ICcoPzpUT0RPfEZJWE1FfE5PVEV8QlVHfFhYWCk6JyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0pO1xuICAgIHJldHVybiBtb2RlO1xuICB9O1xuICBobGpzLkNfTElORV9DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJy8vJywgJyQnKTtcbiAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnL1xcXFwqJywgJ1xcXFwqLycpO1xuICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFID0gaGxqcy5DT01NRU5UKCcjJywgJyQnKTtcbiAgaGxqcy5OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLk5VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5DX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQklOQVJZX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuQklOQVJZX05VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5DU1NfTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5OVU1CRVJfUkUgKyAnKCcgK1xuICAgICAgJyV8ZW18ZXh8Y2h8cmVtJyAgK1xuICAgICAgJ3x2d3x2aHx2bWlufHZtYXgnICtcbiAgICAgICd8Y218bW18aW58cHR8cGN8cHgnICtcbiAgICAgICd8ZGVnfGdyYWR8cmFkfHR1cm4nICtcbiAgICAgICd8c3xtcycgK1xuICAgICAgJ3xIenxrSHonICtcbiAgICAgICd8ZHBpfGRwY218ZHBweCcgK1xuICAgICAgJyk/JyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5SRUdFWFBfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdyZWdleHAnLFxuICAgIGJlZ2luOiAvXFwvLywgZW5kOiAvXFwvW2dpbXV5XSovLFxuICAgIGlsbGVnYWw6IC9cXG4vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLywgZW5kOiAvXFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGhsanMuVElUTEVfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgYmVnaW46IGhsanMuSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLk1FVEhPRF9HVUFSRCA9IHtcbiAgICAvLyBleGNsdWRlcyBtZXRob2QgbmFtZXMgZnJvbSBrZXl3b3JkIHByb2Nlc3NpbmdcbiAgICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICByZXR1cm4gaGxqcztcbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2hpZ2hsaWdodC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW0EtWmEteiRfXVswLTlBLVphLXokX10qJztcbiAgdmFyIEtFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6XG4gICAgICAnaW4gb2YgaWYgZm9yIHdoaWxlIGZpbmFsbHkgdmFyIG5ldyBmdW5jdGlvbiBkbyByZXR1cm4gdm9pZCBlbHNlIGJyZWFrIGNhdGNoICcgK1xuICAgICAgJ2luc3RhbmNlb2Ygd2l0aCB0aHJvdyBjYXNlIGRlZmF1bHQgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHR5cGVvZiBkZWxldGUgJyArXG4gICAgICAnbGV0IHlpZWxkIGNvbnN0IGV4cG9ydCBzdXBlciBkZWJ1Z2dlciBhcyBhc3luYyBhd2FpdCBzdGF0aWMgJyArXG4gICAgICAvLyBFQ01BU2NyaXB0IDYgbW9kdWxlcyBpbXBvcnRcbiAgICAgICdpbXBvcnQgZnJvbSBhcydcbiAgICAsXG4gICAgbGl0ZXJhbDpcbiAgICAgICd0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkIE5hTiBJbmZpbml0eScsXG4gICAgYnVpbHRfaW46XG4gICAgICAnZXZhbCBpc0Zpbml0ZSBpc05hTiBwYXJzZUZsb2F0IHBhcnNlSW50IGRlY29kZVVSSSBkZWNvZGVVUklDb21wb25lbnQgJyArXG4gICAgICAnZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBlc2NhcGUgdW5lc2NhcGUgT2JqZWN0IEZ1bmN0aW9uIEJvb2xlYW4gRXJyb3IgJyArXG4gICAgICAnRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdG9wSXRlcmF0aW9uIFN5bnRheEVycm9yICcgK1xuICAgICAgJ1R5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgRmxvYXQzMkFycmF5ICcgK1xuICAgICAgJ0Zsb2F0NjRBcnJheSBJbnQxNkFycmF5IEludDMyQXJyYXkgSW50OEFycmF5IFVpbnQxNkFycmF5IFVpbnQzMkFycmF5ICcgK1xuICAgICAgJ1VpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBJbnRsIGFyZ3VtZW50cyByZXF1aXJlICcgK1xuICAgICAgJ21vZHVsZSBjb25zb2xlIHdpbmRvdyBkb2N1bWVudCBTeW1ib2wgU2V0IE1hcCBXZWFrU2V0IFdlYWtNYXAgUHJveHkgUmVmbGVjdCAnICtcbiAgICAgICdQcm9taXNlJ1xuICB9O1xuICB2YXIgRVhQUkVTU0lPTlM7XG4gIHZhciBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgeyBiZWdpbjogJ1xcXFxiKDBbYkJdWzAxXSspJyB9LFxuICAgICAgeyBiZWdpbjogJ1xcXFxiKDBbb09dWzAtN10rKScgfSxcbiAgICAgIHsgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUgfVxuICAgIF0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICdcXFxcJFxcXFx7JywgZW5kOiAnXFxcXH0nLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW10gIC8vIGRlZmluZWQgbGF0ZXJcbiAgfTtcbiAgdmFyIFRFTVBMQVRFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnYCcsIGVuZDogJ2AnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBTVUJTVFxuICAgIF1cbiAgfTtcbiAgU1VCU1QuY29udGFpbnMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIE5VTUJFUixcbiAgICBobGpzLlJFR0VYUF9NT0RFXG4gIF1cbiAgdmFyIFBBUkFNU19DT05UQUlOUyA9IFNVQlNULmNvbnRhaW5zLmNvbmNhdChbXG4gICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBobGpzLkNfTElORV9DT01NRU5UX01PREVcbiAgXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCddLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvXiMhLywgZW5kOiAvJC9cbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgVEVNUExBVEVfU1RSSU5HLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIE5VTUJFUixcbiAgICAgIHsgLy8gb2JqZWN0IGF0dHIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAvW3ssXVxccyovLCByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IElERU5UX1JFICsgJ1xcXFxzKjonLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbe2NsYXNzTmFtZTogJ2F0dHInLCBiZWdpbjogSURFTlRfUkUsIHJlbGV2YW5jZTogMH1dXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLlJFR0VYUF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIGJlZ2luOiAnKFxcXFwoLio/XFxcXCl8JyArIElERU5UX1JFICsgJylcXFxccyo9PicsIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgZW5kOiAnXFxcXHMqPT4nLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IElERU5UX1JFXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKFxccypcXCkvLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBFNFggLyBKU1hcbiAgICAgICAgICAgIGJlZ2luOiAvPC8sIGVuZDogLyhcXC9cXHcrfFxcdytcXC8pPi8sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7YmVnaW46IC88XFx3K1xccypcXC8+Lywgc2tpcDogdHJ1ZX0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLzxcXHcrLywgZW5kOiAvKFxcL1xcdyt8XFx3K1xcLyk+Lywgc2tpcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgICAge2JlZ2luOiAvPFxcdytcXHMqXFwvPi8sIHNraXA6IHRydWV9LFxuICAgICAgICAgICAgICAgICAgJ3NlbGYnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2Z1bmN0aW9uJywgZW5kOiAvXFx7LywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7YmVnaW46IElERU5UX1JFfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpbGxlZ2FsOiAvXFxbfCUvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9LFxuICAgICAgaGxqcy5NRVRIT0RfR1VBUkQsXG4gICAgICB7IC8vIEVTNiBjbGFzc1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdjbGFzcycsIGVuZDogL1t7Oz1dLywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgaWxsZWdhbDogL1s6XCJcXFtcXF1dLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7YmVnaW5LZXl3b3JkczogJ2V4dGVuZHMnfSxcbiAgICAgICAgICBobGpzLlVOREVSU0NPUkVfVElUTEVfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbktleXdvcmRzOiAnY29uc3RydWN0b3InLCBlbmQ6IC9cXHsvLCBleGNsdWRlRW5kOiB0cnVlXG4gICAgICB9XG4gICAgXSxcbiAgICBpbGxlZ2FsOiAvIyg/ISEpL1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvamF2YXNjcmlwdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW2EtekEtWi1dW2EtekEtWjAtOV8tXSonO1xuICB2YXIgUlVMRSA9IHtcbiAgICBiZWdpbjogL1tBLVpcXF9cXC5cXC1dK1xccyo6LywgcmV0dXJuQmVnaW46IHRydWUsIGVuZDogJzsnLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICBiZWdpbjogL1xcUy8sIGVuZDogJzonLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWdpbjogL1tcXHctXStcXCgvLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdidWlsdF9pbicsXG4gICAgICAgICAgICAgICAgICBiZWdpbjogL1tcXHctXSsvXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBobGpzLkNTU19OVU1CRVJfTU9ERSxcbiAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLCBiZWdpbjogJyNbMC05QS1GYS1mXSsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtZXRhJywgYmVnaW46ICchaW1wb3J0YW50J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgaWxsZWdhbDogL1s9XFwvfCdcXCRdLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItaWQnLCBiZWdpbjogLyNbQS1aYS16MC05Xy1dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWNsYXNzJywgYmVnaW46IC9cXC5bQS1aYS16MC05Xy1dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWF0dHInLFxuICAgICAgICBiZWdpbjogL1xcWy8sIGVuZDogL1xcXS8sXG4gICAgICAgIGlsbGVnYWw6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItcHNldWRvJyxcbiAgICAgICAgYmVnaW46IC86KDopP1thLXpBLVowLTlcXF9cXC1cXCtcXChcXClcIicuXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ0AoZm9udC1mYWNlfHBhZ2UpJyxcbiAgICAgICAgbGV4ZW1lczogJ1thLXotXSsnLFxuICAgICAgICBrZXl3b3JkczogJ2ZvbnQtZmFjZSBwYWdlJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAJywgZW5kOiAnW3s7XScsIC8vIGF0X3J1bGUgZWF0aW5nIGZpcnN0IFwie1wiIGlzIGEgZ29vZCB0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBkb2VzbuKAmXQgbGV0IGl0IHRvIGJlIHBhcnNlZCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBydWxlIHNldCBidXQgaW5zdGVhZCBkcm9wcyBwYXJzZXIgaW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgbW9kZSB3aGljaCBpcyBob3cgaXQgc2hvdWxkIGJlLlxuICAgICAgICBpbGxlZ2FsOiAvOi8sIC8vIGJyZWFrIG9uIExlc3MgdmFyaWFibGVzIEB2YXI6IC4uLlxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2tleXdvcmQnLFxuICAgICAgICAgICAgYmVnaW46IC9cXHcrL1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXHMvLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSwgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXRhZycsIGJlZ2luOiBJREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICAgICAgaWxsZWdhbDogL1xcUy8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBSVUxFLFxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBYTUxfSURFTlRfUkUgPSAnW0EtWmEtejAtOVxcXFwuXzotXSsnO1xuICB2YXIgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7YmVnaW46IC9cIi8sIGVuZDogL1wiL30sXG4gICAgICAgICAgICAgIHtiZWdpbjogLycvLCBlbmQ6IC8nL30sXG4gICAgICAgICAgICAgIHtiZWdpbjogL1teXFxzXCInPTw+YF0rL31cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIHJldHVybiB7XG4gICAgYWxpYXNlczogWydodG1sJywgJ3hodG1sJywgJ3JzcycsICdhdG9tJywgJ3hqYicsICd4c2QnLCAneHNsJywgJ3BsaXN0J10sXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46ICc8IURPQ1RZUEUnLCBlbmQ6ICc+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICdcXFxcWycsIGVuZDogJ1xcXFxdJ31dXG4gICAgICB9LFxuICAgICAgaGxqcy5DT01NRU5UKFxuICAgICAgICAnPCEtLScsXG4gICAgICAgICctLT4nLFxuICAgICAgICB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgICB9XG4gICAgICApLFxuICAgICAge1xuICAgICAgICBiZWdpbjogJzxcXFxcIVxcXFxbQ0RBVEFcXFxcWycsIGVuZDogJ1xcXFxdXFxcXF0+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC88XFw/KHBocCk/LywgZW5kOiAvXFw/Pi8sXG4gICAgICAgIHN1Ykxhbmd1YWdlOiAncGhwJyxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICcvXFxcXConLCBlbmQ6ICdcXFxcKi8nLCBza2lwOiB0cnVlfV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBsb29rYWhlYWQgcGF0dGVybiAoPz0uLi4pIGVuc3VyZXMgdGhhdCAnYmVnaW4nIG9ubHkgbWF0Y2hlc1xuICAgICAgICAnPHN0eWxlJyBhcyBhIHNpbmdsZSB3b3JkLCBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2Ugb3IgYW5cbiAgICAgICAgZW5kaW5nIGJyYWtldC4gVGhlICckJyBpcyBuZWVkZWQgZm9yIHRoZSBsZXhlbWUgdG8gYmUgcmVjb2duaXplZFxuICAgICAgICBieSBobGpzLnN1Yk1vZGUoKSB0aGF0IHRlc3RzIGxleGVtZXMgb3V0c2lkZSB0aGUgc3RyZWFtLlxuICAgICAgICAqL1xuICAgICAgICBiZWdpbjogJzxzdHlsZSg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHtuYW1lOiAnc3R5bGUnfSxcbiAgICAgICAgY29udGFpbnM6IFtUQUdfSU5URVJOQUxTXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnPC9zdHlsZT4nLCByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFsnY3NzJywgJ3htbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgPHN0eWxlIHRhZyBhYm91dCB0aGUgbG9va2FoZWFkIHBhdHRlcm5cbiAgICAgICAgYmVnaW46ICc8c2NyaXB0KD89XFxcXHN8PnwkKScsIGVuZDogJz4nLFxuICAgICAgICBrZXl3b3Jkczoge25hbWU6ICdzY3JpcHQnfSxcbiAgICAgICAgY29udGFpbnM6IFtUQUdfSU5URVJOQUxTXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnXFw8XFwvc2NyaXB0XFw+JywgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbJ2FjdGlvbnNjcmlwdCcsICdqYXZhc2NyaXB0JywgJ2hhbmRsZWJhcnMnLCAneG1sJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAge2JlZ2luOiAvPFxcP3htbC8sIGVuZDogL1xcPz4vLCByZWxldmFuY2U6IDEwfSxcbiAgICAgICAgICB7YmVnaW46IC88XFw/XFx3Ky8sIGVuZDogL1xcPz4vfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogJzwvPycsIGVuZDogJy8/PicsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsIGJlZ2luOiAvW15cXC8+PFxcc10rLywgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBUQUdfSU5URVJOQUxTXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFZBUiA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtiZWdpbjogL1xcJFtcXHdcXGQjQF1bXFx3XFxkX10qL30sXG4gICAgICB7YmVnaW46IC9cXCRcXHsoLio/KX0vfVxuICAgIF1cbiAgfTtcbiAgdmFyIFFVT1RFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvXCIvLCBlbmQ6IC9cIi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFZBUixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogL1xcJFxcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgdmFyIEFQT1NfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46IC8nLywgZW5kOiAvJy9cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFsaWFzZXM6IFsnc2gnLCAnenNoJ10sXG4gICAgbGV4ZW1lczogL1xcYi0/W2EtelxcLl9dK1xcYi8sXG4gICAga2V5d29yZHM6IHtcbiAgICAgIGtleXdvcmQ6XG4gICAgICAgICdpZiB0aGVuIGVsc2UgZWxpZiBmaSBmb3Igd2hpbGUgaW4gZG8gZG9uZSBjYXNlIGVzYWMgZnVuY3Rpb24nLFxuICAgICAgbGl0ZXJhbDpcbiAgICAgICAgJ3RydWUgZmFsc2UnLFxuICAgICAgYnVpbHRfaW46XG4gICAgICAgIC8vIFNoZWxsIGJ1aWx0LWluc1xuICAgICAgICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NoZWxsLUJ1aWx0aW4tQ29tbWFuZHMuaHRtbFxuICAgICAgICAnYnJlYWsgY2QgY29udGludWUgZXZhbCBleGVjIGV4aXQgZXhwb3J0IGdldG9wdHMgaGFzaCBwd2QgcmVhZG9ubHkgcmV0dXJuIHNoaWZ0IHRlc3QgdGltZXMgJyArXG4gICAgICAgICd0cmFwIHVtYXNrIHVuc2V0ICcgK1xuICAgICAgICAvLyBCYXNoIGJ1aWx0LWluc1xuICAgICAgICAnYWxpYXMgYmluZCBidWlsdGluIGNhbGxlciBjb21tYW5kIGRlY2xhcmUgZWNobyBlbmFibGUgaGVscCBsZXQgbG9jYWwgbG9nb3V0IG1hcGZpbGUgcHJpbnRmICcgK1xuICAgICAgICAncmVhZCByZWFkYXJyYXkgc291cmNlIHR5cGUgdHlwZXNldCB1bGltaXQgdW5hbGlhcyAnICtcbiAgICAgICAgLy8gU2hlbGwgbW9kaWZpZXJzXG4gICAgICAgICdzZXQgc2hvcHQgJyArXG4gICAgICAgIC8vIFpzaCBidWlsdC1pbnNcbiAgICAgICAgJ2F1dG9sb2FkIGJnIGJpbmRrZXkgYnllIGNhcCBjaGRpciBjbG9uZSBjb21wYXJndW1lbnRzIGNvbXBjYWxsIGNvbXBjdGwgY29tcGRlc2NyaWJlIGNvbXBmaWxlcyAnICtcbiAgICAgICAgJ2NvbXBncm91cHMgY29tcHF1b3RlIGNvbXB0YWdzIGNvbXB0cnkgY29tcHZhbHVlcyBkaXJzIGRpc2FibGUgZGlzb3duIGVjaG90YyBlY2hvdGkgZW11bGF0ZSAnICtcbiAgICAgICAgJ2ZjIGZnIGZsb2F0IGZ1bmN0aW9ucyBnZXRjYXAgZ2V0bG4gaGlzdG9yeSBpbnRlZ2VyIGpvYnMga2lsbCBsaW1pdCBsb2cgbm9nbG9iIHBvcGQgcHJpbnQgJyArXG4gICAgICAgICdwdXNoZCBwdXNobG4gcmVoYXNoIHNjaGVkIHNldGNhcCBzZXRvcHQgc3RhdCBzdXNwZW5kIHR0eWN0bCB1bmZ1bmN0aW9uIHVuaGFzaCB1bmxpbWl0ICcgK1xuICAgICAgICAndW5zZXRvcHQgdmFyZWQgd2FpdCB3aGVuY2Ugd2hlcmUgd2hpY2ggemNvbXBpbGUgemZvcm1hdCB6ZnRwIHpsZSB6bW9kbG9hZCB6cGFyc2VvcHRzIHpwcm9mICcgK1xuICAgICAgICAnenB0eSB6cmVnZXhwYXJzZSB6c29ja2V0IHpzdHlsZSB6dGNwJyxcbiAgICAgIF86XG4gICAgICAgICctbmUgLWVxIC1sdCAtZ3QgLWYgLWQgLWUgLXMgLWwgLWEnIC8vIHJlbGV2YW5jZSBib29zdGVyXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC9eIyFbXlxcbl0rc2hcXHMqJC8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW46IC9cXHdbXFx3XFxkX10qXFxzKlxcKFxccypcXClcXHMqXFx7LyxcbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwge2JlZ2luOiAvXFx3W1xcd1xcZF9dKi99KV0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICBRVU9URV9TVFJJTkcsXG4gICAgICBBUE9TX1NUUklORyxcbiAgICAgIFZBUlxuICAgIF1cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Jhc2guanMiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEludGFjdCB7XG4gICAgX21vdW50KCkge1xuICAgICAgICB0aGlzLiRib3JkZXIgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmJvcmRlcicpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3JkZXIoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQm9yZGVyKCkge1xuICAgICAgICBjb25zdCAkbmF2ID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJy5hY3RpdmUnKTtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBpZiAoJG5hdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSAkbmF2LnBvc2l0aW9uKCkubGVmdDtcbiAgICAgICAgICAgIHdpZHRoID0gJG5hdi5vdXRlcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYm9yZGVyLmFkZENsYXNzKCd0cmFuc2l0aW9uJyk7XG4gICAgICAgIHRoaXMuJGJvcmRlci5jc3Moe3dpZHRoOiB3aWR0aCwgbGVmdDogbGVmdH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhZ2VzL2xheW91dC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MpIHtcbmlmIChtb2R1bGUuaG90KSB7XG4gICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgZGF0YS52ZHQgPSBfX3RoaXM7XG4gICAgICAgIGRhdGEuaXNQYXJlbnQgPSBfX3RoaXMuZGF0YSAhPT0gb2JqO1xuICAgIH0pXG59XG5cbl9WZHQgfHwgKF9WZHQgPSBWZHQpO1xub2JqIHx8IChvYmogPSB7fSk7XG5ibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbnZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG5fX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsXG5fX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG5fc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbl9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbnNlbGYgPSB0aGlzLmRhdGEsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9IHNlbGYgJiYgc2VsZi5fcGFyZW50VGVtcGxhdGVcbnZhciBsYXlvdXQgPSByZXF1aXJlKCcuLi9sYXlvdXQudmR0Jyk7XG5cbnJldHVybiAoZnVuY3Rpb24oYmxvY2tzKSB7XG52YXIgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IGV4dGVuZCh7fSwgYmxvY2tzKSwgX29iaiA9IHsnY2xhc3NOYW1lJzogJ2luZGV4LXBhZ2UnfSB8fCB7fTtcbmlmIChfb2JqLmhhc093blByb3BlcnR5KFwiYXJndW1lbnRzXCIpKSB7IGV4dGVuZChfb2JqLCBfb2JqLmFyZ3VtZW50cyA9PT0gdHJ1ZSA/IG9iaiA6IF9vYmouYXJndW1lbnRzKTsgZGVsZXRlIF9vYmouYXJndW1lbnRzOyB9XG5yZXR1cm4gbGF5b3V0LmNhbGwodGhpcywgX29iaiwgX1ZkdCwgKF9ibG9ja3MuY29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCkge3JldHVybiBbaCgnYXJ0aWNsZScsIG51bGwsIFsnXFxuICAgICAgICAgICAgJywgaGMoJyA8aW1nIHNyYz1cXFwiaW1hZ2VzL2xvZ28ucG5nXFxcIiAvPiAnKSwgaCgnaDEnLCBudWxsLCAnSW50YWN0JyksIGgoJ3AnLCBudWxsLCAn5Y+v57un5om/55qE5YmN56uv5byA5Y+R5qGG5p62JyksIGgoJ2RpdicsIG51bGwsIFtoKCdhJywgeydocmVmJzogJyMvZG9jdW1lbnQvc3RhcnQnfSwgJ+W8gOWniycsICdidXR0b24nKSwgaCgnYScsIHsnaHJlZic6ICdodHRwczovL2dpdGh1Yi5jb20vSmF2ZXkvaW50YWN0JywgJ3RhcmdldCc6ICdfYmxhbmsnfSwgJ0dpdEh1YicsICdidXR0b24gd2hpdGUnKV0sICdhY3Rpb25zJyksIGgoJ2RpdicsIG51bGwsIFtoKCdkaXYnLCBudWxsLCBbaCgnaDInLCBudWxsLCAn566A5Y2VJywgJ2JsdWUnKSwgaCgnZGl2JywgbnVsbCwgJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIOayoeacieWkjeadgueahOamguW/te+8jOS9oOS7heS7heWPqumcgOimgeS6huino0hUTUzvvIxDU1PlkoxKYXZhU2NyaXB05Y2z5Y+vXFxuICAgICAgICAgICAgICAgICAgICAnKV0sICdmZWF0dXJlJyksIGgoJ2RpdicsIG51bGwsIFtoKCdoMicsIG51bGwsICfpq5jmlYgnLCAneWVsbG93JyksIGgoJ2RpdicsIG51bGwsIFsnXFxuICAgICAgICAgICAgICAgICAgICAgICAgMjJLQiBtaW4rZ3ppcCDlpKflsI/vvIzljIXlkKvliY3nq6/nvJbor5HmqKHlnZfvvJsnLCBoKCdicicpLCAnXFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ya+iHquebruWJjeacgOW/q+eahOiZmuaLn0RPTeW8leaTjuS5i+S4gO+8iGluZmVybm/vvInmnoTlu7pcXG4gICAgICAgICAgICAgICAgICAgICddKV0sICdmZWF0dXJlJyksIGgoJ2RpdicsIG51bGwsIFtoKCdoMicsIG51bGwsICflj6/nu6fmib8nLCAncmVkJyksIGgoJ2RpdicsIG51bGwsICdcXG4gICAgICAgICAgICAgICAgICAgICAgICDlhYXliIblj5HmjKXnu6fmib/nmoTkvJjlir/vvIzlrp7njrDnu4Tku7bpgLvovpHlkozmqKHmnb/nmoTnu6fmib/mianlsZXvvIxcXG4gICAgICAgICAgICAgICAgICAgICAgICDorqnkvaDmm7Tlv6vpgJ/mlrnkvr/lnLDmnoTlu7rlpI3mnYLnmoTlupTnlKhcXG4gICAgICAgICAgICAgICAgICAgICcpXSwgJ2ZlYXR1cmUnKV0sICdmZWF0dXJlcycpXSwgJ2hvbWUtaGVhZGVyJyksIGgoJ2FydGljbGUnLCBudWxsLCBbJ1xcbiAgICAgICAgICAgICcsIGhjKCcgPGgxPuWPr+e7p+aJv+eahOWTjeW6lOW8j+e7hOS7tjwvaDE+ICcpLCBoKCdoMycsIG51bGwsICfpgJrov4fnu6fmib/nmoTmgJ3mg7PvvIzmnaXmianlsZXniLbnu4Tku7bpgLvovpHlkozmqKHmnb/jgILlkIzml7bnu4Tku7bmlbDmja7lj5jmm7TvvIznlYzpnaLkvJrnq4vljbPoh6rliqjlgZrlh7rnm7jlupTmm7TmlrAnKSwgaCgnZGl2JywgbnVsbCwgW2goJ3NjcmlwdCcsIHsndHlwZSc6ICd0ZXh0L21kJywgJ2lubmVySFRNTCc6ICdcXG5gYGBqc1xcbnZhciBMYXlvdXQgPSBJbnRhY3QuZXh0ZW5kKHtcXG4gICAgdGVtcGxhdGU6IFxcJzxkaXY+XFxcXFxcbiAgICAgICAgPGhlYWRlcj5cXFxcXFxuICAgICAgICAgICAgPGI6aGVhZGVyPkV4dGVuZGFibGUgYW5kIFJlYWN0aXZlIENvbXBvbmVudDwvYjpoZWFkZXI+XFxcXFxcbiAgICAgICAgPC9oZWFkZXI+XFxcXFxcbiAgICAgICAgPGRpdj5cXFxcXFxuICAgICAgICAgICAgPGI6Ym9keT5cXFxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvdW50XFxcIj57c2VsZi5nZXQoXFxcImNvdW50XFxcIil9PC9kaXY+XFxcXFxcbiAgICAgICAgICAgIDwvYjpib2R5PlxcXFxcXG4gICAgICAgIDwvZGl2PlxcXFxcXG4gICAgPC9kaXY+XFwnLFxcbiAgICBkZWZhdWx0czogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4ge2NvdW50OiAwfTtcXG4gICAgfVxcbn0pO1xcblxcbnZhciBQYWdlID0gTGF5b3V0LmV4dGVuZCh7XFxuICAgIHRlbXBsYXRlOiBcXCc8dDpwYXJlbnQ+XFxcXFxcbiAgICAgICAgPGI6Ym9keT5cXFxcXFxuICAgICAgICAgICAge3BhcmVudCgpfVxcXFxcXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b25cXFwiXFxcXFxcbiAgICAgICAgICAgICAgICBldi1jbGljaz17c2VsZi5hZGQuYmluZChzZWxmKX1cXFxcXFxuICAgICAgICAgICAgPkNsaWNrIG1lITwvYnV0dG9uPlxcXFxcXG4gICAgICAgIDwvYjpib2R5PlxcXFxcXG4gICAgPC90OnBhcmVudD5cXCcsXFxuICAgIGFkZDogZnVuY3Rpb24oKSB7XFxuICAgICAgICB0aGlzLnNldChcXCdjb3VudFxcJywgdGhpcy5nZXQoXFwnY291bnRcXCcpICsgMSk7XFxuICAgIH1cXG59KTtcXG5cXG5JbnRhY3QubW91bnQoUGFnZSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFwnYXBwXFwnKSk7XFxuYGBgXFxuICAgICAgICAgICAgICAgICd9KSwgaCgnZGl2JywgbnVsbCwgbnVsbCwgJ2NvZGUnKSwgaCgnZGl2JywgeydpZCc6ICdhcHAnfSwgbnVsbCwgJ291dHB1dCcpXSwgJ2NvZGUtd3JhcHBlcicpXSwgJ2hvbWUtY29tcG9uZW50cycpXTt9KSAmJiAoX19ibG9ja3MuY29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xudmFyIHNlbGYgPSB0aGlzO1xucmV0dXJuIGJsb2Nrcy5jb250ZW50ID8gYmxvY2tzLmNvbnRlbnQuY2FsbCh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBfYmxvY2tzLmNvbnRlbnQuY2FsbChzZWxmLCBwYXJlbnQpO1xufSkgOiBfYmxvY2tzLmNvbnRlbnQuY2FsbCh0aGlzLCBwYXJlbnQpO1xufSkgJiYgX19ibG9ja3MpfSkuY2FsbCh0aGlzLCBibG9ja3MpXG59XG5pZiAobW9kdWxlLmhvdCkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG4gICAgdmFyIHZkdCA9IG1vZHVsZS5ob3QuZGF0YSAmJiBtb2R1bGUuaG90LmRhdGEudmR0XG4gICAgaWYgKHZkdCkge1xuICAgICAgICBpZiAoIW1vZHVsZS5ob3QuZGF0YS5pc1BhcmVudCkge1xuICAgICAgICAgICAgdmR0LnRlbXBsYXRlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgdmR0LnVwZGF0ZSgpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWdlcy9pbmRleC9pbmRleC52ZHQiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vaW5kZXguc3R5bFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vaW5kZXguc3R5bFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vaW5kZXguc3R5bFwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWdlcy9pbmRleC9pbmRleC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAyIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhsanMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgY29sb3I6ICM1MjUyNTI7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG4uaGxqcy1kb2N0eXBlIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uaGxqcy10YWcge1xcbiAgY29sb3I6ICMzZTc2ZjY7XFxufVxcbi5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmhsanMtdmFsdWUge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5obGpzLWtleXdvcmQge1xcbiAgY29sb3I6ICNlOTY5MDA7XFxufVxcbi5obGpzLXN0cmluZyB7XFxuICBjb2xvcjogIzQyYjk4MztcXG59XFxuLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogI2IzYjNiMztcXG59XFxuLmhsanMtb3BlcmF0b3IgLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogIzUyNTI1MjtcXG59XFxuLmhsanMtcmVnZXhwIHtcXG4gIGNvbG9yOiAjYWY3ZGZmO1xcbn1cXG4uaGxqcy1idWlsdF9pbiB7XFxuICBjb2xvcjogIzJkYjdmNTtcXG59XFxuLmNzcyAuaGxqcy1jbGFzcyB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmNzcyAuaGxqcy1udW1iZXIsXFxuLmphdmFzY3JpcHQgLmhsanMtbnVtYmVyIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG4uY3NzIC5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2FmN2RmZjtcXG59XFxuLmNzcyAuaGxqcy1pbXBvcnRhbnQge1xcbiAgY29sb3I6ICNkMDQ7XFxufVxcbi5hY3Rpb25zY3JpcHQgLmhsanMtbGl0ZXJhbCxcXG4uamF2YXNjcmlwdCAuaGxqcy1saXRlcmFsIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG5wcmUge1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG59XFxuY29kZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZjdmN2Y3O1xcbiAgZm9udC1mYW1pbHk6IENvbnNvbGFzLCBNb25hY28sIEFuZGFsZSBNb25vLCBVYnVudHUgTW9ubywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiAzcHg7XFxuICBwYWRkaW5nOiAxcHggNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5pbmRleC1wYWdlIC5jb250ZW50LXdyYXBwZXIge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwYWRkaW5nLXRvcDogODBweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWhlYWRlciB7XFxuICBwYWRkaW5nOiA1MHB4IDA7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWhlYWRlciBoMSB7XFxuICBmb250LXNpemU6IDVlbTtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBmb250LWZhbWlseTogQXJpYWw7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWhlYWRlciBwIHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIGNvbG9yOiAjNDY0ODRhO1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZDA0O1xcbiAgY29sb3I6ICNmZmY7XFxuICBwYWRkaW5nOiAwIDJlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMmVtO1xcbiAgbWFyZ2luOiAwIDEwcHg7XFxuICBoZWlnaHQ6IDNlbTtcXG4gIGxpbmUtaGVpZ2h0OiAzZW07XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZmU0NDQ0O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbi53aGl0ZSB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXG4gIGNvbG9yOiAjNjY2O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbi53aGl0ZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmZlYXR1cmVzIHtcXG4gIHdpZHRoOiAxMDgwcHg7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtYXJnaW4tdG9wOiA1MHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmZlYXR1cmUge1xcbiAgZmxleDogMTtcXG59XFxuLmluZGV4LXBhZ2UgLmhvbWUtaGVhZGVyIC5mZWF0dXJlIGgyIHtcXG4gIG1hcmdpbjogMTBweDtcXG59XFxuLmluZGV4LXBhZ2UgLmhvbWUtY29tcG9uZW50cyB7XFxuICBiYWNrZ3JvdW5kOiAjZjhmOGY4O1xcbiAgcGFkZGluZzogMzBweCAwO1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1jb21wb25lbnRzIGgxIHtcXG4gIGZvbnQtc2l6ZTogM2VtO1xcbiAgY29sb3I6ICMxMTE7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWNvbXBvbmVudHMgaDMge1xcbiAgY29sb3I6ICMzNzM5M2I7XFxuICBmb250LXNpemU6IDEuM2VtO1xcbiAgbWFyZ2luOiAwLjdlbSAwO1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIC5jb2RlIHtcXG4gIHdpZHRoOiA2MjBweDtcXG59XFxuLmluZGV4LXBhZ2UgLmNvZGUtd3JhcHBlciAuY29kZSBwcmUge1xcbiAgbWFyZ2luOiAxMHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIC5jb2RlIGNvZGUge1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG59XFxuLmluZGV4LXBhZ2UgLmNvZGUtd3JhcHBlciAub3V0cHV0IHtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIG1hcmdpbjogMTBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIC5jb3VudCB7XFxuICBjb2xvcjogIzA5ZDtcXG4gIGZvbnQtc2l6ZTogM2VtO1xcbiAgbWFyZ2luOiAxMHB4IDAgMTJweDtcXG59XFxuLmluZGV4LXBhZ2UgLmNvZGUtd3JhcHBlciAuYnV0dG9uIHtcXG4gIGZvbnQtc2l6ZTogMS4yZW07XFxuICBwYWRkaW5nOiAxMHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIGhlYWRlciB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogMTBweCAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXI/e1wiaW5jbHVkZSBjc3NcIjp0cnVlfSEuL3BhZ2VzL2luZGV4L2luZGV4LnN0eWxcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwic291cmNlUm9vdCI6IiJ9