webpackJsonp([3],Array(41).concat([
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _desc, _value, _class;

var _index = __webpack_require__(179);

var _index2 = _interopRequireDefault(_index);

var _index3 = __webpack_require__(183);

var _index4 = _interopRequireDefault(_index3);

var _utils = __webpack_require__(137);

var _layout = __webpack_require__(138);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = function (_Layout) {
    _inherits(_default, _Layout);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Layout.apply(this, arguments));
    }

    _default.prototype._mount = function _mount() {
        _Layout.prototype._mount.call(this);
        var $element = $(this.element);
        var $mds = $element.find('script[type="text/md"]');
        for (var i = 0; i < $mds.length; i++) {
            var $md = $($mds[i]);
            var md = $md.text();
            var html = _utils.marked.render(md);
            if ($md.hasClass('show')) {
                $md.nextUntil('.code').next().html(html);
            } else {
                var $div = $('<div />').html(html);
                var _$codes = $div.find('pre code');
                var _template = void 0;
                for (var _i = 0; _i < _$codes.length; _i++) {
                    var $code = $(_$codes[_i]);
                    var code = $code.text();
                    if ($code.hasClass('language-html')) {
                        _template = Intact.Vdt.compile(code);
                    } else if ($code.hasClass('language-css')) {
                        $code.parent().after('<style>' + code + '</style>');
                    } else if ($code.hasClass('language-js')) {
                        eval(code);
                    }
                }
            }
        }
        var $codes = $element.find('pre code');
        for (var _i2 = 0; _i2 < $codes.length; _i2++) {
            var _$code = $($codes[_i2]);
            _utils.highlight.highlightBlock(_$code[0]);
        }
    };

    _createClass(_default, [{
        key: 'template',
        get: function get() {
            return _index2['default'];
        }
    }]);

    return _default;
}(_layout2['default']), (_applyDecoratedDescriptor(_class.prototype, 'template', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'template'), _class.prototype)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)["default"], __webpack_require__(26)))

/***/ }),
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(60);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(55);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(64);
exports.lib.ucmicro = __webpack_require__(136);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 53 */
/***/ (function(module, exports) {



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 54 */
/***/ (function(module, exports) {



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E49\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ (function(module, exports, __webpack_require__) {



/*eslint quotes:0*/
module.exports = __webpack_require__(139);

/***/ }),
/* 61 */
/***/ (function(module, exports) {



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 62 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
};

/***/ }),
/* 63 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {



module.exports.encode = __webpack_require__(131);
module.exports.decode = __webpack_require__(130);
module.exports.format = __webpack_require__(132);
module.exports.parse = __webpack_require__(133);

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 69 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    var nav = [{
        title: '教程',
        href: 'document'
    }, {
        title: 'API',
        href: 'api'
    }, {
        title: 'Blog',
        href: 'blog'
    }];
    return h('div', null, [h('div', null, h('header', null, (_blocks['header'] = function (parent) {
        return [h('a', {
            'href': '#/'
        }, 'Intact', 'logo'), h('nav', null, [__m(function () {
            try {
                return nav;
            } catch (e) {
                _e(e);
            }
        }.call($this), function (value, key) {
            return h('a', {
                'href': function () {
                    try {
                        return '#/' + value.href;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this)
            }, function () {
                try {
                    return value.title;
                } catch (e) {
                    _e(e);
                }
            }.call($this), _className(function () {
                try {
                    return {
                        active: value.href === scope.navIndex
                    };
                } catch (e) {
                    _e(e);
                }
            }.call($this)));
        }, $this), h('div', null, null, 'border')])];
    }) && (__blocks['header'] = function (parent) {
        var args = arguments;
        return blocks['header'] ? blocks['header'].apply($this, [function () {
            return _blocks['header'].apply($this, args);
        }].concat(__slice.call(args, 1))) : _blocks['header'].apply($this, args);
    }) && __blocks['header'].apply($this, [__noop])), 'header-wrapper'), h('div', null, (_blocks['content'] = function (parent) {
        return null;
    }) && (__blocks['content'] = function (parent) {
        var args = arguments;
        return blocks['content'] ? blocks['content'].apply($this, [function () {
            return _blocks['content'].apply($this, args);
        }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
    }) && __blocks['content'].apply($this, [__noop]), 'content-wrapper')], _className(function () {
        try {
            return 'main-wrapper ' + (scope.className || '');
        } catch (e) {
            _e(e);
        }
    }.call($this)));
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function (factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if (true) {
    factory(exports);
  } else if (globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return globalObject.hljs;
      });
    }
  }
})(function (hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent) {
    // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent) {
      result[key] = parent[key];
    }objects.forEach(function (obj) {
      for (key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:
       if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;
       ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace('"', '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function expand_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function (variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];
  }

  function compileLanguage(language) {

    function reStr(re) {
      return re && re.source || re;
    }

    function langRe(value, global) {
      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }

    function compileMode(mode, parent) {
      if (mode.compiled) return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function flatten(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function (kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') {
          // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin) mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null) mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {
        return expand_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function (c) {
        compileMode(c, mode);
      });

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = mode.contains.map(function (c) {
        return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function exec() /*s*/{
          return null;
        } };
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:
   - relevance (int)
  - value (an HTML string with highlighting markup)
   */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan = '<span class="' + classPrefix,
          closeSpan = leaveOpen ? '' : spanEndTag;

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords) return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += top.subLanguage != null ? processSubLanguage() : processKeywords();
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className ? buildSpan(mode.className, '', true) : '';
      top = Object.create(mode, { parent: { value: top } });
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '',
        current;
    for (current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match,
          count,
          index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match) break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:
   - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)
   */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:
   - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers
   */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {
      if (options.useBR && match === '\n') {
        return '<br>';
      } else if (options.tabReplace) {
        return p1.replace(/\t/g, options.tabReplace);
      }
      return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language)) return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function (alias) {
        aliases[alias] = name;
      });
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
      className: 'comment',
      begin: begin, end: end,
      contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [hljs.BACKSLASH_ESCAPE, {
      begin: /\[/, end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
});

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var VAR = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d#@][\w\d_]*/ }, { begin: /\$\{(.*?)}/ }]
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: /"/, end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, {
      className: 'variable',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  var APOS_STRING = {
    className: 'string',
    begin: /'/, end: /'/
  };

  return {
    aliases: ['sh', 'zsh'],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: 'if then else elif fi for while in do done case esac function',
      literal: 'true false',
      built_in:
      // Shell built-ins
      // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' + 'trap umask unset ' +
      // Bash built-ins
      'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' + 'read readarray source type typeset ulimit unalias ' +
      // Shell modifiers
      'set shopt ' +
      // Zsh built-ins
      'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' + 'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' + 'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' + 'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' + 'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' + 'zpty zregexparse zsocket zstyle ztcp',
      _: '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster
    },
    contains: [{
      className: 'meta',
      begin: /^#![^\n]+sh\s*$/,
      relevance: 10
    }, {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, hljs.HASH_COMMENT_MODE, QUOTE_STRING, APOS_STRING, VAR]
  };
};

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /[A-Z\_\.\-]+\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [{
      className: 'attribute',
      begin: /\S/, end: ':', excludeEnd: true,
      starts: {
        endsWithParent: true, excludeEnd: true,
        contains: [{
          begin: /[\w-]+\(/, returnBegin: true,
          contains: [{
            className: 'built_in',
            begin: /[\w-]+/
          }, {
            begin: /\(/, end: /\)/,
            contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
          }]
        }, hljs.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, hljs.C_BLOCK_COMMENT_MODE, {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        }, {
          className: 'meta', begin: '!important'
        }]
      }
    }]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [hljs.C_BLOCK_COMMENT_MODE, {
      className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
    }, {
      className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
    }, {
      className: 'selector-attr',
      begin: /\[/, end: /\]/,
      illegal: '$'
    }, {
      className: 'selector-pseudo',
      begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
    }, {
      begin: '@(font-face|page)',
      lexemes: '[a-z-]+',
      keywords: 'font-face page'
    }, {
      begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
      // because it doesn’t let it to be parsed as
      // a rule set but instead drops parser into
      // the default mode which is how it should be.
      illegal: /:/, // break on Less variables @var: ...
      contains: [{
        className: 'keyword',
        begin: /\w+/
      }, {
        begin: /\s/, endsWithParent: true, excludeEnd: true,
        relevance: 0,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, hljs.CSS_NUMBER_MODE]
      }]
    }, {
      className: 'selector-tag', begin: IDENT_RE,
      relevance: 0
    }, {
      begin: '{', end: '}',
      illegal: /\S/,
      contains: [hljs.C_BLOCK_COMMENT_MODE, RULE]
    }]
  };
};

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' +
    // ECMAScript 6 modules import
    'import from as',

    literal: 'true false null undefined NaN Infinity',
    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'
  };
  var EXPRESSIONS;
  var NUMBER = {
    className: 'number',
    variants: [{ begin: '\\b(0[bB][01]+)' }, { begin: '\\b(0[oO][0-7]+)' }, { begin: hljs.C_NUMBER_RE }],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: [] // defined later
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];
  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);

  return {
    aliases: ['js', 'jsx'],
    keywords: KEYWORDS,
    contains: [{
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, {
      className: 'meta',
      begin: /^#!/, end: /$/
    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, { // object attr container
      begin: /[{,]\s*/, relevance: 0,
      contains: [{
        begin: IDENT_RE + '\\s*:', returnBegin: true,
        relevance: 0,
        contains: [{ className: 'attr', begin: IDENT_RE, relevance: 0 }]
      }]
    }, { // "value" container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
      keywords: 'return throw case',
      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {
        className: 'function',
        begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
        end: '\\s*=>',
        contains: [{
          className: 'params',
          variants: [{
            begin: IDENT_RE
          }, {
            begin: /\(\s*\)/
          }, {
            begin: /\(/, end: /\)/,
            excludeBegin: true, excludeEnd: true,
            keywords: KEYWORDS,
            contains: PARAMS_CONTAINS
          }]
        }]
      }, { // E4X / JSX
        begin: /</, end: /(\/\w+|\w+\/)>/,
        subLanguage: 'xml',
        contains: [{ begin: /<\w+\s*\/>/, skip: true }, {
          begin: /<\w+/, end: /(\/\w+|\w+\/)>/, skip: true,
          contains: [{ begin: /<\w+\s*\/>/, skip: true }, 'self']
        }]
      }],
      relevance: 0
    }, {
      className: 'function',
      beginKeywords: 'function', end: /\{/, excludeEnd: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }), {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        contains: PARAMS_CONTAINS
      }],
      illegal: /\[|%/
    }, {
      begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
    }, hljs.METHOD_GUARD, { // ES6 class
      className: 'class',
      beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
      illegal: /[:"\[\]]/,
      contains: [{ beginKeywords: 'extends' }, hljs.UNDERSCORE_TITLE_MODE]
    }, {
      beginKeywords: 'constructor', end: /\{/, excludeEnd: true
    }],
    illegal: /#(?!!)/
  };
};

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [{
      className: 'attr',
      begin: XML_IDENT_RE,
      relevance: 0
    }, {
      begin: /=\s*/,
      relevance: 0,
      contains: [{
        className: 'string',
        endsParent: true,
        variants: [{ begin: /"/, end: /"/ }, { begin: /'/, end: /'/ }, { begin: /[^\s"'=<>`]+/ }]
      }]
    }]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
    case_insensitive: true,
    contains: [{
      className: 'meta',
      begin: '<!DOCTYPE', end: '>',
      relevance: 10,
      contains: [{ begin: '\\[', end: '\\]' }]
    }, hljs.COMMENT('<!--', '-->', {
      relevance: 10
    }), {
      begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
      relevance: 10
    }, {
      begin: /<\?(php)?/, end: /\?>/,
      subLanguage: 'php',
      contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
    }, {
      className: 'tag',
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending braket. The '$' is needed for the lexeme to be recognized
      by hljs.subMode() that tests lexemes outside the stream.
      */
      begin: '<style(?=\\s|>|$)', end: '>',
      keywords: { name: 'style' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '</style>', returnEnd: true,
        subLanguage: ['css', 'xml']
      }
    }, {
      className: 'tag',
      // See the comment in the <style tag about the lookahead pattern
      begin: '<script(?=\\s|>|$)', end: '>',
      keywords: { name: 'script' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '\<\/script\>', returnEnd: true,
        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
      }
    }, {
      className: 'meta',
      variants: [{ begin: /<\?xml/, end: /\?>/, relevance: 10 }, { begin: /<\?\w+/, end: /\?>/ }]
    }, {
      className: 'tag',
      begin: '</?', end: '/?>',
      contains: [{
        className: 'name', begin: /[^\/><\s]+/, relevance: 0
      }, TAG_INTERNALS]
    }]
  };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(83)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(67).source;
  re.src_Cc = __webpack_require__(65).source;
  re.src_Z = __webpack_require__(66).source;
  re.src_P = __webpack_require__(55).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 84 */
/***/ (function(module, exports) {


/* eslint-disable no-cond-assign */

var tagExpr = /^<!-- ?\{(?:([a-z0-9]+)(\^[0-9]*)?: ?)?(.*)\} ?-->\n?$/;

module.exports = function attributes(md) {
  md.core.ruler.push('curly_attributes', curlyAttrs);
};

/*
 * List of tag -> token type mappings. Eg, `<li>` is `list_item_open`.
 */

var opening = {
  li: ['list_item'],
  ul: ['bullet_list'],
  p: ['paragraph'],
  ol: ['ordered_list'],
  blockquote: ['blockquote'],
  h1: ['heading'],
  h2: ['heading'],
  h3: ['heading'],
  h4: ['heading'],
  h5: ['heading'],
  h6: ['heading'],
  a: ['link'],
  code: ['code_inline', 'code_block', 'fence']
};

var selfClosing = {
  hr: true,
  image: true

  /**
   * ...
   */

};function curlyAttrs(state) {
  var tokens = state.tokens;
  var omissions = [];
  var parent, m;
  var stack = { len: 0, contents: [], types: {} };

  tokens.forEach(function (token, i) {
    // Save breadcrumbs so html_block will pick it up
    if (isOpener(token.type) || selfClosing[token.type]) {
      spush(stack, token);
    }

    // "# Hello\n<!--{.classname}-->"
    // ...sequence of [heading_open, inline, heading_close, html_block]
    if (token.type === 'html_block') {
      m = token.content.match(tagExpr);
      if (!m) return;

      parent = findParent(stack, m[1], m[2]);
      if (parent && applyToToken(parent, m[3])) {
        omissions.unshift(i);
      }
    }

    // "# Hello <!--{.classname} -->"
    // { type: 'inline', children: { ..., '<!--{...}-->' } }
    if (token.type === 'inline') {
      curlyInline(token.children, stack);
    }
  });

  // Remove <!--...--> html_block tokens
  omissions.forEach(function (idx) {
    return tokens.splice(idx, 1);
  });
}

/**
 * Internal: checks in a token type is a block opener
 */

function isOpener(type) {
  return type.match(/_(open|start)$/) || type === 'fence' || type === 'code_block';
}

/**
 * Internal: Run through inline and stuff
 */

function curlyInline(children, stack) {
  var lastText, m, parent;

  // Keep a list of sub-tokens to be removed
  var omissions = [];

  children.forEach(function (child, i) {
    if (isOpener(child.type) || selfClosing[child.type] || child.type === 'code_inline') {
      spush(stack, child);
    }

    // Decorate tags are found
    if (m = child.content.match(tagExpr)) {
      var tag = m[1];
      var depth = m[2];
      var attrs = m[3];

      // Remove the comment, then remove the extra space
      parent = findParent(stack, tag, depth);
      if (parent && applyToToken(parent, attrs)) {
        omissions.unshift(i);
        if (lastText) trimRight(lastText, 'content');
      }
    }

    if (child.type === 'text') lastText = child;
  });

  // Remove them in a separate step so we don't
  omissions.forEach(function (idx) {
    children.splice(idx, 1);
  });
}

/**
 * Private: given a list of tokens `list` and `lastParent`, find the one that
 * matches `tag`.
 */

function findParent(stack, tag, depth) {
  if (!tag) return stack.last;

  if (depth === '^') {
    depth = 1;
  } else if (typeof depth === 'string') {
    /* '^2' */
    depth = +depth.substr(1);
  } else {
    depth = 0;
  }

  var targets = opening[tag.toLowerCase()] || [tag.toLowerCase()];

  var target = targets.filter(function (target) {
    return stack.types[target];
  });

  var list = stack.types[target];
  if (!list) return; // Can't find tag `tag`

  return list[list.length - 1 - depth];
}

/**
 * Private: trim the right
 */

function trimRight(obj, attr) {
  obj[attr] = obj[attr].replace(/\s*$/, '');
}

/**
 * Private: apply tag to token
 *
 *     applyToToken(token, '.classname')
 */

function applyToToken(token, attrs) {
  var m;
  var todo = [];

  while (attrs.length > 0) {
    if (m = attrs.match(/^\s*\.([a-zA-Z0-9\-_]+)/)) {
      todo.push(['class', m[1], { append: true }]);
      shift();
    } else if (m = attrs.match(/^\s*#([a-zA-Z0-9\-_]+)/)) {
      todo.push(['id', m[1]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)="([^"]*)"/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)='([^']*)'/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)=([^ ]*)/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)/)) {
      todo.push([m[1], '']);
      shift();
    } else if (m = attrs.match(/^\s+/)) {
      shift();
    } else {
      return;
    }
  }

  todo.forEach(function (args) {
    setAttr.apply(this, [token].concat(args));
  });
  return true;

  function shift() {
    attrs = attrs.substr(m[0].length);
  }
}

/**
 * Private: sets an attribute `attr` to `value` in a token. If `options.append`
 * is true, append to the old value instead of overwriting it.
 */

function setAttr(token, attr, value, options) {
  var idx = token.attrIndex(attr);

  if (idx === -1) {
    token.attrPush([attr, value]);
  } else if (options && options.append) {
    token.attrs[idx][1] = token.attrs[idx][1] + ' ' + value;
  } else {
    token.attrs[idx][1] = value;
  }
}

/**
 * Private: pushes a token to the stack
 */

function spush(stack, token) {
  var type = token.type.replace(/_(open|start)$/, '');
  if (!stack.types[type]) {
    stack.types[type] = [];
  }
  stack.types[type].push(token);
  stack.last = token;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = __webpack_require__(91);

/***/ }),
/* 86 */
/***/ (function(module, exports) {



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {



exports.parseLinkLabel = __webpack_require__(89);
exports.parseLinkDestination = __webpack_require__(88);
exports.parseLinkTitle = __webpack_require__(90);

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;
var unescapeAll = __webpack_require__(52).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
      }

    if (code === 0x29 /* ) */) {
        if (level === 0) {
          break;
        }
        level--;
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 89 */
/***/ (function(module, exports) {



module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {



var unescapeAll = __webpack_require__(52).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {



var utils = __webpack_require__(52);
var helpers = __webpack_require__(87);
var Renderer = __webpack_require__(98);
var ParserCore = __webpack_require__(93);
var ParserBlock = __webpack_require__(92);
var ParserInline = __webpack_require__(94);
var LinkifyIt = __webpack_require__(82);
var mdurl = __webpack_require__(64);
var punycode = __webpack_require__(134);

var config = {
  'default': __webpack_require__(96),
  zero: __webpack_require__(97),
  commonmark: __webpack_require__(95)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(110), ['paragraph', 'reference']], ['code', __webpack_require__(100)], ['fence', __webpack_require__(101), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(99), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(103), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(106), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(108)], ['heading', __webpack_require__(102), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(105)], ['html_block', __webpack_require__(104), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(107)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(109);

module.exports = ParserBlock;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

var _rules = [['normalize', __webpack_require__(114)], ['block', __webpack_require__(111)], ['inline', __webpack_require__(112)], ['linkify', __webpack_require__(113)], ['replacements', __webpack_require__(115)], ['smartquotes', __webpack_require__(116)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(117);

module.exports = Core;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(128)], ['newline', __webpack_require__(126)], ['escape', __webpack_require__(122)], ['backticks', __webpack_require__(119)], ['strikethrough', __webpack_require__(63).tokenize], ['emphasis', __webpack_require__(62).tokenize], ['link', __webpack_require__(125)], ['image', __webpack_require__(124)], ['autolink', __webpack_require__(118)], ['html_inline', __webpack_require__(123)], ['entity', __webpack_require__(121)]];

var _rules2 = [['balance_pairs', __webpack_require__(120)], ['strikethrough', __webpack_require__(63).postProcess], ['emphasis', __webpack_require__(62).postProcess], ['text_collapse', __webpack_require__(129)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(127);

module.exports = ParserInline;

/***/ }),
/* 95 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 96 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 97 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {



var assign = __webpack_require__(52).assign;
var unescapeAll = __webpack_require__(52).unescapeAll;
var escapeHtml = __webpack_require__(52).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false;

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !wasOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 100 */
/***/ (function(module, exports) {



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {



var block_names = __webpack_require__(86);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(61).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 105 */
/***/ (function(module, exports) {



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 107 */
/***/ (function(module, exports) {



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);
var isSpace = __webpack_require__(52).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {



module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {



var arrayReplaceAt = __webpack_require__(52).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 114 */
/***/ (function(module, exports) {



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 115 */
/***/ (function(module, exports) {



// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {



var isWhiteSpace = __webpack_require__(52).isWhiteSpace;
var isPunctChar = __webpack_require__(52).isPunctChar;
var isMdAsciiPunct = __webpack_require__(52).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (tokens[j].type !== 'text') continue;

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (tokens[j].type !== 'text') continue;

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 118 */
/***/ (function(module, exports) {



/*eslint max-len:0*/
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 119 */
/***/ (function(module, exports) {



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 120 */
/***/ (function(module, exports) {



module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {



var entities = __webpack_require__(60);
var has = __webpack_require__(52).has;
var isValidEntityCode = __webpack_require__(52).isValidEntityCode;
var fromCodePoint = __webpack_require__(52).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {



var HTML_TAG_RE = __webpack_require__(61).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);
var isWhiteSpace = __webpack_require__(52).isWhiteSpace;
var isPunctChar = __webpack_require__(52).isPunctChar;
var isMdAsciiPunct = __webpack_require__(52).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 128 */
/***/ (function(module, exports) {



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 129 */
/***/ (function(module, exports) {



module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 130 */
/***/ (function(module, exports) {



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 131 */
/***/ (function(module, exports) {



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 132 */
/***/ (function(module, exports) {



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 133 */
/***/ (function(module, exports) {



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(68)) == 'object' && __webpack_require__(68)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module), __webpack_require__(69)))

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {



exports.Any = __webpack_require__(67);
exports.Cc = __webpack_require__(65);
exports.Cf = __webpack_require__(135);
exports.P = __webpack_require__(55);
exports.Z = __webpack_require__(66);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.marked = exports.highlight = undefined;

var _markdownIt = __webpack_require__(85);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _markdownItDecorate = __webpack_require__(84);

var _markdownItDecorate2 = _interopRequireDefault(_markdownItDecorate);

var _highlight = __webpack_require__(77);

var _highlight2 = _interopRequireDefault(_highlight);

var _javascript = __webpack_require__(80);

var _javascript2 = _interopRequireDefault(_javascript);

var _css = __webpack_require__(79);

var _css2 = _interopRequireDefault(_css);

var _xml = __webpack_require__(81);

var _xml2 = _interopRequireDefault(_xml);

var _bash = __webpack_require__(78);

var _bash2 = _interopRequireDefault(_bash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_highlight2['default'].registerLanguage('bash', _bash2['default']);
_highlight2['default'].registerLanguage('css', _css2['default']);
_highlight2['default'].registerLanguage('javascript', _javascript2['default']);
_highlight2['default'].registerLanguage('xml', _xml2['default']);

window.highlight = _highlight2['default'];

var marked = (0, _markdownIt2['default'])({
    html: true,
    breaks: false
}).use(_markdownItDecorate2['default']);
// 去掉段落softbreak
marked.renderer.rules.softbreak = function () {
    return '';
};

exports.highlight = _highlight2['default'];
exports.marked = marked;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _layout = __webpack_require__(76);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Intact) {
    _inherits(_default, _Intact);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _default.prototype._mount = function _mount() {
        this.$border = $(this.element).find('.border');
        this._updateBorder();
    };

    _default.prototype._updateBorder = function _updateBorder() {
        var $nav = $(this.element).find('.active');
        var width = 0;
        var left = 0;
        if ($nav.length) {
            left = $nav.position().left;
            width = $nav.outerWidth();
        }
        this.$border.addClass('transition');
        this.$border.css({ width: width, left: left });
    };

    return _default;
}(Intact), _class2.template = _layout2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)["default"], __webpack_require__(26)))

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    return function () {
        var _obj = {
            'className': 'index-page'
        };
        return parent.call($this, _obj, _Vdt, function (blocks) {
            var _blocks = {},
                __blocks = extend({}, blocks);
            return (_blocks['content'] = function (parent) {
                return [h('article', null, [hc(' <img src=\"images/logo.png\" /> '), h('h1', null, 'Intact'), h('p', null, '可继承，强逻辑模板的前端开发框架'), h('div', null, [h('a', {
                    'href': '#/document/start'
                }, '开始', 'button'), h('a', {
                    'href': 'https://github.com/Javey/intact',
                    'target': '_blank'
                }, 'GitHub', 'button white')], 'actions'), h('div', null, [h('div', null, [h('h2', null, '简单', 'blue'), h('div', null, '\n                        没有复杂的概念，你仅仅只需要了解HTML，CSS和JavaScript即可\n                    ')], 'feature'), h('div', null, [h('h2', null, '高效', 'yellow'), h('div', null, ['\n                        22KB min+gzip 大小，包含前端编译模块；', h('br'), '\n                        fork自目前最快的虚拟DOM引擎之一（inferno）构建\n                    '])], 'feature'), h('div', null, [h('h2', null, '可继承，强逻辑模板', 'red'), h('div', null, '\n                        充分发挥继承的优势，实现组件逻辑和模板的继承扩展，\n                        让你更快速方便地构建复杂的应用\n                    ')], 'feature')], 'features')], 'home-header'), h('article', null, [hc(' <h1>可继承的响应式组件</h1> '), h('h3', null, '通过继承的思想，来扩展父组件逻辑和模板。同时组件数据变更，界面会立即自动做出相应更新'), h('div', null, [h('script', {
                    'type': 'text/md',
                    'innerHTML': '\n```html\n// @file layout.vdt\n<div>\n    <header>\n        <b:header>Extendable and Reactive Component</b:header>\n    </header>\n    <div>\n        <b:body>\n            <div class=\"count\">{self.get(\"count\")}</div>\n        </b:body>\n    </div>\n</div>\n```\n\n```js\n// @file layout.js\nimport Intact from \'intact\';\nimport template from \'./layout.vdt\';\n\nexport default class Layout extends Intact {\n    @Intact.template()\n    static template = template;\n\n    defaults() {\n        return {count: 0};\n    }\n}\n```\n\n```html\n// @file page.vdt\n<t:parent>\n    <b:body>\n        {parent()}\n        <button class=\"button\"\n            ev-click={self.add}\n        >Click me!</button>\n    </b:body>\n</t:parent>\n```\n\n```js\n// @file page.js\nimport Intact from \'intact\';\nimport template from \'./page.vdt\';\nimport Layout from \'./layout\';\n\nexport default class Page extends Layout {\n    @Intact.template()\n    static template = template;\n\n    add() {\n        this.set(\'count\', this.get(\'count\') + 1);\n    }\n}\n\n\nIntact.mount(Page, document.getElementById(\'app\'));\n```\n                '
                }, null, 'show'), h('script', {
                    'type': 'text/md',
                    'innerHTML': '\n```js\nvar Layout = Intact.extend({\n    template: \'<div>\\\n        <header>\\\n            <b:header>Extendable and Reactive Component</b:header>\\\n        </header>\\\n        <div>\\\n            <b:body>\\\n                <div class=\"count\">{self.get(\"count\")}</div>\\\n            </b:body>\\\n        </div>\\\n    </div>\',\n    defaults: function() {\n        return {count: 0};\n    }\n});\n\nvar Page = Layout.extend({\n    template: \'<t:parent>\\\n        <b:body>\\\n            {parent()}\\\n            <button class=\"button\"\\\n                ev-click={self.add.bind(self)}\\\n            >Click me!</button>\\\n        </b:body>\\\n    </t:parent>\',\n    add: function() {\n        this.set(\'count\', this.get(\'count\') + 1);\n    }\n});\n\nIntact.mount(Page, document.getElementById(\'app\'));\n```\n                '
                }, null, 'run'), h('div', null, null, 'code'), h('div', {
                    'id': 'app'
                }, null, 'output')], 'code-wrapper')], 'home-components')];
            }) && (__blocks['content'] = function (parent) {
                var args = arguments;
                return blocks['content'] ? blocks['content'].apply($this, [function () {
                    return _blocks['content'].apply($this, args);
                }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
            }), __blocks;
        }.call($this, blocks), parent);
    }.call($this);
};

/***/ }),
/* 180 */,
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(15)(false);
// imports


// module
exports.push([module.i, ".hljs {\n  display: block;\n  overflow-x: auto;\n  color: #525252;\n  padding: 15px;\n  -webkit-text-size-adjust: none;\n  margin: 0;\n}\n.hljs-doctype {\n  color: #999;\n}\n.hljs-tag {\n  color: #3e76f6;\n}\n.hljs-attribute {\n  color: #e96900;\n}\n.hljs-value {\n  color: #42b983;\n}\n.hljs-keyword {\n  color: #e96900;\n}\n.hljs-string {\n  color: #42b983;\n}\n.hljs-comment {\n  color: #b3b3b3;\n}\n.hljs-operator .hljs-comment {\n  color: #525252;\n}\n.hljs-regexp {\n  color: #af7dff;\n}\n.hljs-built_in {\n  color: #2db7f5;\n}\n.css .hljs-class {\n  color: #e96900;\n}\n.css .hljs-number,\n.javascript .hljs-number {\n  color: #fc1e70;\n}\n.css .hljs-attribute {\n  color: #af7dff;\n}\n.css .hljs-important {\n  color: #d04;\n}\n.actionscript .hljs-literal,\n.javascript .hljs-literal {\n  color: #fc1e70;\n}\npre {\n  padding: 0;\n  margin: 0;\n}\ncode {\n  display: inline-block;\n  background: #f7f7f7;\n  font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;\n  margin: 3px;\n  padding: 1px 5px;\n  border-radius: 3px;\n  color: #666;\n  border: 1px solid #eee;\n  line-height: 20px;\n}\n.index-page .content-wrapper {\n  min-height: 100%;\n  background: #fff;\n  padding-top: 80px;\n  box-sizing: border-box;\n  text-align: center;\n}\n.index-page .home-header {\n  padding: 50px 0;\n}\n.index-page .home-header h1 {\n  font-size: 5em;\n  font-weight: 600;\n  font-family: Arial;\n}\n.index-page .home-header p {\n  font-size: 2em;\n  font-weight: 300;\n  color: #46484a;\n}\n.index-page .home-header .button {\n  display: inline-block;\n  background: #d04;\n  color: #fff;\n  padding: 0 2em;\n  border-radius: 0.2em;\n  margin: 0 10px;\n  height: 3em;\n  line-height: 3em;\n  box-sizing: border-box;\n}\n.index-page .home-header .button:hover {\n  background: #fe4444;\n}\n.index-page .home-header .button.white {\n  background: #fff;\n  border: 1px solid #ccc;\n  color: #666;\n}\n.index-page .home-header .button.white:hover {\n  background: #eee;\n}\n.index-page .home-header .features {\n  width: 1080px;\n  margin: 0 auto;\n  display: flex;\n  margin-top: 50px;\n}\n.index-page .home-header .feature {\n  flex: 1;\n}\n.index-page .home-header .feature h2 {\n  margin: 10px;\n}\n.index-page .home-components {\n  background: #f8f8f8;\n  padding: 30px 0;\n}\n.index-page .home-components h1 {\n  font-size: 3em;\n  color: #111;\n}\n.index-page .home-components h3 {\n  color: #37393b;\n  font-size: 1.3em;\n  margin: 0.7em 0;\n}\n.index-page .code-wrapper {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  text-align: left;\n}\n.index-page .code-wrapper .code {\n  width: 620px;\n}\n.index-page .code-wrapper .code pre {\n  margin: 10px;\n}\n.index-page .code-wrapper .code code {\n  background: #fff;\n}\n.index-page .code-wrapper .output {\n  width: 300px;\n  margin: 10px;\n  background: #fff;\n  border-radius: 3px;\n  padding: 15px;\n}\n.index-page .code-wrapper .count {\n  color: #09d;\n  font-size: 3em;\n  margin: 10px 0 12px;\n}\n.index-page .code-wrapper .button {\n  font-size: 1.2em;\n  padding: 10px;\n}\n.index-page .code-wrapper header {\n  font-size: 2em;\n  margin: 10px 0;\n}\n", ""]);

// exports


/***/ }),
/* 182 */,
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(181);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(16)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./index.styl", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./index.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2luZGV4L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcz83ZjExKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanM/ZmU5OCoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3Rva2VuLmpzPzM2YTEqKiIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qcz8xOWM0KioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzP2JiNmUqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcz84ZjMzKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzP2M1MTcqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcz80OWRmKioiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9pbmRleC5qcz9lMTBhKioiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzP2Y2NjgqKiIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcz9iMzdmKioiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcz83Y2JjKioiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzVmNzEqKiIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgqKiIsIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2xheW91dC52ZHQ/NDJhMCoqIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQuanM/YmNiYioqIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaC5qcz83OGQ4KioiLCJ3ZWJwYWNrOi8vLy4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9jc3MuanM/ZWY4MyoqIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvamF2YXNjcmlwdC5qcz9kZTc3KioiLCJ3ZWJwYWNrOi8vLy4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwuanM/MzZjNCoqIiwid2VicGFjazovLy8uL34vbGlua2lmeS1pdC9pbmRleC5qcz9jMDc2KioiLCJ3ZWJwYWNrOi8vLy4vfi9saW5raWZ5LWl0L2xpYi9yZS5qcz9iMWMxKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC1kZWNvcmF0ZS9pbmRleC5qcz84ZjQwKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9pbmRleC5qcz82MWJhKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzPzAzOWYqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzPzlkZWQqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanM/MDliOSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcz8xNGU5KioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzPzZhNTcqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9pbmRleC5qcz9kZmJkKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzPzc3YmEqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcz83YjQ5KioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qcz9lNjQyKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzP2ZlNDEqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanM/MzUzYSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcz9mYzNlKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanM/YWY5OSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanM/ZTdjZioqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanM/ZjI4YioqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzPzNiN2IqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzPzY0YmMqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcz8wNThlKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5qcz8wMWQ5KioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanM/NTNmYyoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanM/NTY5YioqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcz9iZjIzKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzP2VkNmEqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qcz9hNDljKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanM/NzdkMioqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanM/M2FlNCoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzPzU1YjIqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanM/NTExMyoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzPzU3ODMqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcz81NmEwKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcz9hN2YzKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzPzRhMmUqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanM/NWVmNSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanM/NTc5ZSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzP2MyOWIqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzPzIzZGEqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzPzMyMzEqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanM/MTRjZSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcz9mOWFmKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanM/YTdmZSoqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzPzE4MzEqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzP2RhZTkqKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5qcz8yZTgzKioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanM/NzI4MioqIiwid2VicGFjazovLy8uL34vbWR1cmwvZGVjb2RlLmpzP2NjNjAqKiIsIndlYnBhY2s6Ly8vLi9+L21kdXJsL2VuY29kZS5qcz9kOGUxKioiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9mb3JtYXQuanM/NWNlNyoqIiwid2VicGFjazovLy8uL34vbWR1cmwvcGFyc2UuanM/NWNlYioqIiwid2VicGFjazovLy8uL34vcHVueWNvZGUvcHVueWNvZGUuanM/NDc0ZioqIiwid2VicGFjazovLy8uL34vdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcz8wYWQ3KioiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9pbmRleC5qcz9hNjNlKioiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9saWIvdXRpbHMuanM/ZDMwZioqIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvbGF5b3V0LmpzPzYxNjkqKiIsIndlYnBhY2s6Ly8vLi9+L2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbj8xM2JiKioiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9pbmRleC9pbmRleC52ZHQiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9pbmRleC9pbmRleC5zdHlsIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvaW5kZXgvaW5kZXguc3R5bD8xYzBiIl0sIm5hbWVzIjpbIkludGFjdCIsInRlbXBsYXRlIiwiX21vdW50IiwiJGVsZW1lbnQiLCIkIiwiZWxlbWVudCIsIiRtZHMiLCJmaW5kIiwiaSIsImxlbmd0aCIsIiRtZCIsIm1kIiwidGV4dCIsImh0bWwiLCJtYXJrZWQiLCJyZW5kZXIiLCJoYXNDbGFzcyIsIm5leHRVbnRpbCIsIm5leHQiLCIkZGl2IiwiJGNvZGVzIiwiJGNvZGUiLCJjb2RlIiwiVmR0IiwiY29tcGlsZSIsInBhcmVudCIsImFmdGVyIiwiZXZhbCIsImhpZ2hsaWdodCIsImhpZ2hsaWdodEJsb2NrIiwiTGF5b3V0IiwiX2NsYXNzIiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNTdHJpbmciLCJfaGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsIm9iamVjdCIsImtleSIsImFzc2lnbiIsInNvdXJjZXMiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsInNvdXJjZSIsIlR5cGVFcnJvciIsImtleXMiLCJhcnJheVJlcGxhY2VBdCIsInNyYyIsInBvcyIsIm5ld0VsZW1lbnRzIiwiY29uY2F0IiwiaXNWYWxpZEVudGl0eUNvZGUiLCJjIiwiZnJvbUNvZGVQb2ludCIsInN1cnJvZ2F0ZTEiLCJzdXJyb2dhdGUyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiVU5FU0NBUEVfTURfUkUiLCJFTlRJVFlfUkUiLCJVTkVTQ0FQRV9BTExfUkUiLCJSZWdFeHAiLCJESUdJVEFMX0VOVElUWV9URVNUX1JFIiwiZW50aXRpZXMiLCJyZXF1aXJlIiwicmVwbGFjZUVudGl0eVBhdHRlcm4iLCJtYXRjaCIsIm5hbWUiLCJjaGFyQ29kZUF0IiwidGVzdCIsInRvTG93ZXJDYXNlIiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwic3RyIiwiaW5kZXhPZiIsInJlcGxhY2UiLCJ1bmVzY2FwZUFsbCIsImVzY2FwZWQiLCJlbnRpdHkiLCJIVE1MX0VTQ0FQRV9URVNUX1JFIiwiSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSIsIkhUTUxfUkVQTEFDRU1FTlRTIiwicmVwbGFjZVVuc2FmZUNoYXIiLCJjaCIsImVzY2FwZUh0bWwiLCJSRUdFWFBfRVNDQVBFX1JFIiwiZXNjYXBlUkUiLCJpc1NwYWNlIiwiaXNXaGl0ZVNwYWNlIiwiVU5JQ09ERV9QVU5DVF9SRSIsImlzUHVuY3RDaGFyIiwiaXNNZEFzY2lpUHVuY3QiLCJub3JtYWxpemVSZWZlcmVuY2UiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJleHBvcnRzIiwibGliIiwibWR1cmwiLCJ1Y21pY3JvIiwiUnVsZXIiLCJfX3J1bGVzX18iLCJfX2NhY2hlX18iLCJfX2ZpbmRfXyIsIl9fY29tcGlsZV9fIiwic2VsZiIsImNoYWlucyIsInJ1bGUiLCJlbmFibGVkIiwiYWx0IiwiYWx0TmFtZSIsInB1c2giLCJjaGFpbiIsImZuIiwiYXQiLCJvcHRpb25zIiwiaW5kZXgiLCJvcHQiLCJFcnJvciIsImJlZm9yZSIsImJlZm9yZU5hbWUiLCJydWxlTmFtZSIsInNwbGljZSIsImFmdGVyTmFtZSIsImVuYWJsZSIsImxpc3QiLCJpZ25vcmVJbnZhbGlkIiwiaXNBcnJheSIsInJlc3VsdCIsImlkeCIsImVuYWJsZU9ubHkiLCJkaXNhYmxlIiwiZ2V0UnVsZXMiLCJjaGFpbk5hbWUiLCJtb2R1bGUiLCJUb2tlbiIsInR5cGUiLCJ0YWciLCJuZXN0aW5nIiwiYXR0cnMiLCJtYXAiLCJsZXZlbCIsImNoaWxkcmVuIiwiY29udGVudCIsIm1hcmt1cCIsImluZm8iLCJtZXRhIiwiYmxvY2siLCJoaWRkZW4iLCJhdHRySW5kZXgiLCJsZW4iLCJhdHRyUHVzaCIsImF0dHJEYXRhIiwiYXR0clNldCIsInZhbHVlIiwiYXR0ckdldCIsImF0dHJKb2luIiwiYXR0cl9uYW1lIiwidW5xdW90ZWQiLCJzaW5nbGVfcXVvdGVkIiwiZG91YmxlX3F1b3RlZCIsImF0dHJfdmFsdWUiLCJhdHRyaWJ1dGUiLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsImNvbW1lbnQiLCJwcm9jZXNzaW5nIiwiZGVjbGFyYXRpb24iLCJjZGF0YSIsIkhUTUxfVEFHX1JFIiwiSFRNTF9PUEVOX0NMT1NFX1RBR19SRSIsInRva2VuaXplIiwiZW1waGFzaXMiLCJzdGF0ZSIsInNpbGVudCIsInNjYW5uZWQiLCJ0b2tlbiIsInN0YXJ0IiwibWFya2VyIiwic2NhbkRlbGltcyIsImRlbGltaXRlcnMiLCJqdW1wIiwidG9rZW5zIiwiZW5kIiwib3BlbiIsImNhbl9vcGVuIiwiY2xvc2UiLCJjYW5fY2xvc2UiLCJwb3N0UHJvY2VzcyIsInN0YXJ0RGVsaW0iLCJlbmREZWxpbSIsImlzU3Ryb25nIiwibWF4Iiwic3RyaWtldGhyb3VnaCIsImoiLCJsb25lTWFya2VycyIsInBvcCIsImVuY29kZSIsImRlY29kZSIsImZvcm1hdCIsInBhcnNlIiwiZyIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsIl9WZHQiLCJibG9ja3MiLCIkY2FsbGVlIiwiaCIsIm1pc3MiLCJoYyIsImh1Iiwid2lkZ2V0cyIsIl9ibG9ja3MiLCJfX2Jsb2NrcyIsIl9fdSIsInV0aWxzIiwiZXh0ZW5kIiwiX2UiLCJlcnJvciIsIl9jbGFzc05hbWUiLCJjbGFzc05hbWUiLCJfX3NsaWNlIiwiX19ub29wIiwibm9vcCIsIl9fbSIsIl9fbyIsIk9wdGlvbnMiLCJfZ2V0TW9kZWwiLCJnZXRNb2RlbCIsIl9zZXRNb2RlbCIsInNldE1vZGVsIiwiX3NldENoZWNrYm94TW9kZWwiLCJzZXRDaGVja2JveE1vZGVsIiwiX2RldGVjdENoZWNrYm94Q2hlY2tlZCIsImRldGVjdENoZWNrYm94Q2hlY2tlZCIsIl9zZXRTZWxlY3RNb2RlbCIsInNldFNlbGVjdE1vZGVsIiwiZGF0YSIsIiR0aGlzIiwic2NvcGUiLCJBbmltYXRlIiwiX3N1cGVyIiwibmF2IiwidGl0bGUiLCJocmVmIiwiYWN0aXZlIiwibmF2SW5kZXgiLCJhcmdzIiwiYXBwbHkiLCJmYWN0b3J5IiwiZ2xvYmFsT2JqZWN0IiwiaGxqcyIsImRlZmluZSIsImFtZCIsIkFycmF5UHJvdG8iLCJvYmplY3RLZXlzIiwibGFuZ3VhZ2VzIiwiYWxpYXNlcyIsIm5vSGlnaGxpZ2h0UmUiLCJsYW5ndWFnZVByZWZpeFJlIiwiZml4TWFya3VwUmUiLCJzcGFuRW5kVGFnIiwiY2xhc3NQcmVmaXgiLCJ0YWJSZXBsYWNlIiwidXNlQlIiLCJ1bmRlZmluZWQiLCJlc2NhcGUiLCJub2RlIiwibm9kZU5hbWUiLCJ0ZXN0UmUiLCJyZSIsImxleGVtZSIsImV4ZWMiLCJpc05vdEhpZ2hsaWdodGVkIiwibGFuZ3VhZ2UiLCJibG9ja0xhbmd1YWdlIiwiY2xhc3NlcyIsInBhcmVudE5vZGUiLCJnZXRMYW5ndWFnZSIsInNwbGl0IiwiaW5oZXJpdCIsIm9iamVjdHMiLCJub2RlU3RyZWFtIiwiX25vZGVTdHJlYW0iLCJvZmZzZXQiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsIm5vZGVUeXBlIiwibm9kZVZhbHVlIiwiZXZlbnQiLCJtZXJnZVN0cmVhbXMiLCJvcmlnaW5hbCIsImhpZ2hsaWdodGVkIiwicHJvY2Vzc2VkIiwibm9kZVN0YWNrIiwic2VsZWN0U3RyZWFtIiwiYXR0cl9zdHIiLCJhIiwiYXR0cmlidXRlcyIsImpvaW4iLCJzdHJlYW0iLCJzdWJzdHJpbmciLCJyZXZlcnNlIiwic3Vic3RyIiwiZXhwYW5kX21vZGUiLCJtb2RlIiwidmFyaWFudHMiLCJjYWNoZWRfdmFyaWFudHMiLCJ2YXJpYW50IiwiZW5kc1dpdGhQYXJlbnQiLCJjb21waWxlTGFuZ3VhZ2UiLCJyZVN0ciIsImxhbmdSZSIsImdsb2JhbCIsImNhc2VfaW5zZW5zaXRpdmUiLCJjb21waWxlTW9kZSIsImNvbXBpbGVkIiwia2V5d29yZHMiLCJiZWdpbktleXdvcmRzIiwiY29tcGlsZWRfa2V5d29yZHMiLCJmbGF0dGVuIiwia3ciLCJwYWlyIiwiTnVtYmVyIiwibGV4ZW1lc1JlIiwibGV4ZW1lcyIsImJlZ2luIiwiYmVnaW5SZSIsImVuZFJlIiwidGVybWluYXRvcl9lbmQiLCJpbGxlZ2FsIiwiaWxsZWdhbFJlIiwicmVsZXZhbmNlIiwiY29udGFpbnMiLCJzdGFydHMiLCJ0ZXJtaW5hdG9ycyIsImZpbHRlciIsIkJvb2xlYW4iLCJpZ25vcmVfaWxsZWdhbHMiLCJjb250aW51YXRpb24iLCJzdWJNb2RlIiwiZW5kT2ZNb2RlIiwiZW5kc1BhcmVudCIsImlzSWxsZWdhbCIsImtleXdvcmRNYXRjaCIsIm1hdGNoX3N0ciIsImJ1aWxkU3BhbiIsImNsYXNzbmFtZSIsImluc2lkZVNwYW4iLCJsZWF2ZU9wZW4iLCJub1ByZWZpeCIsIm9wZW5TcGFuIiwiY2xvc2VTcGFuIiwicHJvY2Vzc0tleXdvcmRzIiwia2V5d29yZF9tYXRjaCIsImxhc3RfaW5kZXgiLCJ0b3AiLCJtb2RlX2J1ZmZlciIsImxhc3RJbmRleCIsInByb2Nlc3NTdWJMYW5ndWFnZSIsImV4cGxpY2l0Iiwic3ViTGFuZ3VhZ2UiLCJjb250aW51YXRpb25zIiwiaGlnaGxpZ2h0QXV0byIsInByb2Nlc3NCdWZmZXIiLCJzdGFydE5ld01vZGUiLCJjcmVhdGUiLCJwcm9jZXNzTGV4ZW1lIiwiYnVmZmVyIiwibmV3X21vZGUiLCJza2lwIiwiZXhjbHVkZUJlZ2luIiwicmV0dXJuQmVnaW4iLCJlbmRfbW9kZSIsIm9yaWdpbiIsInJldHVybkVuZCIsImV4Y2x1ZGVFbmQiLCJjdXJyZW50IiwiY291bnQiLCJtZXNzYWdlIiwibGFuZ3VhZ2VTdWJzZXQiLCJzZWNvbmRfYmVzdCIsImZpeE1hcmt1cCIsInAxIiwiYnVpbGRDbGFzc05hbWUiLCJwcmV2Q2xhc3NOYW1lIiwiY3VycmVudExhbmciLCJyZXN1bHRMYW5nIiwib3JpZ2luYWxTdHJlYW0iLCJyZXN1bHROb2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudCIsImNvbmZpZ3VyZSIsInVzZXJfb3B0aW9ucyIsImluaXRIaWdobGlnaHRpbmciLCJjYWxsZWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5pdEhpZ2hsaWdodGluZ09uTG9hZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWdpc3Rlckxhbmd1YWdlIiwibGFuZyIsImFsaWFzIiwibGlzdExhbmd1YWdlcyIsIklERU5UX1JFIiwiVU5ERVJTQ09SRV9JREVOVF9SRSIsIk5VTUJFUl9SRSIsIkNfTlVNQkVSX1JFIiwiQklOQVJZX05VTUJFUl9SRSIsIlJFX1NUQVJURVJTX1JFIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkFQT1NfU1RSSU5HX01PREUiLCJRVU9URV9TVFJJTkdfTU9ERSIsIlBIUkFTQUxfV09SRFNfTU9ERSIsIkNPTU1FTlQiLCJpbmhlcml0cyIsIkNfTElORV9DT01NRU5UX01PREUiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIkhBU0hfQ09NTUVOVF9NT0RFIiwiTlVNQkVSX01PREUiLCJDX05VTUJFUl9NT0RFIiwiQklOQVJZX05VTUJFUl9NT0RFIiwiQ1NTX05VTUJFUl9NT0RFIiwiUkVHRVhQX01PREUiLCJUSVRMRV9NT0RFIiwiVU5ERVJTQ09SRV9USVRMRV9NT0RFIiwiTUVUSE9EX0dVQVJEIiwiVkFSIiwiUVVPVEVfU1RSSU5HIiwiQVBPU19TVFJJTkciLCJrZXl3b3JkIiwibGl0ZXJhbCIsImJ1aWx0X2luIiwiXyIsIlJVTEUiLCJLRVlXT1JEUyIsIkVYUFJFU1NJT05TIiwiTlVNQkVSIiwiU1VCU1QiLCJURU1QTEFURV9TVFJJTkciLCJQQVJBTVNfQ09OVEFJTlMiLCJYTUxfSURFTlRfUkUiLCJUQUdfSU5URVJOQUxTIiwiaXNPYmplY3QiLCJpc1JlZ0V4cCIsImlzRnVuY3Rpb24iLCJkZWZhdWx0T3B0aW9ucyIsImZ1enp5TGluayIsImZ1enp5RW1haWwiLCJmdXp6eUlQIiwiaXNPcHRpb25zT2JqIiwicmVkdWNlIiwiYWNjIiwiayIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJ0YWlsIiwiaHR0cCIsInNyY19hdXRoIiwic3JjX2hvc3RfcG9ydF9zdHJpY3QiLCJzcmNfcGF0aCIsIm5vX2h0dHAiLCJzcmNfZG9tYWluIiwic3JjX2RvbWFpbl9yb290Iiwic3JjX3BvcnQiLCJzcmNfaG9zdF90ZXJtaW5hdG9yIiwibWFpbHRvIiwic3JjX2VtYWlsX25hbWUiLCJzcmNfaG9zdF9zdHJpY3QiLCJ0bGRzXzJjaF9zcmNfcmUiLCJ0bGRzX2RlZmF1bHQiLCJyZXNldFNjYW5DYWNoZSIsIl9faW5kZXhfXyIsIl9fdGV4dF9jYWNoZV9fIiwiY3JlYXRlVmFsaWRhdG9yIiwiY3JlYXRlTm9ybWFsaXplciIsIm5vcm1hbGl6ZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiX19jb21waWxlZF9fIiwic2NoZW1hRXJyb3IiLCJ2YWwiLCJfX3NjaGVtYXNfXyIsImxpbmsiLCJzbGlzdCIsInNjaGVtYV90ZXN0Iiwic3JjX1pQQ2MiLCJzY2hlbWFfc2VhcmNoIiwicHJldGVzdCIsIk1hdGNoIiwic2hpZnQiLCJfX2xhc3RfaW5kZXhfXyIsInNjaGVtYSIsIl9fc2NoZW1hX18iLCJyYXciLCJ1cmwiLCJjcmVhdGVNYXRjaCIsIkxpbmtpZnlJdCIsInNjaGVtYXMiLCJhZGQiLCJkZWZpbml0aW9uIiwic2V0IiwibSIsIm1sIiwibWUiLCJ0bGRfcG9zIiwiYXRfcG9zIiwidGVzdFNjaGVtYUF0Iiwic2VhcmNoIiwia2VlcE9sZCIsInNvcnQiLCJlbCIsImFyciIsIm9wdHMiLCJzcmNfQW55Iiwic3JjX0NjIiwic3JjX1oiLCJzcmNfUCIsInNyY19aQ2MiLCJ0ZXh0X3NlcGFyYXRvcnMiLCJzcmNfcHNldWRvX2xldHRlciIsInNyY19pcDQiLCJzcmNfaG9zdCIsInRwbF9ob3N0X2Z1enp5IiwidHBsX2hvc3Rfbm9faXBfZnV6enkiLCJ0cGxfaG9zdF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0IiwidGFnRXhwciIsImNvcmUiLCJydWxlciIsImN1cmx5QXR0cnMiLCJvcGVuaW5nIiwibGkiLCJ1bCIsInAiLCJvbCIsImJsb2NrcXVvdGUiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJzZWxmQ2xvc2luZyIsImhyIiwiaW1hZ2UiLCJvbWlzc2lvbnMiLCJzdGFjayIsImNvbnRlbnRzIiwidHlwZXMiLCJpc09wZW5lciIsInNwdXNoIiwiZmluZFBhcmVudCIsImFwcGx5VG9Ub2tlbiIsInVuc2hpZnQiLCJjdXJseUlubGluZSIsImxhc3RUZXh0IiwiZGVwdGgiLCJ0cmltUmlnaHQiLCJsYXN0IiwidGFyZ2V0cyIsInRhcmdldCIsImF0dHIiLCJ0b2RvIiwiYXBwZW5kIiwic2V0QXR0ciIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsImxpbmVzIiwib2siLCJkaXNhYmxlTmVzdGVkIiwiZm91bmQiLCJwcmV2UG9zIiwibGFiZWxFbmQiLCJwb3NNYXgiLCJvbGRQb3MiLCJpbmxpbmUiLCJza2lwVG9rZW4iLCJoZWxwZXJzIiwiUmVuZGVyZXIiLCJQYXJzZXJDb3JlIiwiUGFyc2VyQmxvY2siLCJQYXJzZXJJbmxpbmUiLCJwdW55Y29kZSIsImNvbmZpZyIsInplcm8iLCJjb21tb25tYXJrIiwiQkFEX1BST1RPX1JFIiwiR09PRF9EQVRBX1JFIiwidmFsaWRhdGVMaW5rIiwiUkVDT0RFX0hPU1ROQU1FX0ZPUiIsIm5vcm1hbGl6ZUxpbmsiLCJwYXJzZWQiLCJob3N0bmFtZSIsInByb3RvY29sIiwidG9BU0NJSSIsImVyIiwibm9ybWFsaXplTGlua1RleHQiLCJ0b1VuaWNvZGUiLCJNYXJrZG93bkl0IiwicHJlc2V0TmFtZSIsInJlbmRlcmVyIiwibGlua2lmeSIsInByZXNldHMiLCJjb21wb25lbnRzIiwicnVsZXMiLCJydWxlczIiLCJydWxlcjIiLCJtaXNzZWQiLCJ1c2UiLCJwbHVnaW4iLCJlbnYiLCJTdGF0ZSIsInByb2Nlc3MiLCJwYXJzZUlubGluZSIsImlubGluZU1vZGUiLCJyZW5kZXJJbmxpbmUiLCJfcnVsZXMiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZSIsImhhc0VtcHR5TGluZXMiLCJtYXhOZXN0aW5nIiwic2tpcEVtcHR5TGluZXMiLCJzQ291bnQiLCJibGtJbmRlbnQiLCJ0aWdodCIsImlzRW1wdHkiLCJvdXRUb2tlbnMiLCJsaW5lTWF4IiwiQ29yZSIsImwiLCJfcnVsZXMyIiwiY2FjaGUiLCJwZW5kaW5nIiwicHVzaFBlbmRpbmciLCJ4aHRtbE91dCIsImJyZWFrcyIsImxhbmdQcmVmaXgiLCJ0eXBvZ3JhcGhlciIsInF1b3RlcyIsImRlZmF1bHRfcnVsZXMiLCJjb2RlX2lubGluZSIsInNsZiIsInJlbmRlckF0dHJzIiwiY29kZV9ibG9jayIsImZlbmNlIiwibGFuZ05hbWUiLCJ0bXBBdHRycyIsInRtcFRva2VuIiwicmVuZGVySW5saW5lQXNUZXh0IiwicmVuZGVyVG9rZW4iLCJoYXJkYnJlYWsiLCJzb2Z0YnJlYWsiLCJodG1sX2Jsb2NrIiwiaHRtbF9pbmxpbmUiLCJuZXh0VG9rZW4iLCJuZWVkTGYiLCJhZGp1c3RUYWIiLCJpbml0aWFsIiwibGFzdExpbmVFbXB0eSIsIm5leHRMaW5lIiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwid2FzT3V0ZGVudGVkIiwib2xkTGluZU1heCIsImJNYXJrcyIsInRTaGlmdCIsImVNYXJrcyIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwiZ2V0TGluZXMiLCJwYXJhbXMiLCJtZW0iLCJoYXZlRW5kTWFya2VyIiwic2tpcENoYXJzIiwic2tpcFNwYWNlcyIsImhlYWRpbmciLCJ0bXAiLCJza2lwU3BhY2VzQmFjayIsInNraXBDaGFyc0JhY2siLCJjbnQiLCJibG9ja19uYW1lcyIsIkhUTUxfU0VRVUVOQ0VTIiwibGluZVRleHQiLCJsaGVhZGluZyIsInNraXBCdWxsZXRMaXN0TWFya2VyIiwic2tpcE9yZGVyZWRMaXN0TWFya2VyIiwibWFya1RpZ2h0UGFyYWdyYXBocyIsImNvbnRlbnRTdGFydCIsImluZGVudCIsImluZGVudEFmdGVyTWFya2VyIiwiaXNPcmRlcmVkIiwiaXRlbUxpbmVzIiwibGlzdExpbmVzIiwibGlzdFRva0lkeCIsIm1hcmtlckNoYXJDb2RlIiwibWFya2VyVmFsdWUiLCJvbGRMSW5kZW50Iiwib2xkVGlnaHQiLCJwb3NBZnRlck1hcmtlciIsInByZXZFbXB0eUVuZCIsImlzVGVybWluYXRpbmdQYXJhZ3JhcGgiLCJNYXRoIiwibWluIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwiX2VuZExpbmUiLCJkZXN0RW5kUG9zIiwiZGVzdEVuZExpbmVObyIsImxhYmVsIiwicmVzIiwicmVmZXJlbmNlcyIsIlN0YXRlQmxvY2siLCJzIiwiaW5kZW50X2ZvdW5kIiwiZGRJbmRlbnQiLCJmcm9tIiwia2VlcExhc3RMRiIsImxpbmVJbmRlbnQiLCJmaXJzdCIsInF1ZXVlIiwibGluZVN0YXJ0IiwiZ2V0TGluZSIsImVzY2FwZWRTcGxpdCIsImVzY2FwZXMiLCJsYXN0UG9zIiwiYmFja1RpY2tlZCIsImxhc3RCYWNrVGljayIsInRhYmxlIiwiY29sdW1ucyIsImNvbHVtbkNvdW50IiwiYWxpZ25zIiwidCIsInRhYmxlTGluZXMiLCJ0Ym9keUxpbmVzIiwidG9rIiwiaXNMaW5rT3BlbiIsImlzTGlua0Nsb3NlIiwiY3VycmVudFRva2VuIiwibm9kZXMiLCJsbiIsImh0bWxMaW5rTGV2ZWwiLCJmdWxsVXJsIiwidXJsVGV4dCIsImJsb2NrVG9rZW5zIiwibGlua3MiLCJORVdMSU5FU19SRSIsIk5VTExfUkUiLCJSQVJFX1JFIiwiU0NPUEVEX0FCQlJfVEVTVF9SRSIsIlNDT1BFRF9BQkJSX1JFIiwiU0NPUEVEX0FCQlIiLCJyIiwidG0iLCJyZXBsYWNlRm4iLCJyZXBsYWNlX3Njb3BlZCIsImlubGluZVRva2VucyIsImluc2lkZV9hdXRvbGluayIsInJlcGxhY2VfcmFyZSIsImJsa0lkeCIsIlFVT1RFX1RFU1RfUkUiLCJRVU9URV9SRSIsIkFQT1NUUk9QSEUiLCJyZXBsYWNlQXQiLCJwcm9jZXNzX2lubGluZXMiLCJ0aGlzTGV2ZWwiLCJpdGVtIiwibGFzdENoYXIiLCJuZXh0Q2hhciIsImlzTGFzdFB1bmN0Q2hhciIsImlzTmV4dFB1bmN0Q2hhciIsImlzTGFzdFdoaXRlU3BhY2UiLCJpc05leHRXaGl0ZVNwYWNlIiwiY2FuT3BlbiIsImNhbkNsb3NlIiwiaXNTaW5nbGUiLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsIkVNQUlMX1JFIiwiQVVUT0xJTktfUkUiLCJhdXRvbGluayIsImxpbmtNYXRjaCIsImVtYWlsTWF0Y2giLCJiYWNrdGljayIsIm1hdGNoU3RhcnQiLCJtYXRjaEVuZCIsImxpbmtfcGFpcnMiLCJsYXN0RGVsaW0iLCJjdXJyRGVsaW0iLCJvZGRfbWF0Y2giLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJFU0NBUEVEIiwiaXNMZXR0ZXIiLCJsYyIsImxhYmVsU3RhcnQiLCJyZWYiLCJwYXJzZVJlZmVyZW5jZSIsIm5ld2xpbmUiLCJwbWF4IiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJsZWZ0X2ZsYW5raW5nIiwicmlnaHRfZmxhbmtpbmciLCJpc1Rlcm1pbmF0b3JDaGFyIiwidGV4dF9jb2xsYXBzZSIsImN1cnIiLCJkZWNvZGVDYWNoZSIsImdldERlY29kZUNhY2hlIiwiZXhjbHVkZSIsInN0cmluZyIsImRlZmF1bHRDaGFycyIsInNlcSIsImIxIiwiYjIiLCJiMyIsImI0IiwiY2hyIiwiY29tcG9uZW50Q2hhcnMiLCJlbmNvZGVDYWNoZSIsImdldEVuY29kZUNhY2hlIiwia2VlcEVzY2FwZWQiLCJuZXh0Q29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsInBhdGhuYW1lIiwiaGFzaCIsIlVybCIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwidXJsUGFyc2UiLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJsb3dlclByb3RvIiwiaGVjIiwicmVzdCIsInNpbXBsZVBhdGgiLCJwcm90byIsImhvc3RFbmQiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsImhvc3QiLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwicW0iLCJyb290IiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwiZnJlZUdsb2JhbCIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiUmFuZ2VFcnJvciIsImFycmF5IiwibWFwRG9tYWluIiwicGFydHMiLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsIm91dHB1dCIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsIm4iLCJiaWFzIiwiYmFzaWMiLCJvbGRpIiwidyIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJBbnkiLCJDYyIsIkNmIiwiUCIsIloiLCJsQmFzaCIsImxDc3MiLCJsSmF2YXNjcmlwdCIsImxYbWwiLCJNYXJrZG93bkl0RGVjb3JhdGUiLCIkYm9yZGVyIiwiX3VwZGF0ZUJvcmRlciIsIiRuYXYiLCJ3aWR0aCIsImxlZnQiLCJwb3NpdGlvbiIsIm91dGVyV2lkdGgiLCJhZGRDbGFzcyIsImNzcyIsIl9vYmoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFHS0EsT0FBT0MsUUFBUCxFOzs7Ozs7Ozs7dUJBR0RDLE0scUJBQVM7QUFDTCwwQkFBTUEsTUFBTjtBQUNBLFlBQU1DLFdBQVdDLEVBQUUsS0FBS0MsT0FBUCxDQUFqQjtBQUNBLFlBQU1DLE9BQU9ILFNBQVNJLElBQVQsQ0FBYyx3QkFBZCxDQUFiO0FBQ0EsYUFBSyxJQUFJQyxJQUFJLENBQWIs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dkIsU0FBT00saUJBQWlCcEIsSUFBakIsQ0FBc0JjLEVBQXRCLENBQVA7QUFDRDs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNRLGNBQVQsQ0FBd0JSLEVBQXhCLEVBQTRCO0FBQzFCLFVBQVFBLEVBQVI7QUFDRSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUws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QixHQUFHLDBDQUEwQyxxQkFBcUIsMkJBQTJCLGdCQUFnQixHQUFHLGdEQUFnRCxxQkFBcUIsR0FBRyxzQ0FBc0Msa0JBQWtCLG1CQUFtQixrQkFBa0IscUJBQXFCLEdBQUcscUNBQXFDLFlBQVksR0FBRyx3Q0FBd0MsaUJBQWlCLEdBQUcsZ0NBQWdDLHdCQUF3QixvQkFBb0IsR0FBRyxtQ0FBbUMsbUJBQW1CLGdCQUFnQixHQUFHLG1DQUFtQyxtQkFBbUIscUJBQXFCLG9CQUFvQixHQUFHLDZCQUE2QixrQkFBa0Isd0JBQXdCLDRCQUE0QixxQkFBcUIsR0FBRyxtQ0FBbUMsaUJBQWlCLEdBQUcsdUNBQXVDLGlCQUFpQixHQUFHLHdDQUF3QyxxQkFBcUIsR0FBRyxxQ0FBcUMsaUJBQWlCLGlCQUFpQixxQkFBcUIsdUJBQXVCLGtCQUFrQixHQUFHLG9DQUFvQyxnQkFBZ0IsbUJBQW1CLHdCQUF3QixHQUFHLHFDQUFxQyxxQkFBcUIsa0JBQWtCLEdBQUcsb0NBQW9DLG1CQUFtQixtQkFBbUIsR0FBRzs7QUFFdm1HOzs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQyIsImZpbGUiOiJzdGF0aWMvY2h1bmsvMWRjMDUwNmY0ZGY1ZDc2Njg0YjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9pbmRleC52ZHQnO1xuaW1wb3J0IGNzcyBmcm9tICcuL2luZGV4LnN0eWwnO1xuaW1wb3J0IHtoaWdobGlnaHQsIG1hcmtlZH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBMYXlvdXQge1xuICAgIEBJbnRhY3QudGVtcGxhdGUoKVxuICAgIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIHRlbXBsYXRlOyB9XG5cbiAgICBfbW91bnQoKSB7XG4gICAgICAgIHN1cGVyLl9tb3VudCgpO1xuICAgICAgICBjb25zdCAkZWxlbWVudCA9ICQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgY29uc3QgJG1kcyA9ICRlbGVtZW50LmZpbmQoJ3NjcmlwdFt0eXBlPVwidGV4dC9tZFwiXScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRtZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCAkbWQgPSAkKCRtZHNbaV0pO1xuICAgICAgICAgICAgbGV0IG1kID0gJG1kLnRleHQoKTtcbiAgICAgICAgICAgIGxldCBodG1sID0gbWFya2VkLnJlbmRlcihtZCk7XG4gICAgICAgICAgICBpZiAoJG1kLmhhc0NsYXNzKCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAkbWQubmV4dFVudGlsKCcuY29kZScpLm5leHQoKS5odG1sKGh0bWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkZGl2ID0gJCgnPGRpdiAvPicpLmh0bWwoaHRtbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGNvZGVzID0gJGRpdi5maW5kKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJGNvZGUgPSAkKCRjb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gJGNvZGUudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGNvZGUuaGFzQ2xhc3MoJ2xhbmd1YWdlLWh0bWwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBJbnRhY3QuVmR0LmNvbXBpbGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJGNvZGUuaGFzQ2xhc3MoJ2xhbmd1YWdlLWNzcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY29kZS5wYXJlbnQoKS5hZnRlcihgPHN0eWxlPiR7Y29kZX08L3N0eWxlPmApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRjb2RlLmhhc0NsYXNzKCdsYW5ndWFnZS1qcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkY29kZXMgPSAkZWxlbWVudC5maW5kKCdwcmUgY29kZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0ICRjb2RlID0gJCgkY29kZXNbaV0pO1xuICAgICAgICAgICAgaGlnaGxpZ2h0LmhpZ2hsaWdodEJsb2NrKCRjb2RlWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvcGFnZXMvaW5kZXgvaW5kZXguanMiLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn0qL1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUFsbChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgIGlmIChlc2NhcGVkKSB7IHJldHVybiBlc2NhcGVkOyB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgJ1xcXFwkJicpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OlxuICAgIGNhc2UgMHgyMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICBpZiAoY29kZSA+PSAweDIwMDAgJiYgY29kZSA8PSAweDIwMEEpIHsgcmV0dXJuIHRydWU7IH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG52YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxuZnVuY3Rpb24gaXNQdW5jdENoYXIoY2gpIHtcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG59XG5cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDI3LyogJyAqLzpcbiAgICBjYXNlIDB4MjgvKiAoICovOlxuICAgIGNhc2UgMHgyOS8qICkgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyQy8qICwgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4MkUvKiAuICovOlxuICAgIGNhc2UgMHgyRi8qIC8gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHgzRi8qID8gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0MvKiB8ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVwbGVyIHRvIHVuaWZ5IFtyZWZlcmVuY2UgbGFiZWxzXS5cbi8vXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5leHBvcnRzLmxpYiAgICAgICAgICAgICAgICAgPSB7fTtcbmV4cG9ydHMubGliLm1kdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcbmV4cG9ydHMuaGFzICAgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcbmV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgICA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICAgID0gZnJvbUNvZGVQb2ludDtcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlSHRtbCAgICAgICAgICA9IGVzY2FwZUh0bWw7XG5leHBvcnRzLmFycmF5UmVwbGFjZUF0ICAgICAgPSBhcnJheVJlcGxhY2VBdDtcbmV4cG9ydHMuaXNTcGFjZSAgICAgICAgICAgICA9IGlzU3BhY2U7XG5leHBvcnRzLmlzV2hpdGVTcGFjZSAgICAgICAgPSBpc1doaXRlU3BhY2U7XG5leHBvcnRzLmlzTWRBc2NpaVB1bmN0ICAgICAgPSBpc01kQXNjaWlQdW5jdDtcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xuZXhwb3J0cy5lc2NhcGVSRSAgICAgICAgICAgID0gZXNjYXBlUkU7XG5leHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSAgPSBub3JtYWxpemVSZWZlcmVuY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9ncmFwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwiLy8gVG9rZW4gY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogY2xhc3MgVG9rZW5cbiAqKi9cblxuLyoqXG4gKiBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICpcbiAqIENyZWF0ZSBuZXcgdG9rZW4gYW5kIGZpbGwgcGFzc2VkIHByb3BlcnRpZXMuXG4gKiovXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgLyoqXG4gICAqIFRva2VuI3R5cGUgLT4gU3RyaW5nXG4gICAqXG4gICAqIFR5cGUgb2YgdGhlIHRva2VuIChzdHJpbmcsIGUuZy4gXCJwYXJhZ3JhcGhfb3BlblwiKVxuICAgKiovXG4gIHRoaXMudHlwZSAgICAgPSB0eXBlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiN0YWcgLT4gU3RyaW5nXG4gICAqXG4gICAqIGh0bWwgdGFnIG5hbWUsIGUuZy4gXCJwXCJcbiAgICoqL1xuICB0aGlzLnRhZyAgICAgID0gdGFnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNhdHRycyAtPiBBcnJheVxuICAgKlxuICAgKiBIdG1sIGF0dHJpYnV0ZXMuIEZvcm1hdDogYFsgWyBuYW1lMSwgdmFsdWUxIF0sIFsgbmFtZTIsIHZhbHVlMiBdIF1gXG4gICAqKi9cbiAgdGhpcy5hdHRycyAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcCAtPiBBcnJheVxuICAgKlxuICAgKiBTb3VyY2UgbWFwIGluZm8uIEZvcm1hdDogYFsgbGluZV9iZWdpbiwgbGluZV9lbmQgXWBcbiAgICoqL1xuICB0aGlzLm1hcCAgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbmVzdGluZyAtPiBOdW1iZXJcbiAgICpcbiAgICogTGV2ZWwgY2hhbmdlIChudW1iZXIgaW4gey0xLCAwLCAxfSBzZXQpLCB3aGVyZTpcbiAgICpcbiAgICogLSAgYDFgIG1lYW5zIHRoZSB0YWcgaXMgb3BlbmluZ1xuICAgKiAtICBgMGAgbWVhbnMgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmdcbiAgICogLSBgLTFgIG1lYW5zIHRoZSB0YWcgaXMgY2xvc2luZ1xuICAgKiovXG4gIHRoaXMubmVzdGluZyAgPSBuZXN0aW5nO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcbiAgICpcbiAgICogbmVzdGluZyBsZXZlbCwgdGhlIHNhbWUgYXMgYHN0YXRlLmxldmVsYFxuICAgKiovXG4gIHRoaXMubGV2ZWwgICAgPSAwO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjaGlsZHJlbiAtPiBBcnJheVxuICAgKlxuICAgKiBBbiBhcnJheSBvZiBjaGlsZCBub2RlcyAoaW5saW5lIGFuZCBpbWcgdG9rZW5zKVxuICAgKiovXG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjb250ZW50IC0+IFN0cmluZ1xuICAgKlxuICAgKiBJbiBhIGNhc2Ugb2Ygc2VsZi1jbG9zaW5nIHRhZyAoY29kZSwgaHRtbCwgZmVuY2UsIGV0Yy4pLFxuICAgKiBpdCBoYXMgY29udGVudHMgb2YgdGhpcyB0YWcuXG4gICAqKi9cbiAgdGhpcy5jb250ZW50ICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXJrdXAgLT4gU3RyaW5nXG4gICAqXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5tYXJrdXAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNpbmZvIC0+IFN0cmluZ1xuICAgKlxuICAgKiBmZW5jZSBpbmZvc3RyaW5nXG4gICAqKi9cbiAgdGhpcy5pbmZvICAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxuICAgKlxuICAgKiBBIHBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBkYXRhXG4gICAqKi9cbiAgdGhpcy5tZXRhICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2Jsb2NrIC0+IEJvb2xlYW5cbiAgICpcbiAgICogVHJ1ZSBmb3IgYmxvY2stbGV2ZWwgdG9rZW5zLCBmYWxzZSBmb3IgaW5saW5lIHRva2Vucy5cbiAgICogVXNlZCBpbiByZW5kZXJlciB0byBjYWxjdWxhdGUgbGluZSBicmVha3NcbiAgICoqL1xuICB0aGlzLmJsb2NrICAgID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRva2VuI2hpZGRlbiAtPiBCb29sZWFuXG4gICAqXG4gICAqIElmIGl0J3MgdHJ1ZSwgaWdub3JlIHRoaXMgZWxlbWVudCB3aGVuIHJlbmRlcmluZy4gVXNlZCBmb3IgdGlnaHQgbGlzdHNcbiAgICogdG8gaGlkZSBwYXJhZ3JhcGhzLlxuICAgKiovXG4gIHRoaXMuaGlkZGVuICAgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFRva2VuLmF0dHJJbmRleChuYW1lKSAtPiBOdW1iZXJcbiAqXG4gKiBTZWFyY2ggYXR0cmlidXRlIGluZGV4IGJ5IG5hbWUuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckluZGV4ID0gZnVuY3Rpb24gYXR0ckluZGV4KG5hbWUpIHtcbiAgdmFyIGF0dHJzLCBpLCBsZW47XG5cbiAgaWYgKCF0aGlzLmF0dHJzKSB7IHJldHVybiAtMTsgfVxuXG4gIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSA9PT0gbmFtZSkgeyByZXR1cm4gaTsgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyUHVzaChhdHRyRGF0YSlcbiAqXG4gKiBBZGQgYFsgbmFtZSwgdmFsdWUgXWAgYXR0cmlidXRlIHRvIGxpc3QuIEluaXQgYXR0cnMgaWYgbmVjZXNzYXJ5XG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clB1c2ggPSBmdW5jdGlvbiBhdHRyUHVzaChhdHRyRGF0YSkge1xuICBpZiAodGhpcy5hdHRycykge1xuICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRycyA9IFsgYXR0ckRhdGEgXTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJTZXQobmFtZSwgdmFsdWUpXG4gKlxuICogU2V0IGBuYW1lYCBhdHRyaWJ1dGUgdG8gYHZhbHVlYC4gT3ZlcnJpZGUgb2xkIHZhbHVlIGlmIGV4aXN0cy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyU2V0ID0gZnVuY3Rpb24gYXR0clNldChuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksXG4gICAgICBhdHRyRGF0YSA9IFsgbmFtZSwgdmFsdWUgXTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJEYXRhO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckdldChuYW1lKVxuICpcbiAqIEdldCB0aGUgdmFsdWUgb2YgYXR0cmlidXRlIGBuYW1lYCwgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyR2V0ID0gZnVuY3Rpb24gYXR0ckdldChuYW1lKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgdmFsdWUgPSBudWxsO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckpvaW4obmFtZSwgdmFsdWUpXG4gKlxuICogSm9pbiB2YWx1ZSB0byBleGlzdGluZyBhdHRyaWJ1dGUgdmlhIHNwYWNlLiBPciBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBpZiBub3RcbiAqIGV4aXN0cy4gVXNlZnVsIHRvIG9wZXJhdGUgd2l0aCB0b2tlbiBjbGFzc2VzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJKb2luID0gZnVuY3Rpb24gYXR0ckpvaW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChbIG5hbWUsIHZhbHVlIF0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XVsxXSA9IHRoaXMuYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQ5XFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA2W1xcdURFM0YtXFx1REU0NlxcdURFOUEtXFx1REU5Q1xcdURFOUUtXFx1REVBMl18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwiLy8gSFRNTDUgZW50aXRpZXMgbWFwOiB7IG5hbWUgLT4gdXRmMTZzdHJpbmcgfVxuLy9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgcXVvdGVzOjAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcblxudmFyIHVucXVvdGVkICAgICAgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG5cbnZhciBhdHRyX3ZhbHVlICA9ICcoPzonICsgdW5xdW90ZWQgKyAnfCcgKyBzaW5nbGVfcXVvdGVkICsgJ3wnICsgZG91YmxlX3F1b3RlZCArICcpJztcblxudmFyIGF0dHJpYnV0ZSAgID0gJyg/OlxcXFxzKycgKyBhdHRyX25hbWUgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyX3ZhbHVlICsgJyk/KSc7XG5cbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xuXG52YXIgY2xvc2VfdGFnICAgPSAnPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj4nO1xudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIHByb2Nlc3NpbmcgID0gJzxbP10uKj9bP10+JztcbnZhciBkZWNsYXJhdGlvbiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgY2RhdGEgICAgICAgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcblxudmFyIEhUTUxfVEFHX1JFID0gbmV3IFJlZ0V4cCgnXig/OicgKyBvcGVuX3RhZyArICd8JyArIGNsb3NlX3RhZyArICd8JyArIGNvbW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgcHJvY2Vzc2luZyArICd8JyArIGRlY2xhcmF0aW9uICsgJ3wnICsgY2RhdGEgKyAnKScpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJyknKTtcblxubW9kdWxlLmV4cG9ydHMuSFRNTF9UQUdfUkUgPSBIVE1MX1RBR19SRTtcbm1vZHVsZS5leHBvcnRzLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEFuIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGJlZm9yZSB0aGlzIG9uZSB0aGF0J3MgZXF1aXZhbGVudCB0b1xuICAgICAgLy8gY3VycmVudCBvbmUuIEluIHBsYWluIEVuZ2xpc2g6IGlmIHRoaXMgZGVsaW1pdGVyIGRvZXMgbm90IG9wZW5cbiAgICAgIC8vIGFuIGVtcGhhc2lzLCBuZWl0aGVyIGRvIHByZXZpb3VzIGBqdW1wYCBjaGFyYWN0ZXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFVzZWQgdG8gc2tpcCBzZXF1ZW5jZXMgbGlrZSBcIioqKioqXCIgaW4gb25lIHN0ZXAsIGZvciAxc3QgYXN0ZXJpc2tcbiAgICAgIC8vIHZhbHVlIHdpbGwgYmUgMCwgZm9yIDJuZCBpdCdzIDEgYW5kIHNvIG9uLlxuICAgICAgLy9cbiAgICAgIGp1bXA6ICAgaSxcblxuICAgICAgLy8gQSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gdGhpcyBkZWxpbWl0ZXIgY29ycmVzcG9uZHMgdG8uXG4gICAgICAvL1xuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcblxuICAgICAgLy8gVG9rZW4gbGV2ZWwuXG4gICAgICAvL1xuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcblxuICAgICAgLy8gSWYgdGhpcyBkZWxpbWl0ZXIgaXMgbWF0Y2hlZCBhcyBhIHZhbGlkIG9wZW5lciwgYGVuZGAgd2lsbCBiZVxuICAgICAgLy8gZXF1YWwgdG8gaXRzIHBvc2l0aW9uLCBvdGhlcndpc2UgaXQncyBgLTFgLlxuICAgICAgLy9cbiAgICAgIGVuZDogICAgLTEsXG5cbiAgICAgIC8vIEJvb2xlYW4gZmxhZ3MgdGhhdCBkZXRlcm1pbmUgaWYgdGhpcyBkZWxpbWl0ZXIgY291bGQgb3BlbiBvciBjbG9zZVxuICAgICAgLy8gYW4gZW1waGFzaXMuXG4gICAgICAvL1xuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSkge1xuICB2YXIgaSxcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgY2gsXG4gICAgICBpc1N0cm9uZyxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gbWF4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4MkEvKiAqICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIC8vIElmIHRoZSBwcmV2aW91cyBkZWxpbWl0ZXIgaGFzIHRoZSBzYW1lIG1hcmtlciBhbmQgaXMgYWRqYWNlbnQgdG8gdGhpcyBvbmUsXG4gICAgLy8gbWVyZ2UgdGhvc2UgaW50byBvbmUgc3Ryb25nIGRlbGltaXRlci5cbiAgICAvL1xuICAgIC8vIGA8ZW0+PGVtPndoYXRldmVyPC9lbT48L2VtPmAgLT4gYDxzdHJvbmc+d2hhdGV2ZXI8L3N0cm9uZz5gXG4gICAgLy9cbiAgICBpc1N0cm9uZyA9IGkgPiAwICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgLSAxXS5lbmQgPT09IHN0YXJ0RGVsaW0uZW5kICsgMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW4gPT09IGVuZERlbGltLnRva2VuICsgMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlcjtcblxuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydERlbGltLm1hcmtlcik7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfb3BlbicgOiAnZW1fb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX2Nsb3NlJyA6ICdlbV9jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKGlzU3Ryb25nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpIC0gMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBqdW1wOiAgIGksXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcbiAgICAgIGVuZDogICAgLTEsXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUpIHtcbiAgdmFyIGksIGosXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGxvbmVNYXJrZXJzID0gW10sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tZHVybC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmosIF9WZHQsIGJsb2NrcywgJGNhbGxlZSkge1xuICAgIF9WZHQgfHwgKF9WZHQgPSBWZHQpO1xuICAgIG9iaiB8fCAob2JqID0ge30pO1xuICAgIGJsb2NrcyB8fCAoYmxvY2tzID0ge30pO1xuICAgIHZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG4gICAgICAgIF9fdSA9IF9WZHQudXRpbHMsIGV4dGVuZCA9IF9fdS5leHRlbmQsIF9lID0gX191LmVycm9yLCBfY2xhc3NOYW1lID0gX191LmNsYXNzTmFtZSwgX19zbGljZSA9IF9fdS5zbGljZSwgX19ub29wID0gX191Lm5vb3AsXG4gICAgICAgIF9fbSA9IF9fdS5tYXAsIF9fbyA9IF9fdS5PcHRpb25zLCBfZ2V0TW9kZWwgPSBfX28uZ2V0TW9kZWwsIF9zZXRNb2RlbCA9IF9fby5zZXRNb2RlbCxcbiAgICAgICAgX3NldENoZWNrYm94TW9kZWwgPSBfX3Uuc2V0Q2hlY2tib3hNb2RlbCwgX2RldGVjdENoZWNrYm94Q2hlY2tlZCA9IF9fdS5kZXRlY3RDaGVja2JveENoZWNrZWQsXG4gICAgICAgIF9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbiAgICAgICAgc2VsZiA9IHRoaXMuZGF0YSwgJHRoaXMgPSB0aGlzLCBzY29wZSA9IG9iaiwgQW5pbWF0ZSA9IHNlbGYgJiYgc2VsZi5BbmltYXRlLCBwYXJlbnQgPSAoJGNhbGxlZSB8fCB7fSkuX3N1cGVyO1xuXG4gICAgY29uc3QgbmF2ID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6ICfmlZnnqIsnLFxuICAgICAgICBocmVmOiAnZG9jdW1lbnQnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnQVBJJyxcbiAgICAgICAgaHJlZjogJ2FwaSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdCbG9nJyxcbiAgICAgICAgaHJlZjogJ2Jsb2cnXG4gICAgfVxuXVxuICAgIHJldHVybiBoKCdkaXYnLCBudWxsLCBbXG4gICAgICAgIGgoJ2RpdicsIG51bGwsIGgoJ2hlYWRlcicsIG51bGwsIChfYmxvY2tzWydoZWFkZXInXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBoKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAnaHJlZic6ICcjLydcbiAgICAgICAgICAgICAgICB9LCAnSW50YWN0JywgJ2xvZ28nKSxcbiAgICAgICAgICAgICAgICBoKCduYXYnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgIF9fbShmdW5jdGlvbigpIHt0cnkge3JldHVybiAobmF2KX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKGAjLyR7dmFsdWUuaHJlZn1gKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh2YWx1ZS50aXRsZSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHZhbHVlLmhyZWYgPT09IHNjb3BlLm5hdkluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCAkdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsIG51bGwsICdib3JkZXInKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSAmJiAoX19ibG9ja3NbJ2hlYWRlciddID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiBibG9ja3NbJ2hlYWRlciddID8gYmxvY2tzWydoZWFkZXInXS5hcHBseSgkdGhpcywgW2Z1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYmxvY2tzWydoZWFkZXInXS5hcHBseSgkdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3MsIDEpKSkgOiBfYmxvY2tzWydoZWFkZXInXS5hcHBseSgkdGhpcywgYXJncyk7XG4gICAgICAgIH0pICYmIF9fYmxvY2tzWydoZWFkZXInXS5hcHBseSgkdGhpcywgW19fbm9vcF0pKSwgJ2hlYWRlci13cmFwcGVyJyksXG4gICAgICAgIGgoJ2RpdicsIG51bGwsIChfYmxvY2tzWydjb250ZW50J10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSAmJiAoX19ibG9ja3NbJ2NvbnRlbnQnXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tzWydjb250ZW50J10gPyBibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgW2Z1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzLCAxKSkpIDogX2Jsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgfSkgJiYgX19ibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgW19fbm9vcF0pLCAnY29udGVudC13cmFwcGVyJylcbiAgICBdLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICgnbWFpbi13cmFwcGVyICcgKyAoc2NvcGUuY2xhc3NOYW1lIHx8ICcnKSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpKSlcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaXRlL3BhZ2VzL2xheW91dC52ZHQiLCIvKlxuU3ludGF4IGhpZ2hsaWdodGluZyB3aXRoIGxhbmd1YWdlIGF1dG9kZXRlY3Rpb24uXG5odHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG5cbiAgLy8gRmluZCB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgZXhwb3J0IHRvIGJvdGggdGhlIGJyb3dzZXIgYW5kIHdlYiB3b3JrZXJzLlxuICB2YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93IHx8XG4gICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZjtcblxuICAvLyBTZXR1cCBoaWdobGlnaHQuanMgZm9yIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuIEZpcnN0IGlzIE5vZGUuanMgb3JcbiAgLy8gQ29tbW9uSlMuXG4gIGlmKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gIH0gZWxzZSBpZihnbG9iYWxPYmplY3QpIHtcbiAgICAvLyBFeHBvcnQgaGxqcyBnbG9iYWxseSBldmVuIHdoZW4gdXNpbmcgQU1EIGZvciBjYXNlcyB3aGVuIHRoaXMgc2NyaXB0XG4gICAgLy8gaXMgbG9hZGVkIHdpdGggb3RoZXJzIHRoYXQgbWF5IHN0aWxsIGV4cGVjdCBhIGdsb2JhbCBobGpzLlxuICAgIGdsb2JhbE9iamVjdC5obGpzID0gZmFjdG9yeSh7fSk7XG5cbiAgICAvLyBGaW5hbGx5IHJlZ2lzdGVyIHRoZSBnbG9iYWwgaGxqcyB3aXRoIEFNRC5cbiAgICBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxPYmplY3QuaGxqcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59KGZ1bmN0aW9uKGhsanMpIHtcbiAgLy8gQ29udmVuaWVuY2UgdmFyaWFibGVzIGZvciBidWlsZC1pbiBvYmplY3RzXG4gIHZhciBBcnJheVByb3RvID0gW10sXG4gICAgICBvYmplY3RLZXlzID0gT2JqZWN0LmtleXM7XG5cbiAgLy8gR2xvYmFsIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIHdpdGhpbiB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIHZhciBsYW5ndWFnZXMgPSB7fSxcbiAgICAgIGFsaWFzZXMgICA9IHt9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCB0aHJvdWdob3V0IHRoZSBoaWdobGlnaHQuanMgbGlicmFyeS5cbiAgdmFyIG5vSGlnaGxpZ2h0UmUgICAgPSAvXihuby0/aGlnaGxpZ2h0fHBsYWlufHRleHQpJC9pLFxuICAgICAgbGFuZ3VhZ2VQcmVmaXhSZSA9IC9cXGJsYW5nKD86dWFnZSk/LShbXFx3LV0rKVxcYi9pLFxuICAgICAgZml4TWFya3VwUmUgICAgICA9IC8oKF4oPFtePl0rPnxcXHR8KSt8KD86XFxuKSkpL2dtO1xuXG4gIHZhciBzcGFuRW5kVGFnID0gJzwvc3Bhbj4nO1xuXG4gIC8vIEdsb2JhbCBvcHRpb25zIHVzZWQgd2hlbiB3aXRoaW4gZXh0ZXJuYWwgQVBJcy4gVGhpcyBpcyBtb2RpZmllZCB3aGVuXG4gIC8vIGNhbGxpbmcgdGhlIGBobGpzLmNvbmZpZ3VyZWAgZnVuY3Rpb24uXG4gIHZhciBvcHRpb25zID0ge1xuICAgIGNsYXNzUHJlZml4OiAnaGxqcy0nLFxuICAgIHRhYlJlcGxhY2U6IG51bGwsXG4gICAgdXNlQlI6IGZhbHNlLFxuICAgIGxhbmd1YWdlczogdW5kZWZpbmVkXG4gIH07XG5cblxuICAvKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuXG4gIGZ1bmN0aW9uIGVzY2FwZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gIH1cblxuICBmdW5jdGlvbiB0YWcobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0UmUocmUsIGxleGVtZSkge1xuICAgIHZhciBtYXRjaCA9IHJlICYmIHJlLmV4ZWMobGV4ZW1lKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vdEhpZ2hsaWdodGVkKGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIG5vSGlnaGxpZ2h0UmUudGVzdChsYW5ndWFnZSk7XG4gIH1cblxuICBmdW5jdGlvbiBibG9ja0xhbmd1YWdlKGJsb2NrKSB7XG4gICAgdmFyIGksIG1hdGNoLCBsZW5ndGgsIF9jbGFzcztcbiAgICB2YXIgY2xhc3NlcyA9IGJsb2NrLmNsYXNzTmFtZSArICcgJztcblxuICAgIGNsYXNzZXMgKz0gYmxvY2sucGFyZW50Tm9kZSA/IGJsb2NrLnBhcmVudE5vZGUuY2xhc3NOYW1lIDogJyc7XG5cbiAgICAvLyBsYW5ndWFnZS0qIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBub24tcHJlZml4ZWQgY2xhc3MgbmFtZXMuXG4gICAgbWF0Y2ggPSBsYW5ndWFnZVByZWZpeFJlLmV4ZWMoY2xhc3Nlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gZ2V0TGFuZ3VhZ2UobWF0Y2hbMV0pID8gbWF0Y2hbMV0gOiAnbm8taGlnaGxpZ2h0JztcbiAgICB9XG5cbiAgICBjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgX2NsYXNzID0gY2xhc3Nlc1tpXVxuXG4gICAgICBpZiAoaXNOb3RIaWdobGlnaHRlZChfY2xhc3MpIHx8IGdldExhbmd1YWdlKF9jbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIF9jbGFzcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmhlcml0KHBhcmVudCkgeyAgLy8gaW5oZXJpdChwYXJlbnQsIG92ZXJyaWRlX29iaiwgb3ZlcnJpZGVfb2JqLCAuLi4pXG4gICAgdmFyIGtleTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgZm9yIChrZXkgaW4gcGFyZW50KVxuICAgICAgcmVzdWx0W2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICBmb3IgKGtleSBpbiBvYmopXG4gICAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qIFN0cmVhbSBtZXJnaW5nICovXG5cbiAgZnVuY3Rpb24gbm9kZVN0cmVhbShub2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIChmdW5jdGlvbiBfbm9kZVN0cmVhbShub2RlLCBvZmZzZXQpIHtcbiAgICAgIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMpXG4gICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgZXZlbnQ6ICdzdGFydCcsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIG5vZGU6IGNoaWxkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2Zmc2V0ID0gX25vZGVTdHJlYW0oY2hpbGQsIG9mZnNldCk7XG4gICAgICAgICAgLy8gUHJldmVudCB2b2lkIGVsZW1lbnRzIGZyb20gaGF2aW5nIGFuIGVuZCB0YWcgdGhhdCB3b3VsZCBhY3R1YWxseVxuICAgICAgICAgIC8vIGRvdWJsZSB0aGVtIGluIHRoZSBvdXRwdXQuIFRoZXJlIGFyZSBtb3JlIHZvaWQgZWxlbWVudHMgaW4gSFRNTFxuICAgICAgICAgIC8vIGJ1dCB3ZSBsaXN0IG9ubHkgdGhvc2UgcmVhbGlzdGljYWxseSBleHBlY3RlZCBpbiBjb2RlIGRpc3BsYXkuXG4gICAgICAgICAgaWYgKCF0YWcoY2hpbGQpLm1hdGNoKC9icnxocnxpbWd8aW5wdXQvKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICBldmVudDogJ3N0b3AnLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgbm9kZTogY2hpbGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9KShub2RlLCAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VTdHJlYW1zKG9yaWdpbmFsLCBoaWdobGlnaHRlZCwgdmFsdWUpIHtcbiAgICB2YXIgcHJvY2Vzc2VkID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5vZGVTdGFjayA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0U3RyZWFtKCkge1xuICAgICAgaWYgKCFvcmlnaW5hbC5sZW5ndGggfHwgIWhpZ2hsaWdodGVkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwubGVuZ3RoID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbFswXS5vZmZzZXQgIT09IGhpZ2hsaWdodGVkWzBdLm9mZnNldCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsWzBdLm9mZnNldCA8IGhpZ2hsaWdodGVkWzBdLm9mZnNldCkgPyBvcmlnaW5hbCA6IGhpZ2hsaWdodGVkO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgVG8gYXZvaWQgc3RhcnRpbmcgdGhlIHN0cmVhbSBqdXN0IGJlZm9yZSBpdCBzaG91bGQgc3RvcCB0aGUgb3JkZXIgaXNcbiAgICAgIGVuc3VyZWQgdGhhdCBvcmlnaW5hbCBhbHdheXMgc3RhcnRzIGZpcnN0IGFuZCBjbG9zZXMgbGFzdDpcblxuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICBpZiAoZXZlbnQxID09ICdzdGFydCcgJiYgZXZlbnQyID09ICdzdG9wJylcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkO1xuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RvcCcgJiYgZXZlbnQyID09ICdzdGFydCcpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICAgIHJldHVybiBoaWdobGlnaHRlZDtcblxuICAgICAgLi4uIHdoaWNoIGlzIGNvbGxhcHNlZCB0bzpcbiAgICAgICovXG4gICAgICByZXR1cm4gaGlnaGxpZ2h0ZWRbMF0uZXZlbnQgPT09ICdzdGFydCcgPyBvcmlnaW5hbCA6IGhpZ2hsaWdodGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wZW4obm9kZSkge1xuICAgICAgZnVuY3Rpb24gYXR0cl9zdHIoYSkge3JldHVybiAnICcgKyBhLm5vZGVOYW1lICsgJz1cIicgKyBlc2NhcGUoYS52YWx1ZSkucmVwbGFjZSgnXCInLCAnJnF1b3Q7JykgKyAnXCInO31cbiAgICAgIHJlc3VsdCArPSAnPCcgKyB0YWcobm9kZSkgKyBBcnJheVByb3RvLm1hcC5jYWxsKG5vZGUuYXR0cmlidXRlcywgYXR0cl9zdHIpLmpvaW4oJycpICsgJz4nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlKG5vZGUpIHtcbiAgICAgIHJlc3VsdCArPSAnPC8nICsgdGFnKG5vZGUpICsgJz4nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcihldmVudCkge1xuICAgICAgKGV2ZW50LmV2ZW50ID09PSAnc3RhcnQnID8gb3BlbiA6IGNsb3NlKShldmVudC5ub2RlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob3JpZ2luYWwubGVuZ3RoIHx8IGhpZ2hsaWdodGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHN0cmVhbSA9IHNlbGVjdFN0cmVhbSgpO1xuICAgICAgcmVzdWx0ICs9IGVzY2FwZSh2YWx1ZS5zdWJzdHJpbmcocHJvY2Vzc2VkLCBzdHJlYW1bMF0ub2Zmc2V0KSk7XG4gICAgICBwcm9jZXNzZWQgPSBzdHJlYW1bMF0ub2Zmc2V0O1xuICAgICAgaWYgKHN0cmVhbSA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgLypcbiAgICAgICAgT24gYW55IG9wZW5pbmcgb3IgY2xvc2luZyB0YWcgb2YgdGhlIG9yaWdpbmFsIG1hcmt1cCB3ZSBmaXJzdCBjbG9zZVxuICAgICAgICB0aGUgZW50aXJlIGhpZ2hsaWdodGVkIG5vZGUgc3RhY2ssIHRoZW4gcmVuZGVyIHRoZSBvcmlnaW5hbCB0YWcgYWxvbmdcbiAgICAgICAgd2l0aCBhbGwgdGhlIGZvbGxvd2luZyBvcmlnaW5hbCB0YWdzIGF0IHRoZSBzYW1lIG9mZnNldCBhbmQgdGhlblxuICAgICAgICByZW9wZW4gYWxsIHRoZSB0YWdzIG9uIHRoZSBoaWdobGlnaHRlZCBzdGFjay5cbiAgICAgICAgKi9cbiAgICAgICAgbm9kZVN0YWNrLnJldmVyc2UoKS5mb3JFYWNoKGNsb3NlKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHJlbmRlcihzdHJlYW0uc3BsaWNlKDAsIDEpWzBdKTtcbiAgICAgICAgICBzdHJlYW0gPSBzZWxlY3RTdHJlYW0oKTtcbiAgICAgICAgfSB3aGlsZSAoc3RyZWFtID09PSBvcmlnaW5hbCAmJiBzdHJlYW0ubGVuZ3RoICYmIHN0cmVhbVswXS5vZmZzZXQgPT09IHByb2Nlc3NlZCk7XG4gICAgICAgIG5vZGVTdGFjay5yZXZlcnNlKCkuZm9yRWFjaChvcGVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdHJlYW1bMF0uZXZlbnQgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICBub2RlU3RhY2sucHVzaChzdHJlYW1bMF0ubm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcihzdHJlYW0uc3BsaWNlKDAsIDEpWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZSh2YWx1ZS5zdWJzdHIocHJvY2Vzc2VkKSk7XG4gIH1cblxuICAvKiBJbml0aWFsaXphdGlvbiAqL1xuXG4gIGZ1bmN0aW9uIGV4cGFuZF9tb2RlKG1vZGUpIHtcbiAgICBpZiAobW9kZS52YXJpYW50cyAmJiAhbW9kZS5jYWNoZWRfdmFyaWFudHMpIHtcbiAgICAgIG1vZGUuY2FjaGVkX3ZhcmlhbnRzID0gbW9kZS52YXJpYW50cy5tYXAoZnVuY3Rpb24odmFyaWFudCkge1xuICAgICAgICByZXR1cm4gaW5oZXJpdChtb2RlLCB7dmFyaWFudHM6IG51bGx9LCB2YXJpYW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZS5jYWNoZWRfdmFyaWFudHMgfHwgKG1vZGUuZW5kc1dpdGhQYXJlbnQgJiYgW2luaGVyaXQobW9kZSldKSB8fCBbbW9kZV07XG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UpIHtcblxuICAgIGZ1bmN0aW9uIHJlU3RyKHJlKSB7XG4gICAgICAgIHJldHVybiAocmUgJiYgcmUuc291cmNlKSB8fCByZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsYW5nUmUodmFsdWUsIGdsb2JhbCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICAgIHJlU3RyKHZhbHVlKSxcbiAgICAgICAgJ20nICsgKGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyAnaScgOiAnJykgKyAoZ2xvYmFsID8gJ2cnIDogJycpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBpbGVNb2RlKG1vZGUsIHBhcmVudCkge1xuICAgICAgaWYgKG1vZGUuY29tcGlsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG1vZGUuY29tcGlsZWQgPSB0cnVlO1xuXG4gICAgICBtb2RlLmtleXdvcmRzID0gbW9kZS5rZXl3b3JkcyB8fCBtb2RlLmJlZ2luS2V5d29yZHM7XG4gICAgICBpZiAobW9kZS5rZXl3b3Jkcykge1xuICAgICAgICB2YXIgY29tcGlsZWRfa2V5d29yZHMgPSB7fTtcblxuICAgICAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgc3RyKSB7XG4gICAgICAgICAgaWYgKGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGt3KSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IGt3LnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICBjb21waWxlZF9rZXl3b3Jkc1twYWlyWzBdXSA9IFtjbGFzc05hbWUsIHBhaXJbMV0gPyBOdW1iZXIocGFpclsxXSkgOiAxXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIG1vZGUua2V5d29yZHMgPT09ICdzdHJpbmcnKSB7IC8vIHN0cmluZ1xuICAgICAgICAgIGZsYXR0ZW4oJ2tleXdvcmQnLCBtb2RlLmtleXdvcmRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3RLZXlzKG1vZGUua2V5d29yZHMpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgZmxhdHRlbihjbGFzc05hbWUsIG1vZGUua2V5d29yZHNbY2xhc3NOYW1lXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZS5rZXl3b3JkcyA9IGNvbXBpbGVkX2tleXdvcmRzO1xuICAgICAgfVxuICAgICAgbW9kZS5sZXhlbWVzUmUgPSBsYW5nUmUobW9kZS5sZXhlbWVzIHx8IC9cXHcrLywgdHJ1ZSk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKG1vZGUuYmVnaW5LZXl3b3Jkcykge1xuICAgICAgICAgIG1vZGUuYmVnaW4gPSAnXFxcXGIoJyArIG1vZGUuYmVnaW5LZXl3b3Jkcy5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcpXFxcXGInO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZS5iZWdpbilcbiAgICAgICAgICBtb2RlLmJlZ2luID0gL1xcQnxcXGIvO1xuICAgICAgICBtb2RlLmJlZ2luUmUgPSBsYW5nUmUobW9kZS5iZWdpbik7XG4gICAgICAgIGlmICghbW9kZS5lbmQgJiYgIW1vZGUuZW5kc1dpdGhQYXJlbnQpXG4gICAgICAgICAgbW9kZS5lbmQgPSAvXFxCfFxcYi87XG4gICAgICAgIGlmIChtb2RlLmVuZClcbiAgICAgICAgICBtb2RlLmVuZFJlID0gbGFuZ1JlKG1vZGUuZW5kKTtcbiAgICAgICAgbW9kZS50ZXJtaW5hdG9yX2VuZCA9IHJlU3RyKG1vZGUuZW5kKSB8fCAnJztcbiAgICAgICAgaWYgKG1vZGUuZW5kc1dpdGhQYXJlbnQgJiYgcGFyZW50LnRlcm1pbmF0b3JfZW5kKVxuICAgICAgICAgIG1vZGUudGVybWluYXRvcl9lbmQgKz0gKG1vZGUuZW5kID8gJ3wnIDogJycpICsgcGFyZW50LnRlcm1pbmF0b3JfZW5kO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUuaWxsZWdhbClcbiAgICAgICAgbW9kZS5pbGxlZ2FsUmUgPSBsYW5nUmUobW9kZS5pbGxlZ2FsKTtcbiAgICAgIGlmIChtb2RlLnJlbGV2YW5jZSA9PSBudWxsKVxuICAgICAgICBtb2RlLnJlbGV2YW5jZSA9IDE7XG4gICAgICBpZiAoIW1vZGUuY29udGFpbnMpIHtcbiAgICAgICAgbW9kZS5jb250YWlucyA9IFtdO1xuICAgICAgfVxuICAgICAgbW9kZS5jb250YWlucyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIG1vZGUuY29udGFpbnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZF9tb2RlKGMgPT09ICdzZWxmJyA/IG1vZGUgOiBjKVxuICAgICAgfSkpO1xuICAgICAgbW9kZS5jb250YWlucy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtjb21waWxlTW9kZShjLCBtb2RlKTt9KTtcblxuICAgICAgaWYgKG1vZGUuc3RhcnRzKSB7XG4gICAgICAgIGNvbXBpbGVNb2RlKG1vZGUuc3RhcnRzLCBwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGVybWluYXRvcnMgPVxuICAgICAgICBtb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIGMuYmVnaW5LZXl3b3JkcyA/ICdcXFxcLj8oJyArIGMuYmVnaW4gKyAnKVxcXFwuPycgOiBjLmJlZ2luO1xuICAgICAgICB9KVxuICAgICAgICAuY29uY2F0KFttb2RlLnRlcm1pbmF0b3JfZW5kLCBtb2RlLmlsbGVnYWxdKVxuICAgICAgICAubWFwKHJlU3RyKVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgbW9kZS50ZXJtaW5hdG9ycyA9IHRlcm1pbmF0b3JzLmxlbmd0aCA/IGxhbmdSZSh0ZXJtaW5hdG9ycy5qb2luKCd8JyksIHRydWUpIDoge2V4ZWM6IGZ1bmN0aW9uKC8qcyovKSB7cmV0dXJuIG51bGw7fX07XG4gICAgfVxuXG4gICAgY29tcGlsZU1vZGUobGFuZ3VhZ2UpO1xuICB9XG5cbiAgLypcbiAgQ29yZSBoaWdobGlnaHRpbmcgZnVuY3Rpb24uIEFjY2VwdHMgYSBsYW5ndWFnZSBuYW1lLCBvciBhbiBhbGlhcywgYW5kIGFcbiAgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gaGlnaGxpZ2h0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgcHJvcGVydGllczpcblxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG5cbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0KG5hbWUsIHZhbHVlLCBpZ25vcmVfaWxsZWdhbHMsIGNvbnRpbnVhdGlvbikge1xuXG4gICAgZnVuY3Rpb24gc3ViTW9kZShsZXhlbWUsIG1vZGUpIHtcbiAgICAgIHZhciBpLCBsZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG1vZGUuY29udGFpbnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3RSZShtb2RlLmNvbnRhaW5zW2ldLmJlZ2luUmUsIGxleGVtZSkpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZS5jb250YWluc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mTW9kZShtb2RlLCBsZXhlbWUpIHtcbiAgICAgIGlmICh0ZXN0UmUobW9kZS5lbmRSZSwgbGV4ZW1lKSkge1xuICAgICAgICB3aGlsZSAobW9kZS5lbmRzUGFyZW50ICYmIG1vZGUucGFyZW50KSB7XG4gICAgICAgICAgbW9kZSA9IG1vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUuZW5kc1dpdGhQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVuZE9mTW9kZShtb2RlLnBhcmVudCwgbGV4ZW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lsbGVnYWwobGV4ZW1lLCBtb2RlKSB7XG4gICAgICByZXR1cm4gIWlnbm9yZV9pbGxlZ2FscyAmJiB0ZXN0UmUobW9kZS5pbGxlZ2FsUmUsIGxleGVtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5d29yZE1hdGNoKG1vZGUsIG1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hfc3RyID0gbGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/IG1hdGNoWzBdLnRvTG93ZXJDYXNlKCkgOiBtYXRjaFswXTtcbiAgICAgIHJldHVybiBtb2RlLmtleXdvcmRzLmhhc093blByb3BlcnR5KG1hdGNoX3N0cikgJiYgbW9kZS5rZXl3b3Jkc1ttYXRjaF9zdHJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkU3BhbihjbGFzc25hbWUsIGluc2lkZVNwYW4sIGxlYXZlT3Blbiwgbm9QcmVmaXgpIHtcbiAgICAgIHZhciBjbGFzc1ByZWZpeCA9IG5vUHJlZml4ID8gJycgOiBvcHRpb25zLmNsYXNzUHJlZml4LFxuICAgICAgICAgIG9wZW5TcGFuICAgID0gJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzUHJlZml4LFxuICAgICAgICAgIGNsb3NlU3BhbiAgID0gbGVhdmVPcGVuID8gJycgOiBzcGFuRW5kVGFnXG5cbiAgICAgIG9wZW5TcGFuICs9IGNsYXNzbmFtZSArICdcIj4nO1xuXG4gICAgICByZXR1cm4gb3BlblNwYW4gKyBpbnNpZGVTcGFuICsgY2xvc2VTcGFuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkcygpIHtcbiAgICAgIHZhciBrZXl3b3JkX21hdGNoLCBsYXN0X2luZGV4LCBtYXRjaCwgcmVzdWx0O1xuXG4gICAgICBpZiAoIXRvcC5rZXl3b3JkcylcbiAgICAgICAgcmV0dXJuIGVzY2FwZShtb2RlX2J1ZmZlcik7XG5cbiAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgbGFzdF9pbmRleCA9IDA7XG4gICAgICB0b3AubGV4ZW1lc1JlLmxhc3RJbmRleCA9IDA7XG4gICAgICBtYXRjaCA9IHRvcC5sZXhlbWVzUmUuZXhlYyhtb2RlX2J1ZmZlcik7XG5cbiAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICByZXN1bHQgKz0gZXNjYXBlKG1vZGVfYnVmZmVyLnN1YnN0cmluZyhsYXN0X2luZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICBrZXl3b3JkX21hdGNoID0ga2V5d29yZE1hdGNoKHRvcCwgbWF0Y2gpO1xuICAgICAgICBpZiAoa2V5d29yZF9tYXRjaCkge1xuICAgICAgICAgIHJlbGV2YW5jZSArPSBrZXl3b3JkX21hdGNoWzFdO1xuICAgICAgICAgIHJlc3VsdCArPSBidWlsZFNwYW4oa2V5d29yZF9tYXRjaFswXSwgZXNjYXBlKG1hdGNoWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZShtYXRjaFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9pbmRleCA9IHRvcC5sZXhlbWVzUmUubGFzdEluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC5sZXhlbWVzUmUuZXhlYyhtb2RlX2J1ZmZlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlKG1vZGVfYnVmZmVyLnN1YnN0cihsYXN0X2luZGV4KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1N1Ykxhbmd1YWdlKCkge1xuICAgICAgdmFyIGV4cGxpY2l0ID0gdHlwZW9mIHRvcC5zdWJMYW5ndWFnZSA9PT0gJ3N0cmluZyc7XG4gICAgICBpZiAoZXhwbGljaXQgJiYgIWxhbmd1YWdlc1t0b3Auc3ViTGFuZ3VhZ2VdKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGUobW9kZV9idWZmZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gZXhwbGljaXQgP1xuICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodCh0b3Auc3ViTGFuZ3VhZ2UsIG1vZGVfYnVmZmVyLCB0cnVlLCBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0pIDpcbiAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRBdXRvKG1vZGVfYnVmZmVyLCB0b3Auc3ViTGFuZ3VhZ2UubGVuZ3RoID8gdG9wLnN1Ykxhbmd1YWdlIDogdW5kZWZpbmVkKTtcblxuICAgICAgLy8gQ291bnRpbmcgZW1iZWRkZWQgbGFuZ3VhZ2Ugc2NvcmUgdG93YXJkcyB0aGUgaG9zdCBsYW5ndWFnZSBtYXkgYmUgZGlzYWJsZWRcbiAgICAgIC8vIHdpdGggemVyb2luZyB0aGUgY29udGFpbmluZyBtb2RlIHJlbGV2YW5jZS4gVXNlY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZXhwbGljaXQpIHtcbiAgICAgICAgY29udGludWF0aW9uc1t0b3Auc3ViTGFuZ3VhZ2VdID0gcmVzdWx0LnRvcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZFNwYW4ocmVzdWx0Lmxhbmd1YWdlLCByZXN1bHQudmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQnVmZmVyKCkge1xuICAgICAgcmVzdWx0ICs9ICh0b3Auc3ViTGFuZ3VhZ2UgIT0gbnVsbCA/IHByb2Nlc3NTdWJMYW5ndWFnZSgpIDogcHJvY2Vzc0tleXdvcmRzKCkpO1xuICAgICAgbW9kZV9idWZmZXIgPSAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE5ld01vZGUobW9kZSkge1xuICAgICAgcmVzdWx0ICs9IG1vZGUuY2xhc3NOYW1lPyBidWlsZFNwYW4obW9kZS5jbGFzc05hbWUsICcnLCB0cnVlKTogJyc7XG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHtwYXJlbnQ6IHt2YWx1ZTogdG9wfX0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NMZXhlbWUoYnVmZmVyLCBsZXhlbWUpIHtcblxuICAgICAgbW9kZV9idWZmZXIgKz0gYnVmZmVyO1xuXG4gICAgICBpZiAobGV4ZW1lID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld19tb2RlID0gc3ViTW9kZShsZXhlbWUsIHRvcCk7XG4gICAgICBpZiAobmV3X21vZGUpIHtcbiAgICAgICAgaWYgKG5ld19tb2RlLnNraXApIHtcbiAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld19tb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgICAgaWYgKCFuZXdfbW9kZS5yZXR1cm5CZWdpbiAmJiAhbmV3X21vZGUuZXhjbHVkZUJlZ2luKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnROZXdNb2RlKG5ld19tb2RlLCBsZXhlbWUpO1xuICAgICAgICByZXR1cm4gbmV3X21vZGUucmV0dXJuQmVnaW4gPyAwIDogbGV4ZW1lLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVuZF9tb2RlID0gZW5kT2ZNb2RlKHRvcCwgbGV4ZW1lKTtcbiAgICAgIGlmIChlbmRfbW9kZSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gdG9wO1xuICAgICAgICBpZiAob3JpZ2luLnNraXApIHtcbiAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCEob3JpZ2luLnJldHVybkVuZCB8fCBvcmlnaW4uZXhjbHVkZUVuZCkpIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICAgIGlmIChvcmlnaW4uZXhjbHVkZUVuZCkge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAodG9wLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNwYW5FbmRUYWc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdG9wLnNraXApIHtcbiAgICAgICAgICAgIHJlbGV2YW5jZSArPSB0b3AucmVsZXZhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgICB9IHdoaWxlICh0b3AgIT09IGVuZF9tb2RlLnBhcmVudCk7XG4gICAgICAgIGlmIChlbmRfbW9kZS5zdGFydHMpIHtcbiAgICAgICAgICBzdGFydE5ld01vZGUoZW5kX21vZGUuc3RhcnRzLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbi5yZXR1cm5FbmQgPyAwIDogbGV4ZW1lLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWxsZWdhbChsZXhlbWUsIHRvcCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBsZXhlbWUgXCInICsgbGV4ZW1lICsgJ1wiIGZvciBtb2RlIFwiJyArICh0b3AuY2xhc3NOYW1lIHx8ICc8dW5uYW1lZD4nKSArICdcIicpO1xuXG4gICAgICAvKlxuICAgICAgUGFyc2VyIHNob3VsZCBub3QgcmVhY2ggdGhpcyBwb2ludCBhcyBhbGwgdHlwZXMgb2YgbGV4ZW1lcyBzaG91bGQgYmUgY2F1Z2h0XG4gICAgICBlYXJsaWVyLCBidXQgaWYgaXQgZG9lcyBkdWUgdG8gc29tZSBidWcgbWFrZSBzdXJlIGl0IGFkdmFuY2VzIGF0IGxlYXN0IG9uZVxuICAgICAgY2hhcmFjdGVyIGZvcndhcmQgdG8gcHJldmVudCBpbmZpbml0ZSBsb29waW5nLlxuICAgICAgKi9cbiAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgIHJldHVybiBsZXhlbWUubGVuZ3RoIHx8IDE7XG4gICAgfVxuXG4gICAgdmFyIGxhbmd1YWdlID0gZ2V0TGFuZ3VhZ2UobmFtZSk7XG4gICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKTtcbiAgICB2YXIgdG9wID0gY29udGludWF0aW9uIHx8IGxhbmd1YWdlO1xuICAgIHZhciBjb250aW51YXRpb25zID0ge307IC8vIGtlZXAgY29udGludWF0aW9ucyBmb3Igc3ViLWxhbmd1YWdlc1xuICAgIHZhciByZXN1bHQgPSAnJywgY3VycmVudDtcbiAgICBmb3IoY3VycmVudCA9IHRvcDsgY3VycmVudCAhPT0gbGFuZ3VhZ2U7IGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuY2xhc3NOYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGJ1aWxkU3BhbihjdXJyZW50LmNsYXNzTmFtZSwgJycsIHRydWUpICsgcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW9kZV9idWZmZXIgPSAnJztcbiAgICB2YXIgcmVsZXZhbmNlID0gMDtcbiAgICB0cnkge1xuICAgICAgdmFyIG1hdGNoLCBjb3VudCwgaW5kZXggPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdG9wLnRlcm1pbmF0b3JzLmxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC50ZXJtaW5hdG9ycy5leGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY291bnQgPSBwcm9jZXNzTGV4ZW1lKHZhbHVlLnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpLCBtYXRjaFswXSk7XG4gICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXggKyBjb3VudDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NMZXhlbWUodmFsdWUuc3Vic3RyKGluZGV4KSk7XG4gICAgICBmb3IoY3VycmVudCA9IHRvcDsgY3VycmVudC5wYXJlbnQ7IGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudCkgeyAvLyBjbG9zZSBkYW5nbGluZyBtb2Rlc1xuICAgICAgICBpZiAoY3VycmVudC5jbGFzc05hbWUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3BhbkVuZFRhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVsZXZhbmNlOiByZWxldmFuY2UsXG4gICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgIGxhbmd1YWdlOiBuYW1lLFxuICAgICAgICB0b3A6IHRvcFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5tZXNzYWdlICYmIGUubWVzc2FnZS5pbmRleE9mKCdJbGxlZ2FsJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIHZhbHVlOiBlc2NhcGUodmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gIEhpZ2hsaWdodGluZyB3aXRoIGxhbmd1YWdlIGRldGVjdGlvbi4gQWNjZXB0cyBhIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvXG4gIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAgLSBsYW5ndWFnZSAoZGV0ZWN0ZWQgbGFuZ3VhZ2UpXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcbiAgLSBzZWNvbmRfYmVzdCAob2JqZWN0IHdpdGggdGhlIHNhbWUgc3RydWN0dXJlIGZvciBzZWNvbmQtYmVzdCBoZXVyaXN0aWNhbGx5XG4gICAgZGV0ZWN0ZWQgbGFuZ3VhZ2UsIG1heSBiZSBhYnNlbnQpXG5cbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0QXV0byh0ZXh0LCBsYW5ndWFnZVN1YnNldCkge1xuICAgIGxhbmd1YWdlU3Vic2V0ID0gbGFuZ3VhZ2VTdWJzZXQgfHwgb3B0aW9ucy5sYW5ndWFnZXMgfHwgb2JqZWN0S2V5cyhsYW5ndWFnZXMpO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICB2YWx1ZTogZXNjYXBlKHRleHQpXG4gICAgfTtcbiAgICB2YXIgc2Vjb25kX2Jlc3QgPSByZXN1bHQ7XG4gICAgbGFuZ3VhZ2VTdWJzZXQuZmlsdGVyKGdldExhbmd1YWdlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaGlnaGxpZ2h0KG5hbWUsIHRleHQsIGZhbHNlKTtcbiAgICAgIGN1cnJlbnQubGFuZ3VhZ2UgPSBuYW1lO1xuICAgICAgaWYgKGN1cnJlbnQucmVsZXZhbmNlID4gc2Vjb25kX2Jlc3QucmVsZXZhbmNlKSB7XG4gICAgICAgIHNlY29uZF9iZXN0ID0gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50LnJlbGV2YW5jZSA+IHJlc3VsdC5yZWxldmFuY2UpIHtcbiAgICAgICAgc2Vjb25kX2Jlc3QgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHNlY29uZF9iZXN0Lmxhbmd1YWdlKSB7XG4gICAgICByZXN1bHQuc2Vjb25kX2Jlc3QgPSBzZWNvbmRfYmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qXG4gIFBvc3QtcHJvY2Vzc2luZyBvZiB0aGUgaGlnaGxpZ2h0ZWQgbWFya3VwOlxuXG4gIC0gcmVwbGFjZSBUQUJzIHdpdGggc29tZXRoaW5nIG1vcmUgdXNlZnVsXG4gIC0gcmVwbGFjZSByZWFsIGxpbmUtYnJlYWtzIHdpdGggJzxicj4nIGZvciBub24tcHJlIGNvbnRhaW5lcnNcblxuICAqL1xuICBmdW5jdGlvbiBmaXhNYXJrdXAodmFsdWUpIHtcbiAgICByZXR1cm4gIShvcHRpb25zLnRhYlJlcGxhY2UgfHwgb3B0aW9ucy51c2VCUilcbiAgICAgID8gdmFsdWVcbiAgICAgIDogdmFsdWUucmVwbGFjZShmaXhNYXJrdXBSZSwgZnVuY3Rpb24obWF0Y2gsIHAxKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudXNlQlIgJiYgbWF0Y2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50YWJSZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcDEucmVwbGFjZSgvXFx0L2csIG9wdGlvbnMudGFiUmVwbGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDbGFzc05hbWUocHJldkNsYXNzTmFtZSwgY3VycmVudExhbmcsIHJlc3VsdExhbmcpIHtcbiAgICB2YXIgbGFuZ3VhZ2UgPSBjdXJyZW50TGFuZyA/IGFsaWFzZXNbY3VycmVudExhbmddIDogcmVzdWx0TGFuZyxcbiAgICAgICAgcmVzdWx0ICAgPSBbcHJldkNsYXNzTmFtZS50cmltKCldO1xuXG4gICAgaWYgKCFwcmV2Q2xhc3NOYW1lLm1hdGNoKC9cXGJobGpzXFxiLykpIHtcbiAgICAgIHJlc3VsdC5wdXNoKCdobGpzJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZDbGFzc05hbWUuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJykudHJpbSgpO1xuICB9XG5cbiAgLypcbiAgQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gYSBET00gbm9kZSBjb250YWluaW5nIGNvZGUuIEFjY2VwdHMgYSBET00gbm9kZSBhbmRcbiAgdHdvIG9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGZpeE1hcmt1cC5cbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0QmxvY2soYmxvY2spIHtcbiAgICB2YXIgbm9kZSwgb3JpZ2luYWxTdHJlYW0sIHJlc3VsdCwgcmVzdWx0Tm9kZSwgdGV4dDtcbiAgICB2YXIgbGFuZ3VhZ2UgPSBibG9ja0xhbmd1YWdlKGJsb2NrKTtcblxuICAgIGlmIChpc05vdEhpZ2hsaWdodGVkKGxhbmd1YWdlKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlQlIpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnZGl2Jyk7XG4gICAgICBub2RlLmlubmVySFRNTCA9IGJsb2NrLmlubmVySFRNTC5yZXBsYWNlKC9cXG4vZywgJycpLnJlcGxhY2UoLzxiclsgXFwvXSo+L2csICdcXG4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IGJsb2NrO1xuICAgIH1cbiAgICB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICByZXN1bHQgPSBsYW5ndWFnZSA/IGhpZ2hsaWdodChsYW5ndWFnZSwgdGV4dCwgdHJ1ZSkgOiBoaWdobGlnaHRBdXRvKHRleHQpO1xuXG4gICAgb3JpZ2luYWxTdHJlYW0gPSBub2RlU3RyZWFtKG5vZGUpO1xuICAgIGlmIChvcmlnaW5hbFN0cmVhbS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnZGl2Jyk7XG4gICAgICByZXN1bHROb2RlLmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IG1lcmdlU3RyZWFtcyhvcmlnaW5hbFN0cmVhbSwgbm9kZVN0cmVhbShyZXN1bHROb2RlKSwgdGV4dCk7XG4gICAgfVxuICAgIHJlc3VsdC52YWx1ZSA9IGZpeE1hcmt1cChyZXN1bHQudmFsdWUpO1xuXG4gICAgYmxvY2suaW5uZXJIVE1MID0gcmVzdWx0LnZhbHVlO1xuICAgIGJsb2NrLmNsYXNzTmFtZSA9IGJ1aWxkQ2xhc3NOYW1lKGJsb2NrLmNsYXNzTmFtZSwgbGFuZ3VhZ2UsIHJlc3VsdC5sYW5ndWFnZSk7XG4gICAgYmxvY2sucmVzdWx0ID0ge1xuICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5sYW5ndWFnZSxcbiAgICAgIHJlOiByZXN1bHQucmVsZXZhbmNlXG4gICAgfTtcbiAgICBpZiAocmVzdWx0LnNlY29uZF9iZXN0KSB7XG4gICAgICBibG9jay5zZWNvbmRfYmVzdCA9IHtcbiAgICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5zZWNvbmRfYmVzdC5sYW5ndWFnZSxcbiAgICAgICAgcmU6IHJlc3VsdC5zZWNvbmRfYmVzdC5yZWxldmFuY2VcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgVXBkYXRlcyBoaWdobGlnaHQuanMgZ2xvYmFsIG9wdGlvbnMgd2l0aCB2YWx1ZXMgcGFzc2VkIGluIHRoZSBmb3JtIG9mIGFuIG9iamVjdC5cbiAgKi9cbiAgZnVuY3Rpb24gY29uZmlndXJlKHVzZXJfb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBpbmhlcml0KG9wdGlvbnMsIHVzZXJfb3B0aW9ucyk7XG4gIH1cblxuICAvKlxuICBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhbGwgPHByZT48Y29kZT4uLjwvY29kZT48L3ByZT4gYmxvY2tzIG9uIGEgcGFnZS5cbiAgKi9cbiAgZnVuY3Rpb24gaW5pdEhpZ2hsaWdodGluZygpIHtcbiAgICBpZiAoaW5pdEhpZ2hsaWdodGluZy5jYWxsZWQpXG4gICAgICByZXR1cm47XG4gICAgaW5pdEhpZ2hsaWdodGluZy5jYWxsZWQgPSB0cnVlO1xuXG4gICAgdmFyIGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyk7XG4gICAgQXJyYXlQcm90by5mb3JFYWNoLmNhbGwoYmxvY2tzLCBoaWdobGlnaHRCbG9jayk7XG4gIH1cblxuICAvKlxuICBBdHRhY2hlcyBoaWdobGlnaHRpbmcgdG8gdGhlIHBhZ2UgbG9hZCBldmVudC5cbiAgKi9cbiAgZnVuY3Rpb24gaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgaW5pdEhpZ2hsaWdodGluZywgZmFsc2UpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbml0SGlnaGxpZ2h0aW5nLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlckxhbmd1YWdlKG5hbWUsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxhbmcgPSBsYW5ndWFnZXNbbmFtZV0gPSBsYW5ndWFnZShobGpzKTtcbiAgICBpZiAobGFuZy5hbGlhc2VzKSB7XG4gICAgICBsYW5nLmFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbihhbGlhcykge2FsaWFzZXNbYWxpYXNdID0gbmFtZTt9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0TGFuZ3VhZ2VzKCkge1xuICAgIHJldHVybiBvYmplY3RLZXlzKGxhbmd1YWdlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMYW5ndWFnZShuYW1lKSB7XG4gICAgbmFtZSA9IChuYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBsYW5ndWFnZXNbbmFtZV0gfHwgbGFuZ3VhZ2VzW2FsaWFzZXNbbmFtZV1dO1xuICB9XG5cbiAgLyogSW50ZXJmYWNlIGRlZmluaXRpb24gKi9cblxuICBobGpzLmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgaGxqcy5oaWdobGlnaHRBdXRvID0gaGlnaGxpZ2h0QXV0bztcbiAgaGxqcy5maXhNYXJrdXAgPSBmaXhNYXJrdXA7XG4gIGhsanMuaGlnaGxpZ2h0QmxvY2sgPSBoaWdobGlnaHRCbG9jaztcbiAgaGxqcy5jb25maWd1cmUgPSBjb25maWd1cmU7XG4gIGhsanMuaW5pdEhpZ2hsaWdodGluZyA9IGluaXRIaWdobGlnaHRpbmc7XG4gIGhsanMuaW5pdEhpZ2hsaWdodGluZ09uTG9hZCA9IGluaXRIaWdobGlnaHRpbmdPbkxvYWQ7XG4gIGhsanMucmVnaXN0ZXJMYW5ndWFnZSA9IHJlZ2lzdGVyTGFuZ3VhZ2U7XG4gIGhsanMubGlzdExhbmd1YWdlcyA9IGxpc3RMYW5ndWFnZXM7XG4gIGhsanMuZ2V0TGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZTtcbiAgaGxqcy5pbmhlcml0ID0gaW5oZXJpdDtcblxuICAvLyBDb21tb24gcmVnZXhwc1xuICBobGpzLklERU5UX1JFID0gJ1thLXpBLVpdXFxcXHcqJztcbiAgaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFID0gJ1thLXpBLVpfXVxcXFx3Kic7XG4gIGhsanMuTlVNQkVSX1JFID0gJ1xcXFxiXFxcXGQrKFxcXFwuXFxcXGQrKT8nO1xuICBobGpzLkNfTlVNQkVSX1JFID0gJygtPykoXFxcXGIwW3hYXVthLWZBLUYwLTldK3woXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCopP3xcXFxcLlxcXFxkKykoW2VFXVstK10/XFxcXGQrKT8pJzsgLy8gMHguLi4sIDAuLi4sIGRlY2ltYWwsIGZsb2F0XG4gIGhsanMuQklOQVJZX05VTUJFUl9SRSA9ICdcXFxcYigwYlswMV0rKSc7IC8vIDBiLi4uXG4gIGhsanMuUkVfU1RBUlRFUlNfUkUgPSAnIXwhPXwhPT18JXwlPXwmfCYmfCY9fFxcXFwqfFxcXFwqPXxcXFxcK3xcXFxcKz18LHwtfC09fC89fC98Onw7fDw8fDw8PXw8PXw8fD09PXw9PXw9fD4+Pj18Pj49fD49fD4+Pnw+Pnw+fFxcXFw/fFxcXFxbfFxcXFx7fFxcXFwofFxcXFxefFxcXFxePXxcXFxcfHxcXFxcfD18XFxcXHxcXFxcfHx+JztcblxuICAvLyBDb21tb24gbW9kZXNcbiAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFID0ge1xuICAgIGJlZ2luOiAnXFxcXFxcXFxbXFxcXHNcXFxcU10nLCByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5BUE9TX1NUUklOR19NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdcXCcnLCBlbmQ6ICdcXCcnLFxuICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gIH07XG4gIGhsanMuUVVPVEVfU1RSSU5HX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ1wiJywgZW5kOiAnXCInLFxuICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gIH07XG4gIGhsanMuUEhSQVNBTF9XT1JEU19NT0RFID0ge1xuICAgIGJlZ2luOiAvXFxiKGF8YW58dGhlfGFyZXxJJ218aXNuJ3R8ZG9uJ3R8ZG9lc24ndHx3b24ndHxidXR8anVzdHxzaG91bGR8cHJldHR5fHNpbXBseXxlbm91Z2h8Z29ubmF8Z29pbmd8d3RmfHNvfHN1Y2h8d2lsbHx5b3V8eW91cnx0aGV5fGxpa2V8bW9yZSlcXGIvXG4gIH07XG4gIGhsanMuQ09NTUVOVCA9IGZ1bmN0aW9uIChiZWdpbiwgZW5kLCBpbmhlcml0cykge1xuICAgIHZhciBtb2RlID0gaGxqcy5pbmhlcml0KFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgICAgYmVnaW46IGJlZ2luLCBlbmQ6IGVuZCxcbiAgICAgICAgY29udGFpbnM6IFtdXG4gICAgICB9LFxuICAgICAgaW5oZXJpdHMgfHwge31cbiAgICApO1xuICAgIG1vZGUuY29udGFpbnMucHVzaChobGpzLlBIUkFTQUxfV09SRFNfTU9ERSk7XG4gICAgbW9kZS5jb250YWlucy5wdXNoKHtcbiAgICAgIGNsYXNzTmFtZTogJ2RvY3RhZycsXG4gICAgICBiZWdpbjogJyg/OlRPRE98RklYTUV8Tk9URXxCVUd8WFhYKTonLFxuICAgICAgcmVsZXZhbmNlOiAwXG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGU7XG4gIH07XG4gIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnLy8nLCAnJCcpO1xuICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFID0gaGxqcy5DT01NRU5UKCcvXFxcXConLCAnXFxcXCovJyk7XG4gIGhsanMuSEFTSF9DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJyMnLCAnJCcpO1xuICBobGpzLk5VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuTlVNQkVSX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLkNfTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5DX05VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5CSU5BUllfTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5CSU5BUllfTlVNQkVSX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLkNTU19OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLk5VTUJFUl9SRSArICcoJyArXG4gICAgICAnJXxlbXxleHxjaHxyZW0nICArXG4gICAgICAnfHZ3fHZofHZtaW58dm1heCcgK1xuICAgICAgJ3xjbXxtbXxpbnxwdHxwY3xweCcgK1xuICAgICAgJ3xkZWd8Z3JhZHxyYWR8dHVybicgK1xuICAgICAgJ3xzfG1zJyArXG4gICAgICAnfEh6fGtIeicgK1xuICAgICAgJ3xkcGl8ZHBjbXxkcHB4JyArXG4gICAgICAnKT8nLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLlJFR0VYUF9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgYmVnaW46IC9cXC8vLCBlbmQ6IC9cXC9bZ2ltdXldKi8sXG4gICAgaWxsZWdhbDogL1xcbi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXFsvLCBlbmQ6IC9cXF0vLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgaGxqcy5USVRMRV9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICBiZWdpbjogaGxqcy5JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5VTkRFUlNDT1JFX1RJVExFX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuTUVUSE9EX0dVQVJEID0ge1xuICAgIC8vIGV4Y2x1ZGVzIG1ldGhvZCBuYW1lcyBmcm9tIGtleXdvcmQgcHJvY2Vzc2luZ1xuICAgIGJlZ2luOiAnXFxcXC5cXFxccyonICsgaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIHJldHVybiBobGpzO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaWdobGlnaHQuanMvbGliL2hpZ2hsaWdodC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgVkFSID0ge1xuICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICB2YXJpYW50czogW1xuICAgICAge2JlZ2luOiAvXFwkW1xcd1xcZCNAXVtcXHdcXGRfXSovfSxcbiAgICAgIHtiZWdpbjogL1xcJFxceyguKj8pfS99XG4gICAgXVxuICB9O1xuICB2YXIgUVVPVEVfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46IC9cIi8sIGVuZDogL1wiLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgVkFSLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgICAgIGJlZ2luOiAvXFwkXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICB2YXIgQVBPU19TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogLycvLCBlbmQ6IC8nL1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYWxpYXNlczogWydzaCcsICd6c2gnXSxcbiAgICBsZXhlbWVzOiAvXFxiLT9bYS16XFwuX10rXFxiLyxcbiAgICBrZXl3b3Jkczoge1xuICAgICAga2V5d29yZDpcbiAgICAgICAgJ2lmIHRoZW4gZWxzZSBlbGlmIGZpIGZvciB3aGlsZSBpbiBkbyBkb25lIGNhc2UgZXNhYyBmdW5jdGlvbicsXG4gICAgICBsaXRlcmFsOlxuICAgICAgICAndHJ1ZSBmYWxzZScsXG4gICAgICBidWlsdF9pbjpcbiAgICAgICAgLy8gU2hlbGwgYnVpbHQtaW5zXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvU2hlbGwtQnVpbHRpbi1Db21tYW5kcy5odG1sXG4gICAgICAgICdicmVhayBjZCBjb250aW51ZSBldmFsIGV4ZWMgZXhpdCBleHBvcnQgZ2V0b3B0cyBoYXNoIHB3ZCByZWFkb25seSByZXR1cm4gc2hpZnQgdGVzdCB0aW1lcyAnICtcbiAgICAgICAgJ3RyYXAgdW1hc2sgdW5zZXQgJyArXG4gICAgICAgIC8vIEJhc2ggYnVpbHQtaW5zXG4gICAgICAgICdhbGlhcyBiaW5kIGJ1aWx0aW4gY2FsbGVyIGNvbW1hbmQgZGVjbGFyZSBlY2hvIGVuYWJsZSBoZWxwIGxldCBsb2NhbCBsb2dvdXQgbWFwZmlsZSBwcmludGYgJyArXG4gICAgICAgICdyZWFkIHJlYWRhcnJheSBzb3VyY2UgdHlwZSB0eXBlc2V0IHVsaW1pdCB1bmFsaWFzICcgK1xuICAgICAgICAvLyBTaGVsbCBtb2RpZmllcnNcbiAgICAgICAgJ3NldCBzaG9wdCAnICtcbiAgICAgICAgLy8gWnNoIGJ1aWx0LWluc1xuICAgICAgICAnYXV0b2xvYWQgYmcgYmluZGtleSBieWUgY2FwIGNoZGlyIGNsb25lIGNvbXBhcmd1bWVudHMgY29tcGNhbGwgY29tcGN0bCBjb21wZGVzY3JpYmUgY29tcGZpbGVzICcgK1xuICAgICAgICAnY29tcGdyb3VwcyBjb21wcXVvdGUgY29tcHRhZ3MgY29tcHRyeSBjb21wdmFsdWVzIGRpcnMgZGlzYWJsZSBkaXNvd24gZWNob3RjIGVjaG90aSBlbXVsYXRlICcgK1xuICAgICAgICAnZmMgZmcgZmxvYXQgZnVuY3Rpb25zIGdldGNhcCBnZXRsbiBoaXN0b3J5IGludGVnZXIgam9icyBraWxsIGxpbWl0IGxvZyBub2dsb2IgcG9wZCBwcmludCAnICtcbiAgICAgICAgJ3B1c2hkIHB1c2hsbiByZWhhc2ggc2NoZWQgc2V0Y2FwIHNldG9wdCBzdGF0IHN1c3BlbmQgdHR5Y3RsIHVuZnVuY3Rpb24gdW5oYXNoIHVubGltaXQgJyArXG4gICAgICAgICd1bnNldG9wdCB2YXJlZCB3YWl0IHdoZW5jZSB3aGVyZSB3aGljaCB6Y29tcGlsZSB6Zm9ybWF0IHpmdHAgemxlIHptb2Rsb2FkIHpwYXJzZW9wdHMgenByb2YgJyArXG4gICAgICAgICd6cHR5IHpyZWdleHBhcnNlIHpzb2NrZXQgenN0eWxlIHp0Y3AnLFxuICAgICAgXzpcbiAgICAgICAgJy1uZSAtZXEgLWx0IC1ndCAtZiAtZCAtZSAtcyAtbCAtYScgLy8gcmVsZXZhbmNlIGJvb3N0ZXJcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogL14jIVteXFxuXStzaFxccyokLyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICBiZWdpbjogL1xcd1tcXHdcXGRfXSpcXHMqXFwoXFxzKlxcKVxccypcXHsvLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7YmVnaW46IC9cXHdbXFx3XFxkX10qL30pXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSxcbiAgICAgIFFVT1RFX1NUUklORyxcbiAgICAgIEFQT1NfU1RSSU5HLFxuICAgICAgVkFSXG4gICAgXVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Jhc2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIElERU5UX1JFID0gJ1thLXpBLVotXVthLXpBLVowLTlfLV0qJztcbiAgdmFyIFJVTEUgPSB7XG4gICAgYmVnaW46IC9bQS1aXFxfXFwuXFwtXStcXHMqOi8sIHJldHVybkJlZ2luOiB0cnVlLCBlbmQ6ICc7JywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgYmVnaW46IC9cXFMvLCBlbmQ6ICc6JywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVnaW46IC9bXFx3LV0rXFwoLywgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYnVpbHRfaW4nLFxuICAgICAgICAgICAgICAgICAgYmVnaW46IC9bXFx3LV0rL1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREUsXG4gICAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgYmVnaW46ICcjWzAtOUEtRmEtZl0rJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsIGJlZ2luOiAnIWltcG9ydGFudCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGlsbGVnYWw6IC9bPVxcL3wnXFwkXS8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWlkJywgYmVnaW46IC8jW0EtWmEtejAtOV8tXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1jbGFzcycsIGJlZ2luOiAvXFwuW0EtWmEtejAtOV8tXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1hdHRyJyxcbiAgICAgICAgYmVnaW46IC9cXFsvLCBlbmQ6IC9cXF0vLFxuICAgICAgICBpbGxlZ2FsOiAnJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXBzZXVkbycsXG4gICAgICAgIGJlZ2luOiAvOig6KT9bYS16QS1aMC05XFxfXFwtXFwrXFwoXFwpXCInLl0rL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAKGZvbnQtZmFjZXxwYWdlKScsXG4gICAgICAgIGxleGVtZXM6ICdbYS16LV0rJyxcbiAgICAgICAga2V5d29yZHM6ICdmb250LWZhY2UgcGFnZSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQCcsIGVuZDogJ1t7O10nLCAvLyBhdF9ydWxlIGVhdGluZyBmaXJzdCBcIntcIiBpcyBhIGdvb2QgdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgZG9lc27igJl0IGxldCBpdCB0byBiZSBwYXJzZWQgYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgcnVsZSBzZXQgYnV0IGluc3RlYWQgZHJvcHMgcGFyc2VyIGludG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IG1vZGUgd2hpY2ggaXMgaG93IGl0IHNob3VsZCBiZS5cbiAgICAgICAgaWxsZWdhbDogLzovLCAvLyBicmVhayBvbiBMZXNzIHZhcmlhYmxlcyBAdmFyOiAuLi5cbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdrZXl3b3JkJyxcbiAgICAgICAgICAgIGJlZ2luOiAvXFx3Ky9cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvXFxzLywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgIGhsanMuQ1NTX05VTUJFUl9NT0RFXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci10YWcnLCBiZWdpbjogSURFTlRfUkUsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICd7JywgZW5kOiAnfScsXG4gICAgICAgIGlsbGVnYWw6IC9cXFMvLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgUlVMRSxcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9jc3MuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIElERU5UX1JFID0gJ1tBLVphLXokX11bMC05QS1aYS16JF9dKic7XG4gIHZhciBLRVlXT1JEUyA9IHtcbiAgICBrZXl3b3JkOlxuICAgICAgJ2luIG9mIGlmIGZvciB3aGlsZSBmaW5hbGx5IHZhciBuZXcgZnVuY3Rpb24gZG8gcmV0dXJuIHZvaWQgZWxzZSBicmVhayBjYXRjaCAnICtcbiAgICAgICdpbnN0YW5jZW9mIHdpdGggdGhyb3cgY2FzZSBkZWZhdWx0IHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB0eXBlb2YgZGVsZXRlICcgK1xuICAgICAgJ2xldCB5aWVsZCBjb25zdCBleHBvcnQgc3VwZXIgZGVidWdnZXIgYXMgYXN5bmMgYXdhaXQgc3RhdGljICcgK1xuICAgICAgLy8gRUNNQVNjcmlwdCA2IG1vZHVsZXMgaW1wb3J0XG4gICAgICAnaW1wb3J0IGZyb20gYXMnXG4gICAgLFxuICAgIGxpdGVyYWw6XG4gICAgICAndHJ1ZSBmYWxzZSBudWxsIHVuZGVmaW5lZCBOYU4gSW5maW5pdHknLFxuICAgIGJ1aWx0X2luOlxuICAgICAgJ2V2YWwgaXNGaW5pdGUgaXNOYU4gcGFyc2VGbG9hdCBwYXJzZUludCBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50ICcgK1xuICAgICAgJ2VuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgZXNjYXBlIHVuZXNjYXBlIE9iamVjdCBGdW5jdGlvbiBCb29sZWFuIEVycm9yICcgK1xuICAgICAgJ0V2YWxFcnJvciBJbnRlcm5hbEVycm9yIFJhbmdlRXJyb3IgUmVmZXJlbmNlRXJyb3IgU3RvcEl0ZXJhdGlvbiBTeW50YXhFcnJvciAnICtcbiAgICAgICdUeXBlRXJyb3IgVVJJRXJyb3IgTnVtYmVyIE1hdGggRGF0ZSBTdHJpbmcgUmVnRXhwIEFycmF5IEZsb2F0MzJBcnJheSAnICtcbiAgICAgICdGbG9hdDY0QXJyYXkgSW50MTZBcnJheSBJbnQzMkFycmF5IEludDhBcnJheSBVaW50MTZBcnJheSBVaW50MzJBcnJheSAnICtcbiAgICAgICdVaW50OEFycmF5IFVpbnQ4Q2xhbXBlZEFycmF5IEFycmF5QnVmZmVyIERhdGFWaWV3IEpTT04gSW50bCBhcmd1bWVudHMgcmVxdWlyZSAnICtcbiAgICAgICdtb2R1bGUgY29uc29sZSB3aW5kb3cgZG9jdW1lbnQgU3ltYm9sIFNldCBNYXAgV2Vha1NldCBXZWFrTWFwIFByb3h5IFJlZmxlY3QgJyArXG4gICAgICAnUHJvbWlzZSdcbiAgfTtcbiAgdmFyIEVYUFJFU1NJT05TO1xuICB2YXIgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHsgYmVnaW46ICdcXFxcYigwW2JCXVswMV0rKScgfSxcbiAgICAgIHsgYmVnaW46ICdcXFxcYigwW29PXVswLTddKyknIH0sXG4gICAgICB7IGJlZ2luOiBobGpzLkNfTlVNQkVSX1JFIH1cbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICB2YXIgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAnXFxcXCRcXFxceycsIGVuZDogJ1xcXFx9JyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFtdICAvLyBkZWZpbmVkIGxhdGVyXG4gIH07XG4gIHZhciBURU1QTEFURV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ2AnLCBlbmQ6ICdgJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgU1VCU1RcbiAgICBdXG4gIH07XG4gIFNVQlNULmNvbnRhaW5zID0gW1xuICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICBOVU1CRVIsXG4gICAgaGxqcy5SRUdFWFBfTU9ERVxuICBdXG4gIHZhciBQQVJBTVNfQ09OVEFJTlMgPSBTVUJTVC5jb250YWlucy5jb25jYXQoW1xuICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXG4gIF0pO1xuXG4gIHJldHVybiB7XG4gICAgYWxpYXNlczogWydqcycsICdqc3gnXSxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHJlbGV2YW5jZTogMTAsXG4gICAgICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSAoc3RyaWN0fGFzbSlbJ1wiXS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogL14jIS8sIGVuZDogLyQvXG4gICAgICB9LFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBOVU1CRVIsXG4gICAgICB7IC8vIG9iamVjdCBhdHRyIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogL1t7LF1cXHMqLywgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiBJREVOVF9SRSArICdcXFxccyo6JywgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBjb250YWluczogW3tjbGFzc05hbWU6ICdhdHRyJywgYmVnaW46IElERU5UX1JFLCByZWxldmFuY2U6IDB9XVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHsgLy8gXCJ2YWx1ZVwiIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogJygnICsgaGxqcy5SRV9TVEFSVEVSU19SRSArICd8XFxcXGIoY2FzZXxyZXR1cm58dGhyb3cpXFxcXGIpXFxcXHMqJyxcbiAgICAgICAga2V5d29yZHM6ICdyZXR1cm4gdGhyb3cgY2FzZScsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5SRUdFWFBfTU9ERSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBiZWdpbjogJyhcXFxcKC4qP1xcXFwpfCcgKyBJREVOVF9SRSArICcpXFxcXHMqPT4nLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGVuZDogJ1xcXFxzKj0+JyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiBJREVOVF9SRVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXChcXHMqXFwpLyxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gRTRYIC8gSlNYXG4gICAgICAgICAgICBiZWdpbjogLzwvLCBlbmQ6IC8oXFwvXFx3K3xcXHcrXFwvKT4vLFxuICAgICAgICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge2JlZ2luOiAvPFxcdytcXHMqXFwvPi8sIHNraXA6IHRydWV9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC88XFx3Ky8sIGVuZDogLyhcXC9cXHcrfFxcdytcXC8pPi8sIHNraXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgIHtiZWdpbjogLzxcXHcrXFxzKlxcLz4vLCBza2lwOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICdzZWxmJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdmdW5jdGlvbicsIGVuZDogL1xcey8sIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwge2JlZ2luOiBJREVOVF9SRX0pLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaWxsZWdhbDogL1xcW3wlL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCRbKC5dLyAvLyByZWxldmFuY2UgYm9vc3RlciBmb3IgYSBwYXR0ZXJuIGNvbW1vbiB0byBKUyBsaWJzOiBgJChzb21ldGhpbmcpYCBhbmQgYCQuc29tZXRoaW5nYFxuICAgICAgfSxcbiAgICAgIGhsanMuTUVUSE9EX0dVQVJELFxuICAgICAgeyAvLyBFUzYgY2xhc3NcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgICAgICBiZWdpbktleXdvcmRzOiAnY2xhc3MnLCBlbmQ6IC9bezs9XS8sIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGlsbGVnYWw6IC9bOlwiXFxbXFxdXS8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge2JlZ2luS2V5d29yZHM6ICdleHRlbmRzJ30sXG4gICAgICAgICAgaGxqcy5VTkRFUlNDT1JFX1RJVExFX01PREVcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2NvbnN0cnVjdG9yJywgZW5kOiAvXFx7LywgZXhjbHVkZUVuZDogdHJ1ZVxuICAgICAgfVxuICAgIF0sXG4gICAgaWxsZWdhbDogLyMoPyEhKS9cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBYTUxfSURFTlRfUkUgPSAnW0EtWmEtejAtOVxcXFwuXzotXSsnO1xuICB2YXIgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7YmVnaW46IC9cIi8sIGVuZDogL1wiL30sXG4gICAgICAgICAgICAgIHtiZWdpbjogLycvLCBlbmQ6IC8nL30sXG4gICAgICAgICAgICAgIHtiZWdpbjogL1teXFxzXCInPTw+YF0rL31cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIHJldHVybiB7XG4gICAgYWxpYXNlczogWydodG1sJywgJ3hodG1sJywgJ3JzcycsICdhdG9tJywgJ3hqYicsICd4c2QnLCAneHNsJywgJ3BsaXN0J10sXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46ICc8IURPQ1RZUEUnLCBlbmQ6ICc+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICdcXFxcWycsIGVuZDogJ1xcXFxdJ31dXG4gICAgICB9LFxuICAgICAgaGxqcy5DT01NRU5UKFxuICAgICAgICAnPCEtLScsXG4gICAgICAgICctLT4nLFxuICAgICAgICB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgICB9XG4gICAgICApLFxuICAgICAge1xuICAgICAgICBiZWdpbjogJzxcXFxcIVxcXFxbQ0RBVEFcXFxcWycsIGVuZDogJ1xcXFxdXFxcXF0+JyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC88XFw/KHBocCk/LywgZW5kOiAvXFw/Pi8sXG4gICAgICAgIHN1Ykxhbmd1YWdlOiAncGhwJyxcbiAgICAgICAgY29udGFpbnM6IFt7YmVnaW46ICcvXFxcXConLCBlbmQ6ICdcXFxcKi8nLCBza2lwOiB0cnVlfV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBsb29rYWhlYWQgcGF0dGVybiAoPz0uLi4pIGVuc3VyZXMgdGhhdCAnYmVnaW4nIG9ubHkgbWF0Y2hlc1xuICAgICAgICAnPHN0eWxlJyBhcyBhIHNpbmdsZSB3b3JkLCBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2Ugb3IgYW5cbiAgICAgICAgZW5kaW5nIGJyYWtldC4gVGhlICckJyBpcyBuZWVkZWQgZm9yIHRoZSBsZXhlbWUgdG8gYmUgcmVjb2duaXplZFxuICAgICAgICBieSBobGpzLnN1Yk1vZGUoKSB0aGF0IHRlc3RzIGxleGVtZXMgb3V0c2lkZSB0aGUgc3RyZWFtLlxuICAgICAgICAqL1xuICAgICAgICBiZWdpbjogJzxzdHlsZSg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHtuYW1lOiAnc3R5bGUnfSxcbiAgICAgICAgY29udGFpbnM6IFtUQUdfSU5URVJOQUxTXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnPC9zdHlsZT4nLCByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFsnY3NzJywgJ3htbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgPHN0eWxlIHRhZyBhYm91dCB0aGUgbG9va2FoZWFkIHBhdHRlcm5cbiAgICAgICAgYmVnaW46ICc8c2NyaXB0KD89XFxcXHN8PnwkKScsIGVuZDogJz4nLFxuICAgICAgICBrZXl3b3Jkczoge25hbWU6ICdzY3JpcHQnfSxcbiAgICAgICAgY29udGFpbnM6IFtUQUdfSU5URVJOQUxTXSxcbiAgICAgICAgc3RhcnRzOiB7XG4gICAgICAgICAgZW5kOiAnXFw8XFwvc2NyaXB0XFw+JywgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbJ2FjdGlvbnNjcmlwdCcsICdqYXZhc2NyaXB0JywgJ2hhbmRsZWJhcnMnLCAneG1sJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAge2JlZ2luOiAvPFxcP3htbC8sIGVuZDogL1xcPz4vLCByZWxldmFuY2U6IDEwfSxcbiAgICAgICAgICB7YmVnaW46IC88XFw/XFx3Ky8sIGVuZDogL1xcPz4vfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogJzwvPycsIGVuZDogJy8/PicsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsIGJlZ2luOiAvW15cXC8+PFxcc10rLywgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBUQUdfSU5URVJOQUxTXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMveG1sLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsgfVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59O1xuXG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICB9LCBmYWxzZSk7XG59XG5cblxudmFyIGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUuaHR0cCkge1xuICAgICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICAnaHR0cDonLFxuICAnZnRwOic6ICAgICdodHRwOicsXG4gICcvLyc6ICAgICAge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBgOi8vYCAmIGAvLy9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICc6JykgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJy8nKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnbWFpbHRvOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG52YXIgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxudmFyIHRsZHNfZGVmYXVsdCA9ICdiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhCcuc3BsaXQoJ3wnKTtcblxuLyplc2xpbnQtZW5hYmxlIG1heC1sZW4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZShzZWxmKSB7XG4gIHNlbGYuX19pbmRleF9fID0gLTE7XG4gIHNlbGYuX190ZXh0X2NhY2hlX18gICA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfTtcbn1cblxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cbi8vXG5mdW5jdGlvbiBjb21waWxlKHNlbGYpIHtcblxuICAvLyBMb2FkICYgY2xvbmUgUkUgcGF0dGVybnMuXG4gIHZhciByZSA9IHNlbGYucmUgPSByZXF1aXJlKCcuL2xpYi9yZScpKHNlbGYuX19vcHRzX18pO1xuXG4gIC8vIERlZmluZSBkeW5hbWljIHBhdHRlcm5zXG4gIHZhciB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpO1xuXG4gIHNlbGYub25Db21waWxlKCk7XG5cbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgdGxkcy5wdXNoKHRsZHNfMmNoX3NyY19yZSk7XG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bik7XG5cbiAgcmUuc3JjX3RsZHMgPSB0bGRzLmpvaW4oJ3wnKTtcblxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cblxuICByZS5lbWFpbF9mdXp6eSAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKTtcbiAgcmUuaG9zdF9mdXp6eV90ZXN0ICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfaG9zdF9mdXp6eV90ZXN0KSwgJ2knKTtcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgdmFyIGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcoTGlua2lmeUl0KSBJbnZhbGlkIHNjaGVtYSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gc2VsZi5fX3NjaGVtYXNfX1tuYW1lXTtcblxuICAgIC8vIHNraXAgZGlzYWJsZWQgbWV0aG9kc1xuICAgIGlmICh2YWwgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgcG9zdHBvbmVkIGFsaWFzZXNcbiAgLy9cblxuICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgaWYgKCFzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0pIHtcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXG4gICAgICAvLyBzY2hlbWFFcnJvcihhbGlhcywgc2VsZi5fX3NjaGVtYXNfX1thbGlhc10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgdmFyIHNsaXN0ID0gT2JqZWN0LmtleXMoc2VsZi5fX2NvbXBpbGVkX18pXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRpc2FibGVkICYgZmFrZSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAwICYmIHNlbGYuX19jb21waWxlZF9fW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChlc2NhcGVSRSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXG4gIHNlbGYucmUuc2NoZW1hX3Rlc3QgICA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpO1xuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2lnJyk7XG5cbiAgc2VsZi5yZS5wcmV0ZXN0ICAgICAgID0gUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlICsgJyl8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpJyk7XG5cbiAgLy9cbiAgLy8gQ2xlYW51cFxuICAvL1xuXG4gIHJlc2V0U2NhbkNhY2hlKHNlbGYpO1xufVxuXG4vKipcbiAqIGNsYXNzIE1hdGNoXG4gKlxuICogTWF0Y2ggcmVzdWx0LiBTaW5nbGUgZWxlbWVudCBvZiBhcnJheSwgcmV0dXJuZWQgYnkgW1tMaW5raWZ5SXQjbWF0Y2hdXVxuICoqL1xuZnVuY3Rpb24gTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIHN0YXJ0ID0gc2VsZi5fX2luZGV4X18sXG4gICAgICBlbmQgICA9IHNlbGYuX19sYXN0X2luZGV4X18sXG4gICAgICB0ZXh0ICA9IHNlbGYuX190ZXh0X2NhY2hlX18uc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgLyoqXG4gICAqIE1hdGNoI3NjaGVtYSAtPiBTdHJpbmdcbiAgICpcbiAgICogUHJlZml4IChwcm90b2NvbCkgZm9yIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuc2NoZW1hICAgID0gc2VsZi5fX3NjaGVtYV9fLnRvTG93ZXJDYXNlKCk7XG4gIC8qKlxuICAgKiBNYXRjaCNpbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogRmlyc3QgcG9zaXRpb24gb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5pbmRleCAgICAgPSBzdGFydCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjbGFzdEluZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBOZXh0IHBvc2l0aW9uIGFmdGVyIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMubGFzdEluZGV4ID0gZW5kICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNyYXcgLT4gU3RyaW5nXG4gICAqXG4gICAqIE1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMucmF3ICAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3RleHQgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vdG1hbGl6ZWQgdGV4dCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnRleHQgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN1cmwgLT4gU3RyaW5nXG4gICAqXG4gICAqIE5vcm1hbGl6ZWQgdXJsIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudXJsICAgICAgID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2goc2VsZiwgc2hpZnQpIHtcbiAgdmFyIG1hdGNoID0gbmV3IE1hdGNoKHNlbGYsIHNoaWZ0KTtcblxuICBzZWxmLl9fY29tcGlsZWRfX1ttYXRjaC5zY2hlbWFdLm5vcm1hbGl6ZShtYXRjaCwgc2VsZik7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTGlua2lmeUl0XG4gKiovXG5cbi8qKlxuICogbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKVxuICogLSBzY2hlbWFzIChPYmplY3QpOiBPcHRpb25hbC4gQWRkaXRpb25hbCBzY2hlbWFzIHRvIHZhbGlkYXRlIChwcmVmaXgvdmFsaWRhdG9yKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIENyZWF0ZXMgbmV3IGxpbmtpZmllciBpbnN0YW5jZSB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgc2NoZW1hcy5cbiAqIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YCBrZXl3b3JkIGZvciBjb252ZW5pZW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0IHVuZGVyc3RhbmRzOlxuICpcbiAqIC0gYGh0dHAocyk6Ly8uLi5gICwgYGZ0cDovLy4uLmAsIGBtYWlsdG86Li4uYCAmIGAvLy4uLmAgbGlua3NcbiAqIC0gXCJmdXp6eVwiIGxpbmtzIGFuZCBlbWFpbHMgKGV4YW1wbGUuY29tLCBmb29AYmFyLmNvbSkuXG4gKlxuICogYHNjaGVtYXNgIGlzIGFuIG9iamVjdCwgd2hlcmUgZWFjaCBrZXkvdmFsdWUgZGVzY3JpYmVzIHByb3RvY29sL3J1bGU6XG4gKlxuICogLSBfX2tleV9fIC0gbGluayBwcmVmaXggKHVzdWFsbHksIHByb3RvY29sIG5hbWUgd2l0aCBgOmAgYXQgdGhlIGVuZCwgYHNreXBlOmBcbiAqICAgZm9yIGV4YW1wbGUpLiBgbGlua2lmeS1pdGAgbWFrZXMgc2h1cmUgdGhhdCBwcmVmaXggaXMgbm90IHByZWNlZWRlZCB3aXRoXG4gKiAgIGFscGhhbnVtZXJpYyBjaGFyIGFuZCBzeW1ib2xzLiBPbmx5IHdoaXRlc3BhY2VzIGFuZCBwdW5jdHVhdGlvbiBhbGxvd2VkLlxuICogLSBfX3ZhbHVlX18gLSBydWxlIHRvIGNoZWNrIHRhaWwgYWZ0ZXIgbGluayBwcmVmaXhcbiAqICAgLSBfU3RyaW5nXyAtIGp1c3QgYWxpYXMgdG8gZXhpc3RpbmcgcnVsZVxuICogICAtIF9PYmplY3RfXG4gKiAgICAgLSBfdmFsaWRhdGVfIC0gdmFsaWRhdG9yIGZ1bmN0aW9uIChzaG91bGQgcmV0dXJuIG1hdGNoZWQgbGVuZ3RoIG9uIHN1Y2Nlc3MpLFxuICogICAgICAgb3IgYFJlZ0V4cGAuXG4gKiAgICAgLSBfbm9ybWFsaXplXyAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSB0ZXh0ICYgdXJsIG9mIG1hdGNoZWQgcmVzdWx0XG4gKiAgICAgICAoZm9yIGV4YW1wbGUsIGZvciBAdHdpdHRlciBtZW50aW9ucykuXG4gKlxuICogYG9wdGlvbnNgOlxuICpcbiAqIC0gX19mdXp6eUxpbmtfXyAtIHJlY29nbmlnZSBVUkwtcyB3aXRob3V0IGBodHRwKHMpOmAgcHJlZml4LiBEZWZhdWx0IGB0cnVlYC5cbiAqIC0gX19mdXp6eUlQX18gLSBhbGxvdyBJUHMgaW4gZnV6enkgbGlua3MgYWJvdmUuIENhbiBjb25mbGljdCB3aXRoIHNvbWUgdGV4dHNcbiAqICAgbGlrZSB2ZXJzaW9uIG51bWJlcnMuIERlZmF1bHQgYGZhbHNlYC5cbiAqIC0gX19mdXp6eUVtYWlsX18gLSByZWNvZ25pemUgZW1haWxzIHdpdGhvdXQgYG1haWx0bzpgIHByZWZpeC5cbiAqXG4gKiovXG5mdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlua2lmeUl0KSkge1xuICAgIHJldHVybiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKGlzT3B0aW9uc09iaihzY2hlbWFzKSkge1xuICAgICAgb3B0aW9ucyA9IHNjaGVtYXM7XG4gICAgICBzY2hlbWFzID0ge307XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fX29wdHNfXyAgICAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAvLyBDYWNoZSBsYXN0IHRlc3RlZCByZXN1bHQuIFVzZWQgdG8gc2tpcCByZXBlYXRpbmcgc3RlcHMgb24gbmV4dCBgbWF0Y2hgIGNhbGwuXG4gIHRoaXMuX19pbmRleF9fICAgICAgICAgID0gLTE7XG4gIHRoaXMuX19sYXN0X2luZGV4X18gICAgID0gLTE7IC8vIE5leHQgc2NhbiBwb3NpdGlvblxuICB0aGlzLl9fc2NoZW1hX18gICAgICAgICA9ICcnO1xuICB0aGlzLl9fdGV4dF9jYWNoZV9fICAgICA9ICcnO1xuXG4gIHRoaXMuX19zY2hlbWFzX18gICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0U2NoZW1hcywgc2NoZW1hcyk7XG4gIHRoaXMuX19jb21waWxlZF9fICAgICAgID0ge307XG5cbiAgdGhpcy5fX3RsZHNfXyAgICAgICAgICAgPSB0bGRzX2RlZmF1bHQ7XG4gIHRoaXMuX190bGRzX3JlcGxhY2VkX18gID0gZmFsc2U7XG5cbiAgdGhpcy5yZSA9IHt9O1xuXG4gIGNvbXBpbGUodGhpcyk7XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I2FkZChzY2hlbWEsIGRlZmluaXRpb24pXG4gKiAtIHNjaGVtYSAoU3RyaW5nKTogcnVsZSBuYW1lIChmaXhlZCBwYXR0ZXJuIHByZWZpeClcbiAqIC0gZGVmaW5pdGlvbiAoU3RyaW5nfFJlZ0V4cHxPYmplY3QpOiBzY2hlbWEgZGVmaW5pdGlvblxuICpcbiAqIEFkZCBuZXcgcnVsZSBkZWZpbml0aW9uLiBTZWUgY29uc3RydWN0b3IgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChzY2hlbWEsIGRlZmluaXRpb24pIHtcbiAgdGhpcy5fX3NjaGVtYXNfX1tzY2hlbWFdID0gZGVmaW5pdGlvbjtcbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNzZXQob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBTZXQgcmVjb2duaXRpb24gb3B0aW9ucyBmb3IgbGlua3Mgd2l0aG91dCBzY2hlbWEuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gIHRoaXMuX19vcHRzX18gPSBhc3NpZ24odGhpcy5fX29wdHNfXywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBTZWFyY2hlcyBsaW5raWZpYWJsZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzIG9yIGBmYWxzZWAgb24gZmFpbC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QodGV4dCkge1xuICAvLyBSZXNldCBzY2FuIGNhY2hlXG4gIHRoaXMuX190ZXh0X2NhY2hlX18gPSB0ZXh0O1xuICB0aGlzLl9faW5kZXhfXyAgICAgID0gLTE7XG5cbiAgaWYgKCF0ZXh0Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIgbSwgbWwsIG1lLCBsZW4sIHNoaWZ0LCBuZXh0LCByZSwgdGxkX3BvcywgYXRfcG9zO1xuXG4gIC8vIHRyeSB0byBzY2FuIGZvciBsaW5rIHdpdGggc2NoZW1hIC0gdGhhdCdzIHRoZSBtb3N0IHNpbXBsZSBydWxlXG4gIGlmICh0aGlzLnJlLnNjaGVtYV90ZXN0LnRlc3QodGV4dCkpIHtcbiAgICByZSA9IHRoaXMucmUuc2NoZW1hX3NlYXJjaDtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobSA9IHJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICBsZW4gPSB0aGlzLnRlc3RTY2hlbWFBdCh0ZXh0LCBtWzJdLCByZS5sYXN0SW5kZXgpO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gbVsyXTtcbiAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IG0uaW5kZXggKyBtWzFdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBsaW5rc1xuICAgIHRsZF9wb3MgPSB0ZXh0LnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgaWYgKHRsZF9wb3MgPj0gMCkge1xuICAgICAgLy8gaWYgdGxkIGlzIGxvY2F0ZWQgYWZ0ZXIgZm91bmQgbGluayAtIG5vIG5lZWQgdG8gY2hlY2sgZnV6enkgcGF0dGVyblxuICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCB0bGRfcG9zIDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgaWYgKChtbCA9IHRleHQubWF0Y2godGhpcy5fX29wdHNfXy5mdXp6eUlQID8gdGhpcy5yZS5saW5rX2Z1enp5IDogdGhpcy5yZS5saW5rX25vX2lwX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtbC5pbmRleCArIG1sWzBdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUVtYWlsICYmIHRoaXMuX19jb21waWxlZF9fWydtYWlsdG86J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGVtYWlsc1xuICAgIGF0X3BvcyA9IHRleHQuaW5kZXhPZignQCcpO1xuICAgIGlmIChhdF9wb3MgPj0gMCkge1xuICAgICAgLy8gV2UgY2FuJ3Qgc2tpcCB0aGlzIGNoZWNrLCBiZWNhdXNlIHRoaXMgY2FzZXMgYXJlIHBvc3NpYmxlOlxuICAgICAgLy8gMTkyLjE2OC4xLjFAZ21haWwuY29tLCBteS5pbkBleGFtcGxlLmNvbVxuICAgICAgaWYgKChtZSA9IHRleHQubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgc2hpZnQgPSBtZS5pbmRleCArIG1lWzFdLmxlbmd0aDtcbiAgICAgICAgbmV4dCAgPSBtZS5pbmRleCArIG1lWzBdLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHNoaWZ0IDwgdGhpcy5fX2luZGV4X18gfHxcbiAgICAgICAgICAgIChzaGlmdCA9PT0gdGhpcy5fX2luZGV4X18gJiYgbmV4dCA+IHRoaXMuX19sYXN0X2luZGV4X18pKSB7XG4gICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICdtYWlsdG86JztcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjcHJldGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogVmVyeSBxdWljayBjaGVjaywgdGhhdCBjYW4gZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMuIFJldHVybnMgdHJ1ZSBpZiBsaW5rIE1BWSBCRVxuICogY2FuIGV4aXN0cy4gQ2FuIGJlIHVzZWQgZm9yIHNwZWVkIG9wdGltaXphdGlvbiwgd2hlbiB5b3UgbmVlZCB0byBjaGVjayB0aGF0XG4gKiBsaW5rIE5PVCBleGlzdHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnByZXRlc3QgPSBmdW5jdGlvbiBwcmV0ZXN0KHRleHQpIHtcbiAgcmV0dXJuIHRoaXMucmUucHJldGVzdC50ZXN0KHRleHQpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0U2NoZW1hQXQodGV4dCwgbmFtZSwgcG9zaXRpb24pIC0+IE51bWJlclxuICogLSB0ZXh0IChTdHJpbmcpOiB0ZXh0IHRvIHNjYW5cbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSAoc2NoZW1hKSBuYW1lXG4gKiAtIHBvc2l0aW9uIChOdW1iZXIpOiB0ZXh0IG9mZnNldCB0byBjaGVjayBmcm9tXG4gKlxuICogU2ltaWxhciB0byBbW0xpbmtpZnlJdCN0ZXN0XV0gYnV0IGNoZWNrcyBvbmx5IHNwZWNpZmljIHByb3RvY29sIHRhaWwgZXhhY3RseVxuICogYXQgZ2l2ZW4gcG9zaXRpb24uIFJldHVybnMgbGVuZ3RoIG9mIGZvdW5kIHBhdHRlcm4gKDAgb24gZmFpbCkuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3RTY2hlbWFBdCA9IGZ1bmN0aW9uIHRlc3RTY2hlbWFBdCh0ZXh0LCBzY2hlbWEsIHBvcykge1xuICAvLyBJZiBub3Qgc3VwcG9ydGVkIHNjaGVtYSBjaGVjayByZXF1ZXN0ZWQgLSB0ZXJtaW5hdGVcbiAgaWYgKCF0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldLnZhbGlkYXRlKHRleHQsIHBvcywgdGhpcyk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I21hdGNoKHRleHQpIC0+IEFycmF5fG51bGxcbiAqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGZvdW5kIGxpbmsgZGVzY3JpcHRpb25zIG9yIGBudWxsYCBvbiBmYWlsLiBXZSBzdHJvbmdseVxuICogcmVjb21tZW5kIHRvIHVzZSBbW0xpbmtpZnlJdCN0ZXN0XV0gZmlyc3QsIGZvciBiZXN0IHNwZWVkLlxuICpcbiAqICMjIyMjIFJlc3VsdCBtYXRjaCBkZXNjcmlwdGlvblxuICpcbiAqIC0gX19zY2hlbWFfXyAtIGxpbmsgc2NoZW1hLCBjYW4gYmUgZW1wdHkgZm9yIGZ1enp5IGxpbmtzLCBvciBgLy9gIGZvclxuICogICBwcm90b2NvbC1uZXV0cmFsICBsaW5rcy5cbiAqIC0gX19pbmRleF9fIC0gb2Zmc2V0IG9mIG1hdGNoZWQgdGV4dFxuICogLSBfX2xhc3RJbmRleF9fIC0gaW5kZXggb2YgbmV4dCBjaGFyIGFmdGVyIG1hdGhjaCBlbmRcbiAqIC0gX19yYXdfXyAtIG1hdGNoZWQgdGV4dFxuICogLSBfX3RleHRfXyAtIG5vcm1hbGl6ZWQgdGV4dFxuICogLSBfX3VybF9fIC0gbGluaywgZ2VuZXJhdGVkIGZyb20gbWF0Y2hlZCB0ZXh0XG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2godGV4dCkge1xuICB2YXIgc2hpZnQgPSAwLCByZXN1bHQgPSBbXTtcblxuICAvLyBUcnkgdG8gdGFrZSBwcmV2aW91cyBlbGVtZW50IGZyb20gY2FjaGUsIGlmIC50ZXN0KCkgY2FsbGVkIGJlZm9yZVxuICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0KSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcbiAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxuICB2YXIgdGFpbCA9IHNoaWZ0ID8gdGV4dC5zbGljZShzaGlmdCkgOiB0ZXh0O1xuXG4gIC8vIFNjYW4gc3RyaW5nIHVudGlsIGVuZCByZWFjaGVkXG4gIHdoaWxlICh0aGlzLnRlc3QodGFpbCkpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuXG4gICAgdGFpbCA9IHRhaWwuc2xpY2UodGhpcy5fX2xhc3RfaW5kZXhfXyk7XG4gICAgc2hpZnQgKz0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjdGxkcyhsaXN0IFssIGtlZXBPbGRdKSAtPiB0aGlzXG4gKiAtIGxpc3QgKEFycmF5KTogbGlzdCBvZiB0bGRzXG4gKiAtIGtlZXBPbGQgKEJvb2xlYW4pOiBtZXJnZSB3aXRoIGN1cnJlbnQgbGlzdCBpZiBgdHJ1ZWAgKGBmYWxzZWAgYnkgZGVmYXVsdClcbiAqXG4gKiBMb2FkIChvciBtZXJnZSkgbmV3IHRsZHMgbGlzdC4gVGhvc2UgYXJlIHVzZXIgZm9yIGZ1enp5IGxpbmtzICh3aXRob3V0IHByZWZpeClcbiAqIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcy4gQnkgZGVmYXVsdCB0aGlzIGFsZ29yeXRobSB1c2VkOlxuICpcbiAqIC0gaG9zdG5hbWUgd2l0aCBhbnkgMi1sZXR0ZXIgcm9vdCB6b25lcyBhcmUgb2suXG4gKiAtIGJpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEXG4gKiAgIGFyZSBvay5cbiAqIC0gZW5jb2RlZCAoYHhuLS0uLi5gKSByb290IHpvbmVzIGFyZSBvay5cbiAqXG4gKiBJZiBsaXN0IGlzIHJlcGxhY2VkLCB0aGVuIGV4YWN0IG1hdGNoIGZvciAyLWNoYXJzIHJvb3Qgem9uZXMgd2lsbCBiZSBjaGVja2VkLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50bGRzID0gZnVuY3Rpb24gdGxkcyhsaXN0LCBrZWVwT2xkKSB7XG4gIGxpc3QgPSBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdCA6IFsgbGlzdCBdO1xuXG4gIGlmICgha2VlcE9sZCkge1xuICAgIHRoaXMuX190bGRzX18gPSBsaXN0LnNsaWNlKCk7XG4gICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XG4gICAgY29tcGlsZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX190bGRzX18gPSB0aGlzLl9fdGxkc19fLmNvbmNhdChsaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCAhPT0gYXJyW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcblxuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I25vcm1hbGl6ZShtYXRjaClcbiAqXG4gKiBEZWZhdWx0IG5vcm1hbGl6ZXIgKGlmIHNjaGVtYSBkb2VzIG5vdCBkZWZpbmUgaXQncyBvd24pLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWF0Y2gpIHtcblxuICAvLyBEbyBtaW5pbWFsIHBvc3NpYmxlIGNoYW5nZXMgYnkgZGVmYXVsdC4gTmVlZCB0byBjb2xsZWN0IGZlZWRiYWNrIHByaW9yXG4gIC8vIHRvIG1vdmUgZm9yd2FyZCBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdC9pc3N1ZXMvMVxuXG4gIGlmICghbWF0Y2guc2NoZW1hKSB7IG1hdGNoLnVybCA9ICdodHRwOi8vJyArIG1hdGNoLnVybDsgfVxuXG4gIGlmIChtYXRjaC5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdChtYXRjaC51cmwpKSB7XG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I29uQ29tcGlsZSgpXG4gKlxuICogT3ZlcnJpZGUgdG8gbW9kaWZ5IGJhc2ljIFJlZ0V4cC1zLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5vbkNvbXBpbGUgPSBmdW5jdGlvbiBvbkNvbXBpbGUoKSB7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9saW5raWZ5LWl0L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHJlID0ge307XG5cbiAgLy8gVXNlIGRpcmVjdCBleHRyYWN0IGluc3RlYWQgb2YgYHJlZ2VuZXJhdGVgIHRvIHJlZHVzZSBicm93c2VyaWZpZWQgc2l6ZVxuICByZS5zcmNfQW55ID0gcmVxdWlyZSgndWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19DYyAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfWiAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfUCAgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jykuc291cmNlO1xuXG4gIC8vIFxccHtcXFpcXFBcXENjXFxDRn0gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wgKyBmb3JtYXQgKyBwdW5jdHVhdGlvbilcbiAgcmUuc3JjX1pQQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfUCwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIFxccHtcXFpcXENjfSAod2hpdGUgc3BhY2VzICsgY29udHJvbClcbiAgcmUuc3JjX1pDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBFeHBlcmltZW50YWwuIExpc3Qgb2YgY2hhcnMsIGNvbXBsZXRlbHkgcHJvaGliaXRlZCBpbiBsaW5rc1xuICAvLyBiZWNhdXNlIGNhbiBzZXBhcmF0ZSBpdCBmcm9tIG90aGVyIHBhcnQgb2YgdGV4dFxuICB2YXIgdGV4dF9zZXBhcmF0b3JzID0gJ1s+PFxcdWZmNWNdJztcblxuICAvLyBBbGwgcG9zc2libGUgd29yZCBjaGFyYWN0ZXJzIChldmVyeXRoaW5nIHdpdGhvdXQgcHVuY3R1YXRpb24sIHNwYWNlcyAmIGNvbnRyb2xzKVxuICAvLyBEZWZpbmVkIHZpYSBwdW5jdHVhdGlvbiAmIHNwYWNlcyB0byBzYXZlIHNwYWNlXG4gIC8vIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBcXHB7XFxMXFxOXFxTXFxNfSAoXFx3IGJ1dCB3aXRob3V0IGBfYClcbiAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgICAgICAgPSAnKD86KD8hJyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJyknICsgcmUuc3JjX0FueSArICcpJztcbiAgLy8gVGhlIHNhbWUgYXMgYWJvdGhlIGJ1dCB3aXRob3V0IFswLTldXG4gIC8vIHZhciBzcmNfcHNldWRvX2xldHRlcl9ub25fZCA9ICcoPzooPyFbMC05XXwnICsgc3JjX1pQQ2MgKyAnKScgKyBzcmNfQW55ICsgJyknO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgcmUuc3JjX2lwNCA9XG5cbiAgICAnKD86KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXFxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSc7XG5cbiAgLy8gUHJvaGliaXQgYW55IG9mIFwiQC9bXSgpXCIgaW4gdXNlci9wYXNzIHRvIGF2b2lkIHdyb25nIGRvbWFpbiBmZXRjaC5cbiAgcmUuc3JjX2F1dGggICAgPSAnKD86KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/JztcblxuICByZS5zcmNfcG9ydCA9XG5cbiAgICAnKD86Oig/OjYoPzpbMC00XVxcXFxkezN9fDUoPzpbMC00XVxcXFxkezJ9fDUoPzpbMC0yXVxcXFxkfDNbMC01XSkpKXxbMS01XT9cXFxcZHsxLDR9KSk/JztcblxuICByZS5zcmNfaG9zdF90ZXJtaW5hdG9yID1cblxuICAgICcoPz0kfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpKD8hLXxffDpcXFxcZHxcXFxcLi18XFxcXC4oPyEkfCcgKyByZS5zcmNfWlBDYyArICcpKSc7XG5cbiAgcmUuc3JjX3BhdGggPVxuXG4gICAgJyg/OicgK1xuICAgICAgJ1svPyNdJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgICAnKD8hJyArIHJlLnNyY19aQ2MgKyAnfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFsoKVtcXFxcXXt9LixcIlxcJz8hXFxcXC1dKS58JyArXG4gICAgICAgICAgJ1xcXFxbKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFxcXFxdKS4pKlxcXFxdfCcgK1xuICAgICAgICAgICdcXFxcKCg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbKV0pLikqXFxcXCl8JyArXG4gICAgICAgICAgJ1xcXFx7KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFt9XSkuKSpcXFxcfXwnICtcbiAgICAgICAgICAnXFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtcIl0pLikrXFxcXFwifCcgK1xuICAgICAgICAgIFwiXFxcXCcoPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XCIgK1xuICAgICAgICAgIFwiXFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3xbLV0pLnwnICsgIC8vIGFsbG93IGBJJ21fa2luZ2AgaWYgbm8gcGFpciBmb3VuZFxuICAgICAgICAgICdcXFxcLnsyLDN9W2EtekEtWjAtOSUvXXwnICsgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLiBSZXN0cmljdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gZW5nbGlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGVyY2VudC1lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwYXJ0cyBvZiBmaWxlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCBtb3JlIGV4YW1wbGVzIGZvdW5kLlxuICAgICAgICAgICdcXFxcLig/IScgKyByZS5zcmNfWkNjICsgJ3xbLl0pLnwnICtcbiAgICAgICAgICAob3B0cyAmJiBvcHRzWyctLS0nXSA/XG4gICAgICAgICAgICAnXFxcXC0oPyEtLSg/OlteLV18JCkpKD86LSopfCcgLy8gYC0tLWAgPT4gbG9uZyBkYXNoLCB0ZXJtaW5hdGVcbiAgICAgICAgICA6XG4gICAgICAgICAgICAnXFxcXC0rfCdcbiAgICAgICAgICApICtcbiAgICAgICAgICAnXFxcXCwoPyEnICsgcmUuc3JjX1pDYyArICcpLnwnICsgICAgICAvLyBhbGxvdyBgLCwsYCBpbiBwYXRoc1xuICAgICAgICAgICdcXFxcISg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICtcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICByZS5zcmNfZW1haWxfbmFtZSA9XG5cbiAgICAnW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSsnO1xuXG4gIHJlLnNyY194biA9XG5cbiAgICAneG4tLVthLXowLTlcXFxcLV17MSw1OX0nO1xuXG4gIC8vIE1vcmUgdG8gcmVhZCBhYm91dCBkb21haW4gbmFtZXNcbiAgLy8gaHR0cDovL3NlcnZlcmZhdWx0LmNvbS9xdWVzdGlvbnMvNjM4MjYwL1xuXG4gIHJlLnNyY19kb21haW5fcm9vdCA9XG5cbiAgICAvLyBBbGxvdyBsZXR0ZXJzICYgZGlnaXRzIChodHRwOi8vdGVzdDEpXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICByZS5zcmNfcHNldWRvX2xldHRlciArICd7MSw2M30nICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2RvbWFpbiA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICAgJ3wnICtcbiAgICAgIC8vIGRvbid0IGFsbG93IGAtLWAgaW4gZG9tYWluIG5hbWVzLCBiZWNhdXNlOlxuICAgICAgLy8gLSB0aGF0IGNhbiBjb25mbGljdCB3aXRoIG1hcmtkb3duICZtZGFzaDsgLyAmbmRhc2g7XG4gICAgICAvLyAtIG5vYm9keSB1c2UgdGhvc2UgYW55d2F5XG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyg/Oi0oPyEtKXwnICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKXswLDYxfScgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19ob3N0ID1cblxuICAgICcoPzonICtcbiAgICAvLyBEb24ndCBuZWVkIElQIGNoZWNrLCBiZWNhdXNlIGRpZ2l0cyBhcmUgYWxyZWFkeSBhbGxvd2VkIGluIG5vcm1hbCBkb21haW4gbmFtZXNcbiAgICAvLyAgIHNyY19pcDQgK1xuICAgIC8vICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSonICsgcmUuc3JjX2RvbWFpbi8qX3Jvb3QqLyArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9XG5cbiAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKSc7XG5cbiAgcmUuc3JjX2hvc3Rfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiBydWxlc1xuXG4gIC8vIFJ1ZGUgdGVzdCBmdXp6eSBsaW5rcyBieSBob3N0LCBmb3IgcXVpY2sgZGVueVxuICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID1cblxuICAgICdsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHJlLnNyY19aUENjICsgJ3w+fCQpKSc7XG5cbiAgcmUudHBsX2VtYWlsX2Z1enp5ID1cblxuICAgICAgJyhefCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFxcXFwofCcgKyByZS5zcmNfWkNjICsgJykoJyArIHJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX25vX2lwX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJldHVybiByZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xpbmtpZnktaXQvbGliL3JlLmpzIiwiJ3VzZSBzdHJpY3QnXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG52YXIgdGFnRXhwciA9IC9ePCEtLSA/XFx7KD86KFthLXowLTldKykoXFxeWzAtOV0qKT86ID8pPyguKilcXH0gPy0tPlxcbj8kL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF0dHJpYnV0ZXMgKG1kKSB7XG4gIG1kLmNvcmUucnVsZXIucHVzaCgnY3VybHlfYXR0cmlidXRlcycsIGN1cmx5QXR0cnMpXG59XG5cbi8qXG4gKiBMaXN0IG9mIHRhZyAtPiB0b2tlbiB0eXBlIG1hcHBpbmdzLiBFZywgYDxsaT5gIGlzIGBsaXN0X2l0ZW1fb3BlbmAuXG4gKi9cblxudmFyIG9wZW5pbmcgPSB7XG4gIGxpOiBbJ2xpc3RfaXRlbSddLFxuICB1bDogWydidWxsZXRfbGlzdCddLFxuICBwOiBbJ3BhcmFncmFwaCddLFxuICBvbDogWydvcmRlcmVkX2xpc3QnXSxcbiAgYmxvY2txdW90ZTogWydibG9ja3F1b3RlJ10sXG4gIGgxOiBbJ2hlYWRpbmcnXSxcbiAgaDI6IFsnaGVhZGluZyddLFxuICBoMzogWydoZWFkaW5nJ10sXG4gIGg0OiBbJ2hlYWRpbmcnXSxcbiAgaDU6IFsnaGVhZGluZyddLFxuICBoNjogWydoZWFkaW5nJ10sXG4gIGE6IFsnbGluayddLFxuICBjb2RlOiBbJ2NvZGVfaW5saW5lJywgJ2NvZGVfYmxvY2snLCAnZmVuY2UnXVxufVxuXG52YXIgc2VsZkNsb3NpbmcgPSB7XG4gIGhyOiB0cnVlLFxuICBpbWFnZTogdHJ1ZVxufVxuXG4vKipcbiAqIC4uLlxuICovXG5cbmZ1bmN0aW9uIGN1cmx5QXR0cnMgKHN0YXRlKSB7XG4gIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnNcbiAgdmFyIG9taXNzaW9ucyA9IFtdXG4gIHZhciBwYXJlbnQsIG1cbiAgdmFyIHN0YWNrID0geyBsZW46IDAsIGNvbnRlbnRzOiBbXSwgdHlwZXM6IHt9IH1cblxuICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIGkpIHtcbiAgICAvLyBTYXZlIGJyZWFkY3J1bWJzIHNvIGh0bWxfYmxvY2sgd2lsbCBwaWNrIGl0IHVwXG4gICAgaWYgKGlzT3BlbmVyKHRva2VuLnR5cGUpIHx8IHNlbGZDbG9zaW5nW3Rva2VuLnR5cGVdKSB7XG4gICAgICBzcHVzaChzdGFjaywgdG9rZW4pXG4gICAgfVxuXG4gICAgLy8gXCIjIEhlbGxvXFxuPCEtLXsuY2xhc3NuYW1lfS0tPlwiXG4gICAgLy8gLi4uc2VxdWVuY2Ugb2YgW2hlYWRpbmdfb3BlbiwgaW5saW5lLCBoZWFkaW5nX2Nsb3NlLCBodG1sX2Jsb2NrXVxuICAgIGlmICh0b2tlbi50eXBlID09PSAnaHRtbF9ibG9jaycpIHtcbiAgICAgIG0gPSB0b2tlbi5jb250ZW50Lm1hdGNoKHRhZ0V4cHIpXG4gICAgICBpZiAoIW0pIHJldHVyblxuXG4gICAgICBwYXJlbnQgPSBmaW5kUGFyZW50KHN0YWNrLCBtWzFdLCBtWzJdKVxuICAgICAgaWYgKHBhcmVudCAmJiBhcHBseVRvVG9rZW4ocGFyZW50LCBtWzNdKSkge1xuICAgICAgICBvbWlzc2lvbnMudW5zaGlmdChpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFwiIyBIZWxsbyA8IS0tey5jbGFzc25hbWV9IC0tPlwiXG4gICAgLy8geyB0eXBlOiAnaW5saW5lJywgY2hpbGRyZW46IHsgLi4uLCAnPCEtLXsuLi59LS0+JyB9IH1cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIGN1cmx5SW5saW5lKHRva2VuLmNoaWxkcmVuLCBzdGFjaylcbiAgICB9XG4gIH0pXG5cbiAgLy8gUmVtb3ZlIDwhLS0uLi4tLT4gaHRtbF9ibG9jayB0b2tlbnNcbiAgb21pc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gdG9rZW5zLnNwbGljZShpZHgsIDEpIH0pXG59XG5cbi8qKlxuICogSW50ZXJuYWw6IGNoZWNrcyBpbiBhIHRva2VuIHR5cGUgaXMgYSBibG9jayBvcGVuZXJcbiAqL1xuXG5mdW5jdGlvbiBpc09wZW5lciAodHlwZSkge1xuICByZXR1cm4gdHlwZS5tYXRjaCgvXyhvcGVufHN0YXJ0KSQvKSB8fFxuICAgIHR5cGUgPT09ICdmZW5jZScgfHwgdHlwZSA9PT0gJ2NvZGVfYmxvY2snXG59XG5cbi8qKlxuICogSW50ZXJuYWw6IFJ1biB0aHJvdWdoIGlubGluZSBhbmQgc3R1ZmZcbiAqL1xuXG5mdW5jdGlvbiBjdXJseUlubGluZSAoY2hpbGRyZW4sIHN0YWNrKSB7XG4gIHZhciBsYXN0VGV4dCwgbSwgcGFyZW50XG5cbiAgLy8gS2VlcCBhIGxpc3Qgb2Ygc3ViLXRva2VucyB0byBiZSByZW1vdmVkXG4gIHZhciBvbWlzc2lvbnMgPSBbXVxuXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgaWYgKGlzT3BlbmVyKGNoaWxkLnR5cGUpIHx8XG4gICAgICBzZWxmQ2xvc2luZ1tjaGlsZC50eXBlXSB8fFxuICAgICAgY2hpbGQudHlwZSA9PT0gJ2NvZGVfaW5saW5lJykge1xuICAgICAgc3B1c2goc3RhY2ssIGNoaWxkKVxuICAgIH1cblxuICAgIC8vIERlY29yYXRlIHRhZ3MgYXJlIGZvdW5kXG4gICAgaWYgKG0gPSBjaGlsZC5jb250ZW50Lm1hdGNoKHRhZ0V4cHIpKSB7XG4gICAgICB2YXIgdGFnID0gbVsxXVxuICAgICAgdmFyIGRlcHRoID0gbVsyXVxuICAgICAgdmFyIGF0dHJzID0gbVszXVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIGNvbW1lbnQsIHRoZW4gcmVtb3ZlIHRoZSBleHRyYSBzcGFjZVxuICAgICAgcGFyZW50ID0gZmluZFBhcmVudChzdGFjaywgdGFnLCBkZXB0aClcbiAgICAgIGlmIChwYXJlbnQgJiYgYXBwbHlUb1Rva2VuKHBhcmVudCwgYXR0cnMpKSB7XG4gICAgICAgIG9taXNzaW9ucy51bnNoaWZ0KGkpXG4gICAgICAgIGlmIChsYXN0VGV4dCkgdHJpbVJpZ2h0KGxhc3RUZXh0LCAnY29udGVudCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLnR5cGUgPT09ICd0ZXh0JykgbGFzdFRleHQgPSBjaGlsZFxuICB9KVxuXG4gIC8vIFJlbW92ZSB0aGVtIGluIGEgc2VwYXJhdGUgc3RlcCBzbyB3ZSBkb24ndFxuICBvbWlzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSlcbiAgfSlcbn1cblxuLyoqXG4gKiBQcml2YXRlOiBnaXZlbiBhIGxpc3Qgb2YgdG9rZW5zIGBsaXN0YCBhbmQgYGxhc3RQYXJlbnRgLCBmaW5kIHRoZSBvbmUgdGhhdFxuICogbWF0Y2hlcyBgdGFnYC5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUGFyZW50IChzdGFjaywgdGFnLCBkZXB0aCkge1xuICBpZiAoIXRhZykgcmV0dXJuIHN0YWNrLmxhc3RcblxuICBpZiAoZGVwdGggPT09ICdeJykge1xuICAgIGRlcHRoID0gMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3N0cmluZycpIHsgLyogJ14yJyAqL1xuICAgIGRlcHRoID0gK2RlcHRoLnN1YnN0cigxKVxuICB9IGVsc2Uge1xuICAgIGRlcHRoID0gMFxuICB9XG5cbiAgdmFyIHRhcmdldHMgPSBvcGVuaW5nW3RhZy50b0xvd2VyQ2FzZSgpXSB8fCBbdGFnLnRvTG93ZXJDYXNlKCldXG5cbiAgdmFyIHRhcmdldCA9IHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gc3RhY2sudHlwZXNbdGFyZ2V0XVxuICB9KVxuXG4gIHZhciBsaXN0ID0gc3RhY2sudHlwZXNbdGFyZ2V0XVxuICBpZiAoIWxpc3QpIHJldHVybiAvLyBDYW4ndCBmaW5kIHRhZyBgdGFnYFxuXG4gIHJldHVybiBsaXN0W2xpc3QubGVuZ3RoIC0gMSAtIGRlcHRoXVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHRyaW0gdGhlIHJpZ2h0XG4gKi9cblxuZnVuY3Rpb24gdHJpbVJpZ2h0IChvYmosIGF0dHIpIHtcbiAgb2JqW2F0dHJdID0gb2JqW2F0dHJdLnJlcGxhY2UoL1xccyokLywgJycpXG59XG5cbi8qKlxuICogUHJpdmF0ZTogYXBwbHkgdGFnIHRvIHRva2VuXG4gKlxuICogICAgIGFwcGx5VG9Ub2tlbih0b2tlbiwgJy5jbGFzc25hbWUnKVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VG9Ub2tlbiAodG9rZW4sIGF0dHJzKSB7XG4gIHZhciBtXG4gIHZhciB0b2RvID0gW11cblxuICB3aGlsZSAoYXR0cnMubGVuZ3RoID4gMCkge1xuICAgIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqXFwuKFthLXpBLVowLTlcXC1fXSspLykpIHtcbiAgICAgIHRvZG8ucHVzaChbICdjbGFzcycsIG1bMV0sIHsgYXBwZW5kOiB0cnVlIH0gXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccyojKFthLXpBLVowLTlcXC1fXSspLykpIHtcbiAgICAgIHRvZG8ucHVzaChbICdpZCcsIG1bMV0gXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccyooW2EtekEtWjAtOVxcLV9dKyk9XCIoW15cIl0qKVwiLykpIHtcbiAgICAgIHRvZG8ucHVzaChbIG1bMV0sIG1bMl0gXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccyooW2EtekEtWjAtOVxcLV9dKyk9JyhbXiddKiknLykpIHtcbiAgICAgIHRvZG8ucHVzaChbIG1bMV0sIG1bMl0gXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccyooW2EtekEtWjAtOVxcLV9dKyk9KFteIF0qKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspLykpIHtcbiAgICAgIHRvZG8ucHVzaChbIG1bMV0sICcnIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMrLykpIHtcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgdG9kby5mb3JFYWNoKGZ1bmN0aW9uIChhcmdzKSB7IHNldEF0dHIuYXBwbHkodGhpcywgW3Rva2VuXS5jb25jYXQoYXJncykpIH0pXG4gIHJldHVybiB0cnVlXG5cbiAgZnVuY3Rpb24gc2hpZnQgKCkge1xuICAgIGF0dHJzID0gYXR0cnMuc3Vic3RyKG1bMF0ubGVuZ3RoKVxuICB9XG59XG5cbi8qKlxuICogUHJpdmF0ZTogc2V0cyBhbiBhdHRyaWJ1dGUgYGF0dHJgIHRvIGB2YWx1ZWAgaW4gYSB0b2tlbi4gSWYgYG9wdGlvbnMuYXBwZW5kYFxuICogaXMgdHJ1ZSwgYXBwZW5kIHRvIHRoZSBvbGQgdmFsdWUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdC5cbiAqL1xuXG5mdW5jdGlvbiBzZXRBdHRyICh0b2tlbiwgYXR0ciwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIGlkeCA9IHRva2VuLmF0dHJJbmRleChhdHRyKVxuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgdG9rZW4uYXR0clB1c2goWyBhdHRyLCB2YWx1ZSBdKVxuICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hcHBlbmQpIHtcbiAgICB0b2tlbi5hdHRyc1tpZHhdWzFdID1cbiAgICAgIHRva2VuLmF0dHJzW2lkeF1bMV0gKyAnICcgKyB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRva2VuLmF0dHJzW2lkeF1bMV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogUHJpdmF0ZTogcHVzaGVzIGEgdG9rZW4gdG8gdGhlIHN0YWNrXG4gKi9cblxuZnVuY3Rpb24gc3B1c2ggKHN0YWNrLCB0b2tlbikge1xuICB2YXIgdHlwZSA9IHRva2VuLnR5cGUucmVwbGFjZSgvXyhvcGVufHN0YXJ0KSQvLCAnJylcbiAgaWYgKCFzdGFjay50eXBlc1t0eXBlXSkgeyBzdGFjay50eXBlc1t0eXBlXSA9IFtdIH1cbiAgc3RhY2sudHlwZXNbdHlwZV0ucHVzaCh0b2tlbilcbiAgc3RhY2subGFzdCA9IHRva2VuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0LWRlY29yYXRlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwiLy8gTGlzdCBvZiB2YWxpZCBodG1sIGJsb2NrcyBuYW1lcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xuLy8gaHR0cDovL2pnbS5naXRodWIuaW8vQ29tbW9uTWFyay9zcGVjLmh0bWwjaHRtbC1ibG9ja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jhc2UnLFxuICAnYmFzZWZvbnQnLFxuICAnYmxvY2txdW90ZScsXG4gICdib2R5JyxcbiAgJ2NhcHRpb24nLFxuICAnY2VudGVyJyxcbiAgJ2NvbCcsXG4gICdjb2xncm91cCcsXG4gICdkZCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RpYWxvZycsXG4gICdkaXInLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2ZyYW1lJyxcbiAgJ2ZyYW1lc2V0JyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hyJyxcbiAgJ2h0bWwnLFxuICAnaWZyYW1lJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdsaW5rJyxcbiAgJ21haW4nLFxuICAnbWVudScsXG4gICdtZW51aXRlbScsXG4gICdtZXRhJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdzZWN0aW9uJyxcbiAgJ3NvdXJjZScsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcbid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnRzLnBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2xhYmVsJyk7XG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG5leHBvcnRzLnBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX3RpdGxlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwiLy8gUGFyc2UgbGluayBkZXN0aW5hdGlvblxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNTcGFjZSAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLCBsZXZlbCxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4M0MgLyogPCAqLykge1xuICAgIHBvcysrO1xuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovIHx8IGlzU3BhY2UoY29kZSkpIHsgcmV0dXJuIHJlc3VsdDsgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4M0UgLyogPiAqLykge1xuICAgICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIC8vIG5vIGNsb3NpbmcgJz4nXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIHRoaXMgc2hvdWxkIGJlIC4uLiB9IGVsc2UgeyAuLi4gYnJhbmNoXG5cbiAgbGV2ZWwgPSAwO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyMCkgeyBicmVhazsgfVxuXG4gICAgLy8gYXNjaWkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAweDIwIHx8IGNvZGUgPT09IDB4N0YpIHsgYnJlYWs7IH1cblxuICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHsgYnJlYWs7IH1cbiAgICAgIGxldmVsLS07XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG4gIGlmIChsZXZlbCAhPT0gMCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIi8vIFBhcnNlIGxpbmsgbGFiZWxcbi8vXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XG4vLyByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgbGV2ZWwgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCIvLyBQYXJzZSBsaW5rIHRpdGxlXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9pbmRleC5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdodG1sX2Jsb2NrJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9odG1sX2Jsb2NrJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBDb3JlXG4gKlxuICogVG9wLWxldmVsIHJ1bGVzIGV4ZWN1dG9yLiBHbHVlcyBibG9jay9pbmxpbmUgcGFyc2VycyBhbmQgZG9lcyBpbnRlcm1lZGlhdGVcbiAqIHRyYW5zZm9ybWF0aW9ucy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ25vcm1hbGl6ZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL25vcm1hbGl6ZScpICAgICAgXSxcbiAgWyAnYmxvY2snLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYmxvY2snKSAgICAgICAgICBdLFxuICBbICdpbmxpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9pbmxpbmUnKSAgICAgICAgIF0sXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXSxcbiAgWyAncmVwbGFjZW1lbnRzJywgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzJykgICBdLFxuICBbICdzbWFydHF1b3RlcycsICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zbWFydHF1b3RlcycpICAgIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgQ29yZSgpXG4gKiovXG5mdW5jdGlvbiBDb3JlKCkge1xuICAvKipcbiAgICogQ29yZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBjb3JlIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcbiAqXG4gKiBFeGVjdXRlcyBjb3JlIGNoYWluIHJ1bGVzLlxuICoqL1xuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgaSwgbCwgcnVsZXM7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcblxuICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5Db3JlLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zdGF0ZV9jb3JlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUuanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlcklubGluZVxuICpcbiAqIFRva2VuaXplcyBwYXJhZ3JhcGggY29udGVudC5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQYXJzZXIgcnVsZXNcblxudmFyIF9ydWxlcyA9IFtcbiAgWyAndGV4dCcsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dCcpIF0sXG4gIFsgJ25ld2xpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL25ld2xpbmUnKSBdLFxuICBbICdlc2NhcGUnLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lc2NhcGUnKSBdLFxuICBbICdiYWNrdGlja3MnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWNrdGlja3MnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykudG9rZW5pemUgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS50b2tlbml6ZSBdLFxuICBbICdsaW5rJywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9saW5rJykgXSxcbiAgWyAnaW1hZ2UnLCAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaW1hZ2UnKSBdLFxuICBbICdhdXRvbGluaycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9hdXRvbGluaycpIF0sXG4gIFsgJ2h0bWxfaW5saW5lJywgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lJykgXSxcbiAgWyAnZW50aXR5JywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW50aXR5JykgXVxuXTtcblxudmFyIF9ydWxlczIgPSBbXG4gIFsgJ2JhbGFuY2VfcGFpcnMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMnKSBdLFxuICBbICdzdHJpa2V0aHJvdWdoJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoJykucG9zdFByb2Nlc3MgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKS5wb3N0UHJvY2VzcyBdLFxuICBbICd0ZXh0X2NvbGxhcHNlJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJJbmxpbmUoKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VySW5saW5lKCkge1xuICB2YXIgaTtcblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGlubGluZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyMiAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIFNlY29uZCBydWxlciB1c2VkIGZvciBwb3N0LXByb2Nlc3NpbmdcbiAgICogKGUuZy4gaW4gZW1waGFzaXMtbGlrZSBydWxlcykuXG4gICAqKi9cbiAgdGhpcy5ydWxlcjIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzMi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIyLnB1c2goX3J1bGVzMltpXVswXSwgX3J1bGVzMltpXVsxXSk7XG4gIH1cbn1cblxuXG4vLyBTa2lwIHNpbmdsZSB0b2tlbiBieSBydW5uaW5nIGFsbCBydWxlcyBpbiB2YWxpZGF0aW9uIG1vZGU7XG4vLyByZXR1cm5zIGB0cnVlYCBpZiBhbnkgcnVsZSByZXBvcnRlZCBzdWNjZXNzXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5za2lwVG9rZW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLCBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZyxcbiAgICAgIGNhY2hlID0gc3RhdGUuY2FjaGU7XG5cblxuICBpZiAodHlwZW9mIGNhY2hlW3Bvc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUucG9zID0gY2FjaGVbcG9zXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBJbmNyZW1lbnQgc3RhdGUubGV2ZWwgYW5kIGRlY3JlbWVudCBpdCBsYXRlciB0byBsaW1pdCByZWN1cnNpb24uXG4gICAgICAvLyBJdCdzIGhhcm1sZXNzIHRvIGRvIGhlcmUsIGJlY2F1c2Ugbm8gdG9rZW5zIGFyZSBjcmVhdGVkLiBCdXQgaWRlYWxseSxcbiAgICAgIC8vIHdlJ2QgbmVlZCBhIHNlcGFyYXRlIHByaXZhdGUgc3RhdGUgdmFyaWFibGUgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgIC8vXG4gICAgICBzdGF0ZS5sZXZlbCsrO1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5sZXZlbC0tO1xuXG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9vIG11Y2ggbmVzdGluZywganVzdCBza2lwIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBjYXVzZSBsaW5rcyB0byBiZWhhdmUgaW5jb3JyZWN0bHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlLFxuICAgIC8vICAgICAgIHdoZW4gYW4gYW1vdW50IG9mIGBbYCBpcyBleGFjdGx5IGVxdWFsIHRvIGBtYXhOZXN0aW5nICsgMWA6XG4gICAgLy9cbiAgICAvLyAgICAgICBbW1tbW1tbW1tbW1tbW1tbW1tbW1tmb29dKClcbiAgICAvL1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdvcmthcm91bmQgd2hlbiBDTSBzdGFuZGFyZCB3aWxsIGFsbG93IG5lc3RlZCBsaW5rc1xuICAgIC8vICAgICAgICh3ZSBjYW4gcmVwbGFjZSBpdCBieSBwcmV2ZW50aW5nIGxpbmtzIGZyb20gYmVpbmcgcGFyc2VkIGluXG4gICAgLy8gICAgICAgdmFsaWRhdGlvbiBtb2RlKVxuICAgIC8vXG4gICAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4O1xuICB9XG5cbiAgaWYgKCFvaykgeyBzdGF0ZS5wb3MrKzsgfVxuICBjYWNoZVtwb3NdID0gc3RhdGUucG9zO1xufTtcblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgZW5kID0gc3RhdGUucG9zTWF4LFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgZW5kKSB7XG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5wb3NgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2spIHtcbiAgICAgIGlmIChzdGF0ZS5wb3MgPj0gZW5kKSB7IGJyZWFrOyB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1tzdGF0ZS5wb3MrK107XG4gIH1cblxuICBpZiAoc3RhdGUucGVuZGluZykge1xuICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJJbmxpbmUucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggaW5saW5lIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBpLCBydWxlcywgbGVuO1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzdHIsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyMi5nZXRSdWxlcygnJyk7XG4gIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VySW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qcyIsIi8vIENvbW1vbm1hcmsgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgdHJ1ZSwgICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAgJ2ZlbmNlJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbF9ibG9jaycsXG4gICAgICAgICdsaGVhZGluZycsXG4gICAgICAgICdsaXN0JyxcbiAgICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2F1dG9saW5rJyxcbiAgICAgICAgJ2JhY2t0aWNrcycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICdlbnRpdHknLFxuICAgICAgICAnZXNjYXBlJyxcbiAgICAgICAgJ2h0bWxfaW5saW5lJyxcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnbmV3bGluZScsXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIi8vIG1hcmtkb3duLWl0IGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAxMDAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzIiwiLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXG4vLyBtb2Rlcy4gRm9yIGV4YW1wbGUsIHRvIHBhcnNlIGJvbGQvaXRhbGljIG9ubHkuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcyIsIi8qKlxuICogY2xhc3MgUmVuZGVyZXJcbiAqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmcm9tIHBhcnNlZCB0b2tlbiBzdHJlYW0uIEVhY2ggaW5zdGFuY2UgaGFzIGluZGVwZW5kZW50XG4gKiBjb3B5IG9mIHJ1bGVzLiBUaG9zZSBjYW4gYmUgcmV3cml0dGVuIHdpdGggZWFzZS4gQWxzbywgeW91IGNhbiBhZGQgbmV3XG4gKiBydWxlcyBpZiB5b3UgY3JlYXRlIHBsdWdpbiBhbmQgYWRkcyBuZXcgdG9rZW4gdHlwZXMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFzc2lnbiAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuYXNzaWduO1xudmFyIHVuZXNjYXBlQWxsICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZhdWx0X3J1bGVzID0ge307XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxwcmUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+PGNvZGU+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XSxcbiAgICAgIGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogJycsXG4gICAgICBsYW5nTmFtZSA9ICcnLFxuICAgICAgaGlnaGxpZ2h0ZWQsIGksIHRtcEF0dHJzLCB0bXBUb2tlbjtcblxuICBpZiAoaW5mbykge1xuICAgIGxhbmdOYW1lID0gaW5mby5zcGxpdCgvXFxzKy9nKVswXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIGhpZ2hsaWdodGVkID0gb3B0aW9ucy5oaWdobGlnaHQodG9rZW4uY29udGVudCwgbGFuZ05hbWUpIHx8IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9XG5cbiAgaWYgKGhpZ2hsaWdodGVkLmluZGV4T2YoJzxwcmUnKSA9PT0gMCkge1xuICAgIHJldHVybiBoaWdobGlnaHRlZCArICdcXG4nO1xuICB9XG5cbiAgLy8gSWYgbGFuZ3VhZ2UgZXhpc3RzLCBpbmplY3QgY2xhc3MgZ2VudGx5LCB3aXRob3V0IG1vZGlmeWluZyBvcmlnaW5hbCB0b2tlbi5cbiAgLy8gTWF5IGJlLCBvbmUgZGF5IHdlIHdpbGwgYWRkIC5jbG9uZSgpIGZvciB0b2tlbiBhbmQgc2ltcGxpZnkgdGhpcyBwYXJ0LCBidXRcbiAgLy8gbm93IHdlIHByZWZlciB0byBrZWVwIHRoaW5ncyBsb2NhbC5cbiAgaWYgKGluZm8pIHtcbiAgICBpICAgICAgICA9IHRva2VuLmF0dHJJbmRleCgnY2xhc3MnKTtcbiAgICB0bXBBdHRycyA9IHRva2VuLmF0dHJzID8gdG9rZW4uYXR0cnMuc2xpY2UoKSA6IFtdO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0bXBBdHRycy5wdXNoKFsgJ2NsYXNzJywgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWUgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcEF0dHJzW2ldWzFdICs9ICcgJyArIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lO1xuICAgIH1cblxuICAgIC8vIEZha2UgdG9rZW4ganVzdCB0byByZW5kZXIgYXR0cmlidXRlc1xuICAgIHRtcFRva2VuID0ge1xuICAgICAgYXR0cnM6IHRtcEF0dHJzXG4gICAgfTtcblxuICAgIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRtcFRva2VuKSArICc+J1xuICAgICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgfVxuXG5cbiAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nXG4gICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaW1hZ2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFwiYWx0XCIgYXR0ciBNVVNUIGJlIHNldCwgZXZlbiBpZiBlbXB0eS4gQmVjYXVzZSBpdCdzIG1hbmRhdG9yeSBhbmRcbiAgLy8gc2hvdWxkIGJlIHBsYWNlZCBvbiBwcm9wZXIgcG9zaXRpb24gZm9yIHRlc3RzLlxuICAvL1xuICAvLyBSZXBsYWNlIGNvbnRlbnQgd2l0aCBhY3R1YWwgdmFsdWVcblxuICB0b2tlbi5hdHRyc1t0b2tlbi5hdHRySW5kZXgoJ2FsdCcpXVsxXSA9XG4gICAgc2xmLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbi5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcblxuICByZXR1cm4gc2xmLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5oYXJkYnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nO1xufTtcbmRlZmF1bHRfcnVsZXMuc29mdGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMuYnJlYWtzID8gKG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJykgOiAnXFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy50ZXh0ID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaHRtbF9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcbmRlZmF1bHRfcnVsZXMuaHRtbF9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5cblxuLyoqXG4gKiBuZXcgUmVuZGVyZXIoKVxuICpcbiAqIENyZWF0ZXMgbmV3IFtbUmVuZGVyZXJdXSBpbnN0YW5jZSBhbmQgZmlsbCBbW1JlbmRlcmVyI3J1bGVzXV0gd2l0aCBkZWZhdWx0cy5cbiAqKi9cbmZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJlciNydWxlcyAtPiBPYmplY3RcbiAgICpcbiAgICogQ29udGFpbnMgcmVuZGVyIHJ1bGVzIGZvciB0b2tlbnMuIENhbiBiZSB1cGRhdGVkIGFuZCBleHRlbmRlZC5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX29wZW4gID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzxiPic7IH07XG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8L2I+JzsgfTtcbiAgICpcbiAgICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSguLi4pO1xuICAgKiBgYGBcbiAgICpcbiAgICogRWFjaCBydWxlIGlzIGNhbGxlZCBhcyBpbmRlcGVuZGVudCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XG4gICAqICAgLy8gLi4uXG4gICAqICAgcmV0dXJuIHJlbmRlcmVkSFRNTDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcylcbiAgICogZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlcyA9IGFzc2lnbih7fSwgZGVmYXVsdF9ydWxlcyk7XG59XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJBdHRycyh0b2tlbikgLT4gU3RyaW5nXG4gKlxuICogUmVuZGVyIHRva2VuIGF0dHJpYnV0ZXMgdG8gc3RyaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcbiAgdmFyIGksIGwsIHJlc3VsdDtcblxuICBpZiAoIXRva2VuLmF0dHJzKSB7IHJldHVybiAnJzsgfVxuXG4gIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbi5hdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyAnICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVswXSkgKyAnPVwiJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMV0pICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvZiB0b2tlbnNcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICpcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXG4gKiBpbiBbW1JlbmRlcmVyI3J1bGVzXV0uXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICB2YXIgbmV4dFRva2VuLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBuZWVkTGYgPSBmYWxzZSxcbiAgICAgIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gVGlnaHQgbGlzdCBwYXJhZ3JhcGhzXG4gIGlmICh0b2tlbi5oaWRkZW4pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBJbnNlcnQgYSBuZXdsaW5lIGJldHdlZW4gaGlkZGVuIHBhcmFncmFwaCBhbmQgc3Vic2VxdWVudCBvcGVuaW5nXG4gIC8vIGJsb2NrLWxldmVsIHRhZy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGhlcmUgd2Ugc2hvdWxkIGluc2VydCBhIG5ld2xpbmUgYmVmb3JlIGJsb2NrcXVvdGU6XG4gIC8vICAtIGFcbiAgLy8gICAgPlxuICAvL1xuICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBBZGQgdG9rZW4gbmFtZSwgZS5nLiBgPGltZ2BcbiAgcmVzdWx0ICs9ICh0b2tlbi5uZXN0aW5nID09PSAtMSA/ICc8LycgOiAnPCcpICsgdG9rZW4udGFnO1xuXG4gIC8vIEVuY29kZSBhdHRyaWJ1dGVzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiYFxuICByZXN1bHQgKz0gdGhpcy5yZW5kZXJBdHRycyh0b2tlbik7XG5cbiAgLy8gQWRkIGEgc2xhc2ggZm9yIHNlbGYtY2xvc2luZyB0YWdzLCBlLmcuIGA8aW1nIHNyYz1cImZvb1wiIC9gXG4gIGlmICh0b2tlbi5uZXN0aW5nID09PSAwICYmIG9wdGlvbnMueGh0bWxPdXQpIHtcbiAgICByZXN1bHQgKz0gJyAvJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xuICBpZiAodG9rZW4uYmxvY2spIHtcbiAgICBuZWVkTGYgPSB0cnVlO1xuXG4gICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgIGlmIChpZHggKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XG5cbiAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAnaW5saW5lJyB8fCBuZXh0VG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gQmxvY2stbGV2ZWwgdGFnIGNvbnRhaW5pbmcgYW4gaW5saW5lIHRhZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLm5lc3RpbmcgPT09IC0xICYmIG5leHRUb2tlbi50YWcgPT09IHRva2VuLnRhZykge1xuICAgICAgICAgIC8vIE9wZW5pbmcgdGFnICsgY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgdHlwZS4gRS5nLiBgPGxpPjwvbGk+YC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ICs9IG5lZWRMZiA/ICc+XFxuJyA6ICc+JztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZSh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGhlIHNhbWUgYXMgW1tSZW5kZXJlci5yZW5kZXJdXSwgYnV0IGZvciBzaW5nbGUgdG9rZW4gb2YgYGlubGluZWAgdHlwZS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFNwZWNpYWwga2x1ZGdlIGZvciBpbWFnZSBgYWx0YCBhdHRyaWJ1dGVzIHRvIGNvbmZvcm0gQ29tbW9uTWFyayBzcGVjLlxuICogRG9uJ3QgdHJ5IHRvIHVzZSBpdCEgU3BlYyByZXF1aXJlcyB0byBzaG93IGBhbHRgIGNvbnRlbnQgd2l0aCBzdHJpcHBlZCBtYXJrdXAsXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmVBc1RleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzdWx0ICs9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXIodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcbiAqIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgaSwgbGVuLCB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3Rva2Vuc1tpXS50eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGFkanVzdFRhYixcbiAgICAgIGNoLFxuICAgICAgaSxcbiAgICAgIGluaXRpYWwsXG4gICAgICBsLFxuICAgICAgbGFzdExpbmVFbXB0eSxcbiAgICAgIGxpbmVzLFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRCTWFya3MsXG4gICAgICBvbGRCU0NvdW50LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIHdhc091dGRlbnRlZCxcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgIHBvcysrO1xuICAgIGluaXRpYWwrKztcbiAgICBvZmZzZXQrKztcbiAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgaWYgKChzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICBwb3MrKztcbiAgICAgIGluaXRpYWwrKztcbiAgICAgIG9mZnNldCsrO1xuICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgfVxuXG4gIG9sZEJNYXJrcyA9IFsgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIG9sZEJTQ291bnQgPSBbIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICBvbGRTQ291bnQgPSBbIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICBvbGRUU2hpZnQgPSBbIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdibG9ja3F1b3RlJztcbiAgd2FzT3V0ZGVudGVkID0gZmFsc2U7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZzpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vICAgICAgLSAtIC1cbiAgLy8gICAgIGBgYFxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBvdXRkZW50ZWQsIGkuZS4gaXQncyBpbnNpZGUgbGlzdCBpdGVtIGFuZCBpbmRlbnRlZFxuICAgIC8vIGxlc3MgdGhhbiBzYWlkIGxpc3QgaXRlbTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIDEuIGFueXRoaW5nXG4gICAgLy8gICAgPiBjdXJyZW50IGJsb2NrcXVvdGVcbiAgICAvLyAyLiBjaGVja2luZyB0aGlzIGxpbmVcbiAgICAvLyBgYGBcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgd2FzT3V0ZGVudGVkID0gdHJ1ZTtcblxuICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgLy8gQ2FzZSAxOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGlzIGxpbmUgaXMgZW1wdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLyAmJiAhd2FzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBza2lwIHNwYWNlcyBhZnRlciBcIj5cIiBhbmQgcmUtY2FsY3VsYXRlIG9mZnNldFxuICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3MgLSAoc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuXG4gICAgICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgICAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAvLyBRdWlyayB0byBlbmZvcmNlIFwiaGFyZCB0ZXJtaW5hdGlvbiBtb2RlXCIgZm9yIHBhcmFncmFwaHM7XG4gICAgICAvLyBub3JtYWxseSBpZiB5b3UgY2FsbCBgdG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpYCxcbiAgICAgIC8vIHBhcmFncmFwaHMgd2lsbCBsb29rIGJlbG93IG5leHRMaW5lIGZvciBwYXJhZ3JhcGggY29udGludWF0aW9uLFxuICAgICAgLy8gYnV0IGlmIGJsb2NrcXVvdGUgaXMgdGVybWluYXRlZCBieSBhbm90aGVyIHRhZywgdGhleSBzaG91bGRuJ3RcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBuZXh0TGluZTtcblxuICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0ZS5ibGtJbmRlbnQgd2FzIG5vbi16ZXJvLCB3ZSBub3cgc2V0IGl0IHRvIHplcm8sXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGFsbCBvZmZzZXRzIHRvIGFwcGVhciBhc1xuICAgICAgICAvLyBpZiBpbmRlbnQgd2Fzbid0IGNoYW5nZWRcbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCIvLyBDb2RlIGJsb2NrICg0IHNwYWNlcyBwYWRkZWQpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvZGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgbmV4dExpbmUsIGxhc3QsIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA8IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGxhc3QgPSBuZXh0TGluZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBsYXN0O1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2Jsb2NrJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2NvZGUuanMiLCIvLyBmZW5jZXMgKGBgYCBsYW5nLCB+fn4gbGFuZylcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLCB0b2tlbiwgbWFya3VwLFxuICAgICAgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDYwIC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgbWVtID0gcG9zO1xuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIGxlbiA9IHBvcyAtIG1lbTtcblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrdXAgPSBzdGF0ZS5zcmMuc2xpY2UobWVtLCBwb3MpO1xuICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmICFpc1NwYWNlKGNoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIExldCdzIGN1dCB0YWlscyBsaWtlICcgICAgIyMjICAnIGZyb20gdGhlIGVuZCBvZiBzdHJpbmdcblxuICBtYXggPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgsIHBvcyk7XG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9mIHRoZW1cblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaHInLCAnaHInLCAwKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuLy8gQW4gYXJyYXkgb2Ygb3BlbmluZyBhbmQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHNlcXVlbmNlcyBmb3IgaHRtbCB0YWdzLFxuLy8gbGFzdCBhcmd1bWVudCBkZWZpbmVzIHdoZXRoZXIgaXQgY2FuIHRlcm1pbmF0ZSBhIHBhcmFncmFwaCBvciBub3Rcbi8vXG52YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gIFsgL148KHNjcmlwdHxwcmV8c3R5bGUpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlKT4vaSwgdHJ1ZSBdLFxuICBbIC9ePCEtLS8sICAgICAgICAvLS0+LywgICB0cnVlIF0sXG4gIFsgL148XFw/LywgICAgICAgICAvXFw/Pi8sICAgdHJ1ZSBdLFxuICBbIC9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlIF0sXG4gIFsgL148IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cCgnXjwvPygnICsgYmxvY2tfbmFtZXMuam9pbignfCcpICsgJykoPz0oXFxcXHN8Lz8+fCQpKScsICdpJyksIC9eJC8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlIF1cbl07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgaSwgbmV4dExpbmUsIHRva2VuLCBsaW5lVGV4dCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gdHJ1ZSBpZiB0aGlzIHNlcXVlbmNlIGNhbiBiZSBhIHRlcm1pbmF0b3IsIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBIVE1MX1NFUVVFTkNFU1tpXVsyXTtcbiAgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBJZiB3ZSBhcmUgaGVyZSAtIHdlIGRldGVjdGVkIEhUTUwgYmxvY2suXG4gIC8vIExldCdzIHJvbGwgZG93biB0aWxsIGJsb2NrIGVuZC5cbiAgaWYgKCFIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKzsgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgbmV4dExpbmUgXTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5qcyIsIi8vIGxoZWFkaW5nICgtLS0sID09PSlcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgsIGxldmVsLCBtYXJrZXIsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyk7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJzsgLy8gdXNlIHBhcmFncmFwaCB0byBtYXRjaCB0ZXJtaW5hdG9yUnVsZXNcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy9cbiAgICAvLyBDaGVjayBmb3IgdW5kZXJsaW5lIGluIHNldGV4dCBoZWFkZXJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHgyRC8qIC0gKi8gfHwgbWFya2VyID09PSAweDNELyogPSAqLykge1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgICAgICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgICAgICAgIGxldmVsID0gKG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoIWxldmVsKSB7XG4gICAgLy8gRGlkbid0IGZpbmQgdmFsaWQgdW5kZXJsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSAtIDEgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkTEluZGVudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4ICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIHRoaXMgY2FzZVxuICAgICAgLy8gKGxpc3QgaXRlbSBpcyBlbXB0eSwgbGlzdCB0ZXJtaW5hdGVzIGJlZm9yZSBcImZvb1wiKTpcbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICAvLyAgIC1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgZm9vXG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgc3RhdGUubGluZSA9IE1hdGgubWluKHN0YXRlLmxpbmUgKyAyLCBlbmRMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZExJbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvL1xuICAgIC8vIFRyeSB0byBjaGVjayBpZiBsaXN0IGlzIHRlcm1pbmF0ZWQgb3IgY29udGludWVkLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIGxpc3QgaGFzIGFub3RoZXIgdHlwZVxuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VyQ2hhckNvZGUgIT09IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIEZpbmFsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3RfY2xvc2UnLCAndWwnLCAtMSk7XG4gIH1cbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIi8vIFBhcmFncmFwaFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3RhdGUsIHN0YXJ0TGluZS8qLCBlbmRMaW5lKi8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyksXG4gICAgICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnO1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9vcGVuJywgJ3AnLCAxKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlKHN0YXRlLCBzdGFydExpbmUsIF9lbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgZGVzdEVuZFBvcyxcbiAgICAgIGRlc3RFbmRMaW5lTm8sXG4gICAgICBlbmRMaW5lLFxuICAgICAgaHJlZixcbiAgICAgIGksXG4gICAgICBsLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICByZXMsXG4gICAgICBzdGFydCxcbiAgICAgIHN0cixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW1wbGUgY2hlY2sgdG8gcXVpY2tseSBpbnRlcnJ1cHQgc2NhbiBvbiBbbGlua10odXJsKSBhdCB0aGUgc3RhcnQgb2YgbGluZS5cbiAgLy8gQ2FuIGJlIHVzZWZ1bCBvbiBwcmFjdGljZTogaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy81NFxuICB3aGlsZSAoKytwb3MgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovICYmXG4gICAgICAgIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyAtIDEpICE9PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGlmIChwb3MgKyAxID09PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncmVmZXJlbmNlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncmVmZXJlbmNlJztcblxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIHN0ciA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgbWF4ID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxhYmVsRW5kID0gcG9zO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwQSAvKiBcXG4gKi8pIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLykge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgXl5eIHNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICBeXl5eXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCk7XG4gIGlmICghcmVzLm9rKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSByZXMucG9zO1xuICBsaW5lcyArPSByZXMubGluZXM7XG5cbiAgLy8gc2F2ZSBjdXJzb3Igc3RhdGUsIHdlIGNvdWxkIHJlcXVpcmUgdG8gcm9sbGJhY2sgbGF0ZXJcbiAgZGVzdEVuZFBvcyA9IHBvcztcbiAgZGVzdEVuZExpbmVObyA9IGxpbmVzO1xuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeXl4gc2tpcHBpbmcgdGhvc2Ugc3BhY2VzXG4gIHN0YXJ0ID0gcG9zO1xuICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICBwb3MgPSByZXMucG9zO1xuICAgIGxpbmVzICs9IHJlcy5saW5lcztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9ICcnO1xuICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICB9XG5cbiAgLy8gc2tpcCB0cmFpbGluZyBzcGFjZXMgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBhZnRlciB0aXRsZSxcbiAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIHZhbGlkIHJlZmVyZW5jZSBpZiB3ZSByb2xsIGJhY2tcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBDb21tb25NYXJrIDAuMjAgZGlzYWxsb3dzIGVtcHR5IGxhYmVsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFJlZmVyZW5jZSBjYW4gbm90IHRlcm1pbmF0ZSBhbnl0aGluZy4gVGhpcyBjaGVjayBpcyBmb3Igc2FmZXR5IG9ubHkuXG4gIC8qaXN0YW5idWwgaWdub3JlIGlmKi9cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlOiB0aXRsZSwgaHJlZjogaHJlZiB9O1xuICB9XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIGxpbmVzICsgMTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwiLy8gUGFyc2VyIHN0YXRlIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBTdGF0ZUJsb2NrKHNyYywgbWQsIGVudiwgdG9rZW5zKSB7XG4gIHZhciBjaCwgcywgc3RhcnQsIHBvcywgbGVuLCBpbmRlbnQsIG9mZnNldCwgaW5kZW50X2ZvdW5kO1xuXG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG4gIHRoaXMubWQgICAgID0gbWQ7XG5cbiAgdGhpcy5lbnYgPSBlbnY7XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXG4gIHRoaXMuYk1hcmtzID0gW107ICAvLyBsaW5lIGJlZ2luIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy5lTWFya3MgPSBbXTsgIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIG9mZnNldHMgb2YgdGhlIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJzICh0YWJzIG5vdCBleHBhbmRlZClcbiAgdGhpcy5zQ291bnQgPSBbXTsgIC8vIGluZGVudHMgZm9yIGVhY2ggbGluZSAodGFicyBleHBhbmRlZClcblxuICAvLyBBbiBhbW91bnQgb2YgdmlydHVhbCBzcGFjZXMgKHRhYnMgZXhwYW5kZWQpIGJldHdlZW4gYmVnaW5uaW5nXG4gIC8vIG9mIGVhY2ggbGluZSAoYk1hcmtzKSBhbmQgcmVhbCBiZWdpbm5pbmcgb2YgdGhhdCBsaW5lLlxuICAvL1xuICAvLyBJdCBleGlzdHMgb25seSBhcyBhIGhhY2sgYmVjYXVzZSBibG9ja3F1b3RlcyBvdmVycmlkZSBiTWFya3NcbiAgLy8gbG9zaW5nIGluZm9ybWF0aW9uIGluIHRoZSBwcm9jZXNzLlxuICAvL1xuICAvLyBJdCdzIHVzZWQgb25seSB3aGVuIGV4cGFuZGluZyB0YWJzLCB5b3UgY2FuIHRoaW5rIGFib3V0IGl0IGFzXG4gIC8vIGFuIGluaXRpYWwgdGFiIGxlbmd0aCwgZS5nLiBic0NvdW50PTIxIGFwcGxpZWQgdG8gc3RyaW5nIGBcXHQxMjNgXG4gIC8vIG1lYW5zIGZpcnN0IHRhYiBzaG91bGQgYmUgZXhwYW5kZWQgdG8gNC0yMSU0ID09PSAzIHNwYWNlcy5cbiAgLy9cbiAgdGhpcy5ic0NvdW50ID0gW107XG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHdlIGFyZSBpbiBsaXN0KVxuICB0aGlzLmxpbmUgICAgICAgPSAwOyAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxuICB0aGlzLnRpZ2h0ICAgICAgPSBmYWxzZTsgIC8vIGxvb3NlL3RpZ2h0IG1vZGUgZm9yIGxpc3RzXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICAvLyBjYW4gYmUgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdyb290JywgJ3BhcmFncmFwaCcgb3IgJ3JlZmVyZW5jZSdcbiAgLy8gdXNlZCBpbiBsaXN0cyB0byBkZXRlcm1pbmUgaWYgdGhleSBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGhcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnO1xuXG4gIHRoaXMubGV2ZWwgPSAwO1xuXG4gIC8vIHJlbmRlcmVyXG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgLy8gQ3JlYXRlIGNhY2hlc1xuICAvLyBHZW5lcmF0ZSBtYXJrZXJzLlxuICBzID0gdGhpcy5zcmM7XG4gIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSBvZmZzZXQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgIGNoID0gcy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGluZGVudCsrO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBIHx8IHBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgaWYgKGNoICE9PSAweDBBKSB7IHBvcysrOyB9XG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goaW5kZW50KTtcbiAgICAgIHRoaXMuc0NvdW50LnB1c2gob2Zmc2V0KTtcbiAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggZmFrZSBlbnRyeSB0byBzaW1wbGlmeSBjYWNoZSBib3VuZHMgY2hlY2tzXG4gIHRoaXMuYk1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy50U2hpZnQucHVzaCgwKTtcbiAgdGhpcy5zQ291bnQucHVzaCgwKTtcbiAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgdGhpcy5saW5lTWF4ID0gdGhpcy5iTWFya3MubGVuZ3RoIC0gMTsgLy8gZG9uJ3QgY291bnQgbGFzdCBmYWtlIGxpbmVcbn1cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdG9rZW4uYmxvY2sgPSB0cnVlO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwiLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gZ2V0TGluZShzdGF0ZSwgbGluZSkge1xuICB2YXIgcG9zID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuYmxrSW5kZW50LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xuXG4gIHJldHVybiBzdGF0ZS5zcmMuc3Vic3RyKHBvcywgbWF4IC0gcG9zKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZFNwbGl0KHN0cikge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBwb3MgPSAwLFxuICAgICAgbWF4ID0gc3RyLmxlbmd0aCxcbiAgICAgIGNoLFxuICAgICAgZXNjYXBlcyA9IDAsXG4gICAgICBsYXN0UG9zID0gMCxcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZSxcbiAgICAgIGxhc3RCYWNrVGljayA9IDA7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDYwLyogYCAqLykge1xuICAgICAgaWYgKGJhY2tUaWNrZWQpIHtcbiAgICAgICAgLy8gbWFrZSBcXGAgY2xvc2UgY29kZSBzZXF1ZW5jZSwgYnV0IG5vdCBvcGVuIGl0O1xuICAgICAgICAvLyB0aGUgcmVhc29uIGlzOiBgXFxgIGlzIGNvcnJlY3QgY29kZSBibG9ja1xuICAgICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlcyAlIDIgPT09IDApIHtcbiAgICAgICAgYmFja1RpY2tlZCA9IHRydWU7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDdjLyogfCAqLyAmJiAoZXNjYXBlcyAlIDIgPT09IDApICYmICFiYWNrVGlja2VkKSB7XG4gICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDVjLyogXFwgKi8pIHtcbiAgICAgIGVzY2FwZXMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlcyA9IDA7XG4gICAgfVxuXG4gICAgcG9zKys7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gdW4tY2xvc2VkIGJhY2t0aWNrLCBnbyBiYWNrIHRvIGp1c3QgYWZ0ZXJcbiAgICAvLyB0aGUgbGFzdCBiYWNrdGljaywgYnV0IGFzIGlmIGl0IHdhcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAgICBpZiAocG9zID09PSBtYXggJiYgYmFja1RpY2tlZCkge1xuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgcG9zID0gbGFzdEJhY2tUaWNrICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MpKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGFibGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbmV4dExpbmUsIGNvbHVtbnMsIGNvbHVtbkNvdW50LCB0b2tlbixcbiAgICAgIGFsaWducywgdCwgdGFibGVMaW5lcywgdGJvZHlMaW5lcztcblxuICAvLyBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0d28gbGluZXNcbiAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2Vjb25kIGxpbmUgc2hvdWxkIGJlICd8JywgJy0nLCAnOicsXG4gIC8vIGFuZCBubyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkIGJ1dCBzcGFjZXM7XG4gIC8vIGJhc2ljYWxseSwgdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvXlstOnxdWy06fFxcc10qJC8gcmVnZXhwXG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUgKyAxKTtcblxuICBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoJ3wnKTtcbiAgYWxpZ25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIGlmICghdCkge1xuICAgICAgLy8gYWxsb3cgZW1wdHkgY29sdW1ucyBiZWZvcmUgYW5kIGFmdGVyIHRhYmxlLCBidXQgbm90IGluIGJldHdlZW4gY29sdW1ucztcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eOj8tKzo/JC8udGVzdCh0KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovID8gJ2NlbnRlcicgOiAncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWducy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgLy8gaGVhZGVyIHJvdyB3aWxsIGRlZmluZSBhbiBhbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZW50aXJlIHRhYmxlLFxuICAvLyBhbmQgYWxpZ24gcm93IHNob3VsZG4ndCBiZSBzbWFsbGVyIHRoYW4gdGhhdCAodGhlIHJlc3Qgb2YgdGhlIHJvd3MgY2FuKVxuICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPiBhbGlnbnMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0YWJsZV9vcGVuJywgJ3RhYmxlJywgMSk7XG4gIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX29wZW4nLCAndGhlYWQnLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX29wZW4nLCAndGgnLCAxKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgIH1cblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFsgc3RhcnRMaW5lICsgMiwgMCBdO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IGJyZWFrOyB9XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyBicmVhazsgfVxuICAgIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3Rib2R5X2Nsb3NlJywgJ3Rib2R5JywgLTEpO1xuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuXG4gIHRhYmxlTGluZXNbMV0gPSB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuICB2YXIgdG9rZW47XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyAwLCAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzIiwiLy8gUmVwbGFjZSBsaW5rLWxpa2UgdGV4dHMgd2l0aCBsaW5rIG5vZGVzLlxuLy9cbi8vIEN1cnJlbnRseSByZXN0cmljdGVkIGJ5IGBtZC52YWxpZGF0ZUxpbmsoKWAgdG8gaHR0cC9odHRwcy9mdHBcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFycmF5UmVwbGFjZUF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuYXJyYXlSZXBsYWNlQXQ7XG5cblxuZnVuY3Rpb24gaXNMaW5rT3BlbihzdHIpIHtcbiAgcmV0dXJuIC9ePGFbPlxcc10vaS50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc0xpbmtDbG9zZShzdHIpIHtcbiAgcmV0dXJuIC9ePFxcL2FcXHMqPi9pLnRlc3Qoc3RyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtpZnkoc3RhdGUpIHtcbiAgdmFyIGksIGosIGwsIHRva2VucywgdG9rZW4sIGN1cnJlbnRUb2tlbiwgbm9kZXMsIGxuLCB0ZXh0LCBwb3MsIGxhc3RQb3MsXG4gICAgICBsZXZlbCwgaHRtbExpbmtMZXZlbCwgdXJsLCBmdWxsVXJsLCB1cmxUZXh0LFxuICAgICAgYmxvY2tUb2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBsaW5rcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMubGlua2lmeSkgeyByZXR1cm47IH1cblxuICBmb3IgKGogPSAwLCBsID0gYmxvY2tUb2tlbnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgaWYgKGJsb2NrVG9rZW5zW2pdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFzdGF0ZS5tZC5saW5raWZ5LnByZXRlc3QoYmxvY2tUb2tlbnNbal0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRva2VucyA9IGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuO1xuXG4gICAgaHRtbExpbmtMZXZlbCA9IDA7XG5cbiAgICAvLyBXZSBzY2FuIGZyb20gdGhlIGVuZCwgdG8ga2VlcCBwb3NpdGlvbiB3aGVuIG5ldyB0YWdzIGFkZGVkLlxuICAgIC8vIFVzZSByZXZlcnNlZCBsb2dpYyBpbiBsaW5rcyBzdGFydC9lbmQgbWF0Y2hcbiAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGN1cnJlbnRUb2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIG1hcmtkb3duIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJykge1xuICAgICAgICBpLS07XG4gICAgICAgIHdoaWxlICh0b2tlbnNbaV0ubGV2ZWwgIT09IGN1cnJlbnRUb2tlbi5sZXZlbCAmJiB0b2tlbnNbaV0udHlwZSAhPT0gJ2xpbmtfb3BlbicpIHtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBodG1sIHRhZyBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnaHRtbF9pbmxpbmUnKSB7XG4gICAgICAgIGlmIChpc0xpbmtPcGVuKGN1cnJlbnRUb2tlbi5jb250ZW50KSAmJiBodG1sTGlua0xldmVsID4gMCkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5rQ2xvc2UoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaHRtbExpbmtMZXZlbCA+IDApIHsgY29udGludWU7IH1cblxuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAndGV4dCcgJiYgc3RhdGUubWQubGlua2lmeS50ZXN0KGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuXG4gICAgICAgIHRleHQgPSBjdXJyZW50VG9rZW4uY29udGVudDtcbiAgICAgICAgbGlua3MgPSBzdGF0ZS5tZC5saW5raWZ5Lm1hdGNoKHRleHQpO1xuXG4gICAgICAgIC8vIE5vdyBzcGxpdCBzdHJpbmcgdG8gbm9kZXNcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgbGV2ZWwgPSBjdXJyZW50VG9rZW4ubGV2ZWw7XG4gICAgICAgIGxhc3RQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobG4gPSAwOyBsbiA8IGxpbmtzLmxlbmd0aDsgbG4rKykge1xuXG4gICAgICAgICAgdXJsID0gbGlua3NbbG5dLnVybDtcbiAgICAgICAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xuICAgICAgICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB1cmxUZXh0ID0gbGlua3NbbG5dLnRleHQ7XG5cbiAgICAgICAgICAvLyBMaW5raWZpZXIgbWlnaHQgc2VuZCByYXcgaG9zdG5hbWVzIGxpa2UgXCJleGFtcGxlLmNvbVwiLCB3aGVyZSB1cmxcbiAgICAgICAgICAvLyBzdGFydHMgd2l0aCBkb21haW4gbmFtZS4gU28gd2UgcHJlcGVuZCBodHRwOi8vIGluIHRob3NlIGNhc2VzLFxuICAgICAgICAgIC8vIGFuZCByZW1vdmUgaXQgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmICghbGlua3NbbG5dLnNjaGVtYSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdodHRwOi8vJyArIHVybFRleHQpLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sICcnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmtzW2xuXS5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdCh1cmxUZXh0KSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdtYWlsdG86JyArIHVybFRleHQpLnJlcGxhY2UoL15tYWlsdG86LywgJycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsVGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9zID0gbGlua3NbbG5dLmluZGV4O1xuXG4gICAgICAgICAgaWYgKHBvcyA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zLCBwb3MpO1xuICAgICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsKys7XG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9ICdsaW5raWZ5JztcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdXJsVGV4dDtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IC0tbGV2ZWw7XG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9ICdsaW5raWZ5JztcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgbGFzdFBvcyA9IGxpbmtzW2xuXS5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb3MgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcyk7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjZSBjdXJyZW50IG5vZGVcbiAgICAgICAgYmxvY2tUb2tlbnNbal0uY2hpbGRyZW4gPSB0b2tlbnMgPSBhcnJheVJlcGxhY2VBdCh0b2tlbnMsIGksIG5vZGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMiLCIvLyBOb3JtYWxpemUgaW5wdXQgc3RyaW5nXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgTkVXTElORVNfUkUgID0gL1xccltcXG5cXHUwMDg1XT98W1xcdTI0MjRcXHUyMDI4XFx1MDA4NV0vZztcbnZhciBOVUxMX1JFICAgICAgPSAvXFx1MDAwMC9nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciBzdHI7XG5cbiAgLy8gTm9ybWFsaXplIG5ld2xpbmVzXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcblxuICBzdGF0ZS5zcmMgPSBzdHI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanMiLCIvLyBTaW1wbGUgdHlwb2dyYXBoeWMgcmVwbGFjZW1lbnRzXG4vL1xuLy8gKGMpIChDKSDihpIgwqlcbi8vICh0bSkgKFRNKSDihpIg4oSiXG4vLyAocikgKFIpIOKGkiDCrlxuLy8gKy0g4oaSIMKxXG4vLyAocCkgKFApIC0+IMKnXG4vLyAuLi4g4oaSIOKApiAoYWxzbyA/Li4uLiDihpIgPy4uLCAhLi4uLiDihpIgIS4uKVxuLy8gPz8/Pz8/Pz8g4oaSID8/PywgISEhISEg4oaSICEhISwgYCwsYCDihpIgYCxgXG4vLyAtLSDihpIgJm5kYXNoOywgLS0tIOKGkiAmbWRhc2g7XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOlxuLy8gLSBmcmFjdGlvbmFscyAxLzIsIDEvNCwgMy80IC0+IMK9LCDCvCwgwr5cbi8vIC0gbWlsdGlwbGljYXRpb24gMiB4IDQgLT4gMiDDlyA0XG5cbnZhciBSQVJFX1JFID0gL1xcKy18XFwuXFwufFxcP1xcP1xcP1xcP3whISEhfCwsfC0tLztcblxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXG4vLyBvciByb290IGNoZWNrIHdpbGwgZmFpbCBldmVyeSBzZWNvbmQgdGltZVxudmFyIFNDT1BFRF9BQkJSX1RFU1RfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pO1xuXG52YXIgU0NPUEVEX0FCQlJfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pZztcbnZhciBTQ09QRURfQUJCUiA9IHtcbiAgYzogJ8KpJyxcbiAgcjogJ8KuJyxcbiAgcDogJ8KnJyxcbiAgdG06ICfihKInXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlRm4obWF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2Vfc2NvcGVkKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgICAgICAgICAgICAvLyAuLiwgLi4uLCAuLi4uLi4uIC0+IOKAplxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhbPyFdKXs0LH0vZywgJyQxJDEkMScpLnJlcGxhY2UoLyx7Mix9L2csICcsJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZW4tZGFzaFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKFxcc3wkKS9tZywgJyQxXFx1MjAxMyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcyIsIi8vIENvbnZlcnQgc3RyYWlnaHQgcXVvdGF0aW9uIG1hcmtzIHRvIHR5cG9ncmFwaGljIG9uZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxudmFyIFFVT1RFX1RFU1RfUkUgPSAvWydcIl0vO1xudmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XG52YXIgQVBPU1RST1BIRSA9ICdcXHUyMDE5JzsgLyog4oCZICovXG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KHN0ciwgaW5kZXgsIGNoKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2lubGluZXModG9rZW5zLCBzdGF0ZSkge1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGl0ZW0sIGxhc3RDaGFyLCBuZXh0Q2hhcixcbiAgICAgIGlzTGFzdFB1bmN0Q2hhciwgaXNOZXh0UHVuY3RDaGFyLCBpc0xhc3RXaGl0ZVNwYWNlLCBpc05leHRXaGl0ZVNwYWNlLFxuICAgICAgY2FuT3BlbiwgY2FuQ2xvc2UsIGosIGlzU2luZ2xlLCBzdGFjaywgb3BlblF1b3RlLCBjbG9zZVF1b3RlO1xuXG4gIHN0YWNrID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuXG4gICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gaiArIDE7XG5cbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICBwb3MgPSAwO1xuICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgLyplc2xpbnQgbm8tbGFiZWxzOjAsYmxvY2stc2NvcGVkLXZhcjowKi9cbiAgICBPVVRFUjpcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0KTtcbiAgICAgIGlmICghdCkgeyBicmVhazsgfVxuXG4gICAgICBjYW5PcGVuID0gY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XG5cbiAgICAgIC8vIEZpbmQgcHJldmlvdXMgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBsYXN0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmICh0LmluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgIGxhc3RDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHQuaW5kZXggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSA9PT0gJ3NvZnRicmVhaycgfHwgdG9rZW5zW2pdLnR5cGUgPT09ICdoYXJkYnJlYWsnKSBicmVhazsgLy8gbGFzdENoYXIgZGVmYXVsdHMgdG8gMHgyMFxuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSBjb250aW51ZTtcblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSAnc29mdGJyZWFrJyB8fCB0b2tlbnNbal0udHlwZSA9PT0gJ2hhcmRicmVhaycpIGJyZWFrOyAvLyBuZXh0Q2hhciBkZWZhdWx0cyB0byAweDIwXG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgbmV4dENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gICAgICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRDaGFyID09PSAweDIyIC8qIFwiICovICYmIHRbMF0gPT09ICdcIicpIHtcbiAgICAgICAgaWYgKGxhc3RDaGFyID49IDB4MzAgLyogMCAqLyAmJiBsYXN0Q2hhciA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IDFcIlwiIC0gY291bnQgZmlyc3QgcXVvdGUgYXMgYW4gaW5jaFxuICAgICAgICAgIGNhbkNsb3NlID0gY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuICYmIGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRyZWF0IHRoaXMgYXMgdGhlIG1pZGRsZSBvZiB0aGUgd29yZFxuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIGNhbkNsb3NlID0gaXNOZXh0UHVuY3RDaGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbk9wZW4gJiYgIWNhbkNsb3NlKSB7XG4gICAgICAgIC8vIG1pZGRsZSBvZiB3b3JkXG4gICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5DbG9zZSkge1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgY2xvc2luZyBxdW90ZSwgcmV3aW5kIHRoZSBzdGFjayB0byBnZXQgYSBtYXRjaFxuICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICAgICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPCB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICAgICAgICBpZiAoaXRlbS5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcblxuICAgICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzJdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbM107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1swXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRva2VuLmNvbnRlbnQgKmJlZm9yZSogdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlLCBpZiB0aGV5IGFyZSBwb2ludGluZyBhdCB0aGUgc2FtZSB0b2tlbiwgcmVwbGFjZUF0XG4gICAgICAgICAgICAvLyBjb3VsZCBtZXNzIHVwIGluZGljZXMgd2hlbiBxdW90ZSBsZW5ndGggIT0gMVxuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBjbG9zZVF1b3RlKTtcbiAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50ID0gcmVwbGFjZUF0KFxuICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIG9wZW5RdW90ZSk7XG5cbiAgICAgICAgICAgIHBvcyArPSBjbG9zZVF1b3RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoaXRlbS50b2tlbiA9PT0gaSkgeyBwb3MgKz0gb3BlblF1b3RlLmxlbmd0aCAtIDE7IH1cblxuICAgICAgICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlIE9VVEVSO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3Blbikge1xuICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICB0b2tlbjogaSxcbiAgICAgICAgICBwb3M6IHQuaW5kZXgsXG4gICAgICAgICAgc2luZ2xlOiBpc1NpbmdsZSxcbiAgICAgICAgICBsZXZlbDogdGhpc0xldmVsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjYW5DbG9zZSAmJiBpc1NpbmdsZSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21hcnRxdW90ZXMoc3RhdGUpIHtcbiAgLyplc2xpbnQgbWF4LWRlcHRoOjAqL1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhUVVPVEVfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzX2lubGluZXMoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4sIHN0YXRlKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanMiLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgQVVUT0xJTktfUkUgPSAvXjwoW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopPi87XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciB0YWlsLCBsaW5rTWF0Y2gsIGVtYWlsTWF0Y2gsIHVybCwgZnVsbFVybCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHRhaWwgPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTtcblxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChBVVRPTElOS19SRS50ZXN0KHRhaWwpKSB7XG4gICAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XG5cbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGxpbmtNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh0YWlsKSkge1xuICAgIGVtYWlsTWF0Y2ggPSB0YWlsLm1hdGNoKEVNQUlMX1JFKTtcblxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKCdtYWlsdG86JyArIHVybCk7XG4gICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG5cbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgID0gJ2F1dG9saW5rJztcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGVtYWlsTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIi8vIFBhcnNlIGJhY2t0aWNrc1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFja3RpY2soc3RhdGUsIHNpbGVudCkge1xuICB2YXIgc3RhcnQsIG1heCwgbWFya2VyLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDYwLyogYCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGFydCA9IHBvcztcbiAgcG9zKys7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuXG4gIG1hdGNoU3RhcnQgPSBtYXRjaEVuZCA9IHBvcztcblxuICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZignYCcsIG1hdGNoRW5kKSkgIT09IC0xKSB7XG4gICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgMTtcblxuICAgIHdoaWxlIChtYXRjaEVuZCA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDB4NjAvKiBgICovKSB7IG1hdGNoRW5kKys7IH1cblxuICAgIGlmIChtYXRjaEVuZCAtIG1hdGNoU3RhcnQgPT09IG1hcmtlci5sZW5ndGgpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2lubGluZScsICdjb2RlJywgMCk7XG4gICAgICAgIHRva2VuLm1hcmt1cCAgPSBtYXJrZXI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFxuXSsvZywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBtYXJrZXI7IH1cbiAgc3RhdGUucG9zICs9IG1hcmtlci5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanMiLCIvLyBGb3IgZWFjaCBvcGVuaW5nIGVtcGhhc2lzLWxpa2UgbWFya2VyIGZpbmQgYSBtYXRjaGluZyBjbG9zaW5nIG9uZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtfcGFpcnMoc3RhdGUpIHtcbiAgdmFyIGksIGosIGxhc3REZWxpbSwgY3VyckRlbGltLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBsYXN0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKCFsYXN0RGVsaW0uY2xvc2UpIHsgY29udGludWU7IH1cblxuICAgIGogPSBpIC0gbGFzdERlbGltLmp1bXAgLSAxO1xuXG4gICAgd2hpbGUgKGogPj0gMCkge1xuICAgICAgY3VyckRlbGltID0gZGVsaW1pdGVyc1tqXTtcblxuICAgICAgaWYgKGN1cnJEZWxpbS5vcGVuICYmXG4gICAgICAgICAgY3VyckRlbGltLm1hcmtlciA9PT0gbGFzdERlbGltLm1hcmtlciAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgPCAwICYmXG4gICAgICAgICAgY3VyckRlbGltLmxldmVsID09PSBsYXN0RGVsaW0ubGV2ZWwpIHtcblxuICAgICAgICAvLyB0eXBlb2ZzIGFyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHBsdWdpbnNcbiAgICAgICAgdmFyIG9kZF9tYXRjaCA9IChjdXJyRGVsaW0uY2xvc2UgfHwgbGFzdERlbGltLm9wZW4pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY3VyckRlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsYXN0RGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJEZWxpbS5sZW5ndGggKyBsYXN0RGVsaW0ubGVuZ3RoKSAlIDMgPT09IDA7XG5cbiAgICAgICAgaWYgKCFvZGRfbWF0Y2gpIHtcbiAgICAgICAgICBsYXN0RGVsaW0uanVtcCA9IGkgLSBqO1xuICAgICAgICAgIGxhc3REZWxpbS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgY3VyckRlbGltLmVuZCAgPSBpO1xuICAgICAgICAgIGN1cnJEZWxpbS5qdW1wID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBqIC09IGN1cnJEZWxpbS5qdW1wICsgMTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIi8vIFByb2Nlc3MgaHRtbCBlbnRpdHkgLSAmIzEyMzssICYjeEFGOywgJnF1b3Q7LCAuLi5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcbnZhciBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmhhcztcbnZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzVmFsaWRFbnRpdHlDb2RlO1xudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcblxuXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpOy9pO1xudmFyIE5BTUVEX1JFICAgPSAvXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRpdHkoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIGNvZGUsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyNi8qICYgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goRElHSVRBTF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyArPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChoYXMoZW50aXRpZXMsIG1hdGNoWzFdKSkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gZW50aXRpZXNbbWF0Y2hbMV1dOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJyYnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwiLy8gUHJvY2VzcyBlc2NhcGVkIGNoYXJzIGFuZCBoYXJkYnJlYWtzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG52YXIgRVNDQVBFRCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxuXG4nXFxcXCFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi0nXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHsgRVNDQVBFRFtjaC5jaGFyQ29kZUF0KDApXSA9IDE7IH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qy8qIFxcICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcysrO1xuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggPCAyNTYgJiYgRVNDQVBFRFtjaF0gIT09IDApIHtcbiAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107IH1cbiAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgICAvLyBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZXMgZnJvbSBuZXh0IGxpbmVcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICdcXFxcJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIi8vIFByb2Nlc3MgaHRtbCB0YWdzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgSFRNTF9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfVEFHX1JFO1xuXG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIG1hdGNoLCBtYXgsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIENoZWNrIHN0YXJ0XG4gIG1heCA9IHN0YXRlLnBvc01heDtcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovIHx8XG4gICAgICBwb3MgKyAyID49IG1heCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFF1aWNrIGZhaWwgb24gc2Vjb25kIGNoYXJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKEhUTUxfVEFHX1JFKTtcbiAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCIvLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgY29udGVudCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVmLFxuICAgICAgcmVzLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UoXG4gICAgICBjb250ZW50LFxuICAgICAgc3RhdGUubWQsXG4gICAgICBzdGF0ZS5lbnYsXG4gICAgICB0b2tlbnMgPSBbXVxuICAgICk7XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xuICAgIHRva2VuLmF0dHJzICAgID0gYXR0cnMgPSBbIFsgJ3NyYycsIGhyZWYgXSwgWyAnYWx0JywgJycgXSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gdG9rZW5zO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCIvLyBQcm9jZXNzIFtsaW5rXSg8dG8+IFwic3R1ZmZcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBhdHRycyxcbiAgICAgIGNvZGUsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlcyxcbiAgICAgIHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICBocmVmID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDE7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zLCB0cnVlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZTtcblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgICBwb3MgPSByZXMucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgLy8gcGFyc2luZyBhIHZhbGlkIHNob3J0Y3V0IGxpbmsgZmFpbGVkLCBmYWxsYmFjayB0byByZWZlcmVuY2VcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocGFyc2VSZWZlcmVuY2UpIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkgeyBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7IH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICB0b2tlbi5hdHRycyAgPSBhdHRycyA9IFsgWyAnaHJlZicsIGhyZWYgXSBdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cblxuICAgIHN0YXRlLm1kLmlubGluZS50b2tlbml6ZShzdGF0ZSk7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCIvLyBQcm9jZWVzcyAnXFxuJ1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5ld2xpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG1heCwgbWF4LCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xuICAgIH1cbiAgfVxuXG4gIHBvcysrO1xuXG4gIC8vIHNraXAgaGVhZGluZyBzcGFjZXMgZm9yIG5leHQgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4ICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHsgcG9zKys7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwiLy8gSW5saW5lIHBhcnNlciBzdGF0ZVxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRva2VuICAgICAgICAgID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cblxuZnVuY3Rpb24gU3RhdGVJbmxpbmUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLm1kID0gbWQ7XG4gIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zO1xuXG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSAwO1xuXG4gIHRoaXMuY2FjaGUgPSB7fTsgICAgICAgIC8vIFN0b3JlcyB7IHN0YXJ0OiBlbmQgfSBwYWlycy4gVXNlZnVsIGZvciBiYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIG9mIHBhaXJzIHBhcnNlIChlbXBoYXNpcywgc3RyaWtlcykuXG5cbiAgdGhpcy5kZWxpbWl0ZXJzID0gW107ICAgLy8gRW1waGFzaXMtbGlrZSBkZWxpbWl0ZXJzXG59XG5cblxuLy8gRmx1c2ggcGVuZGluZyB0ZXh0XG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2hQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSB0aGlzLnBlbmRpbmc7XG4gIHRva2VuLmxldmVsID0gdGhpcy5wZW5kaW5nTGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgaWYgKHRoaXMucGVuZGluZykge1xuICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgfVxuXG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG4vLyBTY2FuIGEgc2VxdWVuY2Ugb2YgZW1waGFzaXMtbGlrZSBtYXJrZXJzLCBhbmQgZGV0ZXJtaW5lIHdoZXRoZXJcbi8vIGl0IGNhbiBzdGFydCBhbiBlbXBoYXNpcyBzZXF1ZW5jZSBvciBlbmQgYW4gZW1waGFzaXMgc2VxdWVuY2UuXG4vL1xuLy8gIC0gc3RhcnQgLSBwb3NpdGlvbiB0byBzY2FuIGZyb20gKGl0IHNob3VsZCBwb2ludCBhdCBhIHZhbGlkIG1hcmtlcik7XG4vLyAgLSBjYW5TcGxpdFdvcmQgLSBkZXRlcm1pbmUgaWYgdGhlc2UgbWFya2VycyBjYW4gYmUgZm91bmQgaW5zaWRlIGEgd29yZFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKHN0YXJ0LCBjYW5TcGxpdFdvcmQpIHtcbiAgdmFyIHBvcyA9IHN0YXJ0LCBsYXN0Q2hhciwgbmV4dENoYXIsIGNvdW50LCBjYW5fb3BlbiwgY2FuX2Nsb3NlLFxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLFxuICAgICAgaXNOZXh0V2hpdGVTcGFjZSwgaXNOZXh0UHVuY3RDaGFyLFxuICAgICAgbGVmdF9mbGFua2luZyA9IHRydWUsXG4gICAgICByaWdodF9mbGFua2luZyA9IHRydWUsXG4gICAgICBtYXggPSB0aGlzLnBvc01heCxcbiAgICAgIG1hcmtlciA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIC8vIHRyZWF0IGJlZ2lubmluZyBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAweDIwO1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHsgcG9zKys7IH1cblxuICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuXG4gIC8vIHRyZWF0IGVuZCBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgbmV4dENoYXIgPSBwb3MgPCBtYXggPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAweDIwO1xuXG4gIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgbGVmdF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjYW5TcGxpdFdvcmQpIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nICAmJiAoIXJpZ2h0X2ZsYW5raW5nIHx8IGlzTGFzdFB1bmN0Q2hhcik7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmcgJiYgKCFsZWZ0X2ZsYW5raW5nICB8fCBpc05leHRQdW5jdENoYXIpO1xuICB9IGVsc2Uge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmc7XG4gICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNhbl9vcGVuOiAgY2FuX29wZW4sXG4gICAgY2FuX2Nsb3NlOiBjYW5fY2xvc2UsXG4gICAgbGVuZ3RoOiAgICBjb3VudFxuICB9O1xufTtcblxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlSW5saW5lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5qcyIsIi8vIFNraXAgdGV4dCBjaGFyYWN0ZXJzIGZvciB0ZXh0IHRva2VuLCBwbGFjZSB0aG9zZSB0byBwZW5kaW5nIGJ1ZmZlclxuLy8gYW5kIGluY3JlbWVudCBjdXJyZW50IHBvc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gUnVsZSB0byBza2lwIHB1cmUgdGV4dFxuLy8gJ3t9JCVAfis9OicgcmVzZXJ2ZWQgZm9yIGV4dGVudGlvbnNcblxuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG5cbi8vICEhISEgRG9uJ3QgY29uZnVzZSB3aXRoIFwiTWFya2Rvd24gQVNDSUkgUHVuY3R1YXRpb25cIiBjaGFyc1xuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JDaGFyKGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MEEvKiBcXG4gKi86XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA9PT0gc3RhdGUucG9zKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXRlLnBvcywgcG9zKTsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLCBmb3IgbWVtb3J5LlxuLy9cbi8vIEl0IGNvc3RzIDEwJSBvZiBwZXJmb3JtYW5jZSwgYnV0IGFsbG93cyBleHRlbmQgdGVybWluYXRvcnMgbGlzdCwgaWYgcGxhY2UgaXRcbi8vIHRvIGBQYXJjZXJJbmxpbmVgIHByb3BlcnR5LiBQcm9iYWJseSwgd2lsbCBzd2l0Y2ggdG8gaXQgc29tZXRpbWUsIHN1Y2hcbi8vIGZsZXhpYmlsaXR5IHJlcXVpcmVkLlxuXG4vKlxudmFyIFRFUk1JTkFUT1JfUkUgPSAvW1xcbiEjJCUmKitcXC06PD0+QFtcXFxcXFxdXl9ge31+XS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBpZHggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5zZWFyY2goVEVSTUlOQVRPUl9SRSk7XG5cbiAgLy8gZmlyc3QgY2hhciBpcyB0ZXJtaW5hdG9yIC0+IGVtcHR5IHRleHRcbiAgaWYgKGlkeCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBubyB0ZXJtaW5hdG9yIC0+IHRleHQgdGlsbCBlbmQgb2Ygc3RyaW5nXG4gIGlmIChpZHggPCAwKSB7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTsgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnNyYy5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIGlkeCk7IH1cblxuICBzdGF0ZS5wb3MgKz0gaWR4O1xuXG4gIHJldHVybiB0cnVlO1xufTsqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCIvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lLCBhbmQgcmUtY2FsY3VsYXRlIGFsbCB0b2tlbiBsZXZlbHNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gIHZhciBjdXJyLCBsYXN0LFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgdG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBmb3IgKGN1cnIgPSBsYXN0ID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgLy8gcmUtY2FsY3VsYXRlIGxldmVsc1xuICAgIGxldmVsICs9IHRva2Vuc1tjdXJyXS5uZXN0aW5nO1xuICAgIHRva2Vuc1tjdXJyXS5sZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxudmFyIGRlY29kZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBjYWNoZS5wdXNoKGNoKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2ggPSBleGNsdWRlLmNoYXJDb2RlQXQoaSk7XG4gICAgY2FjaGVbY2hdID0gJyUnICsgKCcwJyArIGNoLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRGVjb2RlIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcuXG4vL1xuZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgZXhjbHVkZSkge1xuICB2YXIgY2FjaGU7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgY2FjaGUgPSBnZXREZWNvZGVDYWNoZShleGNsdWRlKTtcblxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyglW2EtZjAtOV17Mn0pKy9naSwgZnVuY3Rpb24oc2VxKSB7XG4gICAgdmFyIGksIGwsIGIxLCBiMiwgYjMsIGI0LCBjaHIsXG4gICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHNlcS5sZW5ndGg7IGkgPCBsOyBpICs9IDMpIHtcbiAgICAgIGIxID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxLCBpICsgMyksIDE2KTtcblxuICAgICAgaWYgKGIxIDwgMHg4MCkge1xuICAgICAgICByZXN1bHQgKz0gY2FjaGVbYjFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RTApID09PSAweEMwICYmIChpICsgMyA8IGwpKSB7XG4gICAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDYpICYgMHg3QzApIHwgKGIyICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEYwKSA9PT0gMHhFMCAmJiAoaSArIDYgPCBsKSkge1xuICAgICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDEyKSAmIDB4RjAwMCkgfCAoKGIyIDw8IDYpICYgMHhGQzApIHwgKGIzICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MDAgfHwgKGNociA+PSAweEQ4MDAgJiYgY2hyIDw9IDB4REZGRikpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjgpID09PSAweEYwICYmIChpICsgOSA8IGwpKSB7XG4gICAgICAgIC8vIDExMTExMHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuICAgICAgICBiNCA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMTAsIGkgKyAxMiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODAgJiYgKGI0ICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDE4KSAmIDB4MUMwMDAwKSB8ICgoYjIgPDwgMTIpICYgMHgzRjAwMCkgfCAoKGIzIDw8IDYpICYgMHhGQzApIHwgKGI0ICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHgxMDAwMCB8fCBjaHIgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyIC09IDB4MTAwMDA7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoY2hyID4+IDEwKSwgMHhEQzAwICsgKGNociAmIDB4M0ZGKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA5O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cblxuZGVjb2RlLmRlZmF1bHRDaGFycyAgID0gJzsvPzpAJj0rJCwjJztcbmRlY29kZS5jb21wb25lbnRDaGFycyA9ICcnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tZHVybC9kZWNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWR1cmwvZW5jb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXQodXJsKSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyAnLy8nIDogJyc7XG4gIHJlc3VsdCArPSB1cmwuYXV0aCA/IHVybC5hdXRoICsgJ0AnIDogJyc7XG5cbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIC8vIGlwdjYgYWRkcmVzc1xuICAgIHJlc3VsdCArPSAnWycgKyB1cmwuaG9zdG5hbWUgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZSB8fCAnJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwucG9ydCA/ICc6JyArIHVybC5wb3J0IDogJyc7XG4gIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLmhhc2ggfHwgJyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21kdXJsL2Zvcm1hdC5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBDaGFuZ2VzIGZyb20gam95ZW50L25vZGU6XG4vL1xuLy8gMS4gTm8gbGVhZGluZyBzbGFzaCBpbiBwYXRocyxcbi8vICAgIGUuZy4gaW4gYHVybC5wYXJzZSgnaHR0cDovL2Zvbz9iYXInKWAgcGF0aG5hbWUgaXMgYGAsIG5vdCBgL2Bcbi8vXG4vLyAyLiBCYWNrc2xhc2hlcyBhcmUgbm90IHJlcGxhY2VkIHdpdGggc2xhc2hlcyxcbi8vICAgIHNvIGBodHRwOlxcXFxleGFtcGxlLm9yZ1xcYCBpcyB0cmVhdGVkIGxpa2UgYSByZWxhdGl2ZSBwYXRoXG4vL1xuLy8gMy4gVHJhaWxpbmcgY29sb24gaXMgdHJlYXRlZCBsaWtlIGEgcGFydCBvZiB0aGUgcGF0aCxcbi8vICAgIGkuZS4gaW4gYGh0dHA6Ly9leGFtcGxlLm9yZzpmb29gIHBhdGhuYW1lIGlzIGA6Zm9vYFxuLy9cbi8vIDQuIE5vdGhpbmcgaXMgVVJMLWVuY29kZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsXG4vLyAgICAoaW4gam95ZW50L25vZGUgc29tZSBjaGFycyBpbiBhdXRoIGFuZCBwYXRocyBhcmUgZW5jb2RlZClcbi8vXG4vLyA1LiBgdXJsLnBhcnNlKClgIGRvZXMgbm90IGhhdmUgYHBhcnNlUXVlcnlTdHJpbmdgIGFyZ3VtZW50XG4vL1xuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcbi8vICAgIHdoaWNoIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyBvdGhlciBwYXJ0cyBvZiB0aGUgdXJsLlxuLy9cblxuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyAnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCcgXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnIF0uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsgJ1xcJycgXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsgJyUnLCAnLycsICc/JywgJzsnLCAnIycgXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWyAnLycsICc/JywgJyMnIF0sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7IHJldHVybiB1cmw7IH1cblxuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLTsgfVxuICAgIHZhciBob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoaG9zdCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbihob3N0KSB7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybFBhcnNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tZHVybC9wYXJzZS5qcyIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTA4RTJcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFxcdURDQkR8XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5BbnkgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jyk7XG5leHBvcnRzLkNjICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DYy9yZWdleCcpO1xuZXhwb3J0cy5DZiAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2YvcmVnZXgnKTtcbmV4cG9ydHMuUCAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1AvcmVnZXgnKTtcbmV4cG9ydHMuWiAgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL1ovcmVnZXgnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vaW5kZXguanMiLCJpbXBvcnQgTWFya2Rvd25JdCBmcm9tICdtYXJrZG93bi1pdCc7XG5pbXBvcnQgTWFya2Rvd25JdERlY29yYXRlIGZyb20gJ21hcmtkb3duLWl0LWRlY29yYXRlJztcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQnO1xuaW1wb3J0IGxKYXZhc2NyaXB0IGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQnO1xuaW1wb3J0IGxDc3MgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzJztcbmltcG9ydCBsWG1sIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbCc7XG5pbXBvcnQgbEJhc2ggZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaCc7XG5cbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdiYXNoJywgbEJhc2gpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2NzcycsIGxDc3MpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2phdmFzY3JpcHQnLCBsSmF2YXNjcmlwdCk7XG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgneG1sJywgbFhtbCk7XG5cbndpbmRvdy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbmNvbnN0IG1hcmtlZCA9IE1hcmtkb3duSXQoe1xuICAgIGh0bWw6IHRydWUsXG4gICAgYnJlYWtzOiBmYWxzZSBcbn0pLnVzZShNYXJrZG93bkl0RGVjb3JhdGUpO1xuLy8g5Y675o6J5q616JC9c29mdGJyZWFrXG5tYXJrZWQucmVuZGVyZXIucnVsZXMuc29mdGJyZWFrID0gKCkgPT4gJyc7XG5cbmV4cG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS9saWIvdXRpbHMuanMiLCJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9sYXlvdXQudmR0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBJbnRhY3Qge1xuICAgIEBJbnRhY3QudGVtcGxhdGUoKVxuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gICAgX21vdW50KCkge1xuICAgICAgICB0aGlzLiRib3JkZXIgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmJvcmRlcicpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3JkZXIoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQm9yZGVyKCkge1xuICAgICAgICBjb25zdCAkbmF2ID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJy5hY3RpdmUnKTtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBpZiAoJG5hdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSAkbmF2LnBvc2l0aW9uKCkubGVmdDtcbiAgICAgICAgICAgIHdpZHRoID0gJG5hdi5vdXRlcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYm9yZGVyLmFkZENsYXNzKCd0cmFuc2l0aW9uJyk7XG4gICAgICAgIHRoaXMuJGJvcmRlci5jc3Moe3dpZHRoOiB3aWR0aCwgbGVmdDogbGVmdH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvcGFnZXMvbGF5b3V0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJBYWN1dGVcIjpcIsOBXCIsXCJhYWN1dGVcIjpcIsOhXCIsXCJBYnJldmVcIjpcIsSCXCIsXCJhYnJldmVcIjpcIsSDXCIsXCJhY1wiOlwi4oi+XCIsXCJhY2RcIjpcIuKIv1wiLFwiYWNFXCI6XCLiiL7Ms1wiLFwiQWNpcmNcIjpcIsOCXCIsXCJhY2lyY1wiOlwiw6JcIixcImFjdXRlXCI6XCLCtFwiLFwiQWN5XCI6XCLQkFwiLFwiYWN5XCI6XCLQsFwiLFwiQUVsaWdcIjpcIsOGXCIsXCJhZWxpZ1wiOlwiw6ZcIixcImFmXCI6XCLigaFcIixcIkFmclwiOlwi8J2UhFwiLFwiYWZyXCI6XCLwnZSeXCIsXCJBZ3JhdmVcIjpcIsOAXCIsXCJhZ3JhdmVcIjpcIsOgXCIsXCJhbGVmc3ltXCI6XCLihLVcIixcImFsZXBoXCI6XCLihLVcIixcIkFscGhhXCI6XCLOkVwiLFwiYWxwaGFcIjpcIs6xXCIsXCJBbWFjclwiOlwixIBcIixcImFtYWNyXCI6XCLEgVwiLFwiYW1hbGdcIjpcIuKov1wiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcImFuZGFuZFwiOlwi4qmVXCIsXCJBbmRcIjpcIuKpk1wiLFwiYW5kXCI6XCLiiKdcIixcImFuZGRcIjpcIuKpnFwiLFwiYW5kc2xvcGVcIjpcIuKpmFwiLFwiYW5kdlwiOlwi4qmaXCIsXCJhbmdcIjpcIuKIoFwiLFwiYW5nZVwiOlwi4qakXCIsXCJhbmdsZVwiOlwi4oigXCIsXCJhbmdtc2RhYVwiOlwi4qaoXCIsXCJhbmdtc2RhYlwiOlwi4qapXCIsXCJhbmdtc2RhY1wiOlwi4qaqXCIsXCJhbmdtc2RhZFwiOlwi4qarXCIsXCJhbmdtc2RhZVwiOlwi4qasXCIsXCJhbmdtc2RhZlwiOlwi4qatXCIsXCJhbmdtc2RhZ1wiOlwi4qauXCIsXCJhbmdtc2RhaFwiOlwi4qavXCIsXCJhbmdtc2RcIjpcIuKIoVwiLFwiYW5ncnRcIjpcIuKIn1wiLFwiYW5ncnR2YlwiOlwi4oq+XCIsXCJhbmdydHZiZFwiOlwi4qadXCIsXCJhbmdzcGhcIjpcIuKIolwiLFwiYW5nc3RcIjpcIsOFXCIsXCJhbmd6YXJyXCI6XCLijbxcIixcIkFvZ29uXCI6XCLEhFwiLFwiYW9nb25cIjpcIsSFXCIsXCJBb3BmXCI6XCLwnZS4XCIsXCJhb3BmXCI6XCLwnZWSXCIsXCJhcGFjaXJcIjpcIuKpr1wiLFwiYXBcIjpcIuKJiFwiLFwiYXBFXCI6XCLiqbBcIixcImFwZVwiOlwi4omKXCIsXCJhcGlkXCI6XCLiiYtcIixcImFwb3NcIjpcIidcIixcIkFwcGx5RnVuY3Rpb25cIjpcIuKBoVwiLFwiYXBwcm94XCI6XCLiiYhcIixcImFwcHJveGVxXCI6XCLiiYpcIixcIkFyaW5nXCI6XCLDhVwiLFwiYXJpbmdcIjpcIsOlXCIsXCJBc2NyXCI6XCLwnZKcXCIsXCJhc2NyXCI6XCLwnZK2XCIsXCJBc3NpZ25cIjpcIuKJlFwiLFwiYXN0XCI6XCIqXCIsXCJhc3ltcFwiOlwi4omIXCIsXCJhc3ltcGVxXCI6XCLiiY1cIixcIkF0aWxkZVwiOlwiw4NcIixcImF0aWxkZVwiOlwiw6NcIixcIkF1bWxcIjpcIsOEXCIsXCJhdW1sXCI6XCLDpFwiLFwiYXdjb25pbnRcIjpcIuKIs1wiLFwiYXdpbnRcIjpcIuKokVwiLFwiYmFja2NvbmdcIjpcIuKJjFwiLFwiYmFja2Vwc2lsb25cIjpcIs+2XCIsXCJiYWNrcHJpbWVcIjpcIuKAtVwiLFwiYmFja3NpbVwiOlwi4oi9XCIsXCJiYWNrc2ltZXFcIjpcIuKLjVwiLFwiQmFja3NsYXNoXCI6XCLiiJZcIixcIkJhcnZcIjpcIuKrp1wiLFwiYmFydmVlXCI6XCLiir1cIixcImJhcndlZFwiOlwi4oyFXCIsXCJCYXJ3ZWRcIjpcIuKMhlwiLFwiYmFyd2VkZ2VcIjpcIuKMhVwiLFwiYmJya1wiOlwi4o61XCIsXCJiYnJrdGJya1wiOlwi4o62XCIsXCJiY29uZ1wiOlwi4omMXCIsXCJCY3lcIjpcItCRXCIsXCJiY3lcIjpcItCxXCIsXCJiZHF1b1wiOlwi4oCeXCIsXCJiZWNhdXNcIjpcIuKItVwiLFwiYmVjYXVzZVwiOlwi4oi1XCIsXCJCZWNhdXNlXCI6XCLiiLVcIixcImJlbXB0eXZcIjpcIuKmsFwiLFwiYmVwc2lcIjpcIs+2XCIsXCJiZXJub3VcIjpcIuKErFwiLFwiQmVybm91bGxpc1wiOlwi4oSsXCIsXCJCZXRhXCI6XCLOklwiLFwiYmV0YVwiOlwizrJcIixcImJldGhcIjpcIuKEtlwiLFwiYmV0d2VlblwiOlwi4omsXCIsXCJCZnJcIjpcIvCdlIVcIixcImJmclwiOlwi8J2Un1wiLFwiYmlnY2FwXCI6XCLii4JcIixcImJpZ2NpcmNcIjpcIuKXr1wiLFwiYmlnY3VwXCI6XCLii4NcIixcImJpZ29kb3RcIjpcIuKogFwiLFwiYmlnb3BsdXNcIjpcIuKogVwiLFwiYmlnb3RpbWVzXCI6XCLiqIJcIixcImJpZ3NxY3VwXCI6XCLiqIZcIixcImJpZ3N0YXJcIjpcIuKYhVwiLFwiYmlndHJpYW5nbGVkb3duXCI6XCLilr1cIixcImJpZ3RyaWFuZ2xldXBcIjpcIuKWs1wiLFwiYmlndXBsdXNcIjpcIuKohFwiLFwiYmlndmVlXCI6XCLii4FcIixcImJpZ3dlZGdlXCI6XCLii4BcIixcImJrYXJvd1wiOlwi4qSNXCIsXCJibGFja2xvemVuZ2VcIjpcIuKnq1wiLFwiYmxhY2tzcXVhcmVcIjpcIuKWqlwiLFwiYmxhY2t0cmlhbmdsZVwiOlwi4pa0XCIsXCJibGFja3RyaWFuZ2xlZG93blwiOlwi4pa+XCIsXCJibGFja3RyaWFuZ2xlbGVmdFwiOlwi4peCXCIsXCJibGFja3RyaWFuZ2xlcmlnaHRcIjpcIuKWuFwiLFwiYmxhbmtcIjpcIuKQo1wiLFwiYmxrMTJcIjpcIuKWklwiLFwiYmxrMTRcIjpcIuKWkVwiLFwiYmxrMzRcIjpcIuKWk1wiLFwiYmxvY2tcIjpcIuKWiFwiLFwiYm5lXCI6XCI94oOlXCIsXCJibmVxdWl2XCI6XCLiiaHig6VcIixcImJOb3RcIjpcIuKrrVwiLFwiYm5vdFwiOlwi4oyQXCIsXCJCb3BmXCI6XCLwnZS5XCIsXCJib3BmXCI6XCLwnZWTXCIsXCJib3RcIjpcIuKKpVwiLFwiYm90dG9tXCI6XCLiiqVcIixcImJvd3RpZVwiOlwi4ouIXCIsXCJib3hib3hcIjpcIuKniVwiLFwiYm94ZGxcIjpcIuKUkFwiLFwiYm94ZExcIjpcIuKVlVwiLFwiYm94RGxcIjpcIuKVllwiLFwiYm94RExcIjpcIuKVl1wiLFwiYm94ZHJcIjpcIuKUjFwiLFwiYm94ZFJcIjpcIuKVklwiLFwiYm94RHJcIjpcIuKVk1wiLFwiYm94RFJcIjpcIuKVlFwiLFwiYm94aFwiOlwi4pSAXCIsXCJib3hIXCI6XCLilZBcIixcImJveGhkXCI6XCLilKxcIixcImJveEhkXCI6XCLilaRcIixcImJveGhEXCI6XCLilaVcIixcImJveEhEXCI6XCLilaZcIixcImJveGh1XCI6XCLilLRcIixcImJveEh1XCI6XCLiladcIixcImJveGhVXCI6XCLilahcIixcImJveEhVXCI6XCLilalcIixcImJveG1pbnVzXCI6XCLiip9cIixcImJveHBsdXNcIjpcIuKKnlwiLFwiYm94dGltZXNcIjpcIuKKoFwiLFwiYm94dWxcIjpcIuKUmFwiLFwiYm94dUxcIjpcIuKVm1wiLFwiYm94VWxcIjpcIuKVnFwiLFwiYm94VUxcIjpcIuKVnVwiLFwiYm94dXJcIjpcIuKUlFwiLFwiYm94dVJcIjpcIuKVmFwiLFwiYm94VXJcIjpcIuKVmVwiLFwiYm94VVJcIjpcIuKVmlwiLFwiYm94dlwiOlwi4pSCXCIsXCJib3hWXCI6XCLilZFcIixcImJveHZoXCI6XCLilLxcIixcImJveHZIXCI6XCLilapcIixcImJveFZoXCI6XCLilatcIixcImJveFZIXCI6XCLilaxcIixcImJveHZsXCI6XCLilKRcIixcImJveHZMXCI6XCLilaFcIixcImJveFZsXCI6XCLilaJcIixcImJveFZMXCI6XCLilaNcIixcImJveHZyXCI6XCLilJxcIixcImJveHZSXCI6XCLilZ5cIixcImJveFZyXCI6XCLilZ9cIixcImJveFZSXCI6XCLilaBcIixcImJwcmltZVwiOlwi4oC1XCIsXCJicmV2ZVwiOlwiy5hcIixcIkJyZXZlXCI6XCLLmFwiLFwiYnJ2YmFyXCI6XCLCplwiLFwiYnNjclwiOlwi8J2St1wiLFwiQnNjclwiOlwi4oSsXCIsXCJic2VtaVwiOlwi4oGPXCIsXCJic2ltXCI6XCLiiL1cIixcImJzaW1lXCI6XCLii41cIixcImJzb2xiXCI6XCLip4VcIixcImJzb2xcIjpcIlxcXFxcIixcImJzb2xoc3ViXCI6XCLin4hcIixcImJ1bGxcIjpcIuKAolwiLFwiYnVsbGV0XCI6XCLigKJcIixcImJ1bXBcIjpcIuKJjlwiLFwiYnVtcEVcIjpcIuKqrlwiLFwiYnVtcGVcIjpcIuKJj1wiLFwiQnVtcGVxXCI6XCLiiY5cIixcImJ1bXBlcVwiOlwi4omPXCIsXCJDYWN1dGVcIjpcIsSGXCIsXCJjYWN1dGVcIjpcIsSHXCIsXCJjYXBhbmRcIjpcIuKphFwiLFwiY2FwYnJjdXBcIjpcIuKpiVwiLFwiY2FwY2FwXCI6XCLiqYtcIixcImNhcFwiOlwi4oipXCIsXCJDYXBcIjpcIuKLklwiLFwiY2FwY3VwXCI6XCLiqYdcIixcImNhcGRvdFwiOlwi4qmAXCIsXCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOlwi4oWFXCIsXCJjYXBzXCI6XCLiiKnvuIBcIixcImNhcmV0XCI6XCLigYFcIixcImNhcm9uXCI6XCLLh1wiLFwiQ2F5bGV5c1wiOlwi4oStXCIsXCJjY2Fwc1wiOlwi4qmNXCIsXCJDY2Fyb25cIjpcIsSMXCIsXCJjY2Fyb25cIjpcIsSNXCIsXCJDY2VkaWxcIjpcIsOHXCIsXCJjY2VkaWxcIjpcIsOnXCIsXCJDY2lyY1wiOlwixIhcIixcImNjaXJjXCI6XCLEiVwiLFwiQ2NvbmludFwiOlwi4oiwXCIsXCJjY3Vwc1wiOlwi4qmMXCIsXCJjY3Vwc3NtXCI6XCLiqZBcIixcIkNkb3RcIjpcIsSKXCIsXCJjZG90XCI6XCLEi1wiLFwiY2VkaWxcIjpcIsK4XCIsXCJDZWRpbGxhXCI6XCLCuFwiLFwiY2VtcHR5dlwiOlwi4qayXCIsXCJjZW50XCI6XCLColwiLFwiY2VudGVyZG90XCI6XCLCt1wiLFwiQ2VudGVyRG90XCI6XCLCt1wiLFwiY2ZyXCI6XCLwnZSgXCIsXCJDZnJcIjpcIuKErVwiLFwiQ0hjeVwiOlwi0KdcIixcImNoY3lcIjpcItGHXCIsXCJjaGVja1wiOlwi4pyTXCIsXCJjaGVja21hcmtcIjpcIuKck1wiLFwiQ2hpXCI6XCLOp1wiLFwiY2hpXCI6XCLPh1wiLFwiY2lyY1wiOlwiy4ZcIixcImNpcmNlcVwiOlwi4omXXCIsXCJjaXJjbGVhcnJvd2xlZnRcIjpcIuKGulwiLFwiY2lyY2xlYXJyb3dyaWdodFwiOlwi4oa7XCIsXCJjaXJjbGVkYXN0XCI6XCLiiptcIixcImNpcmNsZWRjaXJjXCI6XCLiippcIixcImNpcmNsZWRkYXNoXCI6XCLiip1cIixcIkNpcmNsZURvdFwiOlwi4oqZXCIsXCJjaXJjbGVkUlwiOlwiwq5cIixcImNpcmNsZWRTXCI6XCLik4hcIixcIkNpcmNsZU1pbnVzXCI6XCLiipZcIixcIkNpcmNsZVBsdXNcIjpcIuKKlVwiLFwiQ2lyY2xlVGltZXNcIjpcIuKKl1wiLFwiY2lyXCI6XCLil4tcIixcImNpckVcIjpcIuKng1wiLFwiY2lyZVwiOlwi4omXXCIsXCJjaXJmbmludFwiOlwi4qiQXCIsXCJjaXJtaWRcIjpcIuKrr1wiLFwiY2lyc2NpclwiOlwi4qeCXCIsXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIslwiLFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCLigJ1cIixcIkNsb3NlQ3VybHlRdW90ZVwiOlwi4oCZXCIsXCJjbHVic1wiOlwi4pmjXCIsXCJjbHVic3VpdFwiOlwi4pmjXCIsXCJjb2xvblwiOlwiOlwiLFwiQ29sb25cIjpcIuKIt1wiLFwiQ29sb25lXCI6XCLiqbRcIixcImNvbG9uZVwiOlwi4omUXCIsXCJjb2xvbmVxXCI6XCLiiZRcIixcImNvbW1hXCI6XCIsXCIsXCJjb21tYXRcIjpcIkBcIixcImNvbXBcIjpcIuKIgVwiLFwiY29tcGZuXCI6XCLiiJhcIixcImNvbXBsZW1lbnRcIjpcIuKIgVwiLFwiY29tcGxleGVzXCI6XCLihIJcIixcImNvbmdcIjpcIuKJhVwiLFwiY29uZ2RvdFwiOlwi4qmtXCIsXCJDb25ncnVlbnRcIjpcIuKJoVwiLFwiY29uaW50XCI6XCLiiK5cIixcIkNvbmludFwiOlwi4oivXCIsXCJDb250b3VySW50ZWdyYWxcIjpcIuKIrlwiLFwiY29wZlwiOlwi8J2VlFwiLFwiQ29wZlwiOlwi4oSCXCIsXCJjb3Byb2RcIjpcIuKIkFwiLFwiQ29wcm9kdWN0XCI6XCLiiJBcIixcImNvcHlcIjpcIsKpXCIsXCJDT1BZXCI6XCLCqVwiLFwiY29weXNyXCI6XCLihJdcIixcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIs1wiLFwiY3JhcnJcIjpcIuKGtVwiLFwiY3Jvc3NcIjpcIuKcl1wiLFwiQ3Jvc3NcIjpcIuKor1wiLFwiQ3NjclwiOlwi8J2SnlwiLFwiY3NjclwiOlwi8J2SuFwiLFwiY3N1YlwiOlwi4quPXCIsXCJjc3ViZVwiOlwi4quRXCIsXCJjc3VwXCI6XCLiq5BcIixcImNzdXBlXCI6XCLiq5JcIixcImN0ZG90XCI6XCLii69cIixcImN1ZGFycmxcIjpcIuKkuFwiLFwiY3VkYXJyclwiOlwi4qS1XCIsXCJjdWVwclwiOlwi4oueXCIsXCJjdWVzY1wiOlwi4oufXCIsXCJjdWxhcnJcIjpcIuKGtlwiLFwiY3VsYXJycFwiOlwi4qS9XCIsXCJjdXBicmNhcFwiOlwi4qmIXCIsXCJjdXBjYXBcIjpcIuKphlwiLFwiQ3VwQ2FwXCI6XCLiiY1cIixcImN1cFwiOlwi4oiqXCIsXCJDdXBcIjpcIuKLk1wiLFwiY3VwY3VwXCI6XCLiqYpcIixcImN1cGRvdFwiOlwi4oqNXCIsXCJjdXBvclwiOlwi4qmFXCIsXCJjdXBzXCI6XCLiiKrvuIBcIixcImN1cmFyclwiOlwi4oa3XCIsXCJjdXJhcnJtXCI6XCLipLxcIixcImN1cmx5ZXFwcmVjXCI6XCLii55cIixcImN1cmx5ZXFzdWNjXCI6XCLii59cIixcImN1cmx5dmVlXCI6XCLii45cIixcImN1cmx5d2VkZ2VcIjpcIuKLj1wiLFwiY3VycmVuXCI6XCLCpFwiLFwiY3VydmVhcnJvd2xlZnRcIjpcIuKGtlwiLFwiY3VydmVhcnJvd3JpZ2h0XCI6XCLihrdcIixcImN1dmVlXCI6XCLii45cIixcImN1d2VkXCI6XCLii49cIixcImN3Y29uaW50XCI6XCLiiLJcIixcImN3aW50XCI6XCLiiLFcIixcImN5bGN0eVwiOlwi4oytXCIsXCJkYWdnZXJcIjpcIuKAoFwiLFwiRGFnZ2VyXCI6XCLigKFcIixcImRhbGV0aFwiOlwi4oS4XCIsXCJkYXJyXCI6XCLihpNcIixcIkRhcnJcIjpcIuKGoVwiLFwiZEFyclwiOlwi4oeTXCIsXCJkYXNoXCI6XCLigJBcIixcIkRhc2h2XCI6XCLiq6RcIixcImRhc2h2XCI6XCLiiqNcIixcImRia2Fyb3dcIjpcIuKkj1wiLFwiZGJsYWNcIjpcIsudXCIsXCJEY2Fyb25cIjpcIsSOXCIsXCJkY2Fyb25cIjpcIsSPXCIsXCJEY3lcIjpcItCUXCIsXCJkY3lcIjpcItC0XCIsXCJkZGFnZ2VyXCI6XCLigKFcIixcImRkYXJyXCI6XCLih4pcIixcIkREXCI6XCLihYVcIixcImRkXCI6XCLihYZcIixcIkREb3RyYWhkXCI6XCLipJFcIixcImRkb3RzZXFcIjpcIuKpt1wiLFwiZGVnXCI6XCLCsFwiLFwiRGVsXCI6XCLiiIdcIixcIkRlbHRhXCI6XCLOlFwiLFwiZGVsdGFcIjpcIs60XCIsXCJkZW1wdHl2XCI6XCLiprFcIixcImRmaXNodFwiOlwi4qW/XCIsXCJEZnJcIjpcIvCdlIdcIixcImRmclwiOlwi8J2UoVwiLFwiZEhhclwiOlwi4qWlXCIsXCJkaGFybFwiOlwi4oeDXCIsXCJkaGFyclwiOlwi4oeCXCIsXCJEaWFjcml0aWNhbEFjdXRlXCI6XCLCtFwiLFwiRGlhY3JpdGljYWxEb3RcIjpcIsuZXCIsXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6XCLLnVwiLFwiRGlhY3JpdGljYWxHcmF2ZVwiOlwiYFwiLFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiy5xcIixcImRpYW1cIjpcIuKLhFwiLFwiZGlhbW9uZFwiOlwi4ouEXCIsXCJEaWFtb25kXCI6XCLii4RcIixcImRpYW1vbmRzdWl0XCI6XCLimaZcIixcImRpYW1zXCI6XCLimaZcIixcImRpZVwiOlwiwqhcIixcIkRpZmZlcmVudGlhbERcIjpcIuKFhlwiLFwiZGlnYW1tYVwiOlwiz51cIixcImRpc2luXCI6XCLii7JcIixcImRpdlwiOlwiw7dcIixcImRpdmlkZVwiOlwiw7dcIixcImRpdmlkZW9udGltZXNcIjpcIuKLh1wiLFwiZGl2b254XCI6XCLii4dcIixcIkRKY3lcIjpcItCCXCIsXCJkamN5XCI6XCLRklwiLFwiZGxjb3JuXCI6XCLijJ5cIixcImRsY3JvcFwiOlwi4oyNXCIsXCJkb2xsYXJcIjpcIiRcIixcIkRvcGZcIjpcIvCdlLtcIixcImRvcGZcIjpcIvCdlZVcIixcIkRvdFwiOlwiwqhcIixcImRvdFwiOlwiy5lcIixcIkRvdERvdFwiOlwi4oOcXCIsXCJkb3RlcVwiOlwi4omQXCIsXCJkb3RlcWRvdFwiOlwi4omRXCIsXCJEb3RFcXVhbFwiOlwi4omQXCIsXCJkb3RtaW51c1wiOlwi4oi4XCIsXCJkb3RwbHVzXCI6XCLiiJRcIixcImRvdHNxdWFyZVwiOlwi4oqhXCIsXCJkb3VibGViYXJ3ZWRnZVwiOlwi4oyGXCIsXCJEb3VibGVDb250b3VySW50ZWdyYWxcIjpcIuKIr1wiLFwiRG91YmxlRG90XCI6XCLCqFwiLFwiRG91YmxlRG93bkFycm93XCI6XCLih5NcIixcIkRvdWJsZUxlZnRBcnJvd1wiOlwi4oeQXCIsXCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOlwi4oeUXCIsXCJEb3VibGVMZWZ0VGVlXCI6XCLiq6RcIixcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjpcIuKfuFwiLFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7pcIixcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCLin7lcIixcIkRvdWJsZVJpZ2h0QXJyb3dcIjpcIuKHklwiLFwiRG91YmxlUmlnaHRUZWVcIjpcIuKKqFwiLFwiRG91YmxlVXBBcnJvd1wiOlwi4oeRXCIsXCJEb3VibGVVcERvd25BcnJvd1wiOlwi4oeVXCIsXCJEb3VibGVWZXJ0aWNhbEJhclwiOlwi4oilXCIsXCJEb3duQXJyb3dCYXJcIjpcIuKkk1wiLFwiZG93bmFycm93XCI6XCLihpNcIixcIkRvd25BcnJvd1wiOlwi4oaTXCIsXCJEb3duYXJyb3dcIjpcIuKHk1wiLFwiRG93bkFycm93VXBBcnJvd1wiOlwi4oe1XCIsXCJEb3duQnJldmVcIjpcIsyRXCIsXCJkb3duZG93bmFycm93c1wiOlwi4oeKXCIsXCJkb3duaGFycG9vbmxlZnRcIjpcIuKHg1wiLFwiZG93bmhhcnBvb25yaWdodFwiOlwi4oeCXCIsXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCLipZBcIixcIkRvd25MZWZ0VGVlVmVjdG9yXCI6XCLipZ5cIixcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCLipZZcIixcIkRvd25MZWZ0VmVjdG9yXCI6XCLihr1cIixcIkRvd25SaWdodFRlZVZlY3RvclwiOlwi4qWfXCIsXCJEb3duUmlnaHRWZWN0b3JCYXJcIjpcIuKll1wiLFwiRG93blJpZ2h0VmVjdG9yXCI6XCLih4FcIixcIkRvd25UZWVBcnJvd1wiOlwi4oanXCIsXCJEb3duVGVlXCI6XCLiiqRcIixcImRyYmthcm93XCI6XCLipJBcIixcImRyY29yblwiOlwi4oyfXCIsXCJkcmNyb3BcIjpcIuKMjFwiLFwiRHNjclwiOlwi8J2Sn1wiLFwiZHNjclwiOlwi8J2SuVwiLFwiRFNjeVwiOlwi0IVcIixcImRzY3lcIjpcItGVXCIsXCJkc29sXCI6XCLip7ZcIixcIkRzdHJva1wiOlwixJBcIixcImRzdHJva1wiOlwixJFcIixcImR0ZG90XCI6XCLii7FcIixcImR0cmlcIjpcIuKWv1wiLFwiZHRyaWZcIjpcIuKWvlwiLFwiZHVhcnJcIjpcIuKHtVwiLFwiZHVoYXJcIjpcIuKlr1wiLFwiZHdhbmdsZVwiOlwi4qamXCIsXCJEWmN5XCI6XCLQj1wiLFwiZHpjeVwiOlwi0Z9cIixcImR6aWdyYXJyXCI6XCLin79cIixcIkVhY3V0ZVwiOlwiw4lcIixcImVhY3V0ZVwiOlwiw6lcIixcImVhc3RlclwiOlwi4qmuXCIsXCJFY2Fyb25cIjpcIsSaXCIsXCJlY2Fyb25cIjpcIsSbXCIsXCJFY2lyY1wiOlwiw4pcIixcImVjaXJjXCI6XCLDqlwiLFwiZWNpclwiOlwi4omWXCIsXCJlY29sb25cIjpcIuKJlVwiLFwiRWN5XCI6XCLQrVwiLFwiZWN5XCI6XCLRjVwiLFwiZUREb3RcIjpcIuKpt1wiLFwiRWRvdFwiOlwixJZcIixcImVkb3RcIjpcIsSXXCIsXCJlRG90XCI6XCLiiZFcIixcImVlXCI6XCLihYdcIixcImVmRG90XCI6XCLiiZJcIixcIkVmclwiOlwi8J2UiFwiLFwiZWZyXCI6XCLwnZSiXCIsXCJlZ1wiOlwi4qqaXCIsXCJFZ3JhdmVcIjpcIsOIXCIsXCJlZ3JhdmVcIjpcIsOoXCIsXCJlZ3NcIjpcIuKqllwiLFwiZWdzZG90XCI6XCLiqphcIixcImVsXCI6XCLiqplcIixcIkVsZW1lbnRcIjpcIuKIiFwiLFwiZWxpbnRlcnNcIjpcIuKPp1wiLFwiZWxsXCI6XCLihJNcIixcImVsc1wiOlwi4qqVXCIsXCJlbHNkb3RcIjpcIuKql1wiLFwiRW1hY3JcIjpcIsSSXCIsXCJlbWFjclwiOlwixJNcIixcImVtcHR5XCI6XCLiiIVcIixcImVtcHR5c2V0XCI6XCLiiIVcIixcIkVtcHR5U21hbGxTcXVhcmVcIjpcIuKXu1wiLFwiZW1wdHl2XCI6XCLiiIVcIixcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6XCLilqtcIixcImVtc3AxM1wiOlwi4oCEXCIsXCJlbXNwMTRcIjpcIuKAhVwiLFwiZW1zcFwiOlwi4oCDXCIsXCJFTkdcIjpcIsWKXCIsXCJlbmdcIjpcIsWLXCIsXCJlbnNwXCI6XCLigIJcIixcIkVvZ29uXCI6XCLEmFwiLFwiZW9nb25cIjpcIsSZXCIsXCJFb3BmXCI6XCLwnZS8XCIsXCJlb3BmXCI6XCLwnZWWXCIsXCJlcGFyXCI6XCLii5VcIixcImVwYXJzbFwiOlwi4qejXCIsXCJlcGx1c1wiOlwi4qmxXCIsXCJlcHNpXCI6XCLOtVwiLFwiRXBzaWxvblwiOlwizpVcIixcImVwc2lsb25cIjpcIs61XCIsXCJlcHNpdlwiOlwiz7VcIixcImVxY2lyY1wiOlwi4omWXCIsXCJlcWNvbG9uXCI6XCLiiZVcIixcImVxc2ltXCI6XCLiiYJcIixcImVxc2xhbnRndHJcIjpcIuKqllwiLFwiZXFzbGFudGxlc3NcIjpcIuKqlVwiLFwiRXF1YWxcIjpcIuKptVwiLFwiZXF1YWxzXCI6XCI9XCIsXCJFcXVhbFRpbGRlXCI6XCLiiYJcIixcImVxdWVzdFwiOlwi4omfXCIsXCJFcXVpbGlicml1bVwiOlwi4oeMXCIsXCJlcXVpdlwiOlwi4omhXCIsXCJlcXVpdkREXCI6XCLiqbhcIixcImVxdnBhcnNsXCI6XCLip6VcIixcImVyYXJyXCI6XCLipbFcIixcImVyRG90XCI6XCLiiZNcIixcImVzY3JcIjpcIuKEr1wiLFwiRXNjclwiOlwi4oSwXCIsXCJlc2RvdFwiOlwi4omQXCIsXCJFc2ltXCI6XCLiqbNcIixcImVzaW1cIjpcIuKJglwiLFwiRXRhXCI6XCLOl1wiLFwiZXRhXCI6XCLOt1wiLFwiRVRIXCI6XCLDkFwiLFwiZXRoXCI6XCLDsFwiLFwiRXVtbFwiOlwiw4tcIixcImV1bWxcIjpcIsOrXCIsXCJldXJvXCI6XCLigqxcIixcImV4Y2xcIjpcIiFcIixcImV4aXN0XCI6XCLiiINcIixcIkV4aXN0c1wiOlwi4oiDXCIsXCJleHBlY3RhdGlvblwiOlwi4oSwXCIsXCJleHBvbmVudGlhbGVcIjpcIuKFh1wiLFwiRXhwb25lbnRpYWxFXCI6XCLihYdcIixcImZhbGxpbmdkb3RzZXFcIjpcIuKJklwiLFwiRmN5XCI6XCLQpFwiLFwiZmN5XCI6XCLRhFwiLFwiZmVtYWxlXCI6XCLimYBcIixcImZmaWxpZ1wiOlwi76yDXCIsXCJmZmxpZ1wiOlwi76yAXCIsXCJmZmxsaWdcIjpcIu+shFwiLFwiRmZyXCI6XCLwnZSJXCIsXCJmZnJcIjpcIvCdlKNcIixcImZpbGlnXCI6XCLvrIFcIixcIkZpbGxlZFNtYWxsU3F1YXJlXCI6XCLil7xcIixcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOlwi4paqXCIsXCJmamxpZ1wiOlwiZmpcIixcImZsYXRcIjpcIuKZrVwiLFwiZmxsaWdcIjpcIu+sglwiLFwiZmx0bnNcIjpcIuKWsVwiLFwiZm5vZlwiOlwixpJcIixcIkZvcGZcIjpcIvCdlL1cIixcImZvcGZcIjpcIvCdlZdcIixcImZvcmFsbFwiOlwi4oiAXCIsXCJGb3JBbGxcIjpcIuKIgFwiLFwiZm9ya1wiOlwi4ouUXCIsXCJmb3JrdlwiOlwi4quZXCIsXCJGb3VyaWVydHJmXCI6XCLihLFcIixcImZwYXJ0aW50XCI6XCLiqI1cIixcImZyYWMxMlwiOlwiwr1cIixcImZyYWMxM1wiOlwi4oWTXCIsXCJmcmFjMTRcIjpcIsK8XCIsXCJmcmFjMTVcIjpcIuKFlVwiLFwiZnJhYzE2XCI6XCLihZlcIixcImZyYWMxOFwiOlwi4oWbXCIsXCJmcmFjMjNcIjpcIuKFlFwiLFwiZnJhYzI1XCI6XCLihZZcIixcImZyYWMzNFwiOlwiwr5cIixcImZyYWMzNVwiOlwi4oWXXCIsXCJmcmFjMzhcIjpcIuKFnFwiLFwiZnJhYzQ1XCI6XCLihZhcIixcImZyYWM1NlwiOlwi4oWaXCIsXCJmcmFjNThcIjpcIuKFnVwiLFwiZnJhYzc4XCI6XCLihZ5cIixcImZyYXNsXCI6XCLigYRcIixcImZyb3duXCI6XCLijKJcIixcImZzY3JcIjpcIvCdkrtcIixcIkZzY3JcIjpcIuKEsVwiLFwiZ2FjdXRlXCI6XCLHtVwiLFwiR2FtbWFcIjpcIs6TXCIsXCJnYW1tYVwiOlwizrNcIixcIkdhbW1hZFwiOlwiz5xcIixcImdhbW1hZFwiOlwiz51cIixcImdhcFwiOlwi4qqGXCIsXCJHYnJldmVcIjpcIsSeXCIsXCJnYnJldmVcIjpcIsSfXCIsXCJHY2VkaWxcIjpcIsSiXCIsXCJHY2lyY1wiOlwixJxcIixcImdjaXJjXCI6XCLEnVwiLFwiR2N5XCI6XCLQk1wiLFwiZ2N5XCI6XCLQs1wiLFwiR2RvdFwiOlwixKBcIixcImdkb3RcIjpcIsShXCIsXCJnZVwiOlwi4omlXCIsXCJnRVwiOlwi4omnXCIsXCJnRWxcIjpcIuKqjFwiLFwiZ2VsXCI6XCLii5tcIixcImdlcVwiOlwi4omlXCIsXCJnZXFxXCI6XCLiiadcIixcImdlcXNsYW50XCI6XCLiqb5cIixcImdlc2NjXCI6XCLiqqlcIixcImdlc1wiOlwi4qm+XCIsXCJnZXNkb3RcIjpcIuKqgFwiLFwiZ2VzZG90b1wiOlwi4qqCXCIsXCJnZXNkb3RvbFwiOlwi4qqEXCIsXCJnZXNsXCI6XCLii5vvuIBcIixcImdlc2xlc1wiOlwi4qqUXCIsXCJHZnJcIjpcIvCdlIpcIixcImdmclwiOlwi8J2UpFwiLFwiZ2dcIjpcIuKJq1wiLFwiR2dcIjpcIuKLmVwiLFwiZ2dnXCI6XCLii5lcIixcImdpbWVsXCI6XCLihLdcIixcIkdKY3lcIjpcItCDXCIsXCJnamN5XCI6XCLRk1wiLFwiZ2xhXCI6XCLiqqVcIixcImdsXCI6XCLiibdcIixcImdsRVwiOlwi4qqSXCIsXCJnbGpcIjpcIuKqpFwiLFwiZ25hcFwiOlwi4qqKXCIsXCJnbmFwcHJveFwiOlwi4qqKXCIsXCJnbmVcIjpcIuKqiFwiLFwiZ25FXCI6XCLiialcIixcImduZXFcIjpcIuKqiFwiLFwiZ25lcXFcIjpcIuKJqVwiLFwiZ25zaW1cIjpcIuKLp1wiLFwiR29wZlwiOlwi8J2UvlwiLFwiZ29wZlwiOlwi8J2VmFwiLFwiZ3JhdmVcIjpcImBcIixcIkdyZWF0ZXJFcXVhbFwiOlwi4omlXCIsXCJHcmVhdGVyRXF1YWxMZXNzXCI6XCLii5tcIixcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp1wiLFwiR3JlYXRlckdyZWF0ZXJcIjpcIuKqolwiLFwiR3JlYXRlckxlc3NcIjpcIuKJt1wiLFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvlwiLFwiR3JlYXRlclRpbGRlXCI6XCLiibNcIixcIkdzY3JcIjpcIvCdkqJcIixcImdzY3JcIjpcIuKEilwiLFwiZ3NpbVwiOlwi4omzXCIsXCJnc2ltZVwiOlwi4qqOXCIsXCJnc2ltbFwiOlwi4qqQXCIsXCJndGNjXCI6XCLiqqdcIixcImd0Y2lyXCI6XCLiqbpcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiR3RcIjpcIuKJq1wiLFwiZ3Rkb3RcIjpcIuKLl1wiLFwiZ3RsUGFyXCI6XCLippVcIixcImd0cXVlc3RcIjpcIuKpvFwiLFwiZ3RyYXBwcm94XCI6XCLiqoZcIixcImd0cmFyclwiOlwi4qW4XCIsXCJndHJkb3RcIjpcIuKLl1wiLFwiZ3RyZXFsZXNzXCI6XCLii5tcIixcImd0cmVxcWxlc3NcIjpcIuKqjFwiLFwiZ3RybGVzc1wiOlwi4om3XCIsXCJndHJzaW1cIjpcIuKJs1wiLFwiZ3ZlcnRuZXFxXCI6XCLiianvuIBcIixcImd2bkVcIjpcIuKJqe+4gFwiLFwiSGFjZWtcIjpcIsuHXCIsXCJoYWlyc3BcIjpcIuKAilwiLFwiaGFsZlwiOlwiwr1cIixcImhhbWlsdFwiOlwi4oSLXCIsXCJIQVJEY3lcIjpcItCqXCIsXCJoYXJkY3lcIjpcItGKXCIsXCJoYXJyY2lyXCI6XCLipYhcIixcImhhcnJcIjpcIuKGlFwiLFwiaEFyclwiOlwi4oeUXCIsXCJoYXJyd1wiOlwi4oatXCIsXCJIYXRcIjpcIl5cIixcImhiYXJcIjpcIuKEj1wiLFwiSGNpcmNcIjpcIsSkXCIsXCJoY2lyY1wiOlwixKVcIixcImhlYXJ0c1wiOlwi4pmlXCIsXCJoZWFydHN1aXRcIjpcIuKZpVwiLFwiaGVsbGlwXCI6XCLigKZcIixcImhlcmNvblwiOlwi4oq5XCIsXCJoZnJcIjpcIvCdlKVcIixcIkhmclwiOlwi4oSMXCIsXCJIaWxiZXJ0U3BhY2VcIjpcIuKEi1wiLFwiaGtzZWFyb3dcIjpcIuKkpVwiLFwiaGtzd2Fyb3dcIjpcIuKkplwiLFwiaG9hcnJcIjpcIuKHv1wiLFwiaG9tdGh0XCI6XCLiiLtcIixcImhvb2tsZWZ0YXJyb3dcIjpcIuKGqVwiLFwiaG9va3JpZ2h0YXJyb3dcIjpcIuKGqlwiLFwiaG9wZlwiOlwi8J2VmVwiLFwiSG9wZlwiOlwi4oSNXCIsXCJob3JiYXJcIjpcIuKAlVwiLFwiSG9yaXpvbnRhbExpbmVcIjpcIuKUgFwiLFwiaHNjclwiOlwi8J2SvVwiLFwiSHNjclwiOlwi4oSLXCIsXCJoc2xhc2hcIjpcIuKEj1wiLFwiSHN0cm9rXCI6XCLEplwiLFwiaHN0cm9rXCI6XCLEp1wiLFwiSHVtcERvd25IdW1wXCI6XCLiiY5cIixcIkh1bXBFcXVhbFwiOlwi4omPXCIsXCJoeWJ1bGxcIjpcIuKBg1wiLFwiaHlwaGVuXCI6XCLigJBcIixcIklhY3V0ZVwiOlwiw41cIixcImlhY3V0ZVwiOlwiw61cIixcImljXCI6XCLigaNcIixcIkljaXJjXCI6XCLDjlwiLFwiaWNpcmNcIjpcIsOuXCIsXCJJY3lcIjpcItCYXCIsXCJpY3lcIjpcItC4XCIsXCJJZG90XCI6XCLEsFwiLFwiSUVjeVwiOlwi0JVcIixcImllY3lcIjpcItC1XCIsXCJpZXhjbFwiOlwiwqFcIixcImlmZlwiOlwi4oeUXCIsXCJpZnJcIjpcIvCdlKZcIixcIklmclwiOlwi4oSRXCIsXCJJZ3JhdmVcIjpcIsOMXCIsXCJpZ3JhdmVcIjpcIsOsXCIsXCJpaVwiOlwi4oWIXCIsXCJpaWlpbnRcIjpcIuKojFwiLFwiaWlpbnRcIjpcIuKIrVwiLFwiaWluZmluXCI6XCLip5xcIixcImlpb3RhXCI6XCLihKlcIixcIklKbGlnXCI6XCLEslwiLFwiaWpsaWdcIjpcIsSzXCIsXCJJbWFjclwiOlwixKpcIixcImltYWNyXCI6XCLEq1wiLFwiaW1hZ2VcIjpcIuKEkVwiLFwiSW1hZ2luYXJ5SVwiOlwi4oWIXCIsXCJpbWFnbGluZVwiOlwi4oSQXCIsXCJpbWFncGFydFwiOlwi4oSRXCIsXCJpbWF0aFwiOlwixLFcIixcIkltXCI6XCLihJFcIixcImltb2ZcIjpcIuKKt1wiLFwiaW1wZWRcIjpcIsa1XCIsXCJJbXBsaWVzXCI6XCLih5JcIixcImluY2FyZVwiOlwi4oSFXCIsXCJpblwiOlwi4oiIXCIsXCJpbmZpblwiOlwi4oieXCIsXCJpbmZpbnRpZVwiOlwi4qedXCIsXCJpbm9kb3RcIjpcIsSxXCIsXCJpbnRjYWxcIjpcIuKKulwiLFwiaW50XCI6XCLiiKtcIixcIkludFwiOlwi4oisXCIsXCJpbnRlZ2Vyc1wiOlwi4oSkXCIsXCJJbnRlZ3JhbFwiOlwi4oirXCIsXCJpbnRlcmNhbFwiOlwi4oq6XCIsXCJJbnRlcnNlY3Rpb25cIjpcIuKLglwiLFwiaW50bGFyaGtcIjpcIuKol1wiLFwiaW50cHJvZFwiOlwi4qi8XCIsXCJJbnZpc2libGVDb21tYVwiOlwi4oGjXCIsXCJJbnZpc2libGVUaW1lc1wiOlwi4oGiXCIsXCJJT2N5XCI6XCLQgVwiLFwiaW9jeVwiOlwi0ZFcIixcIklvZ29uXCI6XCLErlwiLFwiaW9nb25cIjpcIsSvXCIsXCJJb3BmXCI6XCLwnZWAXCIsXCJpb3BmXCI6XCLwnZWaXCIsXCJJb3RhXCI6XCLOmVwiLFwiaW90YVwiOlwizrlcIixcImlwcm9kXCI6XCLiqLxcIixcImlxdWVzdFwiOlwiwr9cIixcImlzY3JcIjpcIvCdkr5cIixcIklzY3JcIjpcIuKEkFwiLFwiaXNpblwiOlwi4oiIXCIsXCJpc2luZG90XCI6XCLii7VcIixcImlzaW5FXCI6XCLii7lcIixcImlzaW5zXCI6XCLii7RcIixcImlzaW5zdlwiOlwi4ouzXCIsXCJpc2ludlwiOlwi4oiIXCIsXCJpdFwiOlwi4oGiXCIsXCJJdGlsZGVcIjpcIsSoXCIsXCJpdGlsZGVcIjpcIsSpXCIsXCJJdWtjeVwiOlwi0IZcIixcIml1a2N5XCI6XCLRllwiLFwiSXVtbFwiOlwiw49cIixcIml1bWxcIjpcIsOvXCIsXCJKY2lyY1wiOlwixLRcIixcImpjaXJjXCI6XCLEtVwiLFwiSmN5XCI6XCLQmVwiLFwiamN5XCI6XCLQuVwiLFwiSmZyXCI6XCLwnZSNXCIsXCJqZnJcIjpcIvCdlKdcIixcImptYXRoXCI6XCLIt1wiLFwiSm9wZlwiOlwi8J2VgVwiLFwiam9wZlwiOlwi8J2Vm1wiLFwiSnNjclwiOlwi8J2SpVwiLFwianNjclwiOlwi8J2Sv1wiLFwiSnNlcmN5XCI6XCLQiFwiLFwianNlcmN5XCI6XCLRmFwiLFwiSnVrY3lcIjpcItCEXCIsXCJqdWtjeVwiOlwi0ZRcIixcIkthcHBhXCI6XCLOmlwiLFwia2FwcGFcIjpcIs66XCIsXCJrYXBwYXZcIjpcIs+wXCIsXCJLY2VkaWxcIjpcIsS2XCIsXCJrY2VkaWxcIjpcIsS3XCIsXCJLY3lcIjpcItCaXCIsXCJrY3lcIjpcItC6XCIsXCJLZnJcIjpcIvCdlI5cIixcImtmclwiOlwi8J2UqFwiLFwia2dyZWVuXCI6XCLEuFwiLFwiS0hjeVwiOlwi0KVcIixcImtoY3lcIjpcItGFXCIsXCJLSmN5XCI6XCLQjFwiLFwia2pjeVwiOlwi0ZxcIixcIktvcGZcIjpcIvCdlYJcIixcImtvcGZcIjpcIvCdlZxcIixcIktzY3JcIjpcIvCdkqZcIixcImtzY3JcIjpcIvCdk4BcIixcImxBYXJyXCI6XCLih5pcIixcIkxhY3V0ZVwiOlwixLlcIixcImxhY3V0ZVwiOlwixLpcIixcImxhZW1wdHl2XCI6XCLiprRcIixcImxhZ3JhblwiOlwi4oSSXCIsXCJMYW1iZGFcIjpcIs6bXCIsXCJsYW1iZGFcIjpcIs67XCIsXCJsYW5nXCI6XCLin6hcIixcIkxhbmdcIjpcIuKfqlwiLFwibGFuZ2RcIjpcIuKmkVwiLFwibGFuZ2xlXCI6XCLin6hcIixcImxhcFwiOlwi4qqFXCIsXCJMYXBsYWNldHJmXCI6XCLihJJcIixcImxhcXVvXCI6XCLCq1wiLFwibGFycmJcIjpcIuKHpFwiLFwibGFycmJmc1wiOlwi4qSfXCIsXCJsYXJyXCI6XCLihpBcIixcIkxhcnJcIjpcIuKGnlwiLFwibEFyclwiOlwi4oeQXCIsXCJsYXJyZnNcIjpcIuKknVwiLFwibGFycmhrXCI6XCLihqlcIixcImxhcnJscFwiOlwi4oarXCIsXCJsYXJycGxcIjpcIuKkuVwiLFwibGFycnNpbVwiOlwi4qWzXCIsXCJsYXJydGxcIjpcIuKGolwiLFwibGF0YWlsXCI6XCLipJlcIixcImxBdGFpbFwiOlwi4qSbXCIsXCJsYXRcIjpcIuKqq1wiLFwibGF0ZVwiOlwi4qqtXCIsXCJsYXRlc1wiOlwi4qqt77iAXCIsXCJsYmFyclwiOlwi4qSMXCIsXCJsQmFyclwiOlwi4qSOXCIsXCJsYmJya1wiOlwi4p2yXCIsXCJsYnJhY2VcIjpcIntcIixcImxicmFja1wiOlwiW1wiLFwibGJya2VcIjpcIuKmi1wiLFwibGJya3NsZFwiOlwi4qaPXCIsXCJsYnJrc2x1XCI6XCLipo1cIixcIkxjYXJvblwiOlwixL1cIixcImxjYXJvblwiOlwixL5cIixcIkxjZWRpbFwiOlwixLtcIixcImxjZWRpbFwiOlwixLxcIixcImxjZWlsXCI6XCLijIhcIixcImxjdWJcIjpcIntcIixcIkxjeVwiOlwi0JtcIixcImxjeVwiOlwi0LtcIixcImxkY2FcIjpcIuKktlwiLFwibGRxdW9cIjpcIuKAnFwiLFwibGRxdW9yXCI6XCLigJ5cIixcImxkcmRoYXJcIjpcIuKlp1wiLFwibGRydXNoYXJcIjpcIuKli1wiLFwibGRzaFwiOlwi4oayXCIsXCJsZVwiOlwi4omkXCIsXCJsRVwiOlwi4ommXCIsXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCLin6hcIixcIkxlZnRBcnJvd0JhclwiOlwi4oekXCIsXCJsZWZ0YXJyb3dcIjpcIuKGkFwiLFwiTGVmdEFycm93XCI6XCLihpBcIixcIkxlZnRhcnJvd1wiOlwi4oeQXCIsXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCLih4ZcIixcImxlZnRhcnJvd3RhaWxcIjpcIuKGolwiLFwiTGVmdENlaWxpbmdcIjpcIuKMiFwiLFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIuKfplwiLFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIuKloVwiLFwiTGVmdERvd25WZWN0b3JCYXJcIjpcIuKlmVwiLFwiTGVmdERvd25WZWN0b3JcIjpcIuKHg1wiLFwiTGVmdEZsb29yXCI6XCLijIpcIixcImxlZnRoYXJwb29uZG93blwiOlwi4oa9XCIsXCJsZWZ0aGFycG9vbnVwXCI6XCLihrxcIixcImxlZnRsZWZ0YXJyb3dzXCI6XCLih4dcIixcImxlZnRyaWdodGFycm93XCI6XCLihpRcIixcIkxlZnRSaWdodEFycm93XCI6XCLihpRcIixcIkxlZnRyaWdodGFycm93XCI6XCLih5RcIixcImxlZnRyaWdodGFycm93c1wiOlwi4oeGXCIsXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwi4oeLXCIsXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCLihq1cIixcIkxlZnRSaWdodFZlY3RvclwiOlwi4qWOXCIsXCJMZWZ0VGVlQXJyb3dcIjpcIuKGpFwiLFwiTGVmdFRlZVwiOlwi4oqjXCIsXCJMZWZ0VGVlVmVjdG9yXCI6XCLipZpcIixcImxlZnR0aHJlZXRpbWVzXCI6XCLii4tcIixcIkxlZnRUcmlhbmdsZUJhclwiOlwi4qePXCIsXCJMZWZ0VHJpYW5nbGVcIjpcIuKKslwiLFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKKtFwiLFwiTGVmdFVwRG93blZlY3RvclwiOlwi4qWRXCIsXCJMZWZ0VXBUZWVWZWN0b3JcIjpcIuKloFwiLFwiTGVmdFVwVmVjdG9yQmFyXCI6XCLipZhcIixcIkxlZnRVcFZlY3RvclwiOlwi4oa/XCIsXCJMZWZ0VmVjdG9yQmFyXCI6XCLipZJcIixcIkxlZnRWZWN0b3JcIjpcIuKGvFwiLFwibEVnXCI6XCLiqotcIixcImxlZ1wiOlwi4ouaXCIsXCJsZXFcIjpcIuKJpFwiLFwibGVxcVwiOlwi4ommXCIsXCJsZXFzbGFudFwiOlwi4qm9XCIsXCJsZXNjY1wiOlwi4qqoXCIsXCJsZXNcIjpcIuKpvVwiLFwibGVzZG90XCI6XCLiqb9cIixcImxlc2RvdG9cIjpcIuKqgVwiLFwibGVzZG90b3JcIjpcIuKqg1wiLFwibGVzZ1wiOlwi4oua77iAXCIsXCJsZXNnZXNcIjpcIuKqk1wiLFwibGVzc2FwcHJveFwiOlwi4qqFXCIsXCJsZXNzZG90XCI6XCLii5ZcIixcImxlc3NlcWd0clwiOlwi4ouaXCIsXCJsZXNzZXFxZ3RyXCI6XCLiqotcIixcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIuKLmlwiLFwiTGVzc0Z1bGxFcXVhbFwiOlwi4ommXCIsXCJMZXNzR3JlYXRlclwiOlwi4om2XCIsXCJsZXNzZ3RyXCI6XCLiibZcIixcIkxlc3NMZXNzXCI6XCLiqqFcIixcImxlc3NzaW1cIjpcIuKJslwiLFwiTGVzc1NsYW50RXF1YWxcIjpcIuKpvVwiLFwiTGVzc1RpbGRlXCI6XCLiibJcIixcImxmaXNodFwiOlwi4qW8XCIsXCJsZmxvb3JcIjpcIuKMilwiLFwiTGZyXCI6XCLwnZSPXCIsXCJsZnJcIjpcIvCdlKlcIixcImxnXCI6XCLiibZcIixcImxnRVwiOlwi4qqRXCIsXCJsSGFyXCI6XCLipaJcIixcImxoYXJkXCI6XCLihr1cIixcImxoYXJ1XCI6XCLihrxcIixcImxoYXJ1bFwiOlwi4qWqXCIsXCJsaGJsa1wiOlwi4paEXCIsXCJMSmN5XCI6XCLQiVwiLFwibGpjeVwiOlwi0ZlcIixcImxsYXJyXCI6XCLih4dcIixcImxsXCI6XCLiiapcIixcIkxsXCI6XCLii5hcIixcImxsY29ybmVyXCI6XCLijJ5cIixcIkxsZWZ0YXJyb3dcIjpcIuKHmlwiLFwibGxoYXJkXCI6XCLipatcIixcImxsdHJpXCI6XCLil7pcIixcIkxtaWRvdFwiOlwixL9cIixcImxtaWRvdFwiOlwixYBcIixcImxtb3VzdGFjaGVcIjpcIuKOsFwiLFwibG1vdXN0XCI6XCLijrBcIixcImxuYXBcIjpcIuKqiVwiLFwibG5hcHByb3hcIjpcIuKqiVwiLFwibG5lXCI6XCLiqodcIixcImxuRVwiOlwi4omoXCIsXCJsbmVxXCI6XCLiqodcIixcImxuZXFxXCI6XCLiiahcIixcImxuc2ltXCI6XCLii6ZcIixcImxvYW5nXCI6XCLin6xcIixcImxvYXJyXCI6XCLih71cIixcImxvYnJrXCI6XCLin6ZcIixcImxvbmdsZWZ0YXJyb3dcIjpcIuKftVwiLFwiTG9uZ0xlZnRBcnJvd1wiOlwi4p+1XCIsXCJMb25nbGVmdGFycm93XCI6XCLin7hcIixcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+3XCIsXCJMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKft1wiLFwiTG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7pcIixcImxvbmdtYXBzdG9cIjpcIuKfvFwiLFwibG9uZ3JpZ2h0YXJyb3dcIjpcIuKftlwiLFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIuKftlwiLFwiTG9uZ3JpZ2h0YXJyb3dcIjpcIuKfuVwiLFwibG9vcGFycm93bGVmdFwiOlwi4oarXCIsXCJsb29wYXJyb3dyaWdodFwiOlwi4oasXCIsXCJsb3BhclwiOlwi4qaFXCIsXCJMb3BmXCI6XCLwnZWDXCIsXCJsb3BmXCI6XCLwnZWdXCIsXCJsb3BsdXNcIjpcIuKorVwiLFwibG90aW1lc1wiOlwi4qi0XCIsXCJsb3dhc3RcIjpcIuKIl1wiLFwibG93YmFyXCI6XCJfXCIsXCJMb3dlckxlZnRBcnJvd1wiOlwi4oaZXCIsXCJMb3dlclJpZ2h0QXJyb3dcIjpcIuKGmFwiLFwibG96XCI6XCLil4pcIixcImxvemVuZ2VcIjpcIuKXilwiLFwibG96ZlwiOlwi4qerXCIsXCJscGFyXCI6XCIoXCIsXCJscGFybHRcIjpcIuKmk1wiLFwibHJhcnJcIjpcIuKHhlwiLFwibHJjb3JuZXJcIjpcIuKMn1wiLFwibHJoYXJcIjpcIuKHi1wiLFwibHJoYXJkXCI6XCLipa1cIixcImxybVwiOlwi4oCOXCIsXCJscnRyaVwiOlwi4oq/XCIsXCJsc2FxdW9cIjpcIuKAuVwiLFwibHNjclwiOlwi8J2TgVwiLFwiTHNjclwiOlwi4oSSXCIsXCJsc2hcIjpcIuKGsFwiLFwiTHNoXCI6XCLihrBcIixcImxzaW1cIjpcIuKJslwiLFwibHNpbWVcIjpcIuKqjVwiLFwibHNpbWdcIjpcIuKqj1wiLFwibHNxYlwiOlwiW1wiLFwibHNxdW9cIjpcIuKAmFwiLFwibHNxdW9yXCI6XCLigJpcIixcIkxzdHJva1wiOlwixYFcIixcImxzdHJva1wiOlwixYJcIixcImx0Y2NcIjpcIuKqplwiLFwibHRjaXJcIjpcIuKpuVwiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJMdFwiOlwi4omqXCIsXCJsdGRvdFwiOlwi4ouWXCIsXCJsdGhyZWVcIjpcIuKLi1wiLFwibHRpbWVzXCI6XCLii4lcIixcImx0bGFyclwiOlwi4qW2XCIsXCJsdHF1ZXN0XCI6XCLiqbtcIixcImx0cmlcIjpcIuKXg1wiLFwibHRyaWVcIjpcIuKKtFwiLFwibHRyaWZcIjpcIuKXglwiLFwibHRyUGFyXCI6XCLippZcIixcImx1cmRzaGFyXCI6XCLipYpcIixcImx1cnVoYXJcIjpcIuKlplwiLFwibHZlcnRuZXFxXCI6XCLiiajvuIBcIixcImx2bkVcIjpcIuKJqO+4gFwiLFwibWFjclwiOlwiwq9cIixcIm1hbGVcIjpcIuKZglwiLFwibWFsdFwiOlwi4pygXCIsXCJtYWx0ZXNlXCI6XCLinKBcIixcIk1hcFwiOlwi4qSFXCIsXCJtYXBcIjpcIuKGplwiLFwibWFwc3RvXCI6XCLihqZcIixcIm1hcHN0b2Rvd25cIjpcIuKGp1wiLFwibWFwc3RvbGVmdFwiOlwi4oakXCIsXCJtYXBzdG91cFwiOlwi4oalXCIsXCJtYXJrZXJcIjpcIuKWrlwiLFwibWNvbW1hXCI6XCLiqKlcIixcIk1jeVwiOlwi0JxcIixcIm1jeVwiOlwi0LxcIixcIm1kYXNoXCI6XCLigJRcIixcIm1ERG90XCI6XCLiiLpcIixcIm1lYXN1cmVkYW5nbGVcIjpcIuKIoVwiLFwiTWVkaXVtU3BhY2VcIjpcIuKBn1wiLFwiTWVsbGludHJmXCI6XCLihLNcIixcIk1mclwiOlwi8J2UkFwiLFwibWZyXCI6XCLwnZSqXCIsXCJtaG9cIjpcIuKEp1wiLFwibWljcm9cIjpcIsK1XCIsXCJtaWRhc3RcIjpcIipcIixcIm1pZGNpclwiOlwi4quwXCIsXCJtaWRcIjpcIuKIo1wiLFwibWlkZG90XCI6XCLCt1wiLFwibWludXNiXCI6XCLiip9cIixcIm1pbnVzXCI6XCLiiJJcIixcIm1pbnVzZFwiOlwi4oi4XCIsXCJtaW51c2R1XCI6XCLiqKpcIixcIk1pbnVzUGx1c1wiOlwi4oiTXCIsXCJtbGNwXCI6XCLiq5tcIixcIm1sZHJcIjpcIuKAplwiLFwibW5wbHVzXCI6XCLiiJNcIixcIm1vZGVsc1wiOlwi4oqnXCIsXCJNb3BmXCI6XCLwnZWEXCIsXCJtb3BmXCI6XCLwnZWeXCIsXCJtcFwiOlwi4oiTXCIsXCJtc2NyXCI6XCLwnZOCXCIsXCJNc2NyXCI6XCLihLNcIixcIm1zdHBvc1wiOlwi4oi+XCIsXCJNdVwiOlwizpxcIixcIm11XCI6XCLOvFwiLFwibXVsdGltYXBcIjpcIuKKuFwiLFwibXVtYXBcIjpcIuKKuFwiLFwibmFibGFcIjpcIuKIh1wiLFwiTmFjdXRlXCI6XCLFg1wiLFwibmFjdXRlXCI6XCLFhFwiLFwibmFuZ1wiOlwi4oig4oOSXCIsXCJuYXBcIjpcIuKJiVwiLFwibmFwRVwiOlwi4qmwzLhcIixcIm5hcGlkXCI6XCLiiYvMuFwiLFwibmFwb3NcIjpcIsWJXCIsXCJuYXBwcm94XCI6XCLiiYlcIixcIm5hdHVyYWxcIjpcIuKZrlwiLFwibmF0dXJhbHNcIjpcIuKElVwiLFwibmF0dXJcIjpcIuKZrlwiLFwibmJzcFwiOlwiwqBcIixcIm5idW1wXCI6XCLiiY7MuFwiLFwibmJ1bXBlXCI6XCLiiY/MuFwiLFwibmNhcFwiOlwi4qmDXCIsXCJOY2Fyb25cIjpcIsWHXCIsXCJuY2Fyb25cIjpcIsWIXCIsXCJOY2VkaWxcIjpcIsWFXCIsXCJuY2VkaWxcIjpcIsWGXCIsXCJuY29uZ1wiOlwi4omHXCIsXCJuY29uZ2RvdFwiOlwi4qmtzLhcIixcIm5jdXBcIjpcIuKpglwiLFwiTmN5XCI6XCLQnVwiLFwibmN5XCI6XCLQvVwiLFwibmRhc2hcIjpcIuKAk1wiLFwibmVhcmhrXCI6XCLipKRcIixcIm5lYXJyXCI6XCLihpdcIixcIm5lQXJyXCI6XCLih5dcIixcIm5lYXJyb3dcIjpcIuKGl1wiLFwibmVcIjpcIuKJoFwiLFwibmVkb3RcIjpcIuKJkMy4XCIsXCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjpcIuKAi1wiLFwibmVxdWl2XCI6XCLiiaJcIixcIm5lc2VhclwiOlwi4qSoXCIsXCJuZXNpbVwiOlwi4omCzLhcIixcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiiatcIixcIk5lc3RlZExlc3NMZXNzXCI6XCLiiapcIixcIk5ld0xpbmVcIjpcIlxcblwiLFwibmV4aXN0XCI6XCLiiIRcIixcIm5leGlzdHNcIjpcIuKIhFwiLFwiTmZyXCI6XCLwnZSRXCIsXCJuZnJcIjpcIvCdlKtcIixcIm5nRVwiOlwi4omnzLhcIixcIm5nZVwiOlwi4omxXCIsXCJuZ2VxXCI6XCLiibFcIixcIm5nZXFxXCI6XCLiiafMuFwiLFwibmdlcXNsYW50XCI6XCLiqb7MuFwiLFwibmdlc1wiOlwi4qm+zLhcIixcIm5HZ1wiOlwi4ouZzLhcIixcIm5nc2ltXCI6XCLiibVcIixcIm5HdFwiOlwi4omr4oOSXCIsXCJuZ3RcIjpcIuKJr1wiLFwibmd0clwiOlwi4omvXCIsXCJuR3R2XCI6XCLiiavMuFwiLFwibmhhcnJcIjpcIuKGrlwiLFwibmhBcnJcIjpcIuKHjlwiLFwibmhwYXJcIjpcIuKrslwiLFwibmlcIjpcIuKIi1wiLFwibmlzXCI6XCLii7xcIixcIm5pc2RcIjpcIuKLulwiLFwibml2XCI6XCLiiItcIixcIk5KY3lcIjpcItCKXCIsXCJuamN5XCI6XCLRmlwiLFwibmxhcnJcIjpcIuKGmlwiLFwibmxBcnJcIjpcIuKHjVwiLFwibmxkclwiOlwi4oClXCIsXCJubEVcIjpcIuKJpsy4XCIsXCJubGVcIjpcIuKJsFwiLFwibmxlZnRhcnJvd1wiOlwi4oaaXCIsXCJuTGVmdGFycm93XCI6XCLih41cIixcIm5sZWZ0cmlnaHRhcnJvd1wiOlwi4oauXCIsXCJuTGVmdHJpZ2h0YXJyb3dcIjpcIuKHjlwiLFwibmxlcVwiOlwi4omwXCIsXCJubGVxcVwiOlwi4ommzLhcIixcIm5sZXFzbGFudFwiOlwi4qm9zLhcIixcIm5sZXNcIjpcIuKpvcy4XCIsXCJubGVzc1wiOlwi4omuXCIsXCJuTGxcIjpcIuKLmMy4XCIsXCJubHNpbVwiOlwi4om0XCIsXCJuTHRcIjpcIuKJquKDklwiLFwibmx0XCI6XCLiia5cIixcIm5sdHJpXCI6XCLii6pcIixcIm5sdHJpZVwiOlwi4ousXCIsXCJuTHR2XCI6XCLiiarMuFwiLFwibm1pZFwiOlwi4oikXCIsXCJOb0JyZWFrXCI6XCLigaBcIixcIk5vbkJyZWFraW5nU3BhY2VcIjpcIsKgXCIsXCJub3BmXCI6XCLwnZWfXCIsXCJOb3BmXCI6XCLihJVcIixcIk5vdFwiOlwi4qusXCIsXCJub3RcIjpcIsKsXCIsXCJOb3RDb25ncnVlbnRcIjpcIuKJolwiLFwiTm90Q3VwQ2FwXCI6XCLiia1cIixcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKZcIixcIk5vdEVsZW1lbnRcIjpcIuKIiVwiLFwiTm90RXF1YWxcIjpcIuKJoFwiLFwiTm90RXF1YWxUaWxkZVwiOlwi4omCzLhcIixcIk5vdEV4aXN0c1wiOlwi4oiEXCIsXCJOb3RHcmVhdGVyXCI6XCLiia9cIixcIk5vdEdyZWF0ZXJFcXVhbFwiOlwi4omxXCIsXCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiafMuFwiLFwiTm90R3JlYXRlckdyZWF0ZXJcIjpcIuKJq8y4XCIsXCJOb3RHcmVhdGVyTGVzc1wiOlwi4om5XCIsXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+zLhcIixcIk5vdEdyZWF0ZXJUaWxkZVwiOlwi4om1XCIsXCJOb3RIdW1wRG93bkh1bXBcIjpcIuKJjsy4XCIsXCJOb3RIdW1wRXF1YWxcIjpcIuKJj8y4XCIsXCJub3RpblwiOlwi4oiJXCIsXCJub3RpbmRvdFwiOlwi4ou1zLhcIixcIm5vdGluRVwiOlwi4ou5zLhcIixcIm5vdGludmFcIjpcIuKIiVwiLFwibm90aW52YlwiOlwi4ou3XCIsXCJub3RpbnZjXCI6XCLii7ZcIixcIk5vdExlZnRUcmlhbmdsZUJhclwiOlwi4qePzLhcIixcIk5vdExlZnRUcmlhbmdsZVwiOlwi4ouqXCIsXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4ousXCIsXCJOb3RMZXNzXCI6XCLiia5cIixcIk5vdExlc3NFcXVhbFwiOlwi4omwXCIsXCJOb3RMZXNzR3JlYXRlclwiOlwi4om4XCIsXCJOb3RMZXNzTGVzc1wiOlwi4omqzLhcIixcIk5vdExlc3NTbGFudEVxdWFsXCI6XCLiqb3MuFwiLFwiTm90TGVzc1RpbGRlXCI6XCLiibRcIixcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiqqLMuFwiLFwiTm90TmVzdGVkTGVzc0xlc3NcIjpcIuKqocy4XCIsXCJub3RuaVwiOlwi4oiMXCIsXCJub3RuaXZhXCI6XCLiiIxcIixcIm5vdG5pdmJcIjpcIuKLvlwiLFwibm90bml2Y1wiOlwi4ou9XCIsXCJOb3RQcmVjZWRlc1wiOlwi4oqAXCIsXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCLiqq/MuFwiLFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6XCLii6BcIixcIk5vdFJldmVyc2VFbGVtZW50XCI6XCLiiIxcIixcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkMy4XCIsXCJOb3RSaWdodFRyaWFuZ2xlXCI6XCLii6tcIixcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4outXCIsXCJOb3RTcXVhcmVTdWJzZXRcIjpcIuKKj8y4XCIsXCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4ouiXCIsXCJOb3RTcXVhcmVTdXBlcnNldFwiOlwi4oqQzLhcIixcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKLo1wiLFwiTm90U3Vic2V0XCI6XCLiioLig5JcIixcIk5vdFN1YnNldEVxdWFsXCI6XCLiiohcIixcIk5vdFN1Y2NlZWRzXCI6XCLiioFcIixcIk5vdFN1Y2NlZWRzRXF1YWxcIjpcIuKqsMy4XCIsXCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKLoVwiLFwiTm90U3VjY2VlZHNUaWxkZVwiOlwi4om/zLhcIixcIk5vdFN1cGVyc2V0XCI6XCLiioPig5JcIixcIk5vdFN1cGVyc2V0RXF1YWxcIjpcIuKKiVwiLFwiTm90VGlsZGVcIjpcIuKJgVwiLFwiTm90VGlsZGVFcXVhbFwiOlwi4omEXCIsXCJOb3RUaWxkZUZ1bGxFcXVhbFwiOlwi4omHXCIsXCJOb3RUaWxkZVRpbGRlXCI6XCLiiYlcIixcIk5vdFZlcnRpY2FsQmFyXCI6XCLiiKRcIixcIm5wYXJhbGxlbFwiOlwi4oimXCIsXCJucGFyXCI6XCLiiKZcIixcIm5wYXJzbFwiOlwi4qu94oOlXCIsXCJucGFydFwiOlwi4oiCzLhcIixcIm5wb2xpbnRcIjpcIuKolFwiLFwibnByXCI6XCLiioBcIixcIm5wcmN1ZVwiOlwi4ougXCIsXCJucHJlY1wiOlwi4oqAXCIsXCJucHJlY2VxXCI6XCLiqq/MuFwiLFwibnByZVwiOlwi4qqvzLhcIixcIm5yYXJyY1wiOlwi4qSzzLhcIixcIm5yYXJyXCI6XCLihptcIixcIm5yQXJyXCI6XCLih49cIixcIm5yYXJyd1wiOlwi4oadzLhcIixcIm5yaWdodGFycm93XCI6XCLihptcIixcIm5SaWdodGFycm93XCI6XCLih49cIixcIm5ydHJpXCI6XCLii6tcIixcIm5ydHJpZVwiOlwi4outXCIsXCJuc2NcIjpcIuKKgVwiLFwibnNjY3VlXCI6XCLii6FcIixcIm5zY2VcIjpcIuKqsMy4XCIsXCJOc2NyXCI6XCLwnZKpXCIsXCJuc2NyXCI6XCLwnZODXCIsXCJuc2hvcnRtaWRcIjpcIuKIpFwiLFwibnNob3J0cGFyYWxsZWxcIjpcIuKIplwiLFwibnNpbVwiOlwi4omBXCIsXCJuc2ltZVwiOlwi4omEXCIsXCJuc2ltZXFcIjpcIuKJhFwiLFwibnNtaWRcIjpcIuKIpFwiLFwibnNwYXJcIjpcIuKIplwiLFwibnNxc3ViZVwiOlwi4ouiXCIsXCJuc3FzdXBlXCI6XCLii6NcIixcIm5zdWJcIjpcIuKKhFwiLFwibnN1YkVcIjpcIuKrhcy4XCIsXCJuc3ViZVwiOlwi4oqIXCIsXCJuc3Vic2V0XCI6XCLiioLig5JcIixcIm5zdWJzZXRlcVwiOlwi4oqIXCIsXCJuc3Vic2V0ZXFxXCI6XCLiq4XMuFwiLFwibnN1Y2NcIjpcIuKKgVwiLFwibnN1Y2NlcVwiOlwi4qqwzLhcIixcIm5zdXBcIjpcIuKKhVwiLFwibnN1cEVcIjpcIuKrhsy4XCIsXCJuc3VwZVwiOlwi4oqJXCIsXCJuc3Vwc2V0XCI6XCLiioPig5JcIixcIm5zdXBzZXRlcVwiOlwi4oqJXCIsXCJuc3Vwc2V0ZXFxXCI6XCLiq4bMuFwiLFwibnRnbFwiOlwi4om5XCIsXCJOdGlsZGVcIjpcIsORXCIsXCJudGlsZGVcIjpcIsOxXCIsXCJudGxnXCI6XCLiibhcIixcIm50cmlhbmdsZWxlZnRcIjpcIuKLqlwiLFwibnRyaWFuZ2xlbGVmdGVxXCI6XCLii6xcIixcIm50cmlhbmdsZXJpZ2h0XCI6XCLii6tcIixcIm50cmlhbmdsZXJpZ2h0ZXFcIjpcIuKLrVwiLFwiTnVcIjpcIs6dXCIsXCJudVwiOlwizr1cIixcIm51bVwiOlwiI1wiLFwibnVtZXJvXCI6XCLihJZcIixcIm51bXNwXCI6XCLigIdcIixcIm52YXBcIjpcIuKJjeKDklwiLFwibnZkYXNoXCI6XCLiiqxcIixcIm52RGFzaFwiOlwi4oqtXCIsXCJuVmRhc2hcIjpcIuKKrlwiLFwiblZEYXNoXCI6XCLiiq9cIixcIm52Z2VcIjpcIuKJpeKDklwiLFwibnZndFwiOlwiPuKDklwiLFwibnZIYXJyXCI6XCLipIRcIixcIm52aW5maW5cIjpcIuKnnlwiLFwibnZsQXJyXCI6XCLipIJcIixcIm52bGVcIjpcIuKJpOKDklwiLFwibnZsdFwiOlwiPOKDklwiLFwibnZsdHJpZVwiOlwi4oq04oOSXCIsXCJudnJBcnJcIjpcIuKkg1wiLFwibnZydHJpZVwiOlwi4oq14oOSXCIsXCJudnNpbVwiOlwi4oi84oOSXCIsXCJud2FyaGtcIjpcIuKko1wiLFwibndhcnJcIjpcIuKGllwiLFwibndBcnJcIjpcIuKHllwiLFwibndhcnJvd1wiOlwi4oaWXCIsXCJud25lYXJcIjpcIuKkp1wiLFwiT2FjdXRlXCI6XCLDk1wiLFwib2FjdXRlXCI6XCLDs1wiLFwib2FzdFwiOlwi4oqbXCIsXCJPY2lyY1wiOlwiw5RcIixcIm9jaXJjXCI6XCLDtFwiLFwib2NpclwiOlwi4oqaXCIsXCJPY3lcIjpcItCeXCIsXCJvY3lcIjpcItC+XCIsXCJvZGFzaFwiOlwi4oqdXCIsXCJPZGJsYWNcIjpcIsWQXCIsXCJvZGJsYWNcIjpcIsWRXCIsXCJvZGl2XCI6XCLiqLhcIixcIm9kb3RcIjpcIuKKmVwiLFwib2Rzb2xkXCI6XCLiprxcIixcIk9FbGlnXCI6XCLFklwiLFwib2VsaWdcIjpcIsWTXCIsXCJvZmNpclwiOlwi4qa/XCIsXCJPZnJcIjpcIvCdlJJcIixcIm9mclwiOlwi8J2UrFwiLFwib2dvblwiOlwiy5tcIixcIk9ncmF2ZVwiOlwiw5JcIixcIm9ncmF2ZVwiOlwiw7JcIixcIm9ndFwiOlwi4qeBXCIsXCJvaGJhclwiOlwi4qa1XCIsXCJvaG1cIjpcIs6pXCIsXCJvaW50XCI6XCLiiK5cIixcIm9sYXJyXCI6XCLihrpcIixcIm9sY2lyXCI6XCLipr5cIixcIm9sY3Jvc3NcIjpcIuKmu1wiLFwib2xpbmVcIjpcIuKAvlwiLFwib2x0XCI6XCLip4BcIixcIk9tYWNyXCI6XCLFjFwiLFwib21hY3JcIjpcIsWNXCIsXCJPbWVnYVwiOlwizqlcIixcIm9tZWdhXCI6XCLPiVwiLFwiT21pY3JvblwiOlwizp9cIixcIm9taWNyb25cIjpcIs6/XCIsXCJvbWlkXCI6XCLiprZcIixcIm9taW51c1wiOlwi4oqWXCIsXCJPb3BmXCI6XCLwnZWGXCIsXCJvb3BmXCI6XCLwnZWgXCIsXCJvcGFyXCI6XCLiprdcIixcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6XCLigJxcIixcIk9wZW5DdXJseVF1b3RlXCI6XCLigJhcIixcIm9wZXJwXCI6XCLiprlcIixcIm9wbHVzXCI6XCLiipVcIixcIm9yYXJyXCI6XCLihrtcIixcIk9yXCI6XCLiqZRcIixcIm9yXCI6XCLiiKhcIixcIm9yZFwiOlwi4qmdXCIsXCJvcmRlclwiOlwi4oS0XCIsXCJvcmRlcm9mXCI6XCLihLRcIixcIm9yZGZcIjpcIsKqXCIsXCJvcmRtXCI6XCLCulwiLFwib3JpZ29mXCI6XCLiirZcIixcIm9yb3JcIjpcIuKpllwiLFwib3JzbG9wZVwiOlwi4qmXXCIsXCJvcnZcIjpcIuKpm1wiLFwib1NcIjpcIuKTiFwiLFwiT3NjclwiOlwi8J2SqlwiLFwib3NjclwiOlwi4oS0XCIsXCJPc2xhc2hcIjpcIsOYXCIsXCJvc2xhc2hcIjpcIsO4XCIsXCJvc29sXCI6XCLiiphcIixcIk90aWxkZVwiOlwiw5VcIixcIm90aWxkZVwiOlwiw7VcIixcIm90aW1lc2FzXCI6XCLiqLZcIixcIk90aW1lc1wiOlwi4qi3XCIsXCJvdGltZXNcIjpcIuKKl1wiLFwiT3VtbFwiOlwiw5ZcIixcIm91bWxcIjpcIsO2XCIsXCJvdmJhclwiOlwi4oy9XCIsXCJPdmVyQmFyXCI6XCLigL5cIixcIk92ZXJCcmFjZVwiOlwi4o+eXCIsXCJPdmVyQnJhY2tldFwiOlwi4o60XCIsXCJPdmVyUGFyZW50aGVzaXNcIjpcIuKPnFwiLFwicGFyYVwiOlwiwrZcIixcInBhcmFsbGVsXCI6XCLiiKVcIixcInBhclwiOlwi4oilXCIsXCJwYXJzaW1cIjpcIuKrs1wiLFwicGFyc2xcIjpcIuKrvVwiLFwicGFydFwiOlwi4oiCXCIsXCJQYXJ0aWFsRFwiOlwi4oiCXCIsXCJQY3lcIjpcItCfXCIsXCJwY3lcIjpcItC/XCIsXCJwZXJjbnRcIjpcIiVcIixcInBlcmlvZFwiOlwiLlwiLFwicGVybWlsXCI6XCLigLBcIixcInBlcnBcIjpcIuKKpVwiLFwicGVydGVua1wiOlwi4oCxXCIsXCJQZnJcIjpcIvCdlJNcIixcInBmclwiOlwi8J2UrVwiLFwiUGhpXCI6XCLOplwiLFwicGhpXCI6XCLPhlwiLFwicGhpdlwiOlwiz5VcIixcInBobW1hdFwiOlwi4oSzXCIsXCJwaG9uZVwiOlwi4piOXCIsXCJQaVwiOlwizqBcIixcInBpXCI6XCLPgFwiLFwicGl0Y2hmb3JrXCI6XCLii5RcIixcInBpdlwiOlwiz5ZcIixcInBsYW5ja1wiOlwi4oSPXCIsXCJwbGFuY2toXCI6XCLihI5cIixcInBsYW5rdlwiOlwi4oSPXCIsXCJwbHVzYWNpclwiOlwi4qijXCIsXCJwbHVzYlwiOlwi4oqeXCIsXCJwbHVzY2lyXCI6XCLiqKJcIixcInBsdXNcIjpcIitcIixcInBsdXNkb1wiOlwi4oiUXCIsXCJwbHVzZHVcIjpcIuKopVwiLFwicGx1c2VcIjpcIuKpslwiLFwiUGx1c01pbnVzXCI6XCLCsVwiLFwicGx1c21uXCI6XCLCsVwiLFwicGx1c3NpbVwiOlwi4qimXCIsXCJwbHVzdHdvXCI6XCLiqKdcIixcInBtXCI6XCLCsVwiLFwiUG9pbmNhcmVwbGFuZVwiOlwi4oSMXCIsXCJwb2ludGludFwiOlwi4qiVXCIsXCJwb3BmXCI6XCLwnZWhXCIsXCJQb3BmXCI6XCLihJlcIixcInBvdW5kXCI6XCLCo1wiLFwicHJhcFwiOlwi4qq3XCIsXCJQclwiOlwi4qq7XCIsXCJwclwiOlwi4om6XCIsXCJwcmN1ZVwiOlwi4om8XCIsXCJwcmVjYXBwcm94XCI6XCLiqrdcIixcInByZWNcIjpcIuKJulwiLFwicHJlY2N1cmx5ZXFcIjpcIuKJvFwiLFwiUHJlY2VkZXNcIjpcIuKJulwiLFwiUHJlY2VkZXNFcXVhbFwiOlwi4qqvXCIsXCJQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKJvFwiLFwiUHJlY2VkZXNUaWxkZVwiOlwi4om+XCIsXCJwcmVjZXFcIjpcIuKqr1wiLFwicHJlY25hcHByb3hcIjpcIuKquVwiLFwicHJlY25lcXFcIjpcIuKqtVwiLFwicHJlY25zaW1cIjpcIuKLqFwiLFwicHJlXCI6XCLiqq9cIixcInByRVwiOlwi4qqzXCIsXCJwcmVjc2ltXCI6XCLiib5cIixcInByaW1lXCI6XCLigLJcIixcIlByaW1lXCI6XCLigLNcIixcInByaW1lc1wiOlwi4oSZXCIsXCJwcm5hcFwiOlwi4qq5XCIsXCJwcm5FXCI6XCLiqrVcIixcInBybnNpbVwiOlwi4ouoXCIsXCJwcm9kXCI6XCLiiI9cIixcIlByb2R1Y3RcIjpcIuKIj1wiLFwicHJvZmFsYXJcIjpcIuKMrlwiLFwicHJvZmxpbmVcIjpcIuKMklwiLFwicHJvZnN1cmZcIjpcIuKMk1wiLFwicHJvcFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uYWxcIjpcIuKInVwiLFwiUHJvcG9ydGlvblwiOlwi4oi3XCIsXCJwcm9wdG9cIjpcIuKInVwiLFwicHJzaW1cIjpcIuKJvlwiLFwicHJ1cmVsXCI6XCLiirBcIixcIlBzY3JcIjpcIvCdkqtcIixcInBzY3JcIjpcIvCdk4VcIixcIlBzaVwiOlwizqhcIixcInBzaVwiOlwiz4hcIixcInB1bmNzcFwiOlwi4oCIXCIsXCJRZnJcIjpcIvCdlJRcIixcInFmclwiOlwi8J2UrlwiLFwicWludFwiOlwi4qiMXCIsXCJxb3BmXCI6XCLwnZWiXCIsXCJRb3BmXCI6XCLihJpcIixcInFwcmltZVwiOlwi4oGXXCIsXCJRc2NyXCI6XCLwnZKsXCIsXCJxc2NyXCI6XCLwnZOGXCIsXCJxdWF0ZXJuaW9uc1wiOlwi4oSNXCIsXCJxdWF0aW50XCI6XCLiqJZcIixcInF1ZXN0XCI6XCI/XCIsXCJxdWVzdGVxXCI6XCLiiZ9cIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJBYXJyXCI6XCLih5tcIixcInJhY2VcIjpcIuKIvcyxXCIsXCJSYWN1dGVcIjpcIsWUXCIsXCJyYWN1dGVcIjpcIsWVXCIsXCJyYWRpY1wiOlwi4oiaXCIsXCJyYWVtcHR5dlwiOlwi4qazXCIsXCJyYW5nXCI6XCLin6lcIixcIlJhbmdcIjpcIuKfq1wiLFwicmFuZ2RcIjpcIuKmklwiLFwicmFuZ2VcIjpcIuKmpVwiLFwicmFuZ2xlXCI6XCLin6lcIixcInJhcXVvXCI6XCLCu1wiLFwicmFycmFwXCI6XCLipbVcIixcInJhcnJiXCI6XCLih6VcIixcInJhcnJiZnNcIjpcIuKkoFwiLFwicmFycmNcIjpcIuKks1wiLFwicmFyclwiOlwi4oaSXCIsXCJSYXJyXCI6XCLihqBcIixcInJBcnJcIjpcIuKHklwiLFwicmFycmZzXCI6XCLipJ5cIixcInJhcnJoa1wiOlwi4oaqXCIsXCJyYXJybHBcIjpcIuKGrFwiLFwicmFycnBsXCI6XCLipYVcIixcInJhcnJzaW1cIjpcIuKltFwiLFwiUmFycnRsXCI6XCLipJZcIixcInJhcnJ0bFwiOlwi4oajXCIsXCJyYXJyd1wiOlwi4oadXCIsXCJyYXRhaWxcIjpcIuKkmlwiLFwickF0YWlsXCI6XCLipJxcIixcInJhdGlvXCI6XCLiiLZcIixcInJhdGlvbmFsc1wiOlwi4oSaXCIsXCJyYmFyclwiOlwi4qSNXCIsXCJyQmFyclwiOlwi4qSPXCIsXCJSQmFyclwiOlwi4qSQXCIsXCJyYmJya1wiOlwi4p2zXCIsXCJyYnJhY2VcIjpcIn1cIixcInJicmFja1wiOlwiXVwiLFwicmJya2VcIjpcIuKmjFwiLFwicmJya3NsZFwiOlwi4qaOXCIsXCJyYnJrc2x1XCI6XCLippBcIixcIlJjYXJvblwiOlwixZhcIixcInJjYXJvblwiOlwixZlcIixcIlJjZWRpbFwiOlwixZZcIixcInJjZWRpbFwiOlwixZdcIixcInJjZWlsXCI6XCLijIlcIixcInJjdWJcIjpcIn1cIixcIlJjeVwiOlwi0KBcIixcInJjeVwiOlwi0YBcIixcInJkY2FcIjpcIuKkt1wiLFwicmRsZGhhclwiOlwi4qWpXCIsXCJyZHF1b1wiOlwi4oCdXCIsXCJyZHF1b3JcIjpcIuKAnVwiLFwicmRzaFwiOlwi4oazXCIsXCJyZWFsXCI6XCLihJxcIixcInJlYWxpbmVcIjpcIuKEm1wiLFwicmVhbHBhcnRcIjpcIuKEnFwiLFwicmVhbHNcIjpcIuKEnVwiLFwiUmVcIjpcIuKEnFwiLFwicmVjdFwiOlwi4patXCIsXCJyZWdcIjpcIsKuXCIsXCJSRUdcIjpcIsKuXCIsXCJSZXZlcnNlRWxlbWVudFwiOlwi4oiLXCIsXCJSZXZlcnNlRXF1aWxpYnJpdW1cIjpcIuKHi1wiLFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjpcIuKlr1wiLFwicmZpc2h0XCI6XCLipb1cIixcInJmbG9vclwiOlwi4oyLXCIsXCJyZnJcIjpcIvCdlK9cIixcIlJmclwiOlwi4oScXCIsXCJySGFyXCI6XCLipaRcIixcInJoYXJkXCI6XCLih4FcIixcInJoYXJ1XCI6XCLih4BcIixcInJoYXJ1bFwiOlwi4qWsXCIsXCJSaG9cIjpcIs6hXCIsXCJyaG9cIjpcIs+BXCIsXCJyaG92XCI6XCLPsVwiLFwiUmlnaHRBbmdsZUJyYWNrZXRcIjpcIuKfqVwiLFwiUmlnaHRBcnJvd0JhclwiOlwi4oelXCIsXCJyaWdodGFycm93XCI6XCLihpJcIixcIlJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiUmlnaHRhcnJvd1wiOlwi4oeSXCIsXCJSaWdodEFycm93TGVmdEFycm93XCI6XCLih4RcIixcInJpZ2h0YXJyb3d0YWlsXCI6XCLihqNcIixcIlJpZ2h0Q2VpbGluZ1wiOlwi4oyJXCIsXCJSaWdodERvdWJsZUJyYWNrZXRcIjpcIuKfp1wiLFwiUmlnaHREb3duVGVlVmVjdG9yXCI6XCLipZ1cIixcIlJpZ2h0RG93blZlY3RvckJhclwiOlwi4qWVXCIsXCJSaWdodERvd25WZWN0b3JcIjpcIuKHglwiLFwiUmlnaHRGbG9vclwiOlwi4oyLXCIsXCJyaWdodGhhcnBvb25kb3duXCI6XCLih4FcIixcInJpZ2h0aGFycG9vbnVwXCI6XCLih4BcIixcInJpZ2h0bGVmdGFycm93c1wiOlwi4oeEXCIsXCJyaWdodGxlZnRoYXJwb29uc1wiOlwi4oeMXCIsXCJyaWdodHJpZ2h0YXJyb3dzXCI6XCLih4lcIixcInJpZ2h0c3F1aWdhcnJvd1wiOlwi4oadXCIsXCJSaWdodFRlZUFycm93XCI6XCLihqZcIixcIlJpZ2h0VGVlXCI6XCLiiqJcIixcIlJpZ2h0VGVlVmVjdG9yXCI6XCLipZtcIixcInJpZ2h0dGhyZWV0aW1lc1wiOlwi4ouMXCIsXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5BcIixcIlJpZ2h0VHJpYW5nbGVcIjpcIuKKs1wiLFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLiirVcIixcIlJpZ2h0VXBEb3duVmVjdG9yXCI6XCLipY9cIixcIlJpZ2h0VXBUZWVWZWN0b3JcIjpcIuKlnFwiLFwiUmlnaHRVcFZlY3RvckJhclwiOlwi4qWUXCIsXCJSaWdodFVwVmVjdG9yXCI6XCLihr5cIixcIlJpZ2h0VmVjdG9yQmFyXCI6XCLipZNcIixcIlJpZ2h0VmVjdG9yXCI6XCLih4BcIixcInJpbmdcIjpcIsuaXCIsXCJyaXNpbmdkb3RzZXFcIjpcIuKJk1wiLFwicmxhcnJcIjpcIuKHhFwiLFwicmxoYXJcIjpcIuKHjFwiLFwicmxtXCI6XCLigI9cIixcInJtb3VzdGFjaGVcIjpcIuKOsVwiLFwicm1vdXN0XCI6XCLijrFcIixcInJubWlkXCI6XCLiq65cIixcInJvYW5nXCI6XCLin61cIixcInJvYXJyXCI6XCLih75cIixcInJvYnJrXCI6XCLin6dcIixcInJvcGFyXCI6XCLipoZcIixcInJvcGZcIjpcIvCdlaNcIixcIlJvcGZcIjpcIuKEnVwiLFwicm9wbHVzXCI6XCLiqK5cIixcInJvdGltZXNcIjpcIuKotVwiLFwiUm91bmRJbXBsaWVzXCI6XCLipbBcIixcInJwYXJcIjpcIilcIixcInJwYXJndFwiOlwi4qaUXCIsXCJycHBvbGludFwiOlwi4qiSXCIsXCJycmFyclwiOlwi4oeJXCIsXCJScmlnaHRhcnJvd1wiOlwi4oebXCIsXCJyc2FxdW9cIjpcIuKAulwiLFwicnNjclwiOlwi8J2Th1wiLFwiUnNjclwiOlwi4oSbXCIsXCJyc2hcIjpcIuKGsVwiLFwiUnNoXCI6XCLihrFcIixcInJzcWJcIjpcIl1cIixcInJzcXVvXCI6XCLigJlcIixcInJzcXVvclwiOlwi4oCZXCIsXCJydGhyZWVcIjpcIuKLjFwiLFwicnRpbWVzXCI6XCLii4pcIixcInJ0cmlcIjpcIuKWuVwiLFwicnRyaWVcIjpcIuKKtVwiLFwicnRyaWZcIjpcIuKWuFwiLFwicnRyaWx0cmlcIjpcIuKnjlwiLFwiUnVsZURlbGF5ZWRcIjpcIuKntFwiLFwicnVsdWhhclwiOlwi4qWoXCIsXCJyeFwiOlwi4oSeXCIsXCJTYWN1dGVcIjpcIsWaXCIsXCJzYWN1dGVcIjpcIsWbXCIsXCJzYnF1b1wiOlwi4oCaXCIsXCJzY2FwXCI6XCLiqrhcIixcIlNjYXJvblwiOlwixaBcIixcInNjYXJvblwiOlwixaFcIixcIlNjXCI6XCLiqrxcIixcInNjXCI6XCLiibtcIixcInNjY3VlXCI6XCLiib1cIixcInNjZVwiOlwi4qqwXCIsXCJzY0VcIjpcIuKqtFwiLFwiU2NlZGlsXCI6XCLFnlwiLFwic2NlZGlsXCI6XCLFn1wiLFwiU2NpcmNcIjpcIsWcXCIsXCJzY2lyY1wiOlwixZ1cIixcInNjbmFwXCI6XCLiqrpcIixcInNjbkVcIjpcIuKqtlwiLFwic2Nuc2ltXCI6XCLii6lcIixcInNjcG9saW50XCI6XCLiqJNcIixcInNjc2ltXCI6XCLiib9cIixcIlNjeVwiOlwi0KFcIixcInNjeVwiOlwi0YFcIixcInNkb3RiXCI6XCLiiqFcIixcInNkb3RcIjpcIuKLhVwiLFwic2RvdGVcIjpcIuKpplwiLFwic2VhcmhrXCI6XCLipKVcIixcInNlYXJyXCI6XCLihphcIixcInNlQXJyXCI6XCLih5hcIixcInNlYXJyb3dcIjpcIuKGmFwiLFwic2VjdFwiOlwiwqdcIixcInNlbWlcIjpcIjtcIixcInNlc3dhclwiOlwi4qSpXCIsXCJzZXRtaW51c1wiOlwi4oiWXCIsXCJzZXRtblwiOlwi4oiWXCIsXCJzZXh0XCI6XCLinLZcIixcIlNmclwiOlwi8J2UllwiLFwic2ZyXCI6XCLwnZSwXCIsXCJzZnJvd25cIjpcIuKMolwiLFwic2hhcnBcIjpcIuKZr1wiLFwiU0hDSGN5XCI6XCLQqVwiLFwic2hjaGN5XCI6XCLRiVwiLFwiU0hjeVwiOlwi0KhcIixcInNoY3lcIjpcItGIXCIsXCJTaG9ydERvd25BcnJvd1wiOlwi4oaTXCIsXCJTaG9ydExlZnRBcnJvd1wiOlwi4oaQXCIsXCJzaG9ydG1pZFwiOlwi4oijXCIsXCJzaG9ydHBhcmFsbGVsXCI6XCLiiKVcIixcIlNob3J0UmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJTaG9ydFVwQXJyb3dcIjpcIuKGkVwiLFwic2h5XCI6XCLCrVwiLFwiU2lnbWFcIjpcIs6jXCIsXCJzaWdtYVwiOlwiz4NcIixcInNpZ21hZlwiOlwiz4JcIixcInNpZ21hdlwiOlwiz4JcIixcInNpbVwiOlwi4oi8XCIsXCJzaW1kb3RcIjpcIuKpqlwiLFwic2ltZVwiOlwi4omDXCIsXCJzaW1lcVwiOlwi4omDXCIsXCJzaW1nXCI6XCLiqp5cIixcInNpbWdFXCI6XCLiqqBcIixcInNpbWxcIjpcIuKqnVwiLFwic2ltbEVcIjpcIuKqn1wiLFwic2ltbmVcIjpcIuKJhlwiLFwic2ltcGx1c1wiOlwi4qikXCIsXCJzaW1yYXJyXCI6XCLipbJcIixcInNsYXJyXCI6XCLihpBcIixcIlNtYWxsQ2lyY2xlXCI6XCLiiJhcIixcInNtYWxsc2V0bWludXNcIjpcIuKIllwiLFwic21hc2hwXCI6XCLiqLNcIixcInNtZXBhcnNsXCI6XCLip6RcIixcInNtaWRcIjpcIuKIo1wiLFwic21pbGVcIjpcIuKMo1wiLFwic210XCI6XCLiqqpcIixcInNtdGVcIjpcIuKqrFwiLFwic210ZXNcIjpcIuKqrO+4gFwiLFwiU09GVGN5XCI6XCLQrFwiLFwic29mdGN5XCI6XCLRjFwiLFwic29sYmFyXCI6XCLijL9cIixcInNvbGJcIjpcIuKnhFwiLFwic29sXCI6XCIvXCIsXCJTb3BmXCI6XCLwnZWKXCIsXCJzb3BmXCI6XCLwnZWkXCIsXCJzcGFkZXNcIjpcIuKZoFwiLFwic3BhZGVzdWl0XCI6XCLimaBcIixcInNwYXJcIjpcIuKIpVwiLFwic3FjYXBcIjpcIuKKk1wiLFwic3FjYXBzXCI6XCLiipPvuIBcIixcInNxY3VwXCI6XCLiipRcIixcInNxY3Vwc1wiOlwi4oqU77iAXCIsXCJTcXJ0XCI6XCLiiJpcIixcInNxc3ViXCI6XCLiio9cIixcInNxc3ViZVwiOlwi4oqRXCIsXCJzcXN1YnNldFwiOlwi4oqPXCIsXCJzcXN1YnNldGVxXCI6XCLiipFcIixcInNxc3VwXCI6XCLiipBcIixcInNxc3VwZVwiOlwi4oqSXCIsXCJzcXN1cHNldFwiOlwi4oqQXCIsXCJzcXN1cHNldGVxXCI6XCLiipJcIixcInNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlSW50ZXJzZWN0aW9uXCI6XCLiipNcIixcIlNxdWFyZVN1YnNldFwiOlwi4oqPXCIsXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4oqRXCIsXCJTcXVhcmVTdXBlcnNldFwiOlwi4oqQXCIsXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLiipJcIixcIlNxdWFyZVVuaW9uXCI6XCLiipRcIixcInNxdWFyZlwiOlwi4paqXCIsXCJzcXVcIjpcIuKWoVwiLFwic3F1ZlwiOlwi4paqXCIsXCJzcmFyclwiOlwi4oaSXCIsXCJTc2NyXCI6XCLwnZKuXCIsXCJzc2NyXCI6XCLwnZOIXCIsXCJzc2V0bW5cIjpcIuKIllwiLFwic3NtaWxlXCI6XCLijKNcIixcInNzdGFyZlwiOlwi4ouGXCIsXCJTdGFyXCI6XCLii4ZcIixcInN0YXJcIjpcIuKYhlwiLFwic3RhcmZcIjpcIuKYhVwiLFwic3RyYWlnaHRlcHNpbG9uXCI6XCLPtVwiLFwic3RyYWlnaHRwaGlcIjpcIs+VXCIsXCJzdHJuc1wiOlwiwq9cIixcInN1YlwiOlwi4oqCXCIsXCJTdWJcIjpcIuKLkFwiLFwic3ViZG90XCI6XCLiqr1cIixcInN1YkVcIjpcIuKrhVwiLFwic3ViZVwiOlwi4oqGXCIsXCJzdWJlZG90XCI6XCLiq4NcIixcInN1Ym11bHRcIjpcIuKrgVwiLFwic3VibkVcIjpcIuKri1wiLFwic3VibmVcIjpcIuKKilwiLFwic3VicGx1c1wiOlwi4qq/XCIsXCJzdWJyYXJyXCI6XCLipblcIixcInN1YnNldFwiOlwi4oqCXCIsXCJTdWJzZXRcIjpcIuKLkFwiLFwic3Vic2V0ZXFcIjpcIuKKhlwiLFwic3Vic2V0ZXFxXCI6XCLiq4VcIixcIlN1YnNldEVxdWFsXCI6XCLiioZcIixcInN1YnNldG5lcVwiOlwi4oqKXCIsXCJzdWJzZXRuZXFxXCI6XCLiq4tcIixcInN1YnNpbVwiOlwi4quHXCIsXCJzdWJzdWJcIjpcIuKrlVwiLFwic3Vic3VwXCI6XCLiq5NcIixcInN1Y2NhcHByb3hcIjpcIuKquFwiLFwic3VjY1wiOlwi4om7XCIsXCJzdWNjY3VybHllcVwiOlwi4om9XCIsXCJTdWNjZWVkc1wiOlwi4om7XCIsXCJTdWNjZWVkc0VxdWFsXCI6XCLiqrBcIixcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4om9XCIsXCJTdWNjZWVkc1RpbGRlXCI6XCLiib9cIixcInN1Y2NlcVwiOlwi4qqwXCIsXCJzdWNjbmFwcHJveFwiOlwi4qq6XCIsXCJzdWNjbmVxcVwiOlwi4qq2XCIsXCJzdWNjbnNpbVwiOlwi4oupXCIsXCJzdWNjc2ltXCI6XCLiib9cIixcIlN1Y2hUaGF0XCI6XCLiiItcIixcInN1bVwiOlwi4oiRXCIsXCJTdW1cIjpcIuKIkVwiLFwic3VuZ1wiOlwi4pmqXCIsXCJzdXAxXCI6XCLCuVwiLFwic3VwMlwiOlwiwrJcIixcInN1cDNcIjpcIsKzXCIsXCJzdXBcIjpcIuKKg1wiLFwiU3VwXCI6XCLii5FcIixcInN1cGRvdFwiOlwi4qq+XCIsXCJzdXBkc3ViXCI6XCLiq5hcIixcInN1cEVcIjpcIuKrhlwiLFwic3VwZVwiOlwi4oqHXCIsXCJzdXBlZG90XCI6XCLiq4RcIixcIlN1cGVyc2V0XCI6XCLiioNcIixcIlN1cGVyc2V0RXF1YWxcIjpcIuKKh1wiLFwic3VwaHNvbFwiOlwi4p+JXCIsXCJzdXBoc3ViXCI6XCLiq5dcIixcInN1cGxhcnJcIjpcIuKlu1wiLFwic3VwbXVsdFwiOlwi4quCXCIsXCJzdXBuRVwiOlwi4quMXCIsXCJzdXBuZVwiOlwi4oqLXCIsXCJzdXBwbHVzXCI6XCLiq4BcIixcInN1cHNldFwiOlwi4oqDXCIsXCJTdXBzZXRcIjpcIuKLkVwiLFwic3Vwc2V0ZXFcIjpcIuKKh1wiLFwic3Vwc2V0ZXFxXCI6XCLiq4ZcIixcInN1cHNldG5lcVwiOlwi4oqLXCIsXCJzdXBzZXRuZXFxXCI6XCLiq4xcIixcInN1cHNpbVwiOlwi4quIXCIsXCJzdXBzdWJcIjpcIuKrlFwiLFwic3Vwc3VwXCI6XCLiq5ZcIixcInN3YXJoa1wiOlwi4qSmXCIsXCJzd2FyclwiOlwi4oaZXCIsXCJzd0FyclwiOlwi4oeZXCIsXCJzd2Fycm93XCI6XCLihplcIixcInN3bndhclwiOlwi4qSqXCIsXCJzemxpZ1wiOlwiw59cIixcIlRhYlwiOlwiXFx0XCIsXCJ0YXJnZXRcIjpcIuKMllwiLFwiVGF1XCI6XCLOpFwiLFwidGF1XCI6XCLPhFwiLFwidGJya1wiOlwi4o60XCIsXCJUY2Fyb25cIjpcIsWkXCIsXCJ0Y2Fyb25cIjpcIsWlXCIsXCJUY2VkaWxcIjpcIsWiXCIsXCJ0Y2VkaWxcIjpcIsWjXCIsXCJUY3lcIjpcItCiXCIsXCJ0Y3lcIjpcItGCXCIsXCJ0ZG90XCI6XCLig5tcIixcInRlbHJlY1wiOlwi4oyVXCIsXCJUZnJcIjpcIvCdlJdcIixcInRmclwiOlwi8J2UsVwiLFwidGhlcmU0XCI6XCLiiLRcIixcInRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGVyZWZvcmVcIjpcIuKItFwiLFwiVGhldGFcIjpcIs6YXCIsXCJ0aGV0YVwiOlwizrhcIixcInRoZXRhc3ltXCI6XCLPkVwiLFwidGhldGF2XCI6XCLPkVwiLFwidGhpY2thcHByb3hcIjpcIuKJiFwiLFwidGhpY2tzaW1cIjpcIuKIvFwiLFwiVGhpY2tTcGFjZVwiOlwi4oGf4oCKXCIsXCJUaGluU3BhY2VcIjpcIuKAiVwiLFwidGhpbnNwXCI6XCLigIlcIixcInRoa2FwXCI6XCLiiYhcIixcInRoa3NpbVwiOlwi4oi8XCIsXCJUSE9STlwiOlwiw55cIixcInRob3JuXCI6XCLDvlwiLFwidGlsZGVcIjpcIsucXCIsXCJUaWxkZVwiOlwi4oi8XCIsXCJUaWxkZUVxdWFsXCI6XCLiiYNcIixcIlRpbGRlRnVsbEVxdWFsXCI6XCLiiYVcIixcIlRpbGRlVGlsZGVcIjpcIuKJiFwiLFwidGltZXNiYXJcIjpcIuKosVwiLFwidGltZXNiXCI6XCLiiqBcIixcInRpbWVzXCI6XCLDl1wiLFwidGltZXNkXCI6XCLiqLBcIixcInRpbnRcIjpcIuKIrVwiLFwidG9lYVwiOlwi4qSoXCIsXCJ0b3Bib3RcIjpcIuKMtlwiLFwidG9wY2lyXCI6XCLiq7FcIixcInRvcFwiOlwi4oqkXCIsXCJUb3BmXCI6XCLwnZWLXCIsXCJ0b3BmXCI6XCLwnZWlXCIsXCJ0b3Bmb3JrXCI6XCLiq5pcIixcInRvc2FcIjpcIuKkqVwiLFwidHByaW1lXCI6XCLigLRcIixcInRyYWRlXCI6XCLihKJcIixcIlRSQURFXCI6XCLihKJcIixcInRyaWFuZ2xlXCI6XCLilrVcIixcInRyaWFuZ2xlZG93blwiOlwi4pa/XCIsXCJ0cmlhbmdsZWxlZnRcIjpcIuKXg1wiLFwidHJpYW5nbGVsZWZ0ZXFcIjpcIuKKtFwiLFwidHJpYW5nbGVxXCI6XCLiiZxcIixcInRyaWFuZ2xlcmlnaHRcIjpcIuKWuVwiLFwidHJpYW5nbGVyaWdodGVxXCI6XCLiirVcIixcInRyaWRvdFwiOlwi4pesXCIsXCJ0cmllXCI6XCLiiZxcIixcInRyaW1pbnVzXCI6XCLiqLpcIixcIlRyaXBsZURvdFwiOlwi4oObXCIsXCJ0cmlwbHVzXCI6XCLiqLlcIixcInRyaXNiXCI6XCLip41cIixcInRyaXRpbWVcIjpcIuKou1wiLFwidHJwZXppdW1cIjpcIuKPolwiLFwiVHNjclwiOlwi8J2Sr1wiLFwidHNjclwiOlwi8J2TiVwiLFwiVFNjeVwiOlwi0KZcIixcInRzY3lcIjpcItGGXCIsXCJUU0hjeVwiOlwi0ItcIixcInRzaGN5XCI6XCLRm1wiLFwiVHN0cm9rXCI6XCLFplwiLFwidHN0cm9rXCI6XCLFp1wiLFwidHdpeHRcIjpcIuKJrFwiLFwidHdvaGVhZGxlZnRhcnJvd1wiOlwi4oaeXCIsXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwi4oagXCIsXCJVYWN1dGVcIjpcIsOaXCIsXCJ1YWN1dGVcIjpcIsO6XCIsXCJ1YXJyXCI6XCLihpFcIixcIlVhcnJcIjpcIuKGn1wiLFwidUFyclwiOlwi4oeRXCIsXCJVYXJyb2NpclwiOlwi4qWJXCIsXCJVYnJjeVwiOlwi0I5cIixcInVicmN5XCI6XCLRnlwiLFwiVWJyZXZlXCI6XCLFrFwiLFwidWJyZXZlXCI6XCLFrVwiLFwiVWNpcmNcIjpcIsObXCIsXCJ1Y2lyY1wiOlwiw7tcIixcIlVjeVwiOlwi0KNcIixcInVjeVwiOlwi0YNcIixcInVkYXJyXCI6XCLih4VcIixcIlVkYmxhY1wiOlwixbBcIixcInVkYmxhY1wiOlwixbFcIixcInVkaGFyXCI6XCLipa5cIixcInVmaXNodFwiOlwi4qW+XCIsXCJVZnJcIjpcIvCdlJhcIixcInVmclwiOlwi8J2UslwiLFwiVWdyYXZlXCI6XCLDmVwiLFwidWdyYXZlXCI6XCLDuVwiLFwidUhhclwiOlwi4qWjXCIsXCJ1aGFybFwiOlwi4oa/XCIsXCJ1aGFyclwiOlwi4oa+XCIsXCJ1aGJsa1wiOlwi4paAXCIsXCJ1bGNvcm5cIjpcIuKMnFwiLFwidWxjb3JuZXJcIjpcIuKMnFwiLFwidWxjcm9wXCI6XCLijI9cIixcInVsdHJpXCI6XCLil7hcIixcIlVtYWNyXCI6XCLFqlwiLFwidW1hY3JcIjpcIsWrXCIsXCJ1bWxcIjpcIsKoXCIsXCJVbmRlckJhclwiOlwiX1wiLFwiVW5kZXJCcmFjZVwiOlwi4o+fXCIsXCJVbmRlckJyYWNrZXRcIjpcIuKOtVwiLFwiVW5kZXJQYXJlbnRoZXNpc1wiOlwi4o+dXCIsXCJVbmlvblwiOlwi4ouDXCIsXCJVbmlvblBsdXNcIjpcIuKKjlwiLFwiVW9nb25cIjpcIsWyXCIsXCJ1b2dvblwiOlwixbNcIixcIlVvcGZcIjpcIvCdlYxcIixcInVvcGZcIjpcIvCdlaZcIixcIlVwQXJyb3dCYXJcIjpcIuKkklwiLFwidXBhcnJvd1wiOlwi4oaRXCIsXCJVcEFycm93XCI6XCLihpFcIixcIlVwYXJyb3dcIjpcIuKHkVwiLFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwi4oeFXCIsXCJ1cGRvd25hcnJvd1wiOlwi4oaVXCIsXCJVcERvd25BcnJvd1wiOlwi4oaVXCIsXCJVcGRvd25hcnJvd1wiOlwi4oeVXCIsXCJVcEVxdWlsaWJyaXVtXCI6XCLipa5cIixcInVwaGFycG9vbmxlZnRcIjpcIuKGv1wiLFwidXBoYXJwb29ucmlnaHRcIjpcIuKGvlwiLFwidXBsdXNcIjpcIuKKjlwiLFwiVXBwZXJMZWZ0QXJyb3dcIjpcIuKGllwiLFwiVXBwZXJSaWdodEFycm93XCI6XCLihpdcIixcInVwc2lcIjpcIs+FXCIsXCJVcHNpXCI6XCLPklwiLFwidXBzaWhcIjpcIs+SXCIsXCJVcHNpbG9uXCI6XCLOpVwiLFwidXBzaWxvblwiOlwiz4VcIixcIlVwVGVlQXJyb3dcIjpcIuKGpVwiLFwiVXBUZWVcIjpcIuKKpVwiLFwidXB1cGFycm93c1wiOlwi4oeIXCIsXCJ1cmNvcm5cIjpcIuKMnVwiLFwidXJjb3JuZXJcIjpcIuKMnVwiLFwidXJjcm9wXCI6XCLijI5cIixcIlVyaW5nXCI6XCLFrlwiLFwidXJpbmdcIjpcIsWvXCIsXCJ1cnRyaVwiOlwi4pe5XCIsXCJVc2NyXCI6XCLwnZKwXCIsXCJ1c2NyXCI6XCLwnZOKXCIsXCJ1dGRvdFwiOlwi4ouwXCIsXCJVdGlsZGVcIjpcIsWoXCIsXCJ1dGlsZGVcIjpcIsWpXCIsXCJ1dHJpXCI6XCLilrVcIixcInV0cmlmXCI6XCLilrRcIixcInV1YXJyXCI6XCLih4hcIixcIlV1bWxcIjpcIsOcXCIsXCJ1dW1sXCI6XCLDvFwiLFwidXdhbmdsZVwiOlwi4qanXCIsXCJ2YW5ncnRcIjpcIuKmnFwiLFwidmFyZXBzaWxvblwiOlwiz7VcIixcInZhcmthcHBhXCI6XCLPsFwiLFwidmFybm90aGluZ1wiOlwi4oiFXCIsXCJ2YXJwaGlcIjpcIs+VXCIsXCJ2YXJwaVwiOlwiz5ZcIixcInZhcnByb3B0b1wiOlwi4oidXCIsXCJ2YXJyXCI6XCLihpVcIixcInZBcnJcIjpcIuKHlVwiLFwidmFycmhvXCI6XCLPsVwiLFwidmFyc2lnbWFcIjpcIs+CXCIsXCJ2YXJzdWJzZXRuZXFcIjpcIuKKiu+4gFwiLFwidmFyc3Vic2V0bmVxcVwiOlwi4quL77iAXCIsXCJ2YXJzdXBzZXRuZXFcIjpcIuKKi++4gFwiLFwidmFyc3Vwc2V0bmVxcVwiOlwi4quM77iAXCIsXCJ2YXJ0aGV0YVwiOlwiz5FcIixcInZhcnRyaWFuZ2xlbGVmdFwiOlwi4oqyXCIsXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCLiirNcIixcInZCYXJcIjpcIuKrqFwiLFwiVmJhclwiOlwi4qurXCIsXCJ2QmFydlwiOlwi4qupXCIsXCJWY3lcIjpcItCSXCIsXCJ2Y3lcIjpcItCyXCIsXCJ2ZGFzaFwiOlwi4oqiXCIsXCJ2RGFzaFwiOlwi4oqoXCIsXCJWZGFzaFwiOlwi4oqpXCIsXCJWRGFzaFwiOlwi4oqrXCIsXCJWZGFzaGxcIjpcIuKrplwiLFwidmVlYmFyXCI6XCLiirtcIixcInZlZVwiOlwi4oioXCIsXCJWZWVcIjpcIuKLgVwiLFwidmVlZXFcIjpcIuKJmlwiLFwidmVsbGlwXCI6XCLii65cIixcInZlcmJhclwiOlwifFwiLFwiVmVyYmFyXCI6XCLigJZcIixcInZlcnRcIjpcInxcIixcIlZlcnRcIjpcIuKAllwiLFwiVmVydGljYWxCYXJcIjpcIuKIo1wiLFwiVmVydGljYWxMaW5lXCI6XCJ8XCIsXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwi4p2YXCIsXCJWZXJ0aWNhbFRpbGRlXCI6XCLiiYBcIixcIlZlcnlUaGluU3BhY2VcIjpcIuKAilwiLFwiVmZyXCI6XCLwnZSZXCIsXCJ2ZnJcIjpcIvCdlLNcIixcInZsdHJpXCI6XCLiirJcIixcInZuc3ViXCI6XCLiioLig5JcIixcInZuc3VwXCI6XCLiioPig5JcIixcIlZvcGZcIjpcIvCdlY1cIixcInZvcGZcIjpcIvCdladcIixcInZwcm9wXCI6XCLiiJ1cIixcInZydHJpXCI6XCLiirNcIixcIlZzY3JcIjpcIvCdkrFcIixcInZzY3JcIjpcIvCdk4tcIixcInZzdWJuRVwiOlwi4quL77iAXCIsXCJ2c3VibmVcIjpcIuKKiu+4gFwiLFwidnN1cG5FXCI6XCLiq4zvuIBcIixcInZzdXBuZVwiOlwi4oqL77iAXCIsXCJWdmRhc2hcIjpcIuKKqlwiLFwidnppZ3phZ1wiOlwi4qaaXCIsXCJXY2lyY1wiOlwixbRcIixcIndjaXJjXCI6XCLFtVwiLFwid2VkYmFyXCI6XCLiqZ9cIixcIndlZGdlXCI6XCLiiKdcIixcIldlZGdlXCI6XCLii4BcIixcIndlZGdlcVwiOlwi4omZXCIsXCJ3ZWllcnBcIjpcIuKEmFwiLFwiV2ZyXCI6XCLwnZSaXCIsXCJ3ZnJcIjpcIvCdlLRcIixcIldvcGZcIjpcIvCdlY5cIixcIndvcGZcIjpcIvCdlahcIixcIndwXCI6XCLihJhcIixcIndyXCI6XCLiiYBcIixcIndyZWF0aFwiOlwi4omAXCIsXCJXc2NyXCI6XCLwnZKyXCIsXCJ3c2NyXCI6XCLwnZOMXCIsXCJ4Y2FwXCI6XCLii4JcIixcInhjaXJjXCI6XCLil69cIixcInhjdXBcIjpcIuKLg1wiLFwieGR0cmlcIjpcIuKWvVwiLFwiWGZyXCI6XCLwnZSbXCIsXCJ4ZnJcIjpcIvCdlLVcIixcInhoYXJyXCI6XCLin7dcIixcInhoQXJyXCI6XCLin7pcIixcIlhpXCI6XCLOnlwiLFwieGlcIjpcIs6+XCIsXCJ4bGFyclwiOlwi4p+1XCIsXCJ4bEFyclwiOlwi4p+4XCIsXCJ4bWFwXCI6XCLin7xcIixcInhuaXNcIjpcIuKLu1wiLFwieG9kb3RcIjpcIuKogFwiLFwiWG9wZlwiOlwi8J2Vj1wiLFwieG9wZlwiOlwi8J2VqVwiLFwieG9wbHVzXCI6XCLiqIFcIixcInhvdGltZVwiOlwi4qiCXCIsXCJ4cmFyclwiOlwi4p+2XCIsXCJ4ckFyclwiOlwi4p+5XCIsXCJYc2NyXCI6XCLwnZKzXCIsXCJ4c2NyXCI6XCLwnZONXCIsXCJ4c3FjdXBcIjpcIuKohlwiLFwieHVwbHVzXCI6XCLiqIRcIixcInh1dHJpXCI6XCLilrNcIixcInh2ZWVcIjpcIuKLgVwiLFwieHdlZGdlXCI6XCLii4BcIixcIllhY3V0ZVwiOlwiw51cIixcInlhY3V0ZVwiOlwiw71cIixcIllBY3lcIjpcItCvXCIsXCJ5YWN5XCI6XCLRj1wiLFwiWWNpcmNcIjpcIsW2XCIsXCJ5Y2lyY1wiOlwixbdcIixcIlljeVwiOlwi0KtcIixcInljeVwiOlwi0YtcIixcInllblwiOlwiwqVcIixcIllmclwiOlwi8J2UnFwiLFwieWZyXCI6XCLwnZS2XCIsXCJZSWN5XCI6XCLQh1wiLFwieWljeVwiOlwi0ZdcIixcIllvcGZcIjpcIvCdlZBcIixcInlvcGZcIjpcIvCdlapcIixcIllzY3JcIjpcIvCdkrRcIixcInlzY3JcIjpcIvCdk45cIixcIllVY3lcIjpcItCuXCIsXCJ5dWN5XCI6XCLRjlwiLFwieXVtbFwiOlwiw79cIixcIll1bWxcIjpcIsW4XCIsXCJaYWN1dGVcIjpcIsW5XCIsXCJ6YWN1dGVcIjpcIsW6XCIsXCJaY2Fyb25cIjpcIsW9XCIsXCJ6Y2Fyb25cIjpcIsW+XCIsXCJaY3lcIjpcItCXXCIsXCJ6Y3lcIjpcItC3XCIsXCJaZG90XCI6XCLFu1wiLFwiemRvdFwiOlwixbxcIixcInplZXRyZlwiOlwi4oSoXCIsXCJaZXJvV2lkdGhTcGFjZVwiOlwi4oCLXCIsXCJaZXRhXCI6XCLOllwiLFwiemV0YVwiOlwizrZcIixcInpmclwiOlwi8J2Ut1wiLFwiWmZyXCI6XCLihKhcIixcIlpIY3lcIjpcItCWXCIsXCJ6aGN5XCI6XCLQtlwiLFwiemlncmFyclwiOlwi4oedXCIsXCJ6b3BmXCI6XCLwnZWrXCIsXCJab3BmXCI6XCLihKRcIixcIlpzY3JcIjpcIvCdkrVcIixcInpzY3JcIjpcIvCdk49cIixcInp3alwiOlwi4oCNXCIsXCJ6d25qXCI6XCLigIxcIn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmosIF9WZHQsIGJsb2NrcywgJGNhbGxlZSkge1xuICAgIF9WZHQgfHwgKF9WZHQgPSBWZHQpO1xuICAgIG9iaiB8fCAob2JqID0ge30pO1xuICAgIGJsb2NrcyB8fCAoYmxvY2tzID0ge30pO1xuICAgIHZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG4gICAgICAgIF9fdSA9IF9WZHQudXRpbHMsIGV4dGVuZCA9IF9fdS5leHRlbmQsIF9lID0gX191LmVycm9yLCBfY2xhc3NOYW1lID0gX191LmNsYXNzTmFtZSwgX19zbGljZSA9IF9fdS5zbGljZSwgX19ub29wID0gX191Lm5vb3AsXG4gICAgICAgIF9fbSA9IF9fdS5tYXAsIF9fbyA9IF9fdS5PcHRpb25zLCBfZ2V0TW9kZWwgPSBfX28uZ2V0TW9kZWwsIF9zZXRNb2RlbCA9IF9fby5zZXRNb2RlbCxcbiAgICAgICAgX3NldENoZWNrYm94TW9kZWwgPSBfX3Uuc2V0Q2hlY2tib3hNb2RlbCwgX2RldGVjdENoZWNrYm94Q2hlY2tlZCA9IF9fdS5kZXRlY3RDaGVja2JveENoZWNrZWQsXG4gICAgICAgIF9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbiAgICAgICAgc2VsZiA9IHRoaXMuZGF0YSwgJHRoaXMgPSB0aGlzLCBzY29wZSA9IG9iaiwgQW5pbWF0ZSA9IHNlbGYgJiYgc2VsZi5BbmltYXRlLCBwYXJlbnQgPSAoJGNhbGxlZSB8fCB7fSkuX3N1cGVyO1xuXG4gICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9vYmogPSB7XG4gICAgICAgICAgICAnY2xhc3NOYW1lJzogJ2luZGV4LXBhZ2UnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJlbnQuY2FsbCgkdGhpcywgX29iaiwgX1ZkdCwgZnVuY3Rpb24oYmxvY2tzKSB7XG4gICAgICAgICAgICB2YXIgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IGV4dGVuZCh7fSwgYmxvY2tzKTtcbiAgICAgICAgICAgIHJldHVybiAoKF9ibG9ja3NbJ2NvbnRlbnQnXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2FydGljbGUnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYygnIDxpbWcgc3JjPVxcXCJpbWFnZXMvbG9nby5wbmdcXFwiIC8+ICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCgnaDEnLCBudWxsLCAnSW50YWN0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKCdwJywgbnVsbCwgJ+WPr+e7p+aJv++8jOW8uumAu+i+keaooeadv+eahOWJjeerr+W8gOWPkeahhuaeticpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogJyMvZG9jdW1lbnQvc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ+W8gOWniycsICdidXR0b24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6ICdodHRwczovL2dpdGh1Yi5jb20vSmF2ZXkvaW50YWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6ICdfYmxhbmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ0dpdEh1YicsICdidXR0b24gd2hpdGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgJ2FjdGlvbnMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2gyJywgbnVsbCwgJ+eugOWNlScsICdibHVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsICdcXG4gICAgICAgICAgICAgICAgICAgICAgICDmsqHmnInlpI3mnYLnmoTmpoLlv7XvvIzkvaDku4Xku4Xlj6rpnIDopoHkuobop6NIVE1M77yMQ1NT5ZKMSmF2YVNjcmlwdOWNs+WPr1xcbiAgICAgICAgICAgICAgICAgICAgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCAnZmVhdHVyZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnaDInLCBudWxsLCAn6auY5pWIJywgJ3llbGxvdycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuICAgICAgICAgICAgICAgICAgICAgICAgMjJLQiBtaW4rZ3ppcCDlpKflsI/vvIzljIXlkKvliY3nq6/nvJbor5HmqKHlnZfvvJsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnYnInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Jr6Ieq55uu5YmN5pyA5b+r55qE6Jma5oufRE9N5byV5pOO5LmL5LiA77yIaW5mZXJub++8ieaehOW7ulxcbiAgICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sICdmZWF0dXJlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdoMicsIG51bGwsICflj6/nu6fmib/vvIzlvLrpgLvovpHmqKHmnb8nLCAncmVkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsICdcXG4gICAgICAgICAgICAgICAgICAgICAgICDlhYXliIblj5HmjKXnu6fmib/nmoTkvJjlir/vvIzlrp7njrDnu4Tku7bpgLvovpHlkozmqKHmnb/nmoTnu6fmib/mianlsZXvvIxcXG4gICAgICAgICAgICAgICAgICAgICAgICDorqnkvaDmm7Tlv6vpgJ/mlrnkvr/lnLDmnoTlu7rlpI3mnYLnmoTlupTnlKhcXG4gICAgICAgICAgICAgICAgICAgICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgJ2ZlYXR1cmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgJ2ZlYXR1cmVzJylcbiAgICAgICAgICAgICAgICAgICAgXSwgJ2hvbWUtaGVhZGVyJyksXG4gICAgICAgICAgICAgICAgICAgIGgoJ2FydGljbGUnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoYygnIDxoMT7lj6/nu6fmib/nmoTlk43lupTlvI/nu4Tku7Y8L2gxPiAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2gzJywgbnVsbCwgJ+mAmui/h+e7p+aJv+eahOaAneaDs++8jOadpeaJqeWxleeItue7hOS7tumAu+i+keWSjOaooeadv+OAguWQjOaXtue7hOS7tuaVsOaNruWPmOabtO+8jOeVjOmdouS8mueri+WNs+iHquWKqOWBmuWHuuebuOW6lOabtOaWsCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ3NjcmlwdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAndGV4dC9tZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbm5lckhUTUwnOiAnXFxuYGBgaHRtbFxcbi8vIEBmaWxlIGxheW91dC52ZHRcXG48ZGl2PlxcbiAgICA8aGVhZGVyPlxcbiAgICAgICAgPGI6aGVhZGVyPkV4dGVuZGFibGUgYW5kIFJlYWN0aXZlIENvbXBvbmVudDwvYjpoZWFkZXI+XFxuICAgIDwvaGVhZGVyPlxcbiAgICA8ZGl2PlxcbiAgICAgICAgPGI6Ym9keT5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb3VudFxcXCI+e3NlbGYuZ2V0KFxcXCJjb3VudFxcXCIpfTwvZGl2PlxcbiAgICAgICAgPC9iOmJvZHk+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcbmBgYFxcblxcbmBgYGpzXFxuLy8gQGZpbGUgbGF5b3V0LmpzXFxuaW1wb3J0IEludGFjdCBmcm9tIFxcJ2ludGFjdFxcJztcXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSBcXCcuL2xheW91dC52ZHRcXCc7XFxuXFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5b3V0IGV4dGVuZHMgSW50YWN0IHtcXG4gICAgQEludGFjdC50ZW1wbGF0ZSgpXFxuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHRlbXBsYXRlO1xcblxcbiAgICBkZWZhdWx0cygpIHtcXG4gICAgICAgIHJldHVybiB7Y291bnQ6IDB9O1xcbiAgICB9XFxufVxcbmBgYFxcblxcbmBgYGh0bWxcXG4vLyBAZmlsZSBwYWdlLnZkdFxcbjx0OnBhcmVudD5cXG4gICAgPGI6Ym9keT5cXG4gICAgICAgIHtwYXJlbnQoKX1cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgICBldi1jbGljaz17c2VsZi5hZGR9XFxuICAgICAgICA+Q2xpY2sgbWUhPC9idXR0b24+XFxuICAgIDwvYjpib2R5PlxcbjwvdDpwYXJlbnQ+XFxuYGBgXFxuXFxuYGBganNcXG4vLyBAZmlsZSBwYWdlLmpzXFxuaW1wb3J0IEludGFjdCBmcm9tIFxcJ2ludGFjdFxcJztcXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSBcXCcuL3BhZ2UudmR0XFwnO1xcbmltcG9ydCBMYXlvdXQgZnJvbSBcXCcuL2xheW91dFxcJztcXG5cXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlIGV4dGVuZHMgTGF5b3V0IHtcXG4gICAgQEludGFjdC50ZW1wbGF0ZSgpXFxuICAgIHN0YXRpYyB0ZW1wbGF0ZSA9IHRlbXBsYXRlO1xcblxcbiAgICBhZGQoKSB7XFxuICAgICAgICB0aGlzLnNldChcXCdjb3VudFxcJywgdGhpcy5nZXQoXFwnY291bnRcXCcpICsgMSk7XFxuICAgIH1cXG59XFxuXFxuXFxuSW50YWN0Lm1vdW50KFBhZ2UsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcJ2FwcFxcJykpO1xcbmBgYFxcbiAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgJ3Nob3cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdzY3JpcHQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3RleHQvbWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5uZXJIVE1MJzogJ1xcbmBgYGpzXFxudmFyIExheW91dCA9IEludGFjdC5leHRlbmQoe1xcbiAgICB0ZW1wbGF0ZTogXFwnPGRpdj5cXFxcXFxuICAgICAgICA8aGVhZGVyPlxcXFxcXG4gICAgICAgICAgICA8YjpoZWFkZXI+RXh0ZW5kYWJsZSBhbmQgUmVhY3RpdmUgQ29tcG9uZW50PC9iOmhlYWRlcj5cXFxcXFxuICAgICAgICA8L2hlYWRlcj5cXFxcXFxuICAgICAgICA8ZGl2PlxcXFxcXG4gICAgICAgICAgICA8Yjpib2R5PlxcXFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY291bnRcXFwiPntzZWxmLmdldChcXFwiY291bnRcXFwiKX08L2Rpdj5cXFxcXFxuICAgICAgICAgICAgPC9iOmJvZHk+XFxcXFxcbiAgICAgICAgPC9kaXY+XFxcXFxcbiAgICA8L2Rpdj5cXCcsXFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB7Y291bnQ6IDB9O1xcbiAgICB9XFxufSk7XFxuXFxudmFyIFBhZ2UgPSBMYXlvdXQuZXh0ZW5kKHtcXG4gICAgdGVtcGxhdGU6IFxcJzx0OnBhcmVudD5cXFxcXFxuICAgICAgICA8Yjpib2R5PlxcXFxcXG4gICAgICAgICAgICB7cGFyZW50KCl9XFxcXFxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvblxcXCJcXFxcXFxuICAgICAgICAgICAgICAgIGV2LWNsaWNrPXtzZWxmLmFkZC5iaW5kKHNlbGYpfVxcXFxcXG4gICAgICAgICAgICA+Q2xpY2sgbWUhPC9idXR0b24+XFxcXFxcbiAgICAgICAgPC9iOmJvZHk+XFxcXFxcbiAgICA8L3Q6cGFyZW50PlxcJyxcXG4gICAgYWRkOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHRoaXMuc2V0KFxcJ2NvdW50XFwnLCB0aGlzLmdldChcXCdjb3VudFxcJykgKyAxKTtcXG4gICAgfVxcbn0pO1xcblxcbkludGFjdC5tb3VudChQYWdlLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXCdhcHBcXCcpKTtcXG5gYGBcXG4gICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG51bGwsICdydW4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCBudWxsLCBudWxsLCAnY29kZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogJ2FwcCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBudWxsLCAnb3V0cHV0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sICdjb2RlLXdyYXBwZXInKVxuICAgICAgICAgICAgICAgICAgICBdLCAnaG9tZS1jb21wb25lbnRzJylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSkgJiYgKF9fYmxvY2tzWydjb250ZW50J10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tzWydjb250ZW50J10gPyBibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgW2Z1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3MsIDEpKSkgOiBfYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSksIF9fYmxvY2tzKTtcbiAgICAgICAgfS5jYWxsKCR0aGlzLCBibG9ja3MpLCBwYXJlbnQpXG4gICAgfSkuY2FsbCgkdGhpcylcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaXRlL3BhZ2VzL2luZGV4L2luZGV4LnZkdCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhsanMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgY29sb3I6ICM1MjUyNTI7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG4uaGxqcy1kb2N0eXBlIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uaGxqcy10YWcge1xcbiAgY29sb3I6ICMzZTc2ZjY7XFxufVxcbi5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmhsanMtdmFsdWUge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5obGpzLWtleXdvcmQge1xcbiAgY29sb3I6ICNlOTY5MDA7XFxufVxcbi5obGpzLXN0cmluZyB7XFxuICBjb2xvcjogIzQyYjk4MztcXG59XFxuLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogI2IzYjNiMztcXG59XFxuLmhsanMtb3BlcmF0b3IgLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogIzUyNTI1MjtcXG59XFxuLmhsanMtcmVnZXhwIHtcXG4gIGNvbG9yOiAjYWY3ZGZmO1xcbn1cXG4uaGxqcy1idWlsdF9pbiB7XFxuICBjb2xvcjogIzJkYjdmNTtcXG59XFxuLmNzcyAuaGxqcy1jbGFzcyB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmNzcyAuaGxqcy1udW1iZXIsXFxuLmphdmFzY3JpcHQgLmhsanMtbnVtYmVyIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG4uY3NzIC5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2FmN2RmZjtcXG59XFxuLmNzcyAuaGxqcy1pbXBvcnRhbnQge1xcbiAgY29sb3I6ICNkMDQ7XFxufVxcbi5hY3Rpb25zY3JpcHQgLmhsanMtbGl0ZXJhbCxcXG4uamF2YXNjcmlwdCAuaGxqcy1saXRlcmFsIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG5wcmUge1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG59XFxuY29kZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZjdmN2Y3O1xcbiAgZm9udC1mYW1pbHk6IENvbnNvbGFzLCBNb25hY28sIEFuZGFsZSBNb25vLCBVYnVudHUgTW9ubywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiAzcHg7XFxuICBwYWRkaW5nOiAxcHggNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5pbmRleC1wYWdlIC5jb250ZW50LXdyYXBwZXIge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwYWRkaW5nLXRvcDogODBweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWhlYWRlciB7XFxuICBwYWRkaW5nOiA1MHB4IDA7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWhlYWRlciBoMSB7XFxuICBmb250LXNpemU6IDVlbTtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBmb250LWZhbWlseTogQXJpYWw7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWhlYWRlciBwIHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIGNvbG9yOiAjNDY0ODRhO1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZDA0O1xcbiAgY29sb3I6ICNmZmY7XFxuICBwYWRkaW5nOiAwIDJlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMmVtO1xcbiAgbWFyZ2luOiAwIDEwcHg7XFxuICBoZWlnaHQ6IDNlbTtcXG4gIGxpbmUtaGVpZ2h0OiAzZW07XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZmU0NDQ0O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbi53aGl0ZSB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXG4gIGNvbG9yOiAjNjY2O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmJ1dHRvbi53aGl0ZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmZlYXR1cmVzIHtcXG4gIHdpZHRoOiAxMDgwcHg7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtYXJnaW4tdG9wOiA1MHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1oZWFkZXIgLmZlYXR1cmUge1xcbiAgZmxleDogMTtcXG59XFxuLmluZGV4LXBhZ2UgLmhvbWUtaGVhZGVyIC5mZWF0dXJlIGgyIHtcXG4gIG1hcmdpbjogMTBweDtcXG59XFxuLmluZGV4LXBhZ2UgLmhvbWUtY29tcG9uZW50cyB7XFxuICBiYWNrZ3JvdW5kOiAjZjhmOGY4O1xcbiAgcGFkZGluZzogMzBweCAwO1xcbn1cXG4uaW5kZXgtcGFnZSAuaG9tZS1jb21wb25lbnRzIGgxIHtcXG4gIGZvbnQtc2l6ZTogM2VtO1xcbiAgY29sb3I6ICMxMTE7XFxufVxcbi5pbmRleC1wYWdlIC5ob21lLWNvbXBvbmVudHMgaDMge1xcbiAgY29sb3I6ICMzNzM5M2I7XFxuICBmb250LXNpemU6IDEuM2VtO1xcbiAgbWFyZ2luOiAwLjdlbSAwO1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIC5jb2RlIHtcXG4gIHdpZHRoOiA2MjBweDtcXG59XFxuLmluZGV4LXBhZ2UgLmNvZGUtd3JhcHBlciAuY29kZSBwcmUge1xcbiAgbWFyZ2luOiAxMHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIC5jb2RlIGNvZGUge1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG59XFxuLmluZGV4LXBhZ2UgLmNvZGUtd3JhcHBlciAub3V0cHV0IHtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIG1hcmdpbjogMTBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIC5jb3VudCB7XFxuICBjb2xvcjogIzA5ZDtcXG4gIGZvbnQtc2l6ZTogM2VtO1xcbiAgbWFyZ2luOiAxMHB4IDAgMTJweDtcXG59XFxuLmluZGV4LXBhZ2UgLmNvZGUtd3JhcHBlciAuYnV0dG9uIHtcXG4gIGZvbnQtc2l6ZTogMS4yZW07XFxuICBwYWRkaW5nOiAxMHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuY29kZS13cmFwcGVyIGhlYWRlciB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogMTBweCAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vc3R5bHVzLWxvYWRlcj97XCJpbmNsdWRlIGNzc1wiOnRydWV9IS4vc2l0ZS9wYWdlcy9pbmRleC9pbmRleC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2luZGV4LnN0eWxcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2luZGV4LnN0eWxcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2luZGV4LnN0eWxcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2l0ZS9wYWdlcy9pbmRleC9pbmRleC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAzIl0sInNvdXJjZVJvb3QiOiIifQ==