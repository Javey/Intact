webpackJsonp([0,1,2],Array(27).concat([
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _document = __webpack_require__(140);

var _document2 = _interopRequireDefault(_document);

var _document3 = __webpack_require__(174);

var _document4 = _interopRequireDefault(_document3);

var _throttle = __webpack_require__(170);

var _throttle2 = _interopRequireDefault(_throttle);

var _shuffle = __webpack_require__(168);

var _shuffle2 = _interopRequireDefault(_shuffle);

var _debounce = __webpack_require__(73);

var _debounce2 = _interopRequireDefault(_debounce);

var _utils = __webpack_require__(137);

var _layout = __webpack_require__(138);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

// for debug
window.Intact = Intact;
window._ = { throttle: _throttle2['default'], shuffle: _shuffle2['default'], debounce: _debounce2['default'] };
window.$ = $;

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Layout) {
    _inherits(_default, _Layout);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Layout.apply(this, arguments));
    }

    _default.prototype.defaults = function defaults() {
        return {
            docPath: './docs'
        };
    };

    _default.prototype._init = function _init() {
        var _this2 = this;

        return fetch(this.get('docPath') + '/' + this.get('title') + '.md').then(function (response) {
            return response.text();
        }).then(function (md) {
            _this2.set('content', _utils.marked.render(md));
        });
    };

    _default.prototype._mount = function _mount() {
        _Layout.prototype._mount.call(this);
        var codes = this.element.querySelectorAll('pre code');
        codes.forEach(function (item) {
            _utils.highlight.highlightBlock(item);
        });
        var catalogs = [];
        catalogs.active = 'active1';
        this.element.querySelectorAll('h1').forEach(function (item) {
            var catalog = { title: item.innerText };
            var nextSibling = item.nextSibling;
            while (nextSibling) {
                var tagName = (nextSibling.tagName || '').toLowerCase();
                if (tagName === 'h1') break;
                if (tagName === 'h2') {
                    if (!catalog.subs) {
                        catalog.subs = [];
                        catalog.subs.active = 'active2';
                    }
                    catalog.subs.push({
                        title: nextSibling.innerText
                    });
                }
                nextSibling = nextSibling.nextSibling;
            }
            catalogs.push(catalog);
        });
        this.set('subCatalogs', catalogs);

        this.evalScript();
        this.onScroll();
    };

    _default.prototype.evalScript = function evalScript() {
        var $examples = $(this.element).find('.example');
        var template = void 0;
        for (var i = 0; i < $examples.length; i++) {
            var $example = $examples.eq(i);
            var code = $example.text();
            if ($example.hasClass('auto')) {
                var _C = void 0;
                if ($example.hasClass('language-html')) {
                    template = Intact.Vdt.compile(code);
                    _C = Intact.extend({
                        template: template
                    });
                } else if ($example.hasClass('javascript')) {
                    _C = eval(code);
                }
                var $container = $('<div class="output"></div>');
                $example.parent().after($container);
                Intact.mount(_C, $container[0]);
            } else if ($example.hasClass('manual')) {
                var $button = $('<button>点击运行</button>');
                var $p = $('<p></p>').append($button);
                $example.parent().after($p);
                $button.on('click', function (code) {
                    return function () {
                        eval(code);
                    };
                }(code));
            } else if ($example.hasClass('language-html')) {
                template = Intact.Vdt.compile(code);
            } else if ($example.hasClass('javascript')) {
                eval(code);
            } else if ($example.hasClass('language-css')) {
                $example.parent().after('<style>' + code + '</style>');
            }
        }

        // 执行script标签
        var $scripts = $(this.element).find('script');
        for (var _i = 0; _i < $scripts.length; _i++) {
            var $script = $scripts.eq(_i);
            var _code = $script.text();
            eval(_code);
        }
    };

    _default.prototype.onScroll = function onScroll() {
        var _this3 = this;

        var $wrapper = $(this.element).find('.content-wrapper');
        var $article = $(this.element).find('article');
        var $h1s = $article.find('h1');
        var $h2s = $article.find('h2');
        var $aside = $(this.element).find('aside');
        var $border = $aside.find('.aside-border');
        var $window = $(window);
        $window.off('scroll');
        $window.on('scroll.fix', function () {
            var scrollTop = $(window).scrollTop();
            $wrapper[scrollTop >= 15 ? 'addClass' : 'removeClass']('fixed');
        });
        $window.on('scroll.active', (0, _throttle2['default'])(function () {
            var scrollTop = $(window).scrollTop();

            function findActive($hs) {
                var minTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                for (var i = $hs.length - 1; i >= 0; i--) {
                    var $h = $hs.eq(i);
                    var top = $h.position().top;
                    if (top > minTop && scrollTop >= top - 60) {
                        return {
                            text: $h.text(),
                            top: top
                        };
                    }
                }
                return { text: '', top: 0 };
            }

            var active1 = findActive($h1s);
            var active2 = findActive($h2s, active1.top);

            _this3.set({
                active2: active2.text,
                active1: active1.text
            });

            var $activeA = $aside.find('.active').last().children('a');
            if ($activeA.length) {
                var height = $activeA.height();
                var top = $activeA.position().top;
                $border.css({ height: height, top: top });
            }
        }, 50));
        $window.trigger('scroll');
    };

    _default.prototype.scrollTo = function scrollTo(text, type) {
        var _this4 = this;

        var $article = $(this.element).find('article');
        var $hs = $article.find(type === 'active1' ? 'h1' : 'h2');

        for (var i = 0; i < $hs.length; i++) {
            var $h = $hs.eq(i);
            if ($h.text() === text) {
                var top = $h.position().top;
                $(window).off('scroll.active');
                $('html, body').animate({
                    scrollTop: top - 60
                }, {
                    complete: function complete() {
                        _this4.onScroll();
                    }
                });
                break;
            }
        }
    };

    _default.prototype._destroy = function _destroy() {
        $(window).off('scroll');
    };

    return _default;
}(_layout2['default']), _class2.template = _document2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)["default"], __webpack_require__(26)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact) {exports.__esModule = true;
exports['default'] = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _desc, _value, _class;

var _document = __webpack_require__(27);

var _document2 = _interopRequireDefault(_document);

var _api = __webpack_require__(175);

var _api2 = _interopRequireDefault(_api);

var _api3 = __webpack_require__(177);

var _api4 = _interopRequireDefault(_api3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = function (_DocumentPage) {
    _inherits(_default, _DocumentPage);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _DocumentPage.apply(this, arguments));
    }

    _createClass(_default, [{
        key: 'template',
        get: function get() {
            return _api2['default'];
        }
    }]);

    return _default;
}(_document2['default']), (_applyDecoratedDescriptor(_class.prototype, 'template', [_dec], Object.getOwnPropertyDescriptor(_class.prototype, 'template'), _class.prototype)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)["default"]))

/***/ }),
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact) {exports.__esModule = true;
exports['default'] = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _api = __webpack_require__(28);

var _api2 = _interopRequireDefault(_api);

var _index = __webpack_require__(178);

var _index2 = _interopRequireDefault(_index);

__webpack_require__(182);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Api) {
    _inherits(_default, _Api);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Api.apply(this, arguments));
    }

    _default.prototype.defaults = function defaults() {
        return _extends({}, _Api.prototype.defaults.call(this), {
            docPath: './docs/blogs'
        });
    };

    return _default;
}(_api2['default']), _class2.template = _index2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)["default"]))

/***/ }),
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(60);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(55);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(64);
exports.lib.ucmicro = __webpack_require__(136);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 53 */
/***/ (function(module, exports) {



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 54 */
/***/ (function(module, exports) {



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E49\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(70),
    getRawTag = __webpack_require__(153),
    objectToString = __webpack_require__(158);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(71);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {



/*eslint quotes:0*/
module.exports = __webpack_require__(139);

/***/ }),
/* 61 */
/***/ (function(module, exports) {



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 62 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
};

/***/ }),
/* 63 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {



module.exports.encode = __webpack_require__(131);
module.exports.decode = __webpack_require__(130);
module.exports.format = __webpack_require__(132);
module.exports.parse = __webpack_require__(133);

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 69 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(59);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(69)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom = __webpack_require__(147);

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
    var index = -1,
        length = array.length,
        lastIndex = length - 1;

    size = size === undefined ? length : size;
    while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
    }
    array.length = size;
    return array;
}

module.exports = shuffleSelf;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(57),
    now = __webpack_require__(167),
    toNumber = __webpack_require__(171);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    var nav = [{
        title: '教程',
        href: 'document'
    }, {
        title: 'API',
        href: 'api'
    }, {
        title: 'Blog',
        href: 'blog'
    }];
    return h('div', null, [h('div', null, h('header', null, (_blocks['header'] = function (parent) {
        return [h('a', {
            'href': '#/'
        }, 'Intact', 'logo'), h('nav', null, [__m(function () {
            try {
                return nav;
            } catch (e) {
                _e(e);
            }
        }.call($this), function (value, key) {
            return h('a', {
                'href': function () {
                    try {
                        return '#/' + value.href;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this)
            }, function () {
                try {
                    return value.title;
                } catch (e) {
                    _e(e);
                }
            }.call($this), _className(function () {
                try {
                    return {
                        active: value.href === scope.navIndex
                    };
                } catch (e) {
                    _e(e);
                }
            }.call($this)));
        }, $this), h('div', null, null, 'border')])];
    }) && (__blocks['header'] = function (parent) {
        var args = arguments;
        return blocks['header'] ? blocks['header'].apply($this, [function () {
            return _blocks['header'].apply($this, args);
        }].concat(__slice.call(args, 1))) : _blocks['header'].apply($this, args);
    }) && __blocks['header'].apply($this, [__noop])), 'header-wrapper'), h('div', null, (_blocks['content'] = function (parent) {
        return null;
    }) && (__blocks['content'] = function (parent) {
        var args = arguments;
        return blocks['content'] ? blocks['content'].apply($this, [function () {
            return _blocks['content'].apply($this, args);
        }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
    }) && __blocks['content'].apply($this, [__noop]), 'content-wrapper')], _className(function () {
        try {
            return 'main-wrapper ' + (scope.className || '');
        } catch (e) {
            _e(e);
        }
    }.call($this)));
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function (factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if (true) {
    factory(exports);
  } else if (globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return globalObject.hljs;
      });
    }
  }
})(function (hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent) {
    // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent) {
      result[key] = parent[key];
    }objects.forEach(function (obj) {
      for (key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:
       if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;
       ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace('"', '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function expand_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function (variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];
  }

  function compileLanguage(language) {

    function reStr(re) {
      return re && re.source || re;
    }

    function langRe(value, global) {
      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }

    function compileMode(mode, parent) {
      if (mode.compiled) return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function flatten(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function (kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') {
          // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin) mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null) mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {
        return expand_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function (c) {
        compileMode(c, mode);
      });

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = mode.contains.map(function (c) {
        return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function exec() /*s*/{
          return null;
        } };
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:
   - relevance (int)
  - value (an HTML string with highlighting markup)
   */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan = '<span class="' + classPrefix,
          closeSpan = leaveOpen ? '' : spanEndTag;

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords) return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += top.subLanguage != null ? processSubLanguage() : processKeywords();
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className ? buildSpan(mode.className, '', true) : '';
      top = Object.create(mode, { parent: { value: top } });
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '',
        current;
    for (current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match,
          count,
          index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match) break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:
   - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)
   */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:
   - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers
   */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {
      if (options.useBR && match === '\n') {
        return '<br>';
      } else if (options.tabReplace) {
        return p1.replace(/\t/g, options.tabReplace);
      }
      return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language)) return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function (alias) {
        aliases[alias] = name;
      });
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
      className: 'comment',
      begin: begin, end: end,
      contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [hljs.BACKSLASH_ESCAPE, {
      begin: /\[/, end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
});

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var VAR = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d#@][\w\d_]*/ }, { begin: /\$\{(.*?)}/ }]
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: /"/, end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, {
      className: 'variable',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  var APOS_STRING = {
    className: 'string',
    begin: /'/, end: /'/
  };

  return {
    aliases: ['sh', 'zsh'],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: 'if then else elif fi for while in do done case esac function',
      literal: 'true false',
      built_in:
      // Shell built-ins
      // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' + 'trap umask unset ' +
      // Bash built-ins
      'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' + 'read readarray source type typeset ulimit unalias ' +
      // Shell modifiers
      'set shopt ' +
      // Zsh built-ins
      'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' + 'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' + 'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' + 'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' + 'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' + 'zpty zregexparse zsocket zstyle ztcp',
      _: '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster
    },
    contains: [{
      className: 'meta',
      begin: /^#![^\n]+sh\s*$/,
      relevance: 10
    }, {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, hljs.HASH_COMMENT_MODE, QUOTE_STRING, APOS_STRING, VAR]
  };
};

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /[A-Z\_\.\-]+\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [{
      className: 'attribute',
      begin: /\S/, end: ':', excludeEnd: true,
      starts: {
        endsWithParent: true, excludeEnd: true,
        contains: [{
          begin: /[\w-]+\(/, returnBegin: true,
          contains: [{
            className: 'built_in',
            begin: /[\w-]+/
          }, {
            begin: /\(/, end: /\)/,
            contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
          }]
        }, hljs.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, hljs.C_BLOCK_COMMENT_MODE, {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        }, {
          className: 'meta', begin: '!important'
        }]
      }
    }]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [hljs.C_BLOCK_COMMENT_MODE, {
      className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
    }, {
      className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
    }, {
      className: 'selector-attr',
      begin: /\[/, end: /\]/,
      illegal: '$'
    }, {
      className: 'selector-pseudo',
      begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
    }, {
      begin: '@(font-face|page)',
      lexemes: '[a-z-]+',
      keywords: 'font-face page'
    }, {
      begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
      // because it doesn’t let it to be parsed as
      // a rule set but instead drops parser into
      // the default mode which is how it should be.
      illegal: /:/, // break on Less variables @var: ...
      contains: [{
        className: 'keyword',
        begin: /\w+/
      }, {
        begin: /\s/, endsWithParent: true, excludeEnd: true,
        relevance: 0,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, hljs.CSS_NUMBER_MODE]
      }]
    }, {
      className: 'selector-tag', begin: IDENT_RE,
      relevance: 0
    }, {
      begin: '{', end: '}',
      illegal: /\S/,
      contains: [hljs.C_BLOCK_COMMENT_MODE, RULE]
    }]
  };
};

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' +
    // ECMAScript 6 modules import
    'import from as',

    literal: 'true false null undefined NaN Infinity',
    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'
  };
  var EXPRESSIONS;
  var NUMBER = {
    className: 'number',
    variants: [{ begin: '\\b(0[bB][01]+)' }, { begin: '\\b(0[oO][0-7]+)' }, { begin: hljs.C_NUMBER_RE }],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: [] // defined later
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];
  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);

  return {
    aliases: ['js', 'jsx'],
    keywords: KEYWORDS,
    contains: [{
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, {
      className: 'meta',
      begin: /^#!/, end: /$/
    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, { // object attr container
      begin: /[{,]\s*/, relevance: 0,
      contains: [{
        begin: IDENT_RE + '\\s*:', returnBegin: true,
        relevance: 0,
        contains: [{ className: 'attr', begin: IDENT_RE, relevance: 0 }]
      }]
    }, { // "value" container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
      keywords: 'return throw case',
      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {
        className: 'function',
        begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
        end: '\\s*=>',
        contains: [{
          className: 'params',
          variants: [{
            begin: IDENT_RE
          }, {
            begin: /\(\s*\)/
          }, {
            begin: /\(/, end: /\)/,
            excludeBegin: true, excludeEnd: true,
            keywords: KEYWORDS,
            contains: PARAMS_CONTAINS
          }]
        }]
      }, { // E4X / JSX
        begin: /</, end: /(\/\w+|\w+\/)>/,
        subLanguage: 'xml',
        contains: [{ begin: /<\w+\s*\/>/, skip: true }, {
          begin: /<\w+/, end: /(\/\w+|\w+\/)>/, skip: true,
          contains: [{ begin: /<\w+\s*\/>/, skip: true }, 'self']
        }]
      }],
      relevance: 0
    }, {
      className: 'function',
      beginKeywords: 'function', end: /\{/, excludeEnd: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }), {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        contains: PARAMS_CONTAINS
      }],
      illegal: /\[|%/
    }, {
      begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
    }, hljs.METHOD_GUARD, { // ES6 class
      className: 'class',
      beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
      illegal: /[:"\[\]]/,
      contains: [{ beginKeywords: 'extends' }, hljs.UNDERSCORE_TITLE_MODE]
    }, {
      beginKeywords: 'constructor', end: /\{/, excludeEnd: true
    }],
    illegal: /#(?!!)/
  };
};

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [{
      className: 'attr',
      begin: XML_IDENT_RE,
      relevance: 0
    }, {
      begin: /=\s*/,
      relevance: 0,
      contains: [{
        className: 'string',
        endsParent: true,
        variants: [{ begin: /"/, end: /"/ }, { begin: /'/, end: /'/ }, { begin: /[^\s"'=<>`]+/ }]
      }]
    }]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
    case_insensitive: true,
    contains: [{
      className: 'meta',
      begin: '<!DOCTYPE', end: '>',
      relevance: 10,
      contains: [{ begin: '\\[', end: '\\]' }]
    }, hljs.COMMENT('<!--', '-->', {
      relevance: 10
    }), {
      begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
      relevance: 10
    }, {
      begin: /<\?(php)?/, end: /\?>/,
      subLanguage: 'php',
      contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
    }, {
      className: 'tag',
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending braket. The '$' is needed for the lexeme to be recognized
      by hljs.subMode() that tests lexemes outside the stream.
      */
      begin: '<style(?=\\s|>|$)', end: '>',
      keywords: { name: 'style' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '</style>', returnEnd: true,
        subLanguage: ['css', 'xml']
      }
    }, {
      className: 'tag',
      // See the comment in the <style tag about the lookahead pattern
      begin: '<script(?=\\s|>|$)', end: '>',
      keywords: { name: 'script' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '\<\/script\>', returnEnd: true,
        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
      }
    }, {
      className: 'meta',
      variants: [{ begin: /<\?xml/, end: /\?>/, relevance: 10 }, { begin: /<\?\w+/, end: /\?>/ }]
    }, {
      className: 'tag',
      begin: '</?', end: '/?>',
      contains: [{
        className: 'name', begin: /[^\/><\s]+/, relevance: 0
      }, TAG_INTERNALS]
    }]
  };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(83)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(67).source;
  re.src_Cc = __webpack_require__(65).source;
  re.src_Z = __webpack_require__(66).source;
  re.src_P = __webpack_require__(55).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 84 */
/***/ (function(module, exports) {


/* eslint-disable no-cond-assign */

var tagExpr = /^<!-- ?\{(?:([a-z0-9]+)(\^[0-9]*)?: ?)?(.*)\} ?-->\n?$/;

module.exports = function attributes(md) {
  md.core.ruler.push('curly_attributes', curlyAttrs);
};

/*
 * List of tag -> token type mappings. Eg, `<li>` is `list_item_open`.
 */

var opening = {
  li: ['list_item'],
  ul: ['bullet_list'],
  p: ['paragraph'],
  ol: ['ordered_list'],
  blockquote: ['blockquote'],
  h1: ['heading'],
  h2: ['heading'],
  h3: ['heading'],
  h4: ['heading'],
  h5: ['heading'],
  h6: ['heading'],
  a: ['link'],
  code: ['code_inline', 'code_block', 'fence']
};

var selfClosing = {
  hr: true,
  image: true

  /**
   * ...
   */

};function curlyAttrs(state) {
  var tokens = state.tokens;
  var omissions = [];
  var parent, m;
  var stack = { len: 0, contents: [], types: {} };

  tokens.forEach(function (token, i) {
    // Save breadcrumbs so html_block will pick it up
    if (isOpener(token.type) || selfClosing[token.type]) {
      spush(stack, token);
    }

    // "# Hello\n<!--{.classname}-->"
    // ...sequence of [heading_open, inline, heading_close, html_block]
    if (token.type === 'html_block') {
      m = token.content.match(tagExpr);
      if (!m) return;

      parent = findParent(stack, m[1], m[2]);
      if (parent && applyToToken(parent, m[3])) {
        omissions.unshift(i);
      }
    }

    // "# Hello <!--{.classname} -->"
    // { type: 'inline', children: { ..., '<!--{...}-->' } }
    if (token.type === 'inline') {
      curlyInline(token.children, stack);
    }
  });

  // Remove <!--...--> html_block tokens
  omissions.forEach(function (idx) {
    return tokens.splice(idx, 1);
  });
}

/**
 * Internal: checks in a token type is a block opener
 */

function isOpener(type) {
  return type.match(/_(open|start)$/) || type === 'fence' || type === 'code_block';
}

/**
 * Internal: Run through inline and stuff
 */

function curlyInline(children, stack) {
  var lastText, m, parent;

  // Keep a list of sub-tokens to be removed
  var omissions = [];

  children.forEach(function (child, i) {
    if (isOpener(child.type) || selfClosing[child.type] || child.type === 'code_inline') {
      spush(stack, child);
    }

    // Decorate tags are found
    if (m = child.content.match(tagExpr)) {
      var tag = m[1];
      var depth = m[2];
      var attrs = m[3];

      // Remove the comment, then remove the extra space
      parent = findParent(stack, tag, depth);
      if (parent && applyToToken(parent, attrs)) {
        omissions.unshift(i);
        if (lastText) trimRight(lastText, 'content');
      }
    }

    if (child.type === 'text') lastText = child;
  });

  // Remove them in a separate step so we don't
  omissions.forEach(function (idx) {
    children.splice(idx, 1);
  });
}

/**
 * Private: given a list of tokens `list` and `lastParent`, find the one that
 * matches `tag`.
 */

function findParent(stack, tag, depth) {
  if (!tag) return stack.last;

  if (depth === '^') {
    depth = 1;
  } else if (typeof depth === 'string') {
    /* '^2' */
    depth = +depth.substr(1);
  } else {
    depth = 0;
  }

  var targets = opening[tag.toLowerCase()] || [tag.toLowerCase()];

  var target = targets.filter(function (target) {
    return stack.types[target];
  });

  var list = stack.types[target];
  if (!list) return; // Can't find tag `tag`

  return list[list.length - 1 - depth];
}

/**
 * Private: trim the right
 */

function trimRight(obj, attr) {
  obj[attr] = obj[attr].replace(/\s*$/, '');
}

/**
 * Private: apply tag to token
 *
 *     applyToToken(token, '.classname')
 */

function applyToToken(token, attrs) {
  var m;
  var todo = [];

  while (attrs.length > 0) {
    if (m = attrs.match(/^\s*\.([a-zA-Z0-9\-_]+)/)) {
      todo.push(['class', m[1], { append: true }]);
      shift();
    } else if (m = attrs.match(/^\s*#([a-zA-Z0-9\-_]+)/)) {
      todo.push(['id', m[1]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)="([^"]*)"/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)='([^']*)'/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)=([^ ]*)/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)/)) {
      todo.push([m[1], '']);
      shift();
    } else if (m = attrs.match(/^\s+/)) {
      shift();
    } else {
      return;
    }
  }

  todo.forEach(function (args) {
    setAttr.apply(this, [token].concat(args));
  });
  return true;

  function shift() {
    attrs = attrs.substr(m[0].length);
  }
}

/**
 * Private: sets an attribute `attr` to `value` in a token. If `options.append`
 * is true, append to the old value instead of overwriting it.
 */

function setAttr(token, attr, value, options) {
  var idx = token.attrIndex(attr);

  if (idx === -1) {
    token.attrPush([attr, value]);
  } else if (options && options.append) {
    token.attrs[idx][1] = token.attrs[idx][1] + ' ' + value;
  } else {
    token.attrs[idx][1] = value;
  }
}

/**
 * Private: pushes a token to the stack
 */

function spush(stack, token) {
  var type = token.type.replace(/_(open|start)$/, '');
  if (!stack.types[type]) {
    stack.types[type] = [];
  }
  stack.types[type].push(token);
  stack.last = token;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = __webpack_require__(91);

/***/ }),
/* 86 */
/***/ (function(module, exports) {



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {



exports.parseLinkLabel = __webpack_require__(89);
exports.parseLinkDestination = __webpack_require__(88);
exports.parseLinkTitle = __webpack_require__(90);

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;
var unescapeAll = __webpack_require__(52).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
      }

    if (code === 0x29 /* ) */) {
        if (level === 0) {
          break;
        }
        level--;
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 89 */
/***/ (function(module, exports) {



module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {



var unescapeAll = __webpack_require__(52).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {



var utils = __webpack_require__(52);
var helpers = __webpack_require__(87);
var Renderer = __webpack_require__(98);
var ParserCore = __webpack_require__(93);
var ParserBlock = __webpack_require__(92);
var ParserInline = __webpack_require__(94);
var LinkifyIt = __webpack_require__(82);
var mdurl = __webpack_require__(64);
var punycode = __webpack_require__(134);

var config = {
  'default': __webpack_require__(96),
  zero: __webpack_require__(97),
  commonmark: __webpack_require__(95)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(110), ['paragraph', 'reference']], ['code', __webpack_require__(100)], ['fence', __webpack_require__(101), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(99), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(103), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(106), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(108)], ['heading', __webpack_require__(102), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(105)], ['html_block', __webpack_require__(104), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(107)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(109);

module.exports = ParserBlock;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

var _rules = [['normalize', __webpack_require__(114)], ['block', __webpack_require__(111)], ['inline', __webpack_require__(112)], ['linkify', __webpack_require__(113)], ['replacements', __webpack_require__(115)], ['smartquotes', __webpack_require__(116)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(117);

module.exports = Core;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(128)], ['newline', __webpack_require__(126)], ['escape', __webpack_require__(122)], ['backticks', __webpack_require__(119)], ['strikethrough', __webpack_require__(63).tokenize], ['emphasis', __webpack_require__(62).tokenize], ['link', __webpack_require__(125)], ['image', __webpack_require__(124)], ['autolink', __webpack_require__(118)], ['html_inline', __webpack_require__(123)], ['entity', __webpack_require__(121)]];

var _rules2 = [['balance_pairs', __webpack_require__(120)], ['strikethrough', __webpack_require__(63).postProcess], ['emphasis', __webpack_require__(62).postProcess], ['text_collapse', __webpack_require__(129)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(127);

module.exports = ParserInline;

/***/ }),
/* 95 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 96 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 97 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {



var assign = __webpack_require__(52).assign;
var unescapeAll = __webpack_require__(52).unescapeAll;
var escapeHtml = __webpack_require__(52).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false;

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !wasOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 100 */
/***/ (function(module, exports) {



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {



var block_names = __webpack_require__(86);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(61).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 105 */
/***/ (function(module, exports) {



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 107 */
/***/ (function(module, exports) {



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);
var isSpace = __webpack_require__(52).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {



module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {



var arrayReplaceAt = __webpack_require__(52).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 114 */
/***/ (function(module, exports) {



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 115 */
/***/ (function(module, exports) {



// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {



var isWhiteSpace = __webpack_require__(52).isWhiteSpace;
var isPunctChar = __webpack_require__(52).isPunctChar;
var isMdAsciiPunct = __webpack_require__(52).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (tokens[j].type !== 'text') continue;

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (tokens[j].type !== 'text') continue;

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 118 */
/***/ (function(module, exports) {



/*eslint max-len:0*/
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 119 */
/***/ (function(module, exports) {



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 120 */
/***/ (function(module, exports) {



module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {



var entities = __webpack_require__(60);
var has = __webpack_require__(52).has;
var isValidEntityCode = __webpack_require__(52).isValidEntityCode;
var fromCodePoint = __webpack_require__(52).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {



var HTML_TAG_RE = __webpack_require__(61).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);
var isWhiteSpace = __webpack_require__(52).isWhiteSpace;
var isPunctChar = __webpack_require__(52).isPunctChar;
var isMdAsciiPunct = __webpack_require__(52).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 128 */
/***/ (function(module, exports) {



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 129 */
/***/ (function(module, exports) {



module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 130 */
/***/ (function(module, exports) {



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 131 */
/***/ (function(module, exports) {



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 132 */
/***/ (function(module, exports) {



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 133 */
/***/ (function(module, exports) {



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(68)) == 'object' && __webpack_require__(68)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module), __webpack_require__(69)))

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {



exports.Any = __webpack_require__(67);
exports.Cc = __webpack_require__(65);
exports.Cf = __webpack_require__(135);
exports.P = __webpack_require__(55);
exports.Z = __webpack_require__(66);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.marked = exports.highlight = undefined;

var _markdownIt = __webpack_require__(85);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _markdownItDecorate = __webpack_require__(84);

var _markdownItDecorate2 = _interopRequireDefault(_markdownItDecorate);

var _highlight = __webpack_require__(77);

var _highlight2 = _interopRequireDefault(_highlight);

var _javascript = __webpack_require__(80);

var _javascript2 = _interopRequireDefault(_javascript);

var _css = __webpack_require__(79);

var _css2 = _interopRequireDefault(_css);

var _xml = __webpack_require__(81);

var _xml2 = _interopRequireDefault(_xml);

var _bash = __webpack_require__(78);

var _bash2 = _interopRequireDefault(_bash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_highlight2['default'].registerLanguage('bash', _bash2['default']);
_highlight2['default'].registerLanguage('css', _css2['default']);
_highlight2['default'].registerLanguage('javascript', _javascript2['default']);
_highlight2['default'].registerLanguage('xml', _xml2['default']);

window.highlight = _highlight2['default'];

var marked = (0, _markdownIt2['default'])({
    html: true,
    breaks: false
}).use(_markdownItDecorate2['default']);
// 去掉段落softbreak
marked.renderer.rules.softbreak = function () {
    return '';
};

exports.highlight = _highlight2['default'];
exports.marked = marked;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _layout = __webpack_require__(76);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Intact) {
    _inherits(_default, _Intact);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _default.prototype._mount = function _mount() {
        this.$border = $(this.element).find('.border');
        this._updateBorder();
    };

    _default.prototype._updateBorder = function _updateBorder() {
        var $nav = $(this.element).find('.active');
        var width = 0;
        var left = 0;
        if ($nav.length) {
            left = $nav.position().left;
            width = $nav.outerWidth();
        }
        this.$border.addClass('transition');
        this.$border.css({ width: width, left: left });
    };

    return _default;
}(Intact), _class2.template = _layout2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)["default"], __webpack_require__(26)))

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    var catalogs = [{
        title: '基础',
        subCatalogs: [{
            title: '开始',
            href: 'start'
        }, {
            title: 'Intact实例',
            href: 'instance'
        }, {
            title: '组件生命周期',
            href: 'lifecycle'
        }, {
            title: '模板语法',
            href: 'syntax'
        }, {
            title: '事件处理',
            href: 'event'
        }, {
            title: '表单处理',
            href: 'form'
        }, {
            title: '组件',
            href: 'component'
        }, {
            title: '组件继承',
            href: 'extend'
        }]
    }, {
        title: '进阶',
        subCatalogs: [{
            title: '动画',
            href: 'animation'
        }, {
            title: '模板template',
            href: 'template'
        }, {
            title: '路由',
            href: 'router'
        }, {
            title: 'webpack实践',
            href: 'project'
        }, {
            title: '服务器端渲染',
            href: 'ssr'
        }]
    }, {
        title: '其它',
        subCatalogs: [{
            title: '更新日志',
            href: 'changelog'
        }]
    }];
    var currentNav = {};

    var Subs = function Subs(attr) {
        return function () {
            try {
                return attr.subs;
            } catch (e) {
                _e(e);
            }
        }.call($this) ? h('ul', null, __m(function () {
            try {
                return attr.subs;
            } catch (e) {
                _e(e);
            }
        }.call($this), function (value, key) {
            return h('li', null, [h('a', {
                'ev-click': function () {
                    try {
                        return self.scrollTo.bind(self, value.title, attr.subs.active);
                    } catch (e) {
                        _e(e);
                    }
                }.call($this)
            }, function () {
                try {
                    return value.title;
                } catch (e) {
                    _e(e);
                }
            }.call($this)), h(Subs, {
                'subs': function () {
                    try {
                        return value.subs;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this),
                '_context': $this
            })], _className(function () {
                try {
                    return {
                        active: self.get(attr.subs.active) === value.title
                    };
                } catch (e) {
                    _e(e);
                }
            }.call($this)));
        }, $this), 'sub-catalogs') : undefined;
    };
    return function () {
        var _obj = _extends({
            'navIndex': 'document',
            'className': 'document-page'
        }, function () {
            try {
                return scope;
            } catch (e) {
                _e(e);
            }
        }.call($this));
        return parent.call($this, _obj, _Vdt, function (blocks) {
            var _blocks = {},
                __blocks = extend({}, blocks);
            return (_blocks['content'] = function (parent) {
                return [h('aside', null, h('div', null, [__m(function () {
                    try {
                        return catalogs;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this), function (value, key) {
                    return h('div', null, [h('h5', null, function () {
                        try {
                            return value.title;
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)), h('ul', null, __m(function () {
                        try {
                            return value.subCatalogs;
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this), function (value, key) {
                        return h('li', null, [function () {
                            try {
                                return function () {
                                    if (value.href === self.get('title')) {
                                        currentNav = value;
                                    }
                                }();
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this), h('a', {
                            'href': function () {
                                try {
                                    return '#/document/' + value.href;
                                } catch (e) {
                                    _e(e);
                                }
                            }.call($this)
                        }, function () {
                            try {
                                return value.title;
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this)), function () {
                            try {
                                return value.href === self.get('title');
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this) ? h(Subs, {
                            'subs': function () {
                                try {
                                    return self.get('subCatalogs');
                                } catch (e) {
                                    _e(e);
                                }
                            }.call($this),
                            '_context': $this
                        }) : undefined], _className(function () {
                            try {
                                return {
                                    active: value.href === self.get('title')
                                };
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this)));
                    }, $this))], 'catalog-section');
                }, $this), h('div', null, null, 'aside-border transition')], 'aside-wrapper')), h('article', null, [h('div', null, [h('div', null, function () {
                    try {
                        return currentNav.title;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this), 'title'), h('div', null, ['\n                    如果你发现文档有问题，请帮忙在\n                    ', h('a', {
                    'target': '_blank',
                    'href': function () {
                        try {
                            return 'https://github.com/Javey/Intact/blob/master/docs/' + self.get('title') + '.md';
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)
                }, 'github'), '\n                    上修正该文档\n                '], 'edit-link')], 'article-head'), h('div', {
                    'innerHTML': function () {
                        try {
                            return self.get('content');
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)
                })])];
            }) && (__blocks['content'] = function (parent) {
                var args = arguments;
                return blocks['content'] ? blocks['content'].apply($this, [function () {
                    return _blocks['content'].apply($this, args);
                }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
            }), __blocks;
        }.call($this, blocks), parent);
    }.call($this);
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(149),
    isArguments = __webpack_require__(160),
    isArray = __webpack_require__(74),
    isBuffer = __webpack_require__(162),
    isIndex = __webpack_require__(154),
    isTypedArray = __webpack_require__(165);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray = __webpack_require__(152),
    shuffleSelf = __webpack_require__(72);

/**
 * A specialized version of `_.shuffle` for arrays.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function arrayShuffle(array) {
  return shuffleSelf(copyArray(array));
}

module.exports = arrayShuffle;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(56),
    isObjectLike = __webpack_require__(58);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(56),
    isLength = __webpack_require__(75),
    isObjectLike = __webpack_require__(58);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(155),
    nativeKeys = __webpack_require__(156);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 147 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var shuffleSelf = __webpack_require__(72),
    values = __webpack_require__(172);

/**
 * The base implementation of `_.shuffle`.
 *
 * @private
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function baseShuffle(collection) {
  return shuffleSelf(values(collection));
}

module.exports = baseShuffle;

/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(142);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(70);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(159);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(71);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module)))

/***/ }),
/* 158 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(144),
    isObjectLike = __webpack_require__(58);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(163),
    isLength = __webpack_require__(75);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(59),
    stubFalse = __webpack_require__(169);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(56),
    isObject = __webpack_require__(57);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(56),
    isObjectLike = __webpack_require__(58);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(145),
    baseUnary = __webpack_require__(150),
    nodeUtil = __webpack_require__(157);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(141),
    baseKeys = __webpack_require__(146),
    isArrayLike = __webpack_require__(161);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(59);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var arrayShuffle = __webpack_require__(143),
    baseShuffle = __webpack_require__(148),
    isArray = __webpack_require__(74);

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  var func = isArray(collection) ? arrayShuffle : baseShuffle;
  return func(collection);
}

module.exports = shuffle;

/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(73),
    isObject = __webpack_require__(57);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(57),
    isSymbol = __webpack_require__(164);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(151),
    keys = __webpack_require__(166);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(15)(false);
// imports


// module
exports.push([module.i, ".hljs {\n  display: block;\n  overflow-x: auto;\n  color: #525252;\n  padding: 15px;\n  -webkit-text-size-adjust: none;\n  margin: 0;\n}\n.hljs-doctype {\n  color: #999;\n}\n.hljs-tag {\n  color: #3e76f6;\n}\n.hljs-attribute {\n  color: #e96900;\n}\n.hljs-value {\n  color: #42b983;\n}\n.hljs-keyword {\n  color: #e96900;\n}\n.hljs-string {\n  color: #42b983;\n}\n.hljs-comment {\n  color: #b3b3b3;\n}\n.hljs-operator .hljs-comment {\n  color: #525252;\n}\n.hljs-regexp {\n  color: #af7dff;\n}\n.hljs-built_in {\n  color: #2db7f5;\n}\n.css .hljs-class {\n  color: #e96900;\n}\n.css .hljs-number,\n.javascript .hljs-number {\n  color: #fc1e70;\n}\n.css .hljs-attribute {\n  color: #af7dff;\n}\n.css .hljs-important {\n  color: #d04;\n}\n.actionscript .hljs-literal,\n.javascript .hljs-literal {\n  color: #fc1e70;\n}\npre {\n  padding: 0;\n  margin: 0;\n}\ncode {\n  display: inline-block;\n  background: #f7f7f7;\n  font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;\n  margin: 3px;\n  padding: 1px 5px;\n  border-radius: 3px;\n  color: #666;\n  border: 1px solid #eee;\n  line-height: 20px;\n}\n.document-page {\n  padding-top: 95px;\n  box-sizing: border-box;\n}\n.document-page .content-wrapper.fixed {\n  margin-bottom: 0;\n}\n.document-page .content-wrapper.fixed .aside-wrapper {\n  position: fixed;\n  top: 80px;\n  background: #fff;\n  height: calc(100% - 80px);\n  overflow: auto;\n  box-sizing: border-box;\n  width: 200px;\n}\n.document-page .content-wrapper {\n  width: 1080px;\n  display: flex;\n  background: #fff;\n  margin: 0 auto;\n  border-radius: 5px;\n  box-shadow: 0 1px 1px rgba(0,0,0,0.08);\n  min-height: calc(100% - 15px);\n}\n.document-page .content-wrapper aside {\n  width: 200px;\n  border-right: 1px solid #eee;\n}\n.document-page .content-wrapper .aside-wrapper {\n  position: relative;\n}\n.document-page .content-wrapper .aside-wrapper h5 {\n  font-size: 16px;\n  margin: 25px 0 15px 20px;\n  color: #999;\n}\n.document-page .content-wrapper .aside-wrapper ul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.document-page .content-wrapper .aside-wrapper a {\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  padding-left: 25px;\n  color: #333;\n}\n.document-page .content-wrapper .aside-wrapper a:hover {\n  background: #f3f3f3;\n}\n.document-page .content-wrapper .aside-wrapper .active > a {\n  color: #fe4444;\n}\n.document-page .content-wrapper .aside-wrapper .sub-catalogs {\n  margin-left: 10px;\n  font-size: 12px;\n}\n.document-page .content-wrapper .aside-wrapper .aside-border {\n  border-right: 2px solid #fe4444;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.document-page .content-wrapper article {\n  flex: 1;\n  padding: 10px 20px;\n  overflow: auto;\n}\n.document-page .content-wrapper .article-head .title {\n  padding: 10px 0;\n  font-size: 2.2em;\n  color: #000;\n  display: inline-block;\n}\n.document-page .content-wrapper .article-head .edit-link {\n  display: inline-block;\n  margin-left: 20px;\n  color: #999;\n  font-style: italic;\n}\n.document-page .content-wrapper article h1 {\n  padding: 10px 0;\n  border-bottom: 1px solid #eee;\n  margin: 20px 0;\n}\n.document-page .content-wrapper article h2,\n.document-page .content-wrapper article h3 {\n  padding: 10px 0;\n  margin: 15px 0;\n}\n.document-page .content-wrapper article p {\n  line-height: 25px;\n}\n.document-page .content-wrapper article .output {\n  padding: 20px;\n  border: 1px solid #eee;\n  margin: 20px 0;\n}\n", ""]);

// exports


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(173);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(16)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    var Subs = function Subs(attr) {
        return function () {
            try {
                return attr.subs;
            } catch (e) {
                _e(e);
            }
        }.call($this) ? h('ul', null, __m(function () {
            try {
                return attr.subs;
            } catch (e) {
                _e(e);
            }
        }.call($this), function (value, key) {
            return h('li', null, [h('a', {
                'ev-click': function () {
                    try {
                        return self.scrollTo.bind(self, value.title, attr.subs.active);
                    } catch (e) {
                        _e(e);
                    }
                }.call($this)
            }, function () {
                try {
                    return value.title;
                } catch (e) {
                    _e(e);
                }
            }.call($this)), h(Subs, {
                'subs': function () {
                    try {
                        return value.subs;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this),
                '_context': $this
            })], _className(function () {
                try {
                    return {
                        active: self.get(attr.subs.active) === value.title
                    };
                } catch (e) {
                    _e(e);
                }
            }.call($this)));
        }, $this), _className(function () {
            try {
                return { "sub-catalogs": !attr.isFirst };
            } catch (e) {
                _e(e);
            }
        }.call($this))) : undefined;
    };
    return function () {
        var _obj = _extends({
            'navIndex': 'api',
            'className': 'document-page api-page'
        }, function () {
            try {
                return scope;
            } catch (e) {
                _e(e);
            }
        }.call($this));
        return parent.call($this, _obj, _Vdt, function (blocks) {
            var _blocks = {},
                __blocks = extend({}, blocks);
            return (_blocks['content'] = function (parent) {
                return [h('aside', null, h('div', null, [h(Subs, {
                    'subs': function () {
                        try {
                            return self.get('subCatalogs');
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this),
                    'isFirst': function () {
                        try {
                            return true;
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this),
                    '_context': $this
                }), h('div', null, null, 'aside-border transition')], 'aside-wrapper')), h('article', null, h('div', {
                    'innerHTML': function () {
                        try {
                            return self.get('content');
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)
                }))];
            }) && (__blocks['content'] = function (parent) {
                var args = arguments;
                return blocks['content'] ? blocks['content'].apply($this, [function () {
                    return _blocks['content'].apply($this, args);
                }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
            }), __blocks;
        }.call($this, blocks), parent);
    }.call($this);
};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(15)(false);
// imports


// module
exports.push([module.i, ".api-page .content-wrapper aside {\n  padding: 20px 0;\n}\n", ""]);

// exports


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(176);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(16)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./api.styl", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./api.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    return function () {
        var _obj = {
            'navIndex': 'blog',
            'className': 'document-page blog-page'
        };
        return parent.call($this, _obj, _Vdt, blocks, parent);
    }.call($this);
};

/***/ }),
/* 179 */,
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(15)(false);
// imports


// module
exports.push([module.i, ".blog-page .content-wrapper {\n  box-shadow: none;\n  flex-direction: row-reverse;\n}\n.blog-page .content-wrapper aside {\n  width: 350px;\n  border: none;\n  background: #eee;\n}\n.blog-page .content-wrapper article {\n  box-shadow: 0 1px 1px rgba(0,0,0,0.08);\n}\n.blog-page .content-wrapper .aside-wrapper {\n  margin: 30px;\n}\n.blog-page .content-wrapper .aside-wrapper .aside-border {\n  left: 0;\n  right: auto !important;\n}\n.blog-page .content-wrapper.fixed .aside-wrapper {\n  margin-right: -999px;\n  padding-right: 999px;\n  background: none;\n  width: auto;\n}\n", ""]);

// exports


/***/ }),
/* 181 */,
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(180);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(16)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./index.styl", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./index.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvYXBpL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvYmxvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvdG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zaHVmZmxlU2VsZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzTGVuZ3RoLmpzIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvbGF5b3V0LnZkdCIsIndlYnBhY2s6Ly8vLi9+L2hpZ2hsaWdodC5qcy9saWIvaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9saW5raWZ5LWl0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbGlua2lmeS1pdC9saWIvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC1kZWNvcmF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tZHVybC9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL34vdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NpdGUvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvbGF5b3V0LmpzIiwid2VicGFjazovLy8uL34vZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQudmR0Iiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlTaHVmZmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUmFuZG9tLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlU2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbm93LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3NodWZmbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3Rocm90dGxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3ZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWwiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC5zdHlsP2JjOTIiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9hcGkvYXBpLnZkdCIsIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2FwaS9hcGkuc3R5bCIsIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2FwaS9hcGkuc3R5bD81ZmEwIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvYmxvZy9pbmRleC52ZHQiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9ibG9nL2luZGV4LnN0eWwiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9ibG9nL2luZGV4LnN0eWw/ZTZiYSJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJJbnRhY3QiLCJfIiwidGhyb3R0bGUiLCJzaHVmZmxlIiwiZGVib3VuY2UiLCIkIiwidGVtcGxhdGUiLCJkZWZhdWx0cyIsImRvY1BhdGgiLCJfaW5pdCIsImZldGNoIiwiZ2V0IiwidGhlbiIsInJlc3BvbnNlIiwidGV4dCIsInNldCIsIm1hcmtlZCIsInJlbmRlciIsIm1kIiwiX21vdW50IiwiY29kZXMiLCJlbGVtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJoaWdobGlnaHQiLCJoaWdobGlnaHRCbG9jayIsIml0ZW0iLCJjYXRhbG9ncyIsImFjdGl2ZSIsImNhdGFsb2ciLCJ0aXRsZSIsImlubmVyVGV4dCIsIm5leHRTaWJsaW5nIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwic3VicyIsInB1c2giLCJldmFsU2NyaXB0Iiwib25TY3JvbGwiLCIkZXhhbXBsZXMiLCJmaW5kIiwiaSIsImxlbmd0aCIsIiRleGFtcGxlIiwiZXEiLCJjb2RlIiwiaGFzQ2xhc3MiLCJfQyIsIlZkdCIsImNvbXBpbGUiLCJleHRlbmQiLCJldmFsIiwiJGNvbnRhaW5lciIsInBhcmVudCIsImFmdGVyIiwibW91bnQiLCIkYnV0dG9uIiwiJHAiLCJhcHBlbmQiLCJvbiIsIiRzY3JpcHRzIiwiJHNjcmlwdCIsIiR3cmFwcGVyIiwiJGFydGljbGUiLCIkaDFzIiwiJGgycyIsIiRhc2lkZSIsIiRib3JkZXIiLCIkd2luZG93Iiwib2ZmIiwic2Nyb2xsVG9wIiwiZmluZEFjdGl2ZSIsIiRocyIsIm1pblRvcCIsIiRoIiwidG9wIiwicG9zaXRpb24iLCJhY3RpdmUxIiwiYWN0aXZlMiIsIiRhY3RpdmVBIiwibGFzdCIsImNoaWxkcmVuIiwiaGVpZ2h0IiwiY3NzIiwidHJpZ2dlciIsInNjcm9sbFRvIiwidHlwZSIsImFuaW1hdGUiLCJjb21wbGV0ZSIsIl9kZXN0cm95IiwiTGF5b3V0IiwiRG9jdW1lbnRQYWdlIiwiQXBpIiwiX2NsYXNzIiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNTdHJpbmciLCJfaGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsIm9iamVjdCIsImtleSIsImFzc2lnbiIsInNvdXJjZXMiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwic291cmNlIiwiVHlwZUVycm9yIiwia2V5cyIsImFycmF5UmVwbGFjZUF0Iiwic3JjIiwicG9zIiwibmV3RWxlbWVudHMiLCJjb25jYXQiLCJpc1ZhbGlkRW50aXR5Q29kZSIsImMiLCJmcm9tQ29kZVBvaW50Iiwic3Vycm9nYXRlMSIsInN1cnJvZ2F0ZTIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTkVTQ0FQRV9NRF9SRSIsIkVOVElUWV9SRSIsIlVORVNDQVBFX0FMTF9SRSIsIlJlZ0V4cCIsIkRJR0lUQUxfRU5USVRZX1RFU1RfUkUiLCJlbnRpdGllcyIsInJlcXVpcmUiLCJyZXBsYWNlRW50aXR5UGF0dGVybiIsIm1hdGNoIiwibmFtZSIsImNoYXJDb2RlQXQiLCJ0ZXN0IiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwic3RyIiwiaW5kZXhPZiIsInJlcGxhY2UiLCJ1bmVzY2FwZUFsbCIsImVzY2FwZWQiLCJlbnRpdHkiLCJIVE1MX0VTQ0FQRV9URVNUX1JFIiwiSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSIsIkhUTUxfUkVQTEFDRU1FTlRTIiwicmVwbGFjZVVuc2FmZUNoYXIiLCJjaCIsImVzY2FwZUh0bWwiLCJSRUdFWFBfRVNDQVBFX1JFIiwiZXNjYXBlUkUiLCJpc1NwYWNlIiwiaXNXaGl0ZVNwYWNlIiwiVU5JQ09ERV9QVU5DVF9SRSIsImlzUHVuY3RDaGFyIiwiaXNNZEFzY2lpUHVuY3QiLCJub3JtYWxpemVSZWZlcmVuY2UiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJleHBvcnRzIiwibGliIiwibWR1cmwiLCJ1Y21pY3JvIiwiUnVsZXIiLCJfX3J1bGVzX18iLCJfX2NhY2hlX18iLCJfX2ZpbmRfXyIsIl9fY29tcGlsZV9fIiwic2VsZiIsImNoYWlucyIsInJ1bGUiLCJlbmFibGVkIiwiYWx0IiwiYWx0TmFtZSIsImNoYWluIiwiZm4iLCJhdCIsIm9wdGlvbnMiLCJpbmRleCIsIm9wdCIsIkVycm9yIiwiYmVmb3JlIiwiYmVmb3JlTmFtZSIsInJ1bGVOYW1lIiwic3BsaWNlIiwiYWZ0ZXJOYW1lIiwiZW5hYmxlIiwibGlzdCIsImlnbm9yZUludmFsaWQiLCJpc0FycmF5IiwicmVzdWx0IiwiaWR4IiwiZW5hYmxlT25seSIsImRpc2FibGUiLCJnZXRSdWxlcyIsImNoYWluTmFtZSIsIm1vZHVsZSIsIlRva2VuIiwidGFnIiwibmVzdGluZyIsImF0dHJzIiwibWFwIiwibGV2ZWwiLCJjb250ZW50IiwibWFya3VwIiwiaW5mbyIsIm1ldGEiLCJibG9jayIsImhpZGRlbiIsImF0dHJJbmRleCIsImxlbiIsImF0dHJQdXNoIiwiYXR0ckRhdGEiLCJhdHRyU2V0IiwidmFsdWUiLCJhdHRyR2V0IiwiYXR0ckpvaW4iLCJTeW1ib2wiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0IiwiaXNPYmplY3RMaWtlIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiYXR0cl9uYW1lIiwidW5xdW90ZWQiLCJzaW5nbGVfcXVvdGVkIiwiZG91YmxlX3F1b3RlZCIsImF0dHJfdmFsdWUiLCJhdHRyaWJ1dGUiLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsImNvbW1lbnQiLCJwcm9jZXNzaW5nIiwiZGVjbGFyYXRpb24iLCJjZGF0YSIsIkhUTUxfVEFHX1JFIiwiSFRNTF9PUEVOX0NMT1NFX1RBR19SRSIsInRva2VuaXplIiwiZW1waGFzaXMiLCJzdGF0ZSIsInNpbGVudCIsInNjYW5uZWQiLCJ0b2tlbiIsInN0YXJ0IiwibWFya2VyIiwic2NhbkRlbGltcyIsImRlbGltaXRlcnMiLCJqdW1wIiwidG9rZW5zIiwiZW5kIiwib3BlbiIsImNhbl9vcGVuIiwiY2xvc2UiLCJjYW5fY2xvc2UiLCJwb3N0UHJvY2VzcyIsInN0YXJ0RGVsaW0iLCJlbmREZWxpbSIsImlzU3Ryb25nIiwibWF4Iiwic3RyaWtldGhyb3VnaCIsImoiLCJsb25lTWFya2VycyIsInBvcCIsImVuY29kZSIsImRlY29kZSIsImZvcm1hdCIsInBhcnNlIiwiZyIsImUiLCJnbG9iYWwiLCJiYXNlUmFuZG9tIiwic2h1ZmZsZVNlbGYiLCJhcnJheSIsInNpemUiLCJsYXN0SW5kZXgiLCJyYW5kIiwibm93IiwidG9OdW1iZXIiLCJGVU5DX0VSUk9SX1RFWFQiLCJuYXRpdmVNYXgiLCJNYXRoIiwibmF0aXZlTWluIiwibWluIiwiZnVuYyIsIndhaXQiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJ0cmFpbGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwiYXJncyIsInRoaXNBcmciLCJhcHBseSIsImxlYWRpbmdFZGdlIiwic2V0VGltZW91dCIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImNsZWFyVGltZW91dCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0xlbmd0aCIsIl9WZHQiLCJibG9ja3MiLCIkY2FsbGVlIiwiaCIsIm1pc3MiLCJoYyIsImh1Iiwid2lkZ2V0cyIsIl9ibG9ja3MiLCJfX2Jsb2NrcyIsIl9fdSIsInV0aWxzIiwiX2UiLCJlcnJvciIsIl9jbGFzc05hbWUiLCJjbGFzc05hbWUiLCJfX3NsaWNlIiwiX19ub29wIiwibm9vcCIsIl9fbSIsIl9fbyIsIk9wdGlvbnMiLCJfZ2V0TW9kZWwiLCJnZXRNb2RlbCIsIl9zZXRNb2RlbCIsInNldE1vZGVsIiwiX3NldENoZWNrYm94TW9kZWwiLCJzZXRDaGVja2JveE1vZGVsIiwiX2RldGVjdENoZWNrYm94Q2hlY2tlZCIsImRldGVjdENoZWNrYm94Q2hlY2tlZCIsIl9zZXRTZWxlY3RNb2RlbCIsInNldFNlbGVjdE1vZGVsIiwiZGF0YSIsIiR0aGlzIiwic2NvcGUiLCJBbmltYXRlIiwiX3N1cGVyIiwibmF2IiwiaHJlZiIsIm5hdkluZGV4IiwiZmFjdG9yeSIsImdsb2JhbE9iamVjdCIsImhsanMiLCJkZWZpbmUiLCJhbWQiLCJBcnJheVByb3RvIiwib2JqZWN0S2V5cyIsImxhbmd1YWdlcyIsImFsaWFzZXMiLCJub0hpZ2hsaWdodFJlIiwibGFuZ3VhZ2VQcmVmaXhSZSIsImZpeE1hcmt1cFJlIiwic3BhbkVuZFRhZyIsImNsYXNzUHJlZml4IiwidGFiUmVwbGFjZSIsInVzZUJSIiwiZXNjYXBlIiwibm9kZSIsIm5vZGVOYW1lIiwidGVzdFJlIiwicmUiLCJsZXhlbWUiLCJleGVjIiwiaXNOb3RIaWdobGlnaHRlZCIsImxhbmd1YWdlIiwiYmxvY2tMYW5ndWFnZSIsImNsYXNzZXMiLCJwYXJlbnROb2RlIiwiZ2V0TGFuZ3VhZ2UiLCJzcGxpdCIsImluaGVyaXQiLCJvYmplY3RzIiwibm9kZVN0cmVhbSIsIl9ub2RlU3RyZWFtIiwib2Zmc2V0IiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibm9kZVR5cGUiLCJub2RlVmFsdWUiLCJldmVudCIsIm1lcmdlU3RyZWFtcyIsIm9yaWdpbmFsIiwiaGlnaGxpZ2h0ZWQiLCJwcm9jZXNzZWQiLCJub2RlU3RhY2siLCJzZWxlY3RTdHJlYW0iLCJhdHRyX3N0ciIsImEiLCJhdHRyaWJ1dGVzIiwiam9pbiIsInN0cmVhbSIsInN1YnN0cmluZyIsInJldmVyc2UiLCJzdWJzdHIiLCJleHBhbmRfbW9kZSIsIm1vZGUiLCJ2YXJpYW50cyIsImNhY2hlZF92YXJpYW50cyIsInZhcmlhbnQiLCJlbmRzV2l0aFBhcmVudCIsImNvbXBpbGVMYW5ndWFnZSIsInJlU3RyIiwibGFuZ1JlIiwiY2FzZV9pbnNlbnNpdGl2ZSIsImNvbXBpbGVNb2RlIiwiY29tcGlsZWQiLCJrZXl3b3JkcyIsImJlZ2luS2V5d29yZHMiLCJjb21waWxlZF9rZXl3b3JkcyIsImZsYXR0ZW4iLCJrdyIsInBhaXIiLCJOdW1iZXIiLCJsZXhlbWVzUmUiLCJsZXhlbWVzIiwiYmVnaW4iLCJiZWdpblJlIiwiZW5kUmUiLCJ0ZXJtaW5hdG9yX2VuZCIsImlsbGVnYWwiLCJpbGxlZ2FsUmUiLCJyZWxldmFuY2UiLCJjb250YWlucyIsInN0YXJ0cyIsInRlcm1pbmF0b3JzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImlnbm9yZV9pbGxlZ2FscyIsImNvbnRpbnVhdGlvbiIsInN1Yk1vZGUiLCJlbmRPZk1vZGUiLCJlbmRzUGFyZW50IiwiaXNJbGxlZ2FsIiwia2V5d29yZE1hdGNoIiwibWF0Y2hfc3RyIiwiYnVpbGRTcGFuIiwiY2xhc3NuYW1lIiwiaW5zaWRlU3BhbiIsImxlYXZlT3BlbiIsIm5vUHJlZml4Iiwib3BlblNwYW4iLCJjbG9zZVNwYW4iLCJwcm9jZXNzS2V5d29yZHMiLCJrZXl3b3JkX21hdGNoIiwibGFzdF9pbmRleCIsIm1vZGVfYnVmZmVyIiwicHJvY2Vzc1N1Ykxhbmd1YWdlIiwiZXhwbGljaXQiLCJzdWJMYW5ndWFnZSIsImNvbnRpbnVhdGlvbnMiLCJoaWdobGlnaHRBdXRvIiwicHJvY2Vzc0J1ZmZlciIsInN0YXJ0TmV3TW9kZSIsImNyZWF0ZSIsInByb2Nlc3NMZXhlbWUiLCJidWZmZXIiLCJuZXdfbW9kZSIsInNraXAiLCJleGNsdWRlQmVnaW4iLCJyZXR1cm5CZWdpbiIsImVuZF9tb2RlIiwib3JpZ2luIiwicmV0dXJuRW5kIiwiZXhjbHVkZUVuZCIsImN1cnJlbnQiLCJjb3VudCIsIm1lc3NhZ2UiLCJsYW5ndWFnZVN1YnNldCIsInNlY29uZF9iZXN0IiwiZml4TWFya3VwIiwicDEiLCJidWlsZENsYXNzTmFtZSIsInByZXZDbGFzc05hbWUiLCJjdXJyZW50TGFuZyIsInJlc3VsdExhbmciLCJvcmlnaW5hbFN0cmVhbSIsInJlc3VsdE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwiY29uZmlndXJlIiwidXNlcl9vcHRpb25zIiwiaW5pdEhpZ2hsaWdodGluZyIsImNhbGxlZCIsImluaXRIaWdobGlnaHRpbmdPbkxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVnaXN0ZXJMYW5ndWFnZSIsImxhbmciLCJhbGlhcyIsImxpc3RMYW5ndWFnZXMiLCJJREVOVF9SRSIsIlVOREVSU0NPUkVfSURFTlRfUkUiLCJOVU1CRVJfUkUiLCJDX05VTUJFUl9SRSIsIkJJTkFSWV9OVU1CRVJfUkUiLCJSRV9TVEFSVEVSU19SRSIsIkJBQ0tTTEFTSF9FU0NBUEUiLCJBUE9TX1NUUklOR19NT0RFIiwiUVVPVEVfU1RSSU5HX01PREUiLCJQSFJBU0FMX1dPUkRTX01PREUiLCJDT01NRU5UIiwiaW5oZXJpdHMiLCJDX0xJTkVfQ09NTUVOVF9NT0RFIiwiQ19CTE9DS19DT01NRU5UX01PREUiLCJIQVNIX0NPTU1FTlRfTU9ERSIsIk5VTUJFUl9NT0RFIiwiQ19OVU1CRVJfTU9ERSIsIkJJTkFSWV9OVU1CRVJfTU9ERSIsIkNTU19OVU1CRVJfTU9ERSIsIlJFR0VYUF9NT0RFIiwiVElUTEVfTU9ERSIsIlVOREVSU0NPUkVfVElUTEVfTU9ERSIsIk1FVEhPRF9HVUFSRCIsIlZBUiIsIlFVT1RFX1NUUklORyIsIkFQT1NfU1RSSU5HIiwia2V5d29yZCIsImxpdGVyYWwiLCJidWlsdF9pbiIsIlJVTEUiLCJLRVlXT1JEUyIsIkVYUFJFU1NJT05TIiwiTlVNQkVSIiwiU1VCU1QiLCJURU1QTEFURV9TVFJJTkciLCJQQVJBTVNfQ09OVEFJTlMiLCJYTUxfSURFTlRfUkUiLCJUQUdfSU5URVJOQUxTIiwiaXNSZWdFeHAiLCJpc0Z1bmN0aW9uIiwiZGVmYXVsdE9wdGlvbnMiLCJmdXp6eUxpbmsiLCJmdXp6eUVtYWlsIiwiZnV6enlJUCIsImlzT3B0aW9uc09iaiIsInJlZHVjZSIsImFjYyIsImsiLCJkZWZhdWx0U2NoZW1hcyIsInZhbGlkYXRlIiwidGFpbCIsImh0dHAiLCJzcmNfYXV0aCIsInNyY19ob3N0X3BvcnRfc3RyaWN0Iiwic3JjX3BhdGgiLCJub19odHRwIiwic3JjX2RvbWFpbiIsInNyY19kb21haW5fcm9vdCIsInNyY19wb3J0Iiwic3JjX2hvc3RfdGVybWluYXRvciIsIm1haWx0byIsInNyY19lbWFpbF9uYW1lIiwic3JjX2hvc3Rfc3RyaWN0IiwidGxkc18yY2hfc3JjX3JlIiwidGxkc19kZWZhdWx0IiwicmVzZXRTY2FuQ2FjaGUiLCJfX2luZGV4X18iLCJfX3RleHRfY2FjaGVfXyIsImNyZWF0ZVZhbGlkYXRvciIsImNyZWF0ZU5vcm1hbGl6ZXIiLCJub3JtYWxpemUiLCJfX29wdHNfXyIsInRsZHMiLCJfX3RsZHNfXyIsIm9uQ29tcGlsZSIsIl9fdGxkc19yZXBsYWNlZF9fIiwic3JjX3huIiwic3JjX3RsZHMiLCJ1bnRwbCIsInRwbCIsImVtYWlsX2Z1enp5IiwidHBsX2VtYWlsX2Z1enp5IiwibGlua19mdXp6eSIsInRwbF9saW5rX2Z1enp5IiwibGlua19ub19pcF9mdXp6eSIsInRwbF9saW5rX25vX2lwX2Z1enp5IiwiaG9zdF9mdXp6eV90ZXN0IiwidHBsX2hvc3RfZnV6enlfdGVzdCIsIl9fY29tcGlsZWRfXyIsInNjaGVtYUVycm9yIiwidmFsIiwiX19zY2hlbWFzX18iLCJsaW5rIiwic2xpc3QiLCJzY2hlbWFfdGVzdCIsInNyY19aUENjIiwic2NoZW1hX3NlYXJjaCIsInByZXRlc3QiLCJNYXRjaCIsInNoaWZ0IiwiX19sYXN0X2luZGV4X18iLCJzY2hlbWEiLCJfX3NjaGVtYV9fIiwicmF3IiwidXJsIiwiY3JlYXRlTWF0Y2giLCJMaW5raWZ5SXQiLCJzY2hlbWFzIiwiYWRkIiwiZGVmaW5pdGlvbiIsIm0iLCJtbCIsIm1lIiwibmV4dCIsInRsZF9wb3MiLCJhdF9wb3MiLCJ0ZXN0U2NoZW1hQXQiLCJzZWFyY2giLCJrZWVwT2xkIiwic29ydCIsImVsIiwiYXJyIiwib3B0cyIsInNyY19BbnkiLCJzcmNfQ2MiLCJzcmNfWiIsInNyY19QIiwic3JjX1pDYyIsInRleHRfc2VwYXJhdG9ycyIsInNyY19wc2V1ZG9fbGV0dGVyIiwic3JjX2lwNCIsInNyY19ob3N0IiwidHBsX2hvc3RfZnV6enkiLCJ0cGxfaG9zdF9ub19pcF9mdXp6eSIsInRwbF9ob3N0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QiLCJ0YWdFeHByIiwiY29yZSIsInJ1bGVyIiwiY3VybHlBdHRycyIsIm9wZW5pbmciLCJsaSIsInVsIiwicCIsIm9sIiwiYmxvY2txdW90ZSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsInNlbGZDbG9zaW5nIiwiaHIiLCJpbWFnZSIsIm9taXNzaW9ucyIsInN0YWNrIiwiY29udGVudHMiLCJ0eXBlcyIsImlzT3BlbmVyIiwic3B1c2giLCJmaW5kUGFyZW50IiwiYXBwbHlUb1Rva2VuIiwidW5zaGlmdCIsImN1cmx5SW5saW5lIiwibGFzdFRleHQiLCJkZXB0aCIsInRyaW1SaWdodCIsInRhcmdldHMiLCJ0YXJnZXQiLCJhdHRyIiwidG9kbyIsInNldEF0dHIiLCJwYXJzZUxpbmtMYWJlbCIsInBhcnNlTGlua0Rlc3RpbmF0aW9uIiwicGFyc2VMaW5rVGl0bGUiLCJsaW5lcyIsIm9rIiwiZGlzYWJsZU5lc3RlZCIsImZvdW5kIiwicHJldlBvcyIsImxhYmVsRW5kIiwicG9zTWF4Iiwib2xkUG9zIiwiaW5saW5lIiwic2tpcFRva2VuIiwiaGVscGVycyIsIlJlbmRlcmVyIiwiUGFyc2VyQ29yZSIsIlBhcnNlckJsb2NrIiwiUGFyc2VySW5saW5lIiwicHVueWNvZGUiLCJjb25maWciLCJ6ZXJvIiwiY29tbW9ubWFyayIsIkJBRF9QUk9UT19SRSIsIkdPT0RfREFUQV9SRSIsInZhbGlkYXRlTGluayIsIlJFQ09ERV9IT1NUTkFNRV9GT1IiLCJub3JtYWxpemVMaW5rIiwicGFyc2VkIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRvQVNDSUkiLCJlciIsIm5vcm1hbGl6ZUxpbmtUZXh0IiwidG9Vbmljb2RlIiwiTWFya2Rvd25JdCIsInByZXNldE5hbWUiLCJyZW5kZXJlciIsImxpbmtpZnkiLCJwcmVzZXRzIiwiY29tcG9uZW50cyIsInJ1bGVzIiwicnVsZXMyIiwicnVsZXIyIiwibWlzc2VkIiwidXNlIiwicGx1Z2luIiwiZW52IiwiU3RhdGUiLCJwcm9jZXNzIiwicGFyc2VJbmxpbmUiLCJpbmxpbmVNb2RlIiwicmVuZGVySW5saW5lIiwiX3J1bGVzIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsImxpbmUiLCJoYXNFbXB0eUxpbmVzIiwibWF4TmVzdGluZyIsInNraXBFbXB0eUxpbmVzIiwic0NvdW50IiwiYmxrSW5kZW50IiwidGlnaHQiLCJpc0VtcHR5Iiwib3V0VG9rZW5zIiwibGluZU1heCIsIkNvcmUiLCJsIiwiX3J1bGVzMiIsImNhY2hlIiwicGVuZGluZyIsInB1c2hQZW5kaW5nIiwiaHRtbCIsInhodG1sT3V0IiwiYnJlYWtzIiwibGFuZ1ByZWZpeCIsInR5cG9ncmFwaGVyIiwicXVvdGVzIiwiZGVmYXVsdF9ydWxlcyIsImNvZGVfaW5saW5lIiwic2xmIiwicmVuZGVyQXR0cnMiLCJjb2RlX2Jsb2NrIiwiZmVuY2UiLCJsYW5nTmFtZSIsInRtcEF0dHJzIiwidG1wVG9rZW4iLCJyZW5kZXJJbmxpbmVBc1RleHQiLCJyZW5kZXJUb2tlbiIsImhhcmRicmVhayIsInNvZnRicmVhayIsImh0bWxfYmxvY2siLCJodG1sX2lubGluZSIsIm5leHRUb2tlbiIsIm5lZWRMZiIsImFkanVzdFRhYiIsImluaXRpYWwiLCJsYXN0TGluZUVtcHR5IiwibmV4dExpbmUiLCJvbGRCTWFya3MiLCJvbGRCU0NvdW50Iiwib2xkSW5kZW50Iiwib2xkUGFyZW50VHlwZSIsIm9sZFNDb3VudCIsIm9sZFRTaGlmdCIsInNwYWNlQWZ0ZXJNYXJrZXIiLCJ0ZXJtaW5hdGUiLCJ0ZXJtaW5hdG9yUnVsZXMiLCJ3YXNPdXRkZW50ZWQiLCJvbGRMaW5lTWF4IiwiYk1hcmtzIiwidFNoaWZ0IiwiZU1hcmtzIiwiYnNDb3VudCIsInBhcmVudFR5cGUiLCJnZXRMaW5lcyIsInBhcmFtcyIsIm1lbSIsImhhdmVFbmRNYXJrZXIiLCJza2lwQ2hhcnMiLCJza2lwU3BhY2VzIiwiaGVhZGluZyIsInRtcCIsInNraXBTcGFjZXNCYWNrIiwic2tpcENoYXJzQmFjayIsImNudCIsImJsb2NrX25hbWVzIiwiSFRNTF9TRVFVRU5DRVMiLCJsaW5lVGV4dCIsImxoZWFkaW5nIiwic2tpcEJ1bGxldExpc3RNYXJrZXIiLCJza2lwT3JkZXJlZExpc3RNYXJrZXIiLCJtYXJrVGlnaHRQYXJhZ3JhcGhzIiwiY29udGVudFN0YXJ0IiwiaW5kZW50IiwiaW5kZW50QWZ0ZXJNYXJrZXIiLCJpc09yZGVyZWQiLCJpdGVtTGluZXMiLCJsaXN0TGluZXMiLCJsaXN0VG9rSWR4IiwibWFya2VyQ2hhckNvZGUiLCJtYXJrZXJWYWx1ZSIsIm9sZExJbmRlbnQiLCJvbGRUaWdodCIsInBvc0FmdGVyTWFya2VyIiwicHJldkVtcHR5RW5kIiwiaXNUZXJtaW5hdGluZ1BhcmFncmFwaCIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIl9lbmRMaW5lIiwiZGVzdEVuZFBvcyIsImRlc3RFbmRMaW5lTm8iLCJsYWJlbCIsInJlcyIsInJlZmVyZW5jZXMiLCJTdGF0ZUJsb2NrIiwicyIsImluZGVudF9mb3VuZCIsImRkSW5kZW50IiwiZnJvbSIsImtlZXBMYXN0TEYiLCJsaW5lSW5kZW50IiwiZmlyc3QiLCJxdWV1ZSIsImxpbmVTdGFydCIsImdldExpbmUiLCJlc2NhcGVkU3BsaXQiLCJlc2NhcGVzIiwibGFzdFBvcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJ0YWJsZSIsImNvbHVtbnMiLCJjb2x1bW5Db3VudCIsImFsaWducyIsInQiLCJ0YWJsZUxpbmVzIiwidGJvZHlMaW5lcyIsInRvayIsImlzTGlua09wZW4iLCJpc0xpbmtDbG9zZSIsImN1cnJlbnRUb2tlbiIsIm5vZGVzIiwibG4iLCJodG1sTGlua0xldmVsIiwiZnVsbFVybCIsInVybFRleHQiLCJibG9ja1Rva2VucyIsImxpbmtzIiwiTkVXTElORVNfUkUiLCJOVUxMX1JFIiwiUkFSRV9SRSIsIlNDT1BFRF9BQkJSX1RFU1RfUkUiLCJTQ09QRURfQUJCUl9SRSIsIlNDT1BFRF9BQkJSIiwiciIsInRtIiwicmVwbGFjZUZuIiwicmVwbGFjZV9zY29wZWQiLCJpbmxpbmVUb2tlbnMiLCJpbnNpZGVfYXV0b2xpbmsiLCJyZXBsYWNlX3JhcmUiLCJibGtJZHgiLCJRVU9URV9URVNUX1JFIiwiUVVPVEVfUkUiLCJBUE9TVFJPUEhFIiwicmVwbGFjZUF0IiwicHJvY2Vzc19pbmxpbmVzIiwidGhpc0xldmVsIiwibGFzdENoYXIiLCJuZXh0Q2hhciIsImlzTGFzdFB1bmN0Q2hhciIsImlzTmV4dFB1bmN0Q2hhciIsImlzTGFzdFdoaXRlU3BhY2UiLCJpc05leHRXaGl0ZVNwYWNlIiwiY2FuT3BlbiIsImNhbkNsb3NlIiwiaXNTaW5nbGUiLCJvcGVuUXVvdGUiLCJjbG9zZVF1b3RlIiwiT1VURVIiLCJzaW5nbGUiLCJzbWFydHF1b3RlcyIsIlN0YXRlQ29yZSIsIkVNQUlMX1JFIiwiQVVUT0xJTktfUkUiLCJhdXRvbGluayIsImxpbmtNYXRjaCIsImVtYWlsTWF0Y2giLCJiYWNrdGljayIsIm1hdGNoU3RhcnQiLCJtYXRjaEVuZCIsImxpbmtfcGFpcnMiLCJsYXN0RGVsaW0iLCJjdXJyRGVsaW0iLCJvZGRfbWF0Y2giLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJFU0NBUEVEIiwiaXNMZXR0ZXIiLCJsYyIsImxhYmVsU3RhcnQiLCJyZWYiLCJwYXJzZVJlZmVyZW5jZSIsIm5ld2xpbmUiLCJwbWF4IiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJsZWZ0X2ZsYW5raW5nIiwicmlnaHRfZmxhbmtpbmciLCJpc1Rlcm1pbmF0b3JDaGFyIiwidGV4dF9jb2xsYXBzZSIsImN1cnIiLCJkZWNvZGVDYWNoZSIsImdldERlY29kZUNhY2hlIiwiZXhjbHVkZSIsInN0cmluZyIsImRlZmF1bHRDaGFycyIsInNlcSIsImIxIiwiYjIiLCJiMyIsImI0IiwiY2hyIiwiY29tcG9uZW50Q2hhcnMiLCJlbmNvZGVDYWNoZSIsImdldEVuY29kZUNhY2hlIiwia2VlcEVzY2FwZWQiLCJuZXh0Q29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsInBhdGhuYW1lIiwiaGFzaCIsIlVybCIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwidXJsUGFyc2UiLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJsb3dlclByb3RvIiwiaGVjIiwicmVzdCIsInNpbXBsZVBhdGgiLCJwcm90byIsImhvc3RFbmQiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsImhvc3QiLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwicW0iLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJmbG9vciIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIlJhbmdlRXJyb3IiLCJtYXBEb21haW4iLCJwYXJ0cyIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwib3V0IiwibiIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJ3IiwiYmFzZU1pbnVzVCIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsIkFueSIsIkNjIiwiQ2YiLCJQIiwiWiIsImxCYXNoIiwibENzcyIsImxKYXZhc2NyaXB0IiwibFhtbCIsIk1hcmtkb3duSXREZWNvcmF0ZSIsIl91cGRhdGVCb3JkZXIiLCIkbmF2Iiwid2lkdGgiLCJsZWZ0Iiwib3V0ZXJXaWR0aCIsImFkZENsYXNzIiwic3ViQ2F0YWxvZ3MiLCJjdXJyZW50TmF2IiwiU3VicyIsImJpbmQiLCJfb2JqIiwiYmFzZVRpbWVzIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzSW5kZXgiLCJpc1R5cGVkQXJyYXkiLCJvYmplY3RQcm90byIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiY29weUFycmF5IiwiYXJyYXlTaHVmZmxlIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImlzUHJvdG90eXBlIiwibmF0aXZlS2V5cyIsImJhc2VLZXlzIiwibmF0aXZlRmxvb3IiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJsb3dlciIsInVwcGVyIiwidmFsdWVzIiwiYmFzZVNodWZmbGUiLCJjb2xsZWN0aW9uIiwiYmFzZVVuYXJ5IiwiYmFzZVZhbHVlcyIsInByb3BzIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsInVubWFza2VkIiwicmVJc1VpbnQiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJvdmVyQXJnIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwidHJhbnNmb3JtIiwiYXJnIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FycmF5TGlrZSIsInN0dWJGYWxzZSIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiYXN5bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwibm9kZUlzVHlwZWRBcnJheSIsIkRhdGUiLCJOQU4iLCJyZVRyaW0iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsIm90aGVyIiwidmFsdWVPZiIsImlzQmluYXJ5IiwiaXNGaXJzdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0FBLE9BQU9DLE1BQVAsR0FBZ0JBLE1BQWhCO0FBQ0FELE9BQU9FLENBQVAsR0FBVyxFQUFDQywrQkFBRCxFQUFXQyw2QkFBWCxFQUFvQkMsK0JBQXBCLEVBQVg7QUFDQUwsT0FBT00sQ0FBUCxHQUFXQSxDQUFYOzt1QkFHS0wsT0FBT00sUUFBUCxFOzs7Ozs7Ozs7dUJB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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQyIsImZpbGUiOiJzdGF0aWMvY2h1bmsvMmUxYzQ4MzgzYjYyNDc2ZmQwNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9kb2N1bWVudC52ZHQnO1xuaW1wb3J0IGNzcyBmcm9tICcuL2RvY3VtZW50LnN0eWwnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc2h1ZmZsZSBmcm9tICdsb2Rhc2gvc2h1ZmZsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB7aGlnaGxpZ2h0LCBtYXJrZWR9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbi8vIGZvciBkZWJ1Z1xud2luZG93LkludGFjdCA9IEludGFjdDtcbndpbmRvdy5fID0ge3Rocm90dGxlLCBzaHVmZmxlLCBkZWJvdW5jZX07XG53aW5kb3cuJCA9ICQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBASW50YWN0LnRlbXBsYXRlKClcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgIGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9jUGF0aDogJy4vZG9jcydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKGAke3RoaXMuZ2V0KCdkb2NQYXRoJyl9LyR7dGhpcy5nZXQoJ3RpdGxlJyl9Lm1kYCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KS50aGVuKG1kID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCdjb250ZW50JywgbWFya2VkLnJlbmRlcihtZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfbW91bnQoKSB7XG4gICAgICAgIHN1cGVyLl9tb3VudCgpO1xuICAgICAgICBjb25zdCBjb2RlcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICBjb2Rlcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaGlnaGxpZ2h0LmhpZ2hsaWdodEJsb2NrKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2F0YWxvZ3MgPSBbXTtcbiAgICAgICAgY2F0YWxvZ3MuYWN0aXZlID0gJ2FjdGl2ZTEnO1xuICAgICAgICB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgY2F0YWxvZyA9IHt0aXRsZTogaXRlbS5pbm5lclRleHR9O1xuICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gaXRlbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSAobmV4dFNpYmxpbmcudGFnTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2gxJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdoMicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXRhbG9nLnN1YnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGFsb2cuc3VicyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0YWxvZy5zdWJzLmFjdGl2ZSA9ICdhY3RpdmUyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRhbG9nLnN1YnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbmV4dFNpYmxpbmcuaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0YWxvZ3MucHVzaChjYXRhbG9nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0KCdzdWJDYXRhbG9ncycsIGNhdGFsb2dzKTtcblxuICAgICAgICB0aGlzLmV2YWxTY3JpcHQoKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCgpO1xuICAgIH1cblxuICAgIGV2YWxTY3JpcHQoKSB7XG4gICAgICAgIGNvbnN0ICRleGFtcGxlcyA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuZXhhbXBsZScpO1xuICAgICAgICBsZXQgdGVtcGxhdGU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgJGV4YW1wbGUgPSAkZXhhbXBsZXMuZXEoaSk7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICRleGFtcGxlLnRleHQoKTtcbiAgICAgICAgICAgIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnYXV0bycpKSB7XG4gICAgICAgICAgICAgICAgbGV0IF9DO1xuICAgICAgICAgICAgICAgIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbGFuZ3VhZ2UtaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gSW50YWN0LlZkdC5jb21waWxlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBfQyA9IEludGFjdC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2phdmFzY3JpcHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBfQyA9IGV2YWwoY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCAkY29udGFpbmVyID0gJCgnPGRpdiBjbGFzcz1cIm91dHB1dFwiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICRleGFtcGxlLnBhcmVudCgpLmFmdGVyKCRjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIEludGFjdC5tb3VudChfQywgJGNvbnRhaW5lclswXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdtYW51YWwnKSkge1xuICAgICAgICAgICAgICAgIGxldCAkYnV0dG9uID0gJCgnPGJ1dHRvbj7ngrnlh7vov5DooYw8L2J1dHRvbj4nKTtcbiAgICAgICAgICAgICAgICBsZXQgJHAgPSAkKCc8cD48L3A+JykuYXBwZW5kKCRidXR0b24pO1xuICAgICAgICAgICAgICAgICRleGFtcGxlLnBhcmVudCgpLmFmdGVyKCRwKTtcbiAgICAgICAgICAgICAgICAkYnV0dG9uLm9uKCdjbGljaycsICgoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KShjb2RlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdsYW5ndWFnZS1odG1sJykpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IEludGFjdC5WZHQuY29tcGlsZShjb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2phdmFzY3JpcHQnKSkge1xuICAgICAgICAgICAgICAgIGV2YWwoY29kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdsYW5ndWFnZS1jc3MnKSkge1xuICAgICAgICAgICAgICAgICRleGFtcGxlLnBhcmVudCgpLmFmdGVyKGA8c3R5bGU+JHtjb2RlfTwvc3R5bGU+YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmiafooYxzY3JpcHTmoIfnrb5cbiAgICAgICAgY29uc3QgJHNjcmlwdHMgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnc2NyaXB0Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCAkc2NyaXB0ID0gJHNjcmlwdHMuZXEoaSk7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICRzY3JpcHQudGV4dCgpO1xuICAgICAgICAgICAgZXZhbChjb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICBjb25zdCAkd3JhcHBlciA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuY29udGVudC13cmFwcGVyJyk7XG4gICAgICAgIGNvbnN0ICRhcnRpY2xlID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJ2FydGljbGUnKTtcbiAgICAgICAgY29uc3QgJGgxcyA9ICRhcnRpY2xlLmZpbmQoJ2gxJyk7XG4gICAgICAgIGNvbnN0ICRoMnMgPSAkYXJ0aWNsZS5maW5kKCdoMicpO1xuICAgICAgICBjb25zdCAkYXNpZGUgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnYXNpZGUnKTtcbiAgICAgICAgY29uc3QgJGJvcmRlciA9ICRhc2lkZS5maW5kKCcuYXNpZGUtYm9yZGVyJyk7XG4gICAgICAgIGNvbnN0ICR3aW5kb3cgPSAkKHdpbmRvdyk7XG4gICAgICAgICR3aW5kb3cub2ZmKCdzY3JvbGwnKTtcbiAgICAgICAgJHdpbmRvdy5vbignc2Nyb2xsLmZpeCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICR3cmFwcGVyW3Njcm9sbFRvcCA+PSAxNSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnZml4ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgICR3aW5kb3cub24oJ3Njcm9sbC5hY3RpdmUnLCB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRBY3RpdmUoJGhzLCBtaW5Ub3AgPSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9ICRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJGggPSAkaHMuZXEoaSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSAkaC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCAmJiBzY3JvbGxUb3AgPj0gdG9wIC0gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJGgudGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7dGV4dDogJycsIHRvcDogMH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZTEgPSBmaW5kQWN0aXZlKCRoMXMpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlMiA9IGZpbmRBY3RpdmUoJGgycywgYWN0aXZlMS50b3ApO1xuXG4gICAgICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgICAgICAgYWN0aXZlMjogYWN0aXZlMi50ZXh0LFxuICAgICAgICAgICAgICAgIGFjdGl2ZTE6IGFjdGl2ZTEudGV4dCBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCAkYWN0aXZlQSA9ICRhc2lkZS5maW5kKCcuYWN0aXZlJykubGFzdCgpLmNoaWxkcmVuKCdhJyk7XG4gICAgICAgICAgICBpZiAoJGFjdGl2ZUEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9ICRhY3RpdmVBLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSAkYWN0aXZlQS5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAkYm9yZGVyLmNzcyh7aGVpZ2h0OiBoZWlnaHQsIHRvcDogdG9wfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDUwKSk7XG4gICAgICAgICR3aW5kb3cudHJpZ2dlcignc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgc2Nyb2xsVG8odGV4dCwgdHlwZSkge1xuICAgICAgICBjb25zdCAkYXJ0aWNsZSA9ICQodGhpcy5lbGVtZW50KS5maW5kKCdhcnRpY2xlJyk7XG4gICAgICAgIGNvbnN0ICRocyA9ICRhcnRpY2xlLmZpbmQodHlwZSA9PT0gJ2FjdGl2ZTEnID8gJ2gxJyA6ICdoMicpO1xuICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0ICRoID0gJGhzLmVxKGkpO1xuICAgICAgICAgICAgaWYgKCRoLnRleHQoKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSAkaC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICAgICAkKHdpbmRvdykub2ZmKCdzY3JvbGwuYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHRvcCAtIDYwXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsJyk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS9wYWdlcy9kb2N1bWVudC9pbmRleC5qcyIsImltcG9ydCBEb2N1bWVudFBhZ2UgZnJvbSAnLi4vZG9jdW1lbnQnO1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vYXBpLnZkdCc7XG5pbXBvcnQgY3NzIGZyb20gJy4vYXBpLnN0eWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIERvY3VtZW50UGFnZSB7XG4gICAgQEludGFjdC50ZW1wbGF0ZSgpXG4gICAgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gdGVtcGxhdGU7IH0gXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaXRlL3BhZ2VzL2FwaS9pbmRleC5qcyIsImltcG9ydCBBcGkgZnJvbSAnLi4vYXBpJztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL2luZGV4LnZkdCc7XG5pbXBvcnQgJy4vaW5kZXguc3R5bCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQXBpIHtcbiAgICBASW50YWN0LnRlbXBsYXRlKClcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgIGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuZGVmYXVsdHMoKSxcbiAgICAgICAgICAgIGRvY1BhdGg6ICcuL2RvY3MvYmxvZ3MnLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvcGFnZXMvYmxvZy9pbmRleC5qcyIsIi8vIFV0aWxpdGllc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIFJlbW92ZSBlbGVtZW50IGZyb20gYXJyYXkgYW5kIHB1dCBhbm90aGVyIGFycmF5IGF0IHRob3NlIHBvc2l0aW9uLlxuLy8gVXNlZnVsIGZvciBzb21lIG9wZXJhdGlvbnMgd2l0aCB0b2tlbnNcbmZ1bmN0aW9uIGFycmF5UmVwbGFjZUF0KHNyYywgcG9zLCBuZXdFbGVtZW50cykge1xuICByZXR1cm4gW10uY29uY2F0KHNyYy5zbGljZSgwLCBwb3MpLCBuZXdFbGVtZW50cywgc3JjLnNsaWNlKHBvcyArIDEpKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNWYWxpZEVudGl0eUNvZGUoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICAvLyBicm9rZW4gc2VxdWVuY2VcbiAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBuZXZlciB1c2VkXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKChjICYgMHhGRkZGKSA9PT0gMHhGRkZGIHx8IChjICYgMHhGRkZGKSA9PT0gMHhGRkZFKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBjb250cm9sIGNvZGVzXG4gIGlmIChjID49IDB4MDAgJiYgYyA8PSAweDA4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA9PT0gMHgwQikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHgwRSAmJiBjIDw9IDB4MUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4N0YgJiYgYyA8PSAweDlGKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBvdXQgb2YgcmFuZ2VcbiAgaWYgKGMgPiAweDEwRkZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICBpZiAoYyA+IDB4ZmZmZikge1xuICAgIGMgLT0gMHgxMDAwMDtcbiAgICB2YXIgc3Vycm9nYXRlMSA9IDB4ZDgwMCArIChjID4+IDEwKSxcbiAgICAgICAgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjICYgMHgzZmYpO1xuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoc3Vycm9nYXRlMSwgc3Vycm9nYXRlMik7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG59XG5cblxudmFyIFVORVNDQVBFX01EX1JFICA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dKS9nO1xudmFyIEVOVElUWV9SRSAgICAgICA9IC8mKFthLXojXVthLXowLTldezEsMzF9KTsvZ2k7XG52YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKTtcblxudmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG5cbnZhciBlbnRpdGllcyA9IHJlcXVpcmUoJy4vZW50aXRpZXMnKTtcblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIG5hbWUpIHtcbiAgdmFyIGNvZGUgPSAwO1xuXG4gIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGVudGl0aWVzW25hbWVdO1xuICB9XG5cbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMy8qICMgKi8gJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgY29kZSA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxuICAgIDpcbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMSksIDEwKTtcbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcbiAgLy8gaGVyZSB0byBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAvLyBtZW1iZXJzIChtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcyIsIi8qKlxuICogY2xhc3MgUnVsZXJcbiAqXG4gKiBIZWxwZXIgY2xhc3MsIHVzZWQgYnkgW1tNYXJrZG93bkl0I2NvcmVdXSwgW1tNYXJrZG93bkl0I2Jsb2NrXV0gYW5kXG4gKiBbW01hcmtkb3duSXQjaW5saW5lXV0gdG8gbWFuYWdlIHNlcXVlbmNlcyBvZiBmdW5jdGlvbnMgKHJ1bGVzKTpcbiAqXG4gKiAtIGtlZXAgcnVsZXMgaW4gZGVmaW5lZCBvcmRlclxuICogLSBhc3NpZ24gdGhlIG5hbWUgdG8gZWFjaCBydWxlXG4gKiAtIGVuYWJsZS9kaXNhYmxlIHJ1bGVzXG4gKiAtIGFkZC9yZXBsYWNlIHJ1bGVzXG4gKiAtIGFsbG93IGFzc2lnbiBydWxlcyB0byBhZGRpdGlvbmFsIG5hbWVkIGNoYWlucyAoaW4gdGhlIHNhbWUpXG4gKiAtIGNhY2hlaW5nIGxpc3RzIG9mIGFjdGl2ZSBydWxlc1xuICpcbiAqIFlvdSB3aWxsIG5vdCBuZWVkIHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5IHVudGlsIHdyaXRlIHBsdWdpbnMuIEZvciBzaW1wbGVcbiAqIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0sIFtbTWFya2Rvd25JdC5lbmFibGVdXSBhbmRcbiAqIFtbTWFya2Rvd25JdC51c2VdXS5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIG5ldyBSdWxlcigpXG4gKiovXG5mdW5jdGlvbiBSdWxlcigpIHtcbiAgLy8gTGlzdCBvZiBhZGRlZCBydWxlcy4gRWFjaCBlbGVtZW50IGlzOlxuICAvL1xuICAvLyB7XG4gIC8vICAgbmFtZTogWFhYLFxuICAvLyAgIGVuYWJsZWQ6IEJvb2xlYW4sXG4gIC8vICAgZm46IEZ1bmN0aW9uKCksXG4gIC8vICAgYWx0OiBbIG5hbWUyLCBuYW1lMyBdXG4gIC8vIH1cbiAgLy9cbiAgdGhpcy5fX3J1bGVzX18gPSBbXTtcblxuICAvLyBDYWNoZWQgcnVsZSBjaGFpbnMuXG4gIC8vXG4gIC8vIEZpcnN0IGxldmVsIC0gY2hhaW4gbmFtZSwgJycgZm9yIGRlZmF1bHQuXG4gIC8vIFNlY29uZCBsZXZlbCAtIGRpZ2luYWwgYW5jaG9yIGZvciBmYXN0IGZpbHRlcmluZyBieSBjaGFyY29kZXMuXG4gIC8vXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlciBtZXRob2RzLCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcblxuXG4vLyBGaW5kIHJ1bGUgaW5kZXggYnkgbmFtZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2ZpbmRfXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fX3J1bGVzX18ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5fX3J1bGVzX19baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8gQnVpbGQgcnVsZXMgbG9va3VwIGNhY2hlXG4vL1xuUnVsZXIucHJvdG90eXBlLl9fY29tcGlsZV9fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjaGFpbnMgPSBbICcnIF07XG5cbiAgLy8gY29sbGVjdCB1bmlxdWUgbmFtZXNcbiAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gICAgcnVsZS5hbHQuZm9yRWFjaChmdW5jdGlvbiAoYWx0TmFtZSkge1xuICAgICAgaWYgKGNoYWlucy5pbmRleE9mKGFsdE5hbWUpIDwgMCkge1xuICAgICAgICBjaGFpbnMucHVzaChhbHROYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgc2VsZi5fX2NhY2hlX18gPSB7fTtcblxuICBjaGFpbnMuZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0gPSBbXTtcbiAgICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgICAgaWYgKGNoYWluICYmIHJ1bGUuYWx0LmluZGV4T2YoY2hhaW4pIDwgMCkgeyByZXR1cm47IH1cblxuICAgICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dLnB1c2gocnVsZS5mbik7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmF0KG5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIG5hbWUgdG8gcmVwbGFjZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogbmV3IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IG5ldyBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIFJlcGxhY2UgcnVsZSBieSBuYW1lIHdpdGggbmV3IGZ1bmN0aW9uICYgb3B0aW9ucy4gVGhyb3dzIGVycm9yIGlmIG5hbWUgbm90XG4gKiBmb3VuZC5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIFJlcGxhY2UgZXhpc3RpbmcgdHlwb2dyYXBoZXIgcmVwbGFjZW1lbnQgcnVsZSB3aXRoIG5ldyBvbmU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmNvcmUucnVsZXIuYXQoJ3JlcGxhY2VtZW50cycsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAobmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIG5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmZuID0gZm47XG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5hbHQgPSBvcHQuYWx0IHx8IFtdO1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYmVmb3JlKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYmVmb3JlTmFtZSAoU3RyaW5nKTogbmV3IHJ1bGUgd2lsbCBiZSBhZGRlZCBiZWZvcmUgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGJlZm9yZSBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5hZnRlcl1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5ibG9jay5ydWxlci5iZWZvcmUoJ3BhcmFncmFwaCcsICdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYmVmb3JlTmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBiZWZvcmVOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCwgMCwge1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuYWZ0ZXIoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGFmdGVyTmFtZSAoU3RyaW5nKTogbmV3IHJ1bGUgd2lsbCBiZSBhZGRlZCBhZnRlciB0aGlzIG9uZS5cbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYWZ0ZXIgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYmVmb3JlXV0sIFtbUnVsZXIucHVzaF1dLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIG1kLmlubGluZS5ydWxlci5hZnRlcigndGV4dCcsICdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIChhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGFmdGVyTmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBhZnRlck5hbWUpOyB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4ICsgMSwgMCwge1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJ1bGVyLnB1c2gocnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIFB1c2ggbmV3IHJ1bGUgdG8gdGhlIGVuZCBvZiBjaGFpbi4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYmVmb3JlXV0sIFtbUnVsZXIuYWZ0ZXJdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLnB1c2goJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAocnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX19ydWxlc19fLnB1c2goe1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogUnVsZXIuZW5hYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cbiAqIEVycm9ycyBjYW4gYmUgZGlzYWJsZWQgYnkgc2Vjb25kIHBhcmFtLlxuICpcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxuICpcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZU9ubHldXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBlbmFibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gdHJ1ZTtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZU9ubHkobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZSAod2hpdGVsaXN0KS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLCBhbmQgZGlzYWJsZSBldmVyeXRoaW5nIGVsc2UuIElmIGFueSBydWxlIG5hbWVcbiAqIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVdXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5lbmFibGVPbmx5ID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHsgcnVsZS5lbmFibGVkID0gZmFsc2U7IH0pO1xuXG4gIHRoaXMuZW5hYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmRpc2FibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBEaXNhYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmVuYWJsZV1dLCBbW1J1bGVyLmVuYWJsZU9ubHldXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZGlzYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZiAoaWdub3JlSW52YWxpZCkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmdldFJ1bGVzKGNoYWluTmFtZSkgLT4gQXJyYXlcbiAqXG4gKiBSZXR1cm4gYXJyYXkgb2YgYWN0aXZlIGZ1bmN0aW9ucyAocnVsZXMpIGZvciBnaXZlbiBjaGFpbiBuYW1lLiBJdCBhbmFseXplc1xuICogcnVsZXMgY29uZmlndXJhdGlvbiwgY29tcGlsZXMgY2FjaGVzIGlmIG5vdCBleGlzdHMgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIERlZmF1bHQgY2hhaW4gbmFtZSBpcyBgJydgIChlbXB0eSBzdHJpbmcpLiBJdCBjYW4ndCBiZSBza2lwcGVkLiBUaGF0J3NcbiAqIGRvbmUgaW50ZW50aW9uYWxseSwgdG8ga2VlcCBzaWduYXR1cmUgbW9ub21vcnBoaWMgZm9yIGhpZ2ggc3BlZWQuXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZ2V0UnVsZXMgPSBmdW5jdGlvbiAoY2hhaW5OYW1lKSB7XG4gIGlmICh0aGlzLl9fY2FjaGVfXyA9PT0gbnVsbCkge1xuICAgIHRoaXMuX19jb21waWxlX18oKTtcbiAgfVxuXG4gIC8vIENoYWluIGNhbiBiZSBlbXB0eSwgaWYgcnVsZXMgZGlzYWJsZWQuIEJ1dCB3ZSBzdGlsbCBoYXZlIHRvIHJldHVybiBBcnJheS5cbiAgcmV0dXJuIHRoaXMuX19jYWNoZV9fW2NoYWluTmFtZV0gfHwgW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXIuanMiLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcbiAgICoqL1xuICB0aGlzLmluZm8gICAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21ldGEgLT4gT2JqZWN0XG4gICAqXG4gICAqIEEgcGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgYW4gYXJiaXRyYXJ5IGRhdGFcbiAgICoqL1xuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZTtcblxuICAvKipcbiAgICogVG9rZW4jaGlkZGVuIC0+IEJvb2xlYW5cbiAgICpcbiAgICogSWYgaXQncyB0cnVlLCBpZ25vcmUgdGhpcyBlbGVtZW50IHdoZW4gcmVuZGVyaW5nLiBVc2VkIGZvciB0aWdodCBsaXN0c1xuICAgKiB0byBoaWRlIHBhcmFncmFwaHMuXG4gICAqKi9cbiAgdGhpcy5oaWRkZW4gICA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxuICpcbiAqIFNlYXJjaCBhdHRyaWJ1dGUgaW5kZXggYnkgbmFtZS5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICB2YXIgYXR0cnMsIGksIGxlbjtcblxuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xOyB9XG5cbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRycy5wdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSxcbiAgICAgIGF0dHJEYXRhID0gWyBuYW1lLCB2YWx1ZSBdO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyR2V0KG5hbWUpXG4gKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhdHRyaWJ1dGUgYG5hbWVgLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCB2YWx1ZSA9IG51bGw7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySm9pbihuYW1lLCB2YWx1ZSlcbiAqXG4gKiBKb2luIHZhbHVlIHRvIGV4aXN0aW5nIGF0dHJpYnV0ZSB2aWEgc3BhY2UuIE9yIGNyZWF0ZSBuZXcgYXR0cmlidXRlIGlmIG5vdFxuICogZXhpc3RzLiBVc2VmdWwgdG8gb3BlcmF0ZSB3aXRoIHRva2VuIGNsYXNzZXMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckpvaW4gPSBmdW5jdGlvbiBhdHRySm9pbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKFsgbmFtZSwgdmFsdWUgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWU7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwibW9kdWxlLmV4cG9ydHM9L1shLSMlLVxcKiwtLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MDlGRFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDlcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDZbXFx1REUzRi1cXHVERTQ2XFx1REU5QS1cXHVERTlDXFx1REU5RS1cXHVERUEyXXxcXHVEODA3W1xcdURDNDEtXFx1REM0NVxcdURDNzBcXHVEQzcxXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgzQVtcXHVERDVFXFx1REQ1Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzT2JqZWN0LmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3Jvb3QuanMiLCIvLyBIVE1MNSBlbnRpdGllcyBtYXA6IHsgbmFtZSAtPiB1dGYxNnN0cmluZyB9XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBxdW90ZXM6MCovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvbicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIi8vIFByb2Nlc3MgKnRoaXMqIGFuZCBfdGhhdF9cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4NUYgLyogXyAqLyAmJiBtYXJrZXIgIT09IDB4MkEgLyogKiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gMHgyQSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgIC8vIENoYXIgY29kZSBvZiB0aGUgc3RhcnRpbmcgbWFya2VyIChudW1iZXIpLlxuICAgICAgLy9cbiAgICAgIG1hcmtlcjogbWFya2VyLFxuXG4gICAgICAvLyBUb3RhbCBsZW5ndGggb2YgdGhlc2Ugc2VyaWVzIG9mIGRlbGltaXRlcnMuXG4gICAgICAvL1xuICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcblxuICAgICAgLy8gQW4gYW1vdW50IG9mIGNoYXJhY3RlcnMgYmVmb3JlIHRoaXMgb25lIHRoYXQncyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyBjdXJyZW50IG9uZS4gSW4gcGxhaW4gRW5nbGlzaDogaWYgdGhpcyBkZWxpbWl0ZXIgZG9lcyBub3Qgb3BlblxuICAgICAgLy8gYW4gZW1waGFzaXMsIG5laXRoZXIgZG8gcHJldmlvdXMgYGp1bXBgIGNoYXJhY3RlcnMuXG4gICAgICAvL1xuICAgICAgLy8gVXNlZCB0byBza2lwIHNlcXVlbmNlcyBsaWtlIFwiKioqKipcIiBpbiBvbmUgc3RlcCwgZm9yIDFzdCBhc3Rlcmlza1xuICAgICAgLy8gdmFsdWUgd2lsbCBiZSAwLCBmb3IgMm5kIGl0J3MgMSBhbmQgc28gb24uXG4gICAgICAvL1xuICAgICAganVtcDogICBpLFxuXG4gICAgICAvLyBBIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiB0aGlzIGRlbGltaXRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgIC8vXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuXG4gICAgICAvLyBUb2tlbiBsZXZlbC5cbiAgICAgIC8vXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuXG4gICAgICAvLyBJZiB0aGlzIGRlbGltaXRlciBpcyBtYXRjaGVkIGFzIGEgdmFsaWQgb3BlbmVyLCBgZW5kYCB3aWxsIGJlXG4gICAgICAvLyBlcXVhbCB0byBpdHMgcG9zaXRpb24sIG90aGVyd2lzZSBpdCdzIGAtMWAuXG4gICAgICAvL1xuICAgICAgZW5kOiAgICAtMSxcblxuICAgICAgLy8gQm9vbGVhbiBmbGFncyB0aGF0IGRldGVybWluZSBpZiB0aGlzIGRlbGltaXRlciBjb3VsZCBvcGVuIG9yIGNsb3NlXG4gICAgICAvLyBhbiBlbXBoYXNpcy5cbiAgICAgIC8vXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gIHZhciBpLFxuICAgICAgc3RhcnREZWxpbSxcbiAgICAgIGVuZERlbGltLFxuICAgICAgdG9rZW4sXG4gICAgICBjaCxcbiAgICAgIGlzU3Ryb25nLFxuICAgICAgZGVsaW1pdGVycyA9IHN0YXRlLmRlbGltaXRlcnMsXG4gICAgICBtYXggPSBzdGF0ZS5kZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSBtYXggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDVGLyogXyAqLyAmJiBzdGFydERlbGltLm1hcmtlciAhPT0gMHgyQS8qICogKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3Mgb25seSBvcGVuaW5nIG1hcmtlcnNcbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSA+IDAgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSAtIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgKyAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgLSAxXS50b2tlbiA9PT0gc3RhcnREZWxpbS50b2tlbiAtIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgKyAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gKyAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgLSAxXS5tYXJrZXIgPT09IHN0YXJ0RGVsaW0ubWFya2VyO1xuXG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0RGVsaW0ubWFya2VyKTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19vcGVuJyA6ICdlbV9vcGVuJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfY2xvc2UnIDogJ2VtX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW2kgLSAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgKyAxXS50b2tlbl0uY29udGVudCA9ICcnO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIi8vIH5+c3RyaWtlIHRocm91Z2h+flxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLCBsZW4sIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICBsZW4gPSBzY2FubmVkLmxlbmd0aDtcbiAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgaWYgKGxlbiA8IDIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGxlbiAlIDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2g7XG4gICAgbGVuLS07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gY2ggKyBjaDtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgIGp1bXA6ICAgaSxcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBsZXZlbDogIHN0YXRlLmxldmVsLFxuICAgICAgZW5kOiAgICAtMSxcbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3Nfb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9ICdzJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gJ3NfY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IC0xO1xuICAgIHRva2VuLm1hcmt1cCAgPSAnfn4nO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0uY29udGVudCA9PT0gJ34nKSB7XG5cbiAgICAgIGxvbmVNYXJrZXJzLnB1c2goZW5kRGVsaW0udG9rZW4gLSAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIG1hcmtlciBzZXF1ZW5jZSBoYXMgYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCdzIHNwbGl0dGVkXG4gIC8vIGxpa2UgdGhpczogYH5+fn5+YCAtPiBgfmAgKyBgfn5gICsgYH5+YCwgbGVhdmluZyBvbmUgbWFya2VyIGF0IHRoZVxuICAvLyBzdGFydCBvZiB0aGUgc2VxdWVuY2UuXG4gIC8vXG4gIC8vIFNvLCB3ZSBoYXZlIHRvIG1vdmUgYWxsIHRob3NlIG1hcmtlcnMgYWZ0ZXIgc3Vic2VxdWVudCBzX2Nsb3NlIHRhZ3MuXG4gIC8vXG4gIHdoaWxlIChsb25lTWFya2Vycy5sZW5ndGgpIHtcbiAgICBpID0gbG9uZU1hcmtlcnMucG9wKCk7XG4gICAgaiA9IGkgKyAxO1xuXG4gICAgd2hpbGUgKGogPCBzdGF0ZS50b2tlbnMubGVuZ3RoICYmIHN0YXRlLnRva2Vuc1tqXS50eXBlID09PSAnc19jbG9zZScpIHtcbiAgICAgIGorKztcbiAgICB9XG5cbiAgICBqLS07XG5cbiAgICBpZiAoaSAhPT0gaikge1xuICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbal07XG4gICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICBzdGF0ZS50b2tlbnNbaV0gPSB0b2tlbjtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21kdXJsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwibW9kdWxlLmV4cG9ydHM9L1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX1N5bWJvbC5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwidmFyIGJhc2VSYW5kb20gPSByZXF1aXJlKCcuL19iYXNlUmFuZG9tJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNodWZmbGVTZWxmO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NodWZmbGVTZWxmLmpzIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2RlYm91bmNlLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzQXJyYXkuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0xlbmd0aC5qcyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MsICRjYWxsZWUpIHtcbiAgICBfVmR0IHx8IChfVmR0ID0gVmR0KTtcbiAgICBvYmogfHwgKG9iaiA9IHt9KTtcbiAgICBibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbiAgICB2YXIgaCA9IF9WZHQubWlzcy5oLCBoYyA9IF9WZHQubWlzcy5oYywgaHUgPSBfVmR0Lm1pc3MuaHUsIHdpZGdldHMgPSB0aGlzICYmIHRoaXMud2lkZ2V0cyB8fCB7fSwgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IHt9LFxuICAgICAgICBfX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsIF9fc2xpY2UgPSBfX3Uuc2xpY2UsIF9fbm9vcCA9IF9fdS5ub29wLFxuICAgICAgICBfX20gPSBfX3UubWFwLCBfX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG4gICAgICAgIF9zZXRDaGVja2JveE1vZGVsID0gX191LnNldENoZWNrYm94TW9kZWwsIF9kZXRlY3RDaGVja2JveENoZWNrZWQgPSBfX3UuZGV0ZWN0Q2hlY2tib3hDaGVja2VkLFxuICAgICAgICBfc2V0U2VsZWN0TW9kZWwgPSBfX3Uuc2V0U2VsZWN0TW9kZWwsXG4gICAgICAgIHNlbGYgPSB0aGlzLmRhdGEsICR0aGlzID0gdGhpcywgc2NvcGUgPSBvYmosIEFuaW1hdGUgPSBzZWxmICYmIHNlbGYuQW5pbWF0ZSwgcGFyZW50ID0gKCRjYWxsZWUgfHwge30pLl9zdXBlcjtcblxuICAgIGNvbnN0IG5hdiA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAn5pWZ56iLJyxcbiAgICAgICAgaHJlZjogJ2RvY3VtZW50J1xuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0FQSScsXG4gICAgICAgIGhyZWY6ICdhcGknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnQmxvZycsXG4gICAgICAgIGhyZWY6ICdibG9nJ1xuICAgIH1cbl1cbiAgICByZXR1cm4gaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICBoKCdkaXYnLCBudWxsLCBoKCdoZWFkZXInLCBudWxsLCAoX2Jsb2Nrc1snaGVhZGVyJ10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgaCgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiAnIy8nXG4gICAgICAgICAgICAgICAgfSwgJ0ludGFjdCcsICdsb2dvJyksXG4gICAgICAgICAgICAgICAgaCgnbmF2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICBfX20oZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKG5hdil9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaCgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChgIy8ke3ZhbHVlLmhyZWZ9YCl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUudGl0bGUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB2YWx1ZS5ocmVmID09PSBzY29wZS5uYXZJbmRleFxuICAgICAgICAgICAgICAgICAgICB9KX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCBudWxsLCBudWxsLCAnYm9yZGVyJylcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkgJiYgKF9fYmxvY2tzWydoZWFkZXInXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tzWydoZWFkZXInXSA/IGJsb2Nrc1snaGVhZGVyJ10uYXBwbHkoJHRoaXMsIFtmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Jsb2Nrc1snaGVhZGVyJ10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzLCAxKSkpIDogX2Jsb2Nrc1snaGVhZGVyJ10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KSAmJiBfX2Jsb2Nrc1snaGVhZGVyJ10uYXBwbHkoJHRoaXMsIFtfX25vb3BdKSksICdoZWFkZXItd3JhcHBlcicpLFxuICAgICAgICBoKCdkaXYnLCBudWxsLCAoX2Jsb2Nrc1snY29udGVudCddID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkgJiYgKF9fYmxvY2tzWydjb250ZW50J10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2Nrc1snY29udGVudCddID8gYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIFtmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Jsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1dLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJncywgMSkpKSA6IF9ibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgYXJncyk7XG4gICAgICAgIH0pICYmIF9fYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIFtfX25vb3BdKSwgJ2NvbnRlbnQtd3JhcHBlcicpXG4gICAgXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiAoJ21haW4td3JhcHBlciAnICsgKHNjb3BlLmNsYXNzTmFtZSB8fCAnJykpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSkpXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS9wYWdlcy9sYXlvdXQudmR0IiwiLypcblN5bnRheCBoaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBhdXRvZGV0ZWN0aW9uLlxuaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4qL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEZpbmQgdGhlIGdsb2JhbCBvYmplY3QgZm9yIGV4cG9ydCB0byBib3RoIHRoZSBicm93c2VyIGFuZCB3ZWIgd29ya2Vycy5cbiAgdmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdyB8fFxuICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGY7XG5cbiAgLy8gU2V0dXAgaGlnaGxpZ2h0LmpzIGZvciBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLiBGaXJzdCBpcyBOb2RlLmpzIG9yXG4gIC8vIENvbW1vbkpTLlxuICBpZih0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICB9IGVsc2UgaWYoZ2xvYmFsT2JqZWN0KSB7XG4gICAgLy8gRXhwb3J0IGhsanMgZ2xvYmFsbHkgZXZlbiB3aGVuIHVzaW5nIEFNRCBmb3IgY2FzZXMgd2hlbiB0aGlzIHNjcmlwdFxuICAgIC8vIGlzIGxvYWRlZCB3aXRoIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgaGxqcy5cbiAgICBnbG9iYWxPYmplY3QuaGxqcyA9IGZhY3Rvcnkoe30pO1xuXG4gICAgLy8gRmluYWxseSByZWdpc3RlciB0aGUgZ2xvYmFsIGhsanMgd2l0aCBBTUQuXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsT2JqZWN0LmhsanM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufShmdW5jdGlvbihobGpzKSB7XG4gIC8vIENvbnZlbmllbmNlIHZhcmlhYmxlcyBmb3IgYnVpbGQtaW4gb2JqZWN0c1xuICB2YXIgQXJyYXlQcm90byA9IFtdLFxuICAgICAgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzO1xuXG4gIC8vIEdsb2JhbCBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCB3aXRoaW4gdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICB2YXIgbGFuZ3VhZ2VzID0ge30sXG4gICAgICBhbGlhc2VzICAgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgdGhyb3VnaG91dCB0aGUgaGlnaGxpZ2h0LmpzIGxpYnJhcnkuXG4gIHZhciBub0hpZ2hsaWdodFJlICAgID0gL14obm8tP2hpZ2hsaWdodHxwbGFpbnx0ZXh0KSQvaSxcbiAgICAgIGxhbmd1YWdlUHJlZml4UmUgPSAvXFxibGFuZyg/OnVhZ2UpPy0oW1xcdy1dKylcXGIvaSxcbiAgICAgIGZpeE1hcmt1cFJlICAgICAgPSAvKCheKDxbXj5dKz58XFx0fCkrfCg/OlxcbikpKS9nbTtcblxuICB2YXIgc3BhbkVuZFRhZyA9ICc8L3NwYW4+JztcblxuICAvLyBHbG9iYWwgb3B0aW9ucyB1c2VkIHdoZW4gd2l0aGluIGV4dGVybmFsIEFQSXMuIFRoaXMgaXMgbW9kaWZpZWQgd2hlblxuICAvLyBjYWxsaW5nIHRoZSBgaGxqcy5jb25maWd1cmVgIGZ1bmN0aW9uLlxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjbGFzc1ByZWZpeDogJ2hsanMtJyxcbiAgICB0YWJSZXBsYWNlOiBudWxsLFxuICAgIHVzZUJSOiBmYWxzZSxcbiAgICBsYW5ndWFnZXM6IHVuZGVmaW5lZFxuICB9O1xuXG5cbiAgLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuICBmdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdFJlKHJlLCBsZXhlbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSByZSAmJiByZS5leGVjKGxleGVtZSk7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RIaWdobGlnaHRlZChsYW5ndWFnZSkge1xuICAgIHJldHVybiBub0hpZ2hsaWdodFJlLnRlc3QobGFuZ3VhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2tMYW5ndWFnZShibG9jaykge1xuICAgIHZhciBpLCBtYXRjaCwgbGVuZ3RoLCBfY2xhc3M7XG4gICAgdmFyIGNsYXNzZXMgPSBibG9jay5jbGFzc05hbWUgKyAnICc7XG5cbiAgICBjbGFzc2VzICs9IGJsb2NrLnBhcmVudE5vZGUgPyBibG9jay5wYXJlbnROb2RlLmNsYXNzTmFtZSA6ICcnO1xuXG4gICAgLy8gbGFuZ3VhZ2UtKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgbm9uLXByZWZpeGVkIGNsYXNzIG5hbWVzLlxuICAgIG1hdGNoID0gbGFuZ3VhZ2VQcmVmaXhSZS5leGVjKGNsYXNzZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIGdldExhbmd1YWdlKG1hdGNoWzFdKSA/IG1hdGNoWzFdIDogJ25vLWhpZ2hsaWdodCc7XG4gICAgfVxuXG4gICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIF9jbGFzcyA9IGNsYXNzZXNbaV1cblxuICAgICAgaWYgKGlzTm90SGlnaGxpZ2h0ZWQoX2NsYXNzKSB8fCBnZXRMYW5ndWFnZShfY2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBfY2xhc3M7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQpIHsgIC8vIGluaGVyaXQocGFyZW50LCBvdmVycmlkZV9vYmosIG92ZXJyaWRlX29iaiwgLi4uKVxuICAgIHZhciBrZXk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGZvciAoa2V5IGluIHBhcmVudClcbiAgICAgIHJlc3VsdFtrZXldID0gcGFyZW50W2tleV07XG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgZm9yIChrZXkgaW4gb2JqKVxuICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiBTdHJlYW0gbWVyZ2luZyAqL1xuXG4gIGZ1bmN0aW9uIG5vZGVTdHJlYW0obm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAoZnVuY3Rpb24gX25vZGVTdHJlYW0obm9kZSwgb2Zmc2V0KSB7XG4gICAgICBmb3IgKHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzKVxuICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9mZnNldCA9IF9ub2RlU3RyZWFtKGNoaWxkLCBvZmZzZXQpO1xuICAgICAgICAgIC8vIFByZXZlbnQgdm9pZCBlbGVtZW50cyBmcm9tIGhhdmluZyBhbiBlbmQgdGFnIHRoYXQgd291bGQgYWN0dWFsbHlcbiAgICAgICAgICAvLyBkb3VibGUgdGhlbSBpbiB0aGUgb3V0cHV0LiBUaGVyZSBhcmUgbW9yZSB2b2lkIGVsZW1lbnRzIGluIEhUTUxcbiAgICAgICAgICAvLyBidXQgd2UgbGlzdCBvbmx5IHRob3NlIHJlYWxpc3RpY2FsbHkgZXhwZWN0ZWQgaW4gY29kZSBkaXNwbGF5LlxuICAgICAgICAgIGlmICghdGFnKGNoaWxkKS5tYXRjaCgvYnJ8aHJ8aW1nfGlucHV0LykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgZXZlbnQ6ICdzdG9wJyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgIG5vZGU6IGNoaWxkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSkobm9kZSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhvcmlnaW5hbCwgaGlnaGxpZ2h0ZWQsIHZhbHVlKSB7XG4gICAgdmFyIHByb2Nlc3NlZCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBub2RlU3RhY2sgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNlbGVjdFN0cmVhbSgpIHtcbiAgICAgIGlmICghb3JpZ2luYWwubGVuZ3RoIHx8ICFoaWdobGlnaHRlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmxlbmd0aCA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxbMF0ub2Zmc2V0ICE9PSBoaWdobGlnaHRlZFswXS5vZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbFswXS5vZmZzZXQgPCBoaWdobGlnaHRlZFswXS5vZmZzZXQpID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIFRvIGF2b2lkIHN0YXJ0aW5nIHRoZSBzdHJlYW0ganVzdCBiZWZvcmUgaXQgc2hvdWxkIHN0b3AgdGhlIG9yZGVyIGlzXG4gICAgICBlbnN1cmVkIHRoYXQgb3JpZ2luYWwgYWx3YXlzIHN0YXJ0cyBmaXJzdCBhbmQgY2xvc2VzIGxhc3Q6XG5cbiAgICAgIGlmIChldmVudDEgPT0gJ3N0YXJ0JyAmJiBldmVudDIgPT0gJ3N0YXJ0JylcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICAgIHJldHVybiBoaWdobGlnaHRlZDtcbiAgICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICBpZiAoZXZlbnQxID09ICdzdG9wJyAmJiBldmVudDIgPT0gJ3N0b3AnKVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQ7XG5cbiAgICAgIC4uLiB3aGljaCBpcyBjb2xsYXBzZWQgdG86XG4gICAgICAqL1xuICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkWzBdLmV2ZW50ID09PSAnc3RhcnQnID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVuKG5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIGF0dHJfc3RyKGEpIHtyZXR1cm4gJyAnICsgYS5ub2RlTmFtZSArICc9XCInICsgZXNjYXBlKGEudmFsdWUpLnJlcGxhY2UoJ1wiJywgJyZxdW90OycpICsgJ1wiJzt9XG4gICAgICByZXN1bHQgKz0gJzwnICsgdGFnKG5vZGUpICsgQXJyYXlQcm90by5tYXAuY2FsbChub2RlLmF0dHJpYnV0ZXMsIGF0dHJfc3RyKS5qb2luKCcnKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZShub2RlKSB7XG4gICAgICByZXN1bHQgKz0gJzwvJyArIHRhZyhub2RlKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoZXZlbnQpIHtcbiAgICAgIChldmVudC5ldmVudCA9PT0gJ3N0YXJ0JyA/IG9wZW4gOiBjbG9zZSkoZXZlbnQubm9kZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9yaWdpbmFsLmxlbmd0aCB8fCBoaWdobGlnaHRlZC5sZW5ndGgpIHtcbiAgICAgIHZhciBzdHJlYW0gPSBzZWxlY3RTdHJlYW0oKTtcbiAgICAgIHJlc3VsdCArPSBlc2NhcGUodmFsdWUuc3Vic3RyaW5nKHByb2Nlc3NlZCwgc3RyZWFtWzBdLm9mZnNldCkpO1xuICAgICAgcHJvY2Vzc2VkID0gc3RyZWFtWzBdLm9mZnNldDtcbiAgICAgIGlmIChzdHJlYW0gPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIC8qXG4gICAgICAgIE9uIGFueSBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnIG9mIHRoZSBvcmlnaW5hbCBtYXJrdXAgd2UgZmlyc3QgY2xvc2VcbiAgICAgICAgdGhlIGVudGlyZSBoaWdobGlnaHRlZCBub2RlIHN0YWNrLCB0aGVuIHJlbmRlciB0aGUgb3JpZ2luYWwgdGFnIGFsb25nXG4gICAgICAgIHdpdGggYWxsIHRoZSBmb2xsb3dpbmcgb3JpZ2luYWwgdGFncyBhdCB0aGUgc2FtZSBvZmZzZXQgYW5kIHRoZW5cbiAgICAgICAgcmVvcGVuIGFsbCB0aGUgdGFncyBvbiB0aGUgaGlnaGxpZ2h0ZWQgc3RhY2suXG4gICAgICAgICovXG4gICAgICAgIG5vZGVTdGFjay5yZXZlcnNlKCkuZm9yRWFjaChjbG9zZSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICAgICAgc3RyZWFtID0gc2VsZWN0U3RyZWFtKCk7XG4gICAgICAgIH0gd2hpbGUgKHN0cmVhbSA9PT0gb3JpZ2luYWwgJiYgc3RyZWFtLmxlbmd0aCAmJiBzdHJlYW1bMF0ub2Zmc2V0ID09PSBwcm9jZXNzZWQpO1xuICAgICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2gob3Blbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyZWFtWzBdLmV2ZW50ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgbm9kZVN0YWNrLnB1c2goc3RyZWFtWzBdLm5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGUodmFsdWUuc3Vic3RyKHByb2Nlc3NlZCkpO1xuICB9XG5cbiAgLyogSW5pdGlhbGl6YXRpb24gKi9cblxuICBmdW5jdGlvbiBleHBhbmRfbW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUudmFyaWFudHMgJiYgIW1vZGUuY2FjaGVkX3ZhcmlhbnRzKSB7XG4gICAgICBtb2RlLmNhY2hlZF92YXJpYW50cyA9IG1vZGUudmFyaWFudHMubWFwKGZ1bmN0aW9uKHZhcmlhbnQpIHtcbiAgICAgICAgcmV0dXJuIGluaGVyaXQobW9kZSwge3ZhcmlhbnRzOiBudWxsfSwgdmFyaWFudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGUuY2FjaGVkX3ZhcmlhbnRzIHx8IChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIFtpbmhlcml0KG1vZGUpXSkgfHwgW21vZGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlKSB7XG5cbiAgICBmdW5jdGlvbiByZVN0cihyZSkge1xuICAgICAgICByZXR1cm4gKHJlICYmIHJlLnNvdXJjZSkgfHwgcmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFuZ1JlKHZhbHVlLCBnbG9iYWwpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgICByZVN0cih2YWx1ZSksXG4gICAgICAgICdtJyArIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gJ2knIDogJycpICsgKGdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlTW9kZShtb2RlLCBwYXJlbnQpIHtcbiAgICAgIGlmIChtb2RlLmNvbXBpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBtb2RlLmNvbXBpbGVkID0gdHJ1ZTtcblxuICAgICAgbW9kZS5rZXl3b3JkcyA9IG1vZGUua2V5d29yZHMgfHwgbW9kZS5iZWdpbktleXdvcmRzO1xuICAgICAgaWYgKG1vZGUua2V5d29yZHMpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVkX2tleXdvcmRzID0ge307XG5cbiAgICAgICAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihjbGFzc05hbWUsIHN0cikge1xuICAgICAgICAgIGlmIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihrdykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBrdy5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgY29tcGlsZWRfa2V5d29yZHNbcGFpclswXV0gPSBbY2xhc3NOYW1lLCBwYWlyWzFdID8gTnVtYmVyKHBhaXJbMV0pIDogMV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlLmtleXdvcmRzID09PSAnc3RyaW5nJykgeyAvLyBzdHJpbmdcbiAgICAgICAgICBmbGF0dGVuKCdrZXl3b3JkJywgbW9kZS5rZXl3b3Jkcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0S2V5cyhtb2RlLmtleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oY2xhc3NOYW1lLCBtb2RlLmtleXdvcmRzW2NsYXNzTmFtZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUua2V5d29yZHMgPSBjb21waWxlZF9rZXl3b3JkcztcbiAgICAgIH1cbiAgICAgIG1vZGUubGV4ZW1lc1JlID0gbGFuZ1JlKG1vZGUubGV4ZW1lcyB8fCAvXFx3Ky8sIHRydWUpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChtb2RlLmJlZ2luS2V5d29yZHMpIHtcbiAgICAgICAgICBtb2RlLmJlZ2luID0gJ1xcXFxiKCcgKyBtb2RlLmJlZ2luS2V5d29yZHMuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKVxcXFxiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUuYmVnaW4pXG4gICAgICAgICAgbW9kZS5iZWdpbiA9IC9cXEJ8XFxiLztcbiAgICAgICAgbW9kZS5iZWdpblJlID0gbGFuZ1JlKG1vZGUuYmVnaW4pO1xuICAgICAgICBpZiAoIW1vZGUuZW5kICYmICFtb2RlLmVuZHNXaXRoUGFyZW50KVxuICAgICAgICAgIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgICBpZiAobW9kZS5lbmQpXG4gICAgICAgICAgbW9kZS5lbmRSZSA9IGxhbmdSZShtb2RlLmVuZCk7XG4gICAgICAgIG1vZGUudGVybWluYXRvcl9lbmQgPSByZVN0cihtb2RlLmVuZCkgfHwgJyc7XG4gICAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50ICYmIHBhcmVudC50ZXJtaW5hdG9yX2VuZClcbiAgICAgICAgICBtb2RlLnRlcm1pbmF0b3JfZW5kICs9IChtb2RlLmVuZCA/ICd8JyA6ICcnKSArIHBhcmVudC50ZXJtaW5hdG9yX2VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmlsbGVnYWwpXG4gICAgICAgIG1vZGUuaWxsZWdhbFJlID0gbGFuZ1JlKG1vZGUuaWxsZWdhbCk7XG4gICAgICBpZiAobW9kZS5yZWxldmFuY2UgPT0gbnVsbClcbiAgICAgICAgbW9kZS5yZWxldmFuY2UgPSAxO1xuICAgICAgaWYgKCFtb2RlLmNvbnRhaW5zKSB7XG4gICAgICAgIG1vZGUuY29udGFpbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG1vZGUuY29udGFpbnMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBtb2RlLmNvbnRhaW5zLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRfbW9kZShjID09PSAnc2VsZicgPyBtb2RlIDogYylcbiAgICAgIH0pKTtcbiAgICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaChmdW5jdGlvbihjKSB7Y29tcGlsZU1vZGUoYywgbW9kZSk7fSk7XG5cbiAgICAgIGlmIChtb2RlLnN0YXJ0cykge1xuICAgICAgICBjb21waWxlTW9kZShtb2RlLnN0YXJ0cywgcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlcm1pbmF0b3JzID1cbiAgICAgICAgbW9kZS5jb250YWlucy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjLmJlZ2luS2V5d29yZHMgPyAnXFxcXC4/KCcgKyBjLmJlZ2luICsgJylcXFxcLj8nIDogYy5iZWdpbjtcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbmNhdChbbW9kZS50ZXJtaW5hdG9yX2VuZCwgbW9kZS5pbGxlZ2FsXSlcbiAgICAgICAgLm1hcChyZVN0cilcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIG1vZGUudGVybWluYXRvcnMgPSB0ZXJtaW5hdG9ycy5sZW5ndGggPyBsYW5nUmUodGVybWluYXRvcnMuam9pbignfCcpLCB0cnVlKSA6IHtleGVjOiBmdW5jdGlvbigvKnMqLykge3JldHVybiBudWxsO319O1xuICAgIH1cblxuICAgIGNvbXBpbGVNb2RlKGxhbmd1YWdlKTtcbiAgfVxuXG4gIC8qXG4gIENvcmUgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uLiBBY2NlcHRzIGEgbGFuZ3VhZ2UgbmFtZSwgb3IgYW4gYWxpYXMsIGFuZCBhXG4gIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGhpZ2hsaWdodC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gIHByb3BlcnRpZXM6XG5cbiAgLSByZWxldmFuY2UgKGludClcbiAgLSB2YWx1ZSAoYW4gSFRNTCBzdHJpbmcgd2l0aCBoaWdobGlnaHRpbmcgbWFya3VwKVxuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodChuYW1lLCB2YWx1ZSwgaWdub3JlX2lsbGVnYWxzLCBjb250aW51YXRpb24pIHtcblxuICAgIGZ1bmN0aW9uIHN1Yk1vZGUobGV4ZW1lLCBtb2RlKSB7XG4gICAgICB2YXIgaSwgbGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBtb2RlLmNvbnRhaW5zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0UmUobW9kZS5jb250YWluc1tpXS5iZWdpblJlLCBsZXhlbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGUuY29udGFpbnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZk1vZGUobW9kZSwgbGV4ZW1lKSB7XG4gICAgICBpZiAodGVzdFJlKG1vZGUuZW5kUmUsIGxleGVtZSkpIHtcbiAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgIG1vZGUgPSBtb2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIGxleGVtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJbGxlZ2FsKGxleGVtZSwgbW9kZSkge1xuICAgICAgcmV0dXJuICFpZ25vcmVfaWxsZWdhbHMgJiYgdGVzdFJlKG1vZGUuaWxsZWdhbFJlLCBsZXhlbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXdvcmRNYXRjaChtb2RlLCBtYXRjaCkge1xuICAgICAgdmFyIG1hdGNoX3N0ciA9IGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUgPyBtYXRjaFswXS50b0xvd2VyQ2FzZSgpIDogbWF0Y2hbMF07XG4gICAgICByZXR1cm4gbW9kZS5rZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShtYXRjaF9zdHIpICYmIG1vZGUua2V5d29yZHNbbWF0Y2hfc3RyXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFNwYW4oY2xhc3NuYW1lLCBpbnNpZGVTcGFuLCBsZWF2ZU9wZW4sIG5vUHJlZml4KSB7XG4gICAgICB2YXIgY2xhc3NQcmVmaXggPSBub1ByZWZpeCA/ICcnIDogb3B0aW9ucy5jbGFzc1ByZWZpeCxcbiAgICAgICAgICBvcGVuU3BhbiAgICA9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc1ByZWZpeCxcbiAgICAgICAgICBjbG9zZVNwYW4gICA9IGxlYXZlT3BlbiA/ICcnIDogc3BhbkVuZFRhZ1xuXG4gICAgICBvcGVuU3BhbiArPSBjbGFzc25hbWUgKyAnXCI+JztcblxuICAgICAgcmV0dXJuIG9wZW5TcGFuICsgaW5zaWRlU3BhbiArIGNsb3NlU3BhbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzS2V5d29yZHMoKSB7XG4gICAgICB2YXIga2V5d29yZF9tYXRjaCwgbGFzdF9pbmRleCwgbWF0Y2gsIHJlc3VsdDtcblxuICAgICAgaWYgKCF0b3Aua2V5d29yZHMpXG4gICAgICAgIHJldHVybiBlc2NhcGUobW9kZV9idWZmZXIpO1xuXG4gICAgICByZXN1bHQgPSAnJztcbiAgICAgIGxhc3RfaW5kZXggPSAwO1xuICAgICAgdG9wLmxleGVtZXNSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1lc1JlLmV4ZWMobW9kZV9idWZmZXIpO1xuXG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0ICs9IGVzY2FwZShtb2RlX2J1ZmZlci5zdWJzdHJpbmcobGFzdF9pbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAga2V5d29yZF9tYXRjaCA9IGtleXdvcmRNYXRjaCh0b3AsIG1hdGNoKTtcbiAgICAgICAgaWYgKGtleXdvcmRfbWF0Y2gpIHtcbiAgICAgICAgICByZWxldmFuY2UgKz0ga2V5d29yZF9tYXRjaFsxXTtcbiAgICAgICAgICByZXN1bHQgKz0gYnVpbGRTcGFuKGtleXdvcmRfbWF0Y2hbMF0sIGVzY2FwZShtYXRjaFswXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGUobWF0Y2hbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfaW5kZXggPSB0b3AubGV4ZW1lc1JlLmxhc3RJbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AubGV4ZW1lc1JlLmV4ZWMobW9kZV9idWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZShtb2RlX2J1ZmZlci5zdWJzdHIobGFzdF9pbmRleCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnO1xuICAgICAgaWYgKGV4cGxpY2l0ICYmICFsYW5ndWFnZXNbdG9wLnN1Ykxhbmd1YWdlXSkge1xuICAgICAgICByZXR1cm4gZXNjYXBlKG1vZGVfYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGV4cGxpY2l0ID9cbiAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlX2J1ZmZlciwgdHJ1ZSwgY29udGludWF0aW9uc1t0b3Auc3ViTGFuZ3VhZ2VdKSA6XG4gICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0QXV0byhtb2RlX2J1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIC8vIENvdW50aW5nIGVtYmVkZGVkIGxhbmd1YWdlIHNjb3JlIHRvd2FyZHMgdGhlIGhvc3QgbGFuZ3VhZ2UgbWF5IGJlIGRpc2FibGVkXG4gICAgICAvLyB3aXRoIHplcm9pbmcgdGhlIGNvbnRhaW5pbmcgbW9kZSByZWxldmFuY2UuIFVzZWNhc2UgaW4gcG9pbnQgaXMgTWFya2Rvd24gdGhhdFxuICAgICAgLy8gYWxsb3dzIFhNTCBldmVyeXdoZXJlIGFuZCBtYWtlcyBldmVyeSBYTUwgc25pcHBldCB0byBoYXZlIGEgbXVjaCBsYXJnZXIgTWFya2Rvd25cbiAgICAgIC8vIHNjb3JlLlxuICAgICAgaWYgKHRvcC5yZWxldmFuY2UgPiAwKSB7XG4gICAgICAgIHJlbGV2YW5jZSArPSByZXN1bHQucmVsZXZhbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGxpY2l0KSB7XG4gICAgICAgIGNvbnRpbnVhdGlvbnNbdG9wLnN1Ykxhbmd1YWdlXSA9IHJlc3VsdC50b3A7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRTcGFuKHJlc3VsdC5sYW5ndWFnZSwgcmVzdWx0LnZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0J1ZmZlcigpIHtcbiAgICAgIHJlc3VsdCArPSAodG9wLnN1Ykxhbmd1YWdlICE9IG51bGwgPyBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSA6IHByb2Nlc3NLZXl3b3JkcygpKTtcbiAgICAgIG1vZGVfYnVmZmVyID0gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnROZXdNb2RlKG1vZGUpIHtcbiAgICAgIHJlc3VsdCArPSBtb2RlLmNsYXNzTmFtZT8gYnVpbGRTcGFuKG1vZGUuY2xhc3NOYW1lLCAnJywgdHJ1ZSk6ICcnO1xuICAgICAgdG9wID0gT2JqZWN0LmNyZWF0ZShtb2RlLCB7cGFyZW50OiB7dmFsdWU6IHRvcH19KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGV4ZW1lKGJ1ZmZlciwgbGV4ZW1lKSB7XG5cbiAgICAgIG1vZGVfYnVmZmVyICs9IGJ1ZmZlcjtcblxuICAgICAgaWYgKGxleGVtZSA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfbW9kZSA9IHN1Yk1vZGUobGV4ZW1lLCB0b3ApO1xuICAgICAgaWYgKG5ld19tb2RlKSB7XG4gICAgICAgIGlmIChuZXdfbW9kZS5za2lwKSB7XG4gICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdfbW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICAgIGlmICghbmV3X21vZGUucmV0dXJuQmVnaW4gJiYgIW5ld19tb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0TmV3TW9kZShuZXdfbW9kZSwgbGV4ZW1lKTtcbiAgICAgICAgcmV0dXJuIG5ld19tb2RlLnJldHVybkJlZ2luID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmRfbW9kZSA9IGVuZE9mTW9kZSh0b3AsIGxleGVtZSk7XG4gICAgICBpZiAoZW5kX21vZGUpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRvcDtcbiAgICAgICAgaWYgKG9yaWdpbi5za2lwKSB7XG4gICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghKG9yaWdpbi5yZXR1cm5FbmQgfHwgb3JpZ2luLmV4Y2x1ZGVFbmQpKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgICBpZiAob3JpZ2luLmV4Y2x1ZGVFbmQpIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHRvcC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzcGFuRW5kVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRvcC5za2lwKSB7XG4gICAgICAgICAgICByZWxldmFuY2UgKz0gdG9wLnJlbGV2YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAodG9wICE9PSBlbmRfbW9kZS5wYXJlbnQpO1xuICAgICAgICBpZiAoZW5kX21vZGUuc3RhcnRzKSB7XG4gICAgICAgICAgc3RhcnROZXdNb2RlKGVuZF9tb2RlLnN0YXJ0cywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4ucmV0dXJuRW5kID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lsbGVnYWwobGV4ZW1lLCB0b3ApKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgbGV4ZW1lIFwiJyArIGxleGVtZSArICdcIiBmb3IgbW9kZSBcIicgKyAodG9wLmNsYXNzTmFtZSB8fCAnPHVubmFtZWQ+JykgKyAnXCInKTtcblxuICAgICAgLypcbiAgICAgIFBhcnNlciBzaG91bGQgbm90IHJlYWNoIHRoaXMgcG9pbnQgYXMgYWxsIHR5cGVzIG9mIGxleGVtZXMgc2hvdWxkIGJlIGNhdWdodFxuICAgICAgZWFybGllciwgYnV0IGlmIGl0IGRvZXMgZHVlIHRvIHNvbWUgYnVnIG1ha2Ugc3VyZSBpdCBhZHZhbmNlcyBhdCBsZWFzdCBvbmVcbiAgICAgIGNoYXJhY3RlciBmb3J3YXJkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcGluZy5cbiAgICAgICovXG4gICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICByZXR1cm4gbGV4ZW1lLmxlbmd0aCB8fCAxO1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZSA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZTogXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSk7XG4gICAgdmFyIHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBsYW5ndWFnZTtcbiAgICB2YXIgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICB2YXIgcmVzdWx0ID0gJycsIGN1cnJlbnQ7XG4gICAgZm9yKGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQgIT09IGxhbmd1YWdlOyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmNsYXNzTmFtZSkge1xuICAgICAgICByZXN1bHQgPSBidWlsZFNwYW4oY3VycmVudC5jbGFzc05hbWUsICcnLCB0cnVlKSArIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1vZGVfYnVmZmVyID0gJyc7XG4gICAgdmFyIHJlbGV2YW5jZSA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaCwgY291bnQsIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRvcC50ZXJtaW5hdG9ycy5sYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3AudGVybWluYXRvcnMuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvdW50ID0gcHJvY2Vzc0xleGVtZSh2YWx1ZS5zdWJzdHJpbmcoaW5kZXgsIG1hdGNoLmluZGV4KSwgbWF0Y2hbMF0pO1xuICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgY291bnQ7XG4gICAgICB9XG4gICAgICBwcm9jZXNzTGV4ZW1lKHZhbHVlLnN1YnN0cihpbmRleCkpO1xuICAgICAgZm9yKGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQucGFyZW50OyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHsgLy8gY2xvc2UgZGFuZ2xpbmcgbW9kZXNcbiAgICAgICAgaWYgKGN1cnJlbnQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHNwYW5FbmRUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBsYW5ndWFnZTogbmFtZSxcbiAgICAgICAgdG9wOiB0b3BcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubWVzc2FnZSAmJiBlLm1lc3NhZ2UuaW5kZXhPZignSWxsZWdhbCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICB2YWx1ZTogZXNjYXBlKHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICBIaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24uIEFjY2VwdHMgYSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0b1xuICBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gbGFuZ3VhZ2UgKGRldGVjdGVkIGxhbmd1YWdlKVxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG4gIC0gc2Vjb25kX2Jlc3QgKG9iamVjdCB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBmb3Igc2Vjb25kLWJlc3QgaGV1cmlzdGljYWxseVxuICAgIGRldGVjdGVkIGxhbmd1YWdlLCBtYXkgYmUgYWJzZW50KVxuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG8odGV4dCwgbGFuZ3VhZ2VTdWJzZXQpIHtcbiAgICBsYW5ndWFnZVN1YnNldCA9IGxhbmd1YWdlU3Vic2V0IHx8IG9wdGlvbnMubGFuZ3VhZ2VzIHx8IG9iamVjdEtleXMobGFuZ3VhZ2VzKTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgdmFsdWU6IGVzY2FwZSh0ZXh0KVxuICAgIH07XG4gICAgdmFyIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgIGxhbmd1YWdlU3Vic2V0LmZpbHRlcihnZXRMYW5ndWFnZSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGhpZ2hsaWdodChuYW1lLCB0ZXh0LCBmYWxzZSk7XG4gICAgICBjdXJyZW50Lmxhbmd1YWdlID0gbmFtZTtcbiAgICAgIGlmIChjdXJyZW50LnJlbGV2YW5jZSA+IHNlY29uZF9iZXN0LnJlbGV2YW5jZSkge1xuICAgICAgICBzZWNvbmRfYmVzdCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5yZWxldmFuY2UgPiByZXN1bHQucmVsZXZhbmNlKSB7XG4gICAgICAgIHNlY29uZF9iZXN0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzZWNvbmRfYmVzdC5sYW5ndWFnZSkge1xuICAgICAgcmVzdWx0LnNlY29uZF9iZXN0ID0gc2Vjb25kX2Jlc3Q7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICBQb3N0LXByb2Nlc3Npbmcgb2YgdGhlIGhpZ2hsaWdodGVkIG1hcmt1cDpcblxuICAtIHJlcGxhY2UgVEFCcyB3aXRoIHNvbWV0aGluZyBtb3JlIHVzZWZ1bFxuICAtIHJlcGxhY2UgcmVhbCBsaW5lLWJyZWFrcyB3aXRoICc8YnI+JyBmb3Igbm9uLXByZSBjb250YWluZXJzXG5cbiAgKi9cbiAgZnVuY3Rpb24gZml4TWFya3VwKHZhbHVlKSB7XG4gICAgcmV0dXJuICEob3B0aW9ucy50YWJSZXBsYWNlIHx8IG9wdGlvbnMudXNlQlIpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IHZhbHVlLnJlcGxhY2UoZml4TWFya3VwUmUsIGZ1bmN0aW9uKG1hdGNoLCBwMSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUJSICYmIG1hdGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICc8YnI+JztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFiUmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHAxLnJlcGxhY2UoL1xcdC9nLCBvcHRpb25zLnRhYlJlcGxhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lKHByZXZDbGFzc05hbWUsIGN1cnJlbnRMYW5nLCByZXN1bHRMYW5nKSB7XG4gICAgdmFyIGxhbmd1YWdlID0gY3VycmVudExhbmcgPyBhbGlhc2VzW2N1cnJlbnRMYW5nXSA6IHJlc3VsdExhbmcsXG4gICAgICAgIHJlc3VsdCAgID0gW3ByZXZDbGFzc05hbWUudHJpbSgpXTtcblxuICAgIGlmICghcHJldkNsYXNzTmFtZS5tYXRjaCgvXFxiaGxqc1xcYi8pKSB7XG4gICAgICByZXN1bHQucHVzaCgnaGxqcycpO1xuICAgIH1cblxuICAgIGlmIChwcmV2Q2xhc3NOYW1lLmluZGV4T2YobGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgcmVzdWx0LnB1c2gobGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGEgRE9NIG5vZGUgY29udGFpbmluZyBjb2RlLiBBY2NlcHRzIGEgRE9NIG5vZGUgYW5kXG4gIHR3byBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBmaXhNYXJrdXAuXG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEJsb2NrKGJsb2NrKSB7XG4gICAgdmFyIG5vZGUsIG9yaWdpbmFsU3RyZWFtLCByZXN1bHQsIHJlc3VsdE5vZGUsIHRleHQ7XG4gICAgdmFyIGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShibG9jayk7XG5cbiAgICBpZiAoaXNOb3RIaWdobGlnaHRlZChsYW5ndWFnZSkpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLnVzZUJSKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2RpdicpO1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBibG9jay5pbm5lckhUTUwucmVwbGFjZSgvXFxuL2csICcnKS5yZXBsYWNlKC88YnJbIFxcL10qPi9nLCAnXFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBibG9jaztcbiAgICB9XG4gICAgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgcmVzdWx0ID0gbGFuZ3VhZ2UgPyBoaWdobGlnaHQobGFuZ3VhZ2UsIHRleHQsIHRydWUpIDogaGlnaGxpZ2h0QXV0byh0ZXh0KTtcblxuICAgIG9yaWdpbmFsU3RyZWFtID0gbm9kZVN0cmVhbShub2RlKTtcbiAgICBpZiAob3JpZ2luYWxTdHJlYW0ubGVuZ3RoKSB7XG4gICAgICByZXN1bHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2RpdicpO1xuICAgICAgcmVzdWx0Tm9kZS5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXN1bHQudmFsdWUgPSBtZXJnZVN0cmVhbXMob3JpZ2luYWxTdHJlYW0sIG5vZGVTdHJlYW0ocmVzdWx0Tm9kZSksIHRleHQpO1xuICAgIH1cbiAgICByZXN1bHQudmFsdWUgPSBmaXhNYXJrdXAocmVzdWx0LnZhbHVlKTtcblxuICAgIGJsb2NrLmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICBibG9jay5jbGFzc05hbWUgPSBidWlsZENsYXNzTmFtZShibG9jay5jbGFzc05hbWUsIGxhbmd1YWdlLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIGJsb2NrLnJlc3VsdCA9IHtcbiAgICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgICByZTogcmVzdWx0LnJlbGV2YW5jZVxuICAgIH07XG4gICAgaWYgKHJlc3VsdC5zZWNvbmRfYmVzdCkge1xuICAgICAgYmxvY2suc2Vjb25kX2Jlc3QgPSB7XG4gICAgICAgIGxhbmd1YWdlOiByZXN1bHQuc2Vjb25kX2Jlc3QubGFuZ3VhZ2UsXG4gICAgICAgIHJlOiByZXN1bHQuc2Vjb25kX2Jlc3QucmVsZXZhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIFVwZGF0ZXMgaGlnaGxpZ2h0LmpzIGdsb2JhbCBvcHRpb25zIHdpdGggdmFsdWVzIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBhbiBvYmplY3QuXG4gICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZSh1c2VyX29wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gaW5oZXJpdChvcHRpb25zLCB1c2VyX29wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gYWxsIDxwcmU+PGNvZGU+Li48L2NvZGU+PC9wcmU+IGJsb2NrcyBvbiBhIHBhZ2UuXG4gICovXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmcoKSB7XG4gICAgaWYgKGluaXRIaWdobGlnaHRpbmcuY2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGluaXRIaWdobGlnaHRpbmcuY2FsbGVkID0gdHJ1ZTtcblxuICAgIHZhciBibG9ja3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgIEFycmF5UHJvdG8uZm9yRWFjaC5jYWxsKGJsb2NrcywgaGlnaGxpZ2h0QmxvY2spO1xuICB9XG5cbiAgLypcbiAgQXR0YWNoZXMgaGlnaGxpZ2h0aW5nIHRvIHRoZSBwYWdlIGxvYWQgZXZlbnQuXG4gICovXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaW5pdEhpZ2hsaWdodGluZywgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMYW5ndWFnZShuYW1lLCBsYW5ndWFnZSkge1xuICAgIHZhciBsYW5nID0gbGFuZ3VhZ2VzW25hbWVdID0gbGFuZ3VhZ2UoaGxqcyk7XG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgbGFuZy5hbGlhc2VzLmZvckVhY2goZnVuY3Rpb24oYWxpYXMpIHthbGlhc2VzW2FsaWFzXSA9IG5hbWU7fSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlzdExhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhsYW5ndWFnZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UobmFtZSkge1xuICAgIG5hbWUgPSAobmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbGFuZ3VhZ2VzW25hbWVdIHx8IGxhbmd1YWdlc1thbGlhc2VzW25hbWVdXTtcbiAgfVxuXG4gIC8qIEludGVyZmFjZSBkZWZpbml0aW9uICovXG5cbiAgaGxqcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gIGhsanMuaGlnaGxpZ2h0QXV0byA9IGhpZ2hsaWdodEF1dG87XG4gIGhsanMuZml4TWFya3VwID0gZml4TWFya3VwO1xuICBobGpzLmhpZ2hsaWdodEJsb2NrID0gaGlnaGxpZ2h0QmxvY2s7XG4gIGhsanMuY29uZmlndXJlID0gY29uZmlndXJlO1xuICBobGpzLmluaXRIaWdobGlnaHRpbmcgPSBpbml0SGlnaGxpZ2h0aW5nO1xuICBobGpzLmluaXRIaWdobGlnaHRpbmdPbkxvYWQgPSBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkO1xuICBobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UgPSByZWdpc3Rlckxhbmd1YWdlO1xuICBobGpzLmxpc3RMYW5ndWFnZXMgPSBsaXN0TGFuZ3VhZ2VzO1xuICBobGpzLmdldExhbmd1YWdlID0gZ2V0TGFuZ3VhZ2U7XG4gIGhsanMuaW5oZXJpdCA9IGluaGVyaXQ7XG5cbiAgLy8gQ29tbW9uIHJlZ2V4cHNcbiAgaGxqcy5JREVOVF9SRSA9ICdbYS16QS1aXVxcXFx3Kic7XG4gIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSA9ICdbYS16QS1aX11cXFxcdyonO1xuICBobGpzLk5VTUJFUl9SRSA9ICdcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKyk/JztcbiAgaGxqcy5DX05VTUJFUl9SRSA9ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XSt8KFxcXFxiXFxcXGQrKFxcXFwuXFxcXGQqKT98XFxcXC5cXFxcZCspKFtlRV1bLStdP1xcXFxkKyk/KSc7IC8vIDB4Li4uLCAwLi4uLCBkZWNpbWFsLCBmbG9hdFxuICBobGpzLkJJTkFSWV9OVU1CRVJfUkUgPSAnXFxcXGIoMGJbMDFdKyknOyAvLyAwYi4uLlxuICBobGpzLlJFX1NUQVJURVJTX1JFID0gJyF8IT18IT09fCV8JT18JnwmJnwmPXxcXFxcKnxcXFxcKj18XFxcXCt8XFxcXCs9fCx8LXwtPXwvPXwvfDp8O3w8PHw8PD18PD18PHw9PT18PT18PXw+Pj49fD4+PXw+PXw+Pj58Pj58PnxcXFxcP3xcXFxcW3xcXFxce3xcXFxcKHxcXFxcXnxcXFxcXj18XFxcXHx8XFxcXHw9fFxcXFx8XFxcXHx8fic7XG5cbiAgLy8gQ29tbW9uIG1vZGVzXG4gIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSA9IHtcbiAgICBiZWdpbjogJ1xcXFxcXFxcW1xcXFxzXFxcXFNdJywgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQVBPU19TVFJJTkdfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXFwnJywgZW5kOiAnXFwnJyxcbiAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICB9O1xuICBobGpzLlFVT1RFX1NUUklOR19NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdcIicsIGVuZDogJ1wiJyxcbiAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICB9O1xuICBobGpzLlBIUkFTQUxfV09SRFNfTU9ERSA9IHtcbiAgICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xuICB9O1xuICBobGpzLkNPTU1FTlQgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCwgaW5oZXJpdHMpIHtcbiAgICB2YXIgbW9kZSA9IGhsanMuaW5oZXJpdChcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY29tbWVudCcsXG4gICAgICAgIGJlZ2luOiBiZWdpbiwgZW5kOiBlbmQsXG4gICAgICAgIGNvbnRhaW5zOiBbXVxuICAgICAgfSxcbiAgICAgIGluaGVyaXRzIHx8IHt9XG4gICAgKTtcbiAgICBtb2RlLmNvbnRhaW5zLnB1c2goaGxqcy5QSFJBU0FMX1dPUkRTX01PREUpO1xuICAgIG1vZGUuY29udGFpbnMucHVzaCh7XG4gICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgYmVnaW46ICcoPzpUT0RPfEZJWE1FfE5PVEV8QlVHfFhYWCk6JyxcbiAgICAgIHJlbGV2YW5jZTogMFxuICAgIH0pO1xuICAgIHJldHVybiBtb2RlO1xuICB9O1xuICBobGpzLkNfTElORV9DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJy8vJywgJyQnKTtcbiAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnL1xcXFwqJywgJ1xcXFwqLycpO1xuICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFID0gaGxqcy5DT01NRU5UKCcjJywgJyQnKTtcbiAgaGxqcy5OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLk5VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5DX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQklOQVJZX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuQklOQVJZX05VTUJFUl9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5DU1NfTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5OVU1CRVJfUkUgKyAnKCcgK1xuICAgICAgJyV8ZW18ZXh8Y2h8cmVtJyAgK1xuICAgICAgJ3x2d3x2aHx2bWlufHZtYXgnICtcbiAgICAgICd8Y218bW18aW58cHR8cGN8cHgnICtcbiAgICAgICd8ZGVnfGdyYWR8cmFkfHR1cm4nICtcbiAgICAgICd8c3xtcycgK1xuICAgICAgJ3xIenxrSHonICtcbiAgICAgICd8ZHBpfGRwY218ZHBweCcgK1xuICAgICAgJyk/JyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5SRUdFWFBfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdyZWdleHAnLFxuICAgIGJlZ2luOiAvXFwvLywgZW5kOiAvXFwvW2dpbXV5XSovLFxuICAgIGlsbGVnYWw6IC9cXG4vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLywgZW5kOiAvXFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGhsanMuVElUTEVfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgYmVnaW46IGhsanMuSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICBiZWdpbjogaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLk1FVEhPRF9HVUFSRCA9IHtcbiAgICAvLyBleGNsdWRlcyBtZXRob2QgbmFtZXMgZnJvbSBrZXl3b3JkIHByb2Nlc3NpbmdcbiAgICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICByZXR1cm4gaGxqcztcbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFZBUiA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtiZWdpbjogL1xcJFtcXHdcXGQjQF1bXFx3XFxkX10qL30sXG4gICAgICB7YmVnaW46IC9cXCRcXHsoLio/KX0vfVxuICAgIF1cbiAgfTtcbiAgdmFyIFFVT1RFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvXCIvLCBlbmQ6IC9cIi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFZBUixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICBiZWdpbjogL1xcJFxcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgdmFyIEFQT1NfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46IC8nLywgZW5kOiAvJy9cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFsaWFzZXM6IFsnc2gnLCAnenNoJ10sXG4gICAgbGV4ZW1lczogL1xcYi0/W2EtelxcLl9dK1xcYi8sXG4gICAga2V5d29yZHM6IHtcbiAgICAgIGtleXdvcmQ6XG4gICAgICAgICdpZiB0aGVuIGVsc2UgZWxpZiBmaSBmb3Igd2hpbGUgaW4gZG8gZG9uZSBjYXNlIGVzYWMgZnVuY3Rpb24nLFxuICAgICAgbGl0ZXJhbDpcbiAgICAgICAgJ3RydWUgZmFsc2UnLFxuICAgICAgYnVpbHRfaW46XG4gICAgICAgIC8vIFNoZWxsIGJ1aWx0LWluc1xuICAgICAgICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NoZWxsLUJ1aWx0aW4tQ29tbWFuZHMuaHRtbFxuICAgICAgICAnYnJlYWsgY2QgY29udGludWUgZXZhbCBleGVjIGV4aXQgZXhwb3J0IGdldG9wdHMgaGFzaCBwd2QgcmVhZG9ubHkgcmV0dXJuIHNoaWZ0IHRlc3QgdGltZXMgJyArXG4gICAgICAgICd0cmFwIHVtYXNrIHVuc2V0ICcgK1xuICAgICAgICAvLyBCYXNoIGJ1aWx0LWluc1xuICAgICAgICAnYWxpYXMgYmluZCBidWlsdGluIGNhbGxlciBjb21tYW5kIGRlY2xhcmUgZWNobyBlbmFibGUgaGVscCBsZXQgbG9jYWwgbG9nb3V0IG1hcGZpbGUgcHJpbnRmICcgK1xuICAgICAgICAncmVhZCByZWFkYXJyYXkgc291cmNlIHR5cGUgdHlwZXNldCB1bGltaXQgdW5hbGlhcyAnICtcbiAgICAgICAgLy8gU2hlbGwgbW9kaWZpZXJzXG4gICAgICAgICdzZXQgc2hvcHQgJyArXG4gICAgICAgIC8vIFpzaCBidWlsdC1pbnNcbiAgICAgICAgJ2F1dG9sb2FkIGJnIGJpbmRrZXkgYnllIGNhcCBjaGRpciBjbG9uZSBjb21wYXJndW1lbnRzIGNvbXBjYWxsIGNvbXBjdGwgY29tcGRlc2NyaWJlIGNvbXBmaWxlcyAnICtcbiAgICAgICAgJ2NvbXBncm91cHMgY29tcHF1b3RlIGNvbXB0YWdzIGNvbXB0cnkgY29tcHZhbHVlcyBkaXJzIGRpc2FibGUgZGlzb3duIGVjaG90YyBlY2hvdGkgZW11bGF0ZSAnICtcbiAgICAgICAgJ2ZjIGZnIGZsb2F0IGZ1bmN0aW9ucyBnZXRjYXAgZ2V0bG4gaGlzdG9yeSBpbnRlZ2VyIGpvYnMga2lsbCBsaW1pdCBsb2cgbm9nbG9iIHBvcGQgcHJpbnQgJyArXG4gICAgICAgICdwdXNoZCBwdXNobG4gcmVoYXNoIHNjaGVkIHNldGNhcCBzZXRvcHQgc3RhdCBzdXNwZW5kIHR0eWN0bCB1bmZ1bmN0aW9uIHVuaGFzaCB1bmxpbWl0ICcgK1xuICAgICAgICAndW5zZXRvcHQgdmFyZWQgd2FpdCB3aGVuY2Ugd2hlcmUgd2hpY2ggemNvbXBpbGUgemZvcm1hdCB6ZnRwIHpsZSB6bW9kbG9hZCB6cGFyc2VvcHRzIHpwcm9mICcgK1xuICAgICAgICAnenB0eSB6cmVnZXhwYXJzZSB6c29ja2V0IHpzdHlsZSB6dGNwJyxcbiAgICAgIF86XG4gICAgICAgICctbmUgLWVxIC1sdCAtZ3QgLWYgLWQgLWUgLXMgLWwgLWEnIC8vIHJlbGV2YW5jZSBib29zdGVyXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC9eIyFbXlxcbl0rc2hcXHMqJC8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW46IC9cXHdbXFx3XFxkX10qXFxzKlxcKFxccypcXClcXHMqXFx7LyxcbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwge2JlZ2luOiAvXFx3W1xcd1xcZF9dKi99KV0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICBRVU9URV9TVFJJTkcsXG4gICAgICBBUE9TX1NUUklORyxcbiAgICAgIFZBUlxuICAgIF1cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9iYXNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBJREVOVF9SRSA9ICdbYS16QS1aLV1bYS16QS1aMC05Xy1dKic7XG4gIHZhciBSVUxFID0ge1xuICAgIGJlZ2luOiAvW0EtWlxcX1xcLlxcLV0rXFxzKjovLCByZXR1cm5CZWdpbjogdHJ1ZSwgZW5kOiAnOycsIGVuZHNXaXRoUGFyZW50OiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHJpYnV0ZScsXG4gICAgICAgIGJlZ2luOiAvXFxTLywgZW5kOiAnOicsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJlZ2luOiAvW1xcdy1dK1xcKC8sIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2J1aWx0X2luJyxcbiAgICAgICAgICAgICAgICAgIGJlZ2luOiAvW1xcdy1dKy9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhsanMuQ1NTX05VTUJFUl9NT0RFLFxuICAgICAgICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsIGJlZ2luOiAnI1swLTlBLUZhLWZdKydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLCBiZWdpbjogJyFpbXBvcnRhbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvWz1cXC98J1xcJF0vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1pZCcsIGJlZ2luOiAvI1tBLVphLXowLTlfLV0rL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItY2xhc3MnLCBiZWdpbjogL1xcLltBLVphLXowLTlfLV0rL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItYXR0cicsXG4gICAgICAgIGJlZ2luOiAvXFxbLywgZW5kOiAvXFxdLyxcbiAgICAgICAgaWxsZWdhbDogJyQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1wc2V1ZG8nLFxuICAgICAgICBiZWdpbjogLzooOik/W2EtekEtWjAtOVxcX1xcLVxcK1xcKFxcKVwiJy5dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQChmb250LWZhY2V8cGFnZSknLFxuICAgICAgICBsZXhlbWVzOiAnW2Etei1dKycsXG4gICAgICAgIGtleXdvcmRzOiAnZm9udC1mYWNlIHBhZ2UnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ0AnLCBlbmQ6ICdbeztdJywgLy8gYXRfcnVsZSBlYXRpbmcgZmlyc3QgXCJ7XCIgaXMgYSBnb29kIHRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGRvZXNu4oCZdCBsZXQgaXQgdG8gYmUgcGFyc2VkIGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHJ1bGUgc2V0IGJ1dCBpbnN0ZWFkIGRyb3BzIHBhcnNlciBpbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZGVmYXVsdCBtb2RlIHdoaWNoIGlzIGhvdyBpdCBzaG91bGQgYmUuXG4gICAgICAgIGlsbGVnYWw6IC86LywgLy8gYnJlYWsgb24gTGVzcyB2YXJpYWJsZXMgQHZhcjogLi4uXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAna2V5d29yZCcsXG4gICAgICAgICAgICBiZWdpbjogL1xcdysvXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogL1xccy8sIGVuZHNXaXRoUGFyZW50OiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLCBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgICAgICBobGpzLkNTU19OVU1CRVJfTU9ERVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItdGFnJywgYmVnaW46IElERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAneycsIGVuZDogJ30nLFxuICAgICAgICBpbGxlZ2FsOiAvXFxTLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIFJVTEUsXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBJREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuICB2YXIgS0VZV09SRFMgPSB7XG4gICAga2V5d29yZDpcbiAgICAgICdpbiBvZiBpZiBmb3Igd2hpbGUgZmluYWxseSB2YXIgbmV3IGZ1bmN0aW9uIGRvIHJldHVybiB2b2lkIGVsc2UgYnJlYWsgY2F0Y2ggJyArXG4gICAgICAnaW5zdGFuY2VvZiB3aXRoIHRocm93IGNhc2UgZGVmYXVsdCB0cnkgdGhpcyBzd2l0Y2ggY29udGludWUgdHlwZW9mIGRlbGV0ZSAnICtcbiAgICAgICdsZXQgeWllbGQgY29uc3QgZXhwb3J0IHN1cGVyIGRlYnVnZ2VyIGFzIGFzeW5jIGF3YWl0IHN0YXRpYyAnICtcbiAgICAgIC8vIEVDTUFTY3JpcHQgNiBtb2R1bGVzIGltcG9ydFxuICAgICAgJ2ltcG9ydCBmcm9tIGFzJ1xuICAgICxcbiAgICBsaXRlcmFsOlxuICAgICAgJ3RydWUgZmFsc2UgbnVsbCB1bmRlZmluZWQgTmFOIEluZmluaXR5JyxcbiAgICBidWlsdF9pbjpcbiAgICAgICdldmFsIGlzRmluaXRlIGlzTmFOIHBhcnNlRmxvYXQgcGFyc2VJbnQgZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCAnICtcbiAgICAgICdlbmNvZGVVUkkgZW5jb2RlVVJJQ29tcG9uZW50IGVzY2FwZSB1bmVzY2FwZSBPYmplY3QgRnVuY3Rpb24gQm9vbGVhbiBFcnJvciAnICtcbiAgICAgICdFdmFsRXJyb3IgSW50ZXJuYWxFcnJvciBSYW5nZUVycm9yIFJlZmVyZW5jZUVycm9yIFN0b3BJdGVyYXRpb24gU3ludGF4RXJyb3IgJyArXG4gICAgICAnVHlwZUVycm9yIFVSSUVycm9yIE51bWJlciBNYXRoIERhdGUgU3RyaW5nIFJlZ0V4cCBBcnJheSBGbG9hdDMyQXJyYXkgJyArXG4gICAgICAnRmxvYXQ2NEFycmF5IEludDE2QXJyYXkgSW50MzJBcnJheSBJbnQ4QXJyYXkgVWludDE2QXJyYXkgVWludDMyQXJyYXkgJyArXG4gICAgICAnVWludDhBcnJheSBVaW50OENsYW1wZWRBcnJheSBBcnJheUJ1ZmZlciBEYXRhVmlldyBKU09OIEludGwgYXJndW1lbnRzIHJlcXVpcmUgJyArXG4gICAgICAnbW9kdWxlIGNvbnNvbGUgd2luZG93IGRvY3VtZW50IFN5bWJvbCBTZXQgTWFwIFdlYWtTZXQgV2Vha01hcCBQcm94eSBSZWZsZWN0ICcgK1xuICAgICAgJ1Byb21pc2UnXG4gIH07XG4gIHZhciBFWFBSRVNTSU9OUztcbiAgdmFyIE5VTUJFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7IGJlZ2luOiAnXFxcXGIoMFtiQl1bMDFdKyknIH0sXG4gICAgICB7IGJlZ2luOiAnXFxcXGIoMFtvT11bMC03XSspJyB9LFxuICAgICAgeyBiZWdpbjogaGxqcy5DX05VTUJFUl9SRSB9XG4gICAgXSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgdmFyIFNVQlNUID0ge1xuICAgIGNsYXNzTmFtZTogJ3N1YnN0JyxcbiAgICBiZWdpbjogJ1xcXFwkXFxcXHsnLCBlbmQ6ICdcXFxcfScsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGNvbnRhaW5zOiBbXSAgLy8gZGVmaW5lZCBsYXRlclxuICB9O1xuICB2YXIgVEVNUExBVEVfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdgJywgZW5kOiAnYCcsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFNVQlNUXG4gICAgXVxuICB9O1xuICBTVUJTVC5jb250YWlucyA9IFtcbiAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgTlVNQkVSLFxuICAgIGhsanMuUkVHRVhQX01PREVcbiAgXVxuICB2YXIgUEFSQU1TX0NPTlRBSU5TID0gU1VCU1QuY29udGFpbnMuY29uY2F0KFtcbiAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERVxuICBdKTtcblxuICByZXR1cm4ge1xuICAgIGFsaWFzZXM6IFsnanMnLCAnanN4J10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICByZWxldmFuY2U6IDEwLFxuICAgICAgICBiZWdpbjogL15cXHMqWydcIl11c2UgKHN0cmljdHxhc20pWydcIl0vXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC9eIyEvLCBlbmQ6IC8kL1xuICAgICAgfSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgTlVNQkVSLFxuICAgICAgeyAvLyBvYmplY3QgYXR0ciBjb250YWluZXJcbiAgICAgICAgYmVnaW46IC9beyxdXFxzKi8sIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogSURFTlRfUkUgKyAnXFxcXHMqOicsIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFt7Y2xhc3NOYW1lOiAnYXR0cicsIGJlZ2luOiBJREVOVF9SRSwgcmVsZXZhbmNlOiAwfV1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7IC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgYmVnaW46ICcoJyArIGhsanMuUkVfU1RBUlRFUlNfUkUgKyAnfFxcXFxiKGNhc2V8cmV0dXJufHRocm93KVxcXFxiKVxcXFxzKicsXG4gICAgICAgIGtleXdvcmRzOiAncmV0dXJuIHRocm93IGNhc2UnLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIGhsanMuUkVHRVhQX01PREUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgYmVnaW46ICcoXFxcXCguKj9cXFxcKXwnICsgSURFTlRfUkUgKyAnKVxcXFxzKj0+JywgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICBlbmQ6ICdcXFxccyo9PicsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogSURFTlRfUkVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoXFxzKlxcKS8sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IC8vIEU0WCAvIEpTWFxuICAgICAgICAgICAgYmVnaW46IC88LywgZW5kOiAvKFxcL1xcdyt8XFx3K1xcLyk+LyxcbiAgICAgICAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtiZWdpbjogLzxcXHcrXFxzKlxcLz4vLCBza2lwOiB0cnVlfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiAvPFxcdysvLCBlbmQ6IC8oXFwvXFx3K3xcXHcrXFwvKT4vLCBza2lwOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAgICB7YmVnaW46IC88XFx3K1xccypcXC8+Lywgc2tpcDogdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAnc2VsZidcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICBiZWdpbktleXdvcmRzOiAnZnVuY3Rpb24nLCBlbmQ6IC9cXHsvLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHtiZWdpbjogSURFTlRfUkV9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGlsbGVnYWw6IC9cXFt8JS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFwkWyguXS8gLy8gcmVsZXZhbmNlIGJvb3N0ZXIgZm9yIGEgcGF0dGVybiBjb21tb24gdG8gSlMgbGliczogYCQoc29tZXRoaW5nKWAgYW5kIGAkLnNvbWV0aGluZ2BcbiAgICAgIH0sXG4gICAgICBobGpzLk1FVEhPRF9HVUFSRCxcbiAgICAgIHsgLy8gRVM2IGNsYXNzXG4gICAgICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2NsYXNzJywgZW5kOiAvW3s7PV0vLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBpbGxlZ2FsOiAvWzpcIlxcW1xcXV0vLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtiZWdpbktleXdvcmRzOiAnZXh0ZW5kcyd9LFxuICAgICAgICAgIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdjb25zdHJ1Y3RvcicsIGVuZDogL1xcey8sIGV4Y2x1ZGVFbmQ6IHRydWVcbiAgICAgIH1cbiAgICBdLFxuICAgIGlsbGVnYWw6IC8jKD8hISkvXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvamF2YXNjcmlwdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgWE1MX0lERU5UX1JFID0gJ1tBLVphLXowLTlcXFxcLl86LV0rJztcbiAgdmFyIFRBR19JTlRFUk5BTFMgPSB7XG4gICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgaWxsZWdhbDogLzwvLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICAgICAgYmVnaW46IFhNTF9JREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLz1cXHMqLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAge2JlZ2luOiAvXCIvLCBlbmQ6IC9cIi99LFxuICAgICAgICAgICAgICB7YmVnaW46IC8nLywgZW5kOiAvJy99LFxuICAgICAgICAgICAgICB7YmVnaW46IC9bXlxcc1wiJz08PmBdKy99XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICByZXR1cm4ge1xuICAgIGFsaWFzZXM6IFsnaHRtbCcsICd4aHRtbCcsICdyc3MnLCAnYXRvbScsICd4amInLCAneHNkJywgJ3hzbCcsICdwbGlzdCddLFxuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAnPCFET0NUWVBFJywgZW5kOiAnPicsXG4gICAgICAgIHJlbGV2YW5jZTogMTAsXG4gICAgICAgIGNvbnRhaW5zOiBbe2JlZ2luOiAnXFxcXFsnLCBlbmQ6ICdcXFxcXSd9XVxuICAgICAgfSxcbiAgICAgIGhsanMuQ09NTUVOVChcbiAgICAgICAgJzwhLS0nLFxuICAgICAgICAnLS0+JyxcbiAgICAgICAge1xuICAgICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICc8XFxcXCFcXFxcW0NEQVRBXFxcXFsnLCBlbmQ6ICdcXFxcXVxcXFxdPicsXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPFxcPyhwaHApPy8sIGVuZDogL1xcPz4vLFxuICAgICAgICBzdWJMYW5ndWFnZTogJ3BocCcsXG4gICAgICAgIGNvbnRhaW5zOiBbe2JlZ2luOiAnL1xcXFwqJywgZW5kOiAnXFxcXCovJywgc2tpcDogdHJ1ZX1dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICAvKlxuICAgICAgICBUaGUgbG9va2FoZWFkIHBhdHRlcm4gKD89Li4uKSBlbnN1cmVzIHRoYXQgJ2JlZ2luJyBvbmx5IG1hdGNoZXNcbiAgICAgICAgJzxzdHlsZScgYXMgYSBzaW5nbGUgd29yZCwgZm9sbG93ZWQgYnkgYSB3aGl0ZXNwYWNlIG9yIGFuXG4gICAgICAgIGVuZGluZyBicmFrZXQuIFRoZSAnJCcgaXMgbmVlZGVkIGZvciB0aGUgbGV4ZW1lIHRvIGJlIHJlY29nbml6ZWRcbiAgICAgICAgYnkgaGxqcy5zdWJNb2RlKCkgdGhhdCB0ZXN0cyBsZXhlbWVzIG91dHNpZGUgdGhlIHN0cmVhbS5cbiAgICAgICAgKi9cbiAgICAgICAgYmVnaW46ICc8c3R5bGUoPz1cXFxcc3w+fCQpJywgZW5kOiAnPicsXG4gICAgICAgIGtleXdvcmRzOiB7bmFtZTogJ3N0eWxlJ30sXG4gICAgICAgIGNvbnRhaW5zOiBbVEFHX0lOVEVSTkFMU10sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogJzwvc3R5bGU+JywgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbJ2NzcycsICd4bWwnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIDxzdHlsZSB0YWcgYWJvdXQgdGhlIGxvb2thaGVhZCBwYXR0ZXJuXG4gICAgICAgIGJlZ2luOiAnPHNjcmlwdCg/PVxcXFxzfD58JCknLCBlbmQ6ICc+JyxcbiAgICAgICAga2V5d29yZHM6IHtuYW1lOiAnc2NyaXB0J30sXG4gICAgICAgIGNvbnRhaW5zOiBbVEFHX0lOVEVSTkFMU10sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogJ1xcPFxcL3NjcmlwdFxcPicsIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogWydhY3Rpb25zY3JpcHQnLCAnamF2YXNjcmlwdCcsICdoYW5kbGViYXJzJywgJ3htbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgIHtiZWdpbjogLzxcXD94bWwvLCBlbmQ6IC9cXD8+LywgcmVsZXZhbmNlOiAxMH0sXG4gICAgICAgICAge2JlZ2luOiAvPFxcP1xcdysvLCBlbmQ6IC9cXD8+L31cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46ICc8Lz8nLCBlbmQ6ICcvPz4nLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ25hbWUnLCBiZWdpbjogL1teXFwvPjxcXHNdKy8sIHJlbGV2YW5jZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVEFHX0lOVEVSTkFMU1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyc1xuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJzsgfVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOyB9XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7IH1cblxuXG5mdW5jdGlvbiBlc2NhcGVSRShzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKTsgfVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZnV6enlMaW5rOiB0cnVlLFxuICBmdXp6eUVtYWlsOiB0cnVlLFxuICBmdXp6eUlQOiBmYWxzZVxufTtcblxuXG5mdW5jdGlvbiBpc09wdGlvbnNPYmoob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmogfHwge30pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrKSB7XG4gICAgcmV0dXJuIGFjYyB8fCBkZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgfSwgZmFsc2UpO1xufVxuXG5cbnZhciBkZWZhdWx0U2NoZW1hcyA9IHtcbiAgJ2h0dHA6Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ15cXFxcL1xcXFwvJyArIHNlbGYucmUuc3JjX2F1dGggKyBzZWxmLnJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ICsgc2VsZi5yZS5zcmNfcGF0aCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdodHRwczonOiAgJ2h0dHA6JyxcbiAgJ2Z0cDonOiAgICAnaHR0cDonLFxuICAnLy8nOiAgICAgIHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5ub19odHRwKSB7XG4gICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLm5vX2h0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2F1dGggK1xuICAgICAgICAgIC8vIERvbid0IGFsbG93IHNpbmdsZS1sZXZlbCBkb21haW5zLCBiZWNhdXNlIG9mIGZhbHNlIHBvc2l0aXZlcyBsaWtlICcvL3Rlc3QnXG4gICAgICAgICAgLy8gd2l0aCBjb2RlIGNvbW1lbnRzXG4gICAgICAgICAgJyg/OmxvY2FsaG9zdHwoPzooPzonICsgc2VsZi5yZS5zcmNfZG9tYWluICsgJylcXFxcLikrJyArIHNlbGYucmUuc3JjX2RvbWFpbl9yb290ICsgJyknICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wb3J0ICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BhdGgsXG5cbiAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmUubm9faHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIC8vIHNob3VsZCBub3QgYmUgYDovL2AgJiBgLy8vYCwgdGhhdCBwcm90ZWN0cyBmcm9tIGVycm9ycyBpbiBwcm90b2NvbCBuYW1lXG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnOicpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICcvJykgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm5vX2h0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ21haWx0bzonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubWFpbHRvKSB7XG4gICAgICAgIHNlbGYucmUubWFpbHRvID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICsgc2VsZi5yZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHNlbGYucmUuc3JjX2hvc3Rfc3RyaWN0LCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLm1haWx0by50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubWFpbHRvKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cbi8vIFJFIHBhdHRlcm4gZm9yIDItY2hhcmFjdGVyIHRsZHMgKGF1dG9nZW5lcmF0ZWQgYnkgLi9zdXBwb3J0L3RsZHNfMmNoYXJfZ2VuLmpzKVxudmFyIHRsZHNfMmNoX3NyY19yZSA9ICdhW2NkZWZnaWxtbm9xcnN0dXd4el18YlthYmRlZmdoaWptbm9yc3R2d3l6XXxjW2FjZGZnaGlrbG1ub3J1dnd4eXpdfGRbZWprbW96XXxlW2NlZ3JzdHVdfGZbaWprbW9yXXxnW2FiZGVmZ2hpbG1ucHFyc3R1d3ldfGhba21ucnR1XXxpW2RlbG1ub3Fyc3RdfGpbZW1vcF18a1tlZ2hpbW5wcnd5el18bFthYmNpa3JzdHV2eV18bVthY2RlZ2hrbG1ub3BxcnN0dXZ3eHl6XXxuW2FjZWZnaWxvcHJ1el18b218cFthZWZnaGtsbW5yc3R3eV18cWF8cltlb3N1d118c1thYmNkZWdoaWprbG1ub3J0dXZ4eXpdfHRbY2RmZ2hqa2xtbm9ydHZ3el18dVthZ2tzeXpdfHZbYWNlZ2ludV18d1tmc118eVtldF18elthbXddJztcblxuLy8gRE9OJ1QgdHJ5IHRvIG1ha2UgUFJzIHdpdGggY2hhbmdlcy4gRXh0ZW5kIFRMRHMgd2l0aCBMaW5raWZ5SXQudGxkcygpIGluc3RlYWRcbnZhciB0bGRzX2RlZmF1bHQgPSAnYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YQnLnNwbGl0KCd8Jyk7XG5cbi8qZXNsaW50LWVuYWJsZSBtYXgtbGVuKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gcmVzZXRTY2FuQ2FjaGUoc2VsZikge1xuICBzZWxmLl9faW5kZXhfXyA9IC0xO1xuICBzZWxmLl9fdGV4dF9jYWNoZV9fICAgPSAnJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHJlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGV4dCwgcG9zKSB7XG4gICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICBpZiAocmUudGVzdCh0YWlsKSkge1xuICAgICAgcmV0dXJuIHRhaWwubWF0Y2gocmUpWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6ZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIHNlbGYpIHtcbiAgICBzZWxmLm5vcm1hbGl6ZShtYXRjaCk7XG4gIH07XG59XG5cbi8vIFNjaGVtYXMgY29tcGlsZXIuIEJ1aWxkIHJlZ2V4cHMuXG4vL1xuZnVuY3Rpb24gY29tcGlsZShzZWxmKSB7XG5cbiAgLy8gTG9hZCAmIGNsb25lIFJFIHBhdHRlcm5zLlxuICB2YXIgcmUgPSBzZWxmLnJlID0gcmVxdWlyZSgnLi9saWIvcmUnKShzZWxmLl9fb3B0c19fKTtcblxuICAvLyBEZWZpbmUgZHluYW1pYyBwYXR0ZXJuc1xuICB2YXIgdGxkcyA9IHNlbGYuX190bGRzX18uc2xpY2UoKTtcblxuICBzZWxmLm9uQ29tcGlsZSgpO1xuXG4gIGlmICghc2VsZi5fX3RsZHNfcmVwbGFjZWRfXykge1xuICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpO1xuICB9XG4gIHRsZHMucHVzaChyZS5zcmNfeG4pO1xuXG4gIHJlLnNyY190bGRzID0gdGxkcy5qb2luKCd8Jyk7XG5cbiAgZnVuY3Rpb24gdW50cGwodHBsKSB7IHJldHVybiB0cGwucmVwbGFjZSgnJVRMRFMlJywgcmUuc3JjX3RsZHMpOyB9XG5cbiAgcmUuZW1haWxfZnV6enkgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfZW1haWxfZnV6enkpLCAnaScpO1xuICByZS5saW5rX2Z1enp5ICAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19ub19pcF9mdXp6eSA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19ub19pcF9mdXp6eSksICdpJyk7XG4gIHJlLmhvc3RfZnV6enlfdGVzdCAgPSBSZWdFeHAodW50cGwocmUudHBsX2hvc3RfZnV6enlfdGVzdCksICdpJyk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBlYWNoIHNjaGVtYVxuICAvL1xuXG4gIHZhciBhbGlhc2VzID0gW107XG5cbiAgc2VsZi5fX2NvbXBpbGVkX18gPSB7fTsgLy8gUmVzZXQgY29tcGlsZWQgZGF0YVxuXG4gIGZ1bmN0aW9uIHNjaGVtYUVycm9yKG5hbWUsIHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignKExpbmtpZnlJdCkgSW52YWxpZCBzY2hlbWEgXCInICsgbmFtZSArICdcIjogJyArIHZhbCk7XG4gIH1cblxuICBPYmplY3Qua2V5cyhzZWxmLl9fc2NoZW1hc19fKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbCA9IHNlbGYuX19zY2hlbWFzX19bbmFtZV07XG5cbiAgICAvLyBza2lwIGRpc2FibGVkIG1ldGhvZHNcbiAgICBpZiAodmFsID09PSBudWxsKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0geyB2YWxpZGF0ZTogbnVsbCwgbGluazogbnVsbCB9O1xuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV0gPSBjb21waWxlZDtcblxuICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBpZiAoaXNSZWdFeHAodmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRvcih2YWwudmFsaWRhdGUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSB2YWwudmFsaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWwubm9ybWFsaXplKSkge1xuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSB2YWwubm9ybWFsaXplO1xuICAgICAgfSBlbHNlIGlmICghdmFsLm5vcm1hbGl6ZSkge1xuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSBjcmVhdGVOb3JtYWxpemVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgIGFsaWFzZXMucHVzaChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICB9KTtcblxuICAvL1xuICAvLyBDb21waWxlIHBvc3Rwb25lZCBhbGlhc2VzXG4gIC8vXG5cbiAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgIGlmICghc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dKSB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIG9uIG1pc3NlZCBzY2hlbWFzIHRvIGF2b2lkIGVycm9ucyBvbiBkaXNhYmxlLlxuICAgICAgLy8gc2NoZW1hRXJyb3IoYWxpYXMsIHNlbGYuX19zY2hlbWFzX19bYWxpYXNdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10udmFsaWRhdGUgPVxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLnZhbGlkYXRlO1xuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS5ub3JtYWxpemUgPVxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLm5vcm1hbGl6ZTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gRmFrZSByZWNvcmQgZm9yIGd1ZXNzZWQgbGlua3NcbiAgLy9cbiAgc2VsZi5fX2NvbXBpbGVkX19bJyddID0geyB2YWxpZGF0ZTogbnVsbCwgbm9ybWFsaXplOiBjcmVhdGVOb3JtYWxpemVyKCkgfTtcblxuICAvL1xuICAvLyBCdWlsZCBzY2hlbWEgY29uZGl0aW9uXG4gIC8vXG4gIHZhciBzbGlzdCA9IE9iamVjdC5rZXlzKHNlbGYuX19jb21waWxlZF9fKVxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBkaXNhYmxlZCAmIGZha2Ugc2NoZW1hc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZXNjYXBlUkUpXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgLy8gKD8hXykgY2F1c2UgMS41eCBzbG93ZG93blxuICBzZWxmLnJlLnNjaGVtYV90ZXN0ICAgPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2knKTtcbiAgc2VsZi5yZS5zY2hlbWFfc2VhcmNoID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpZycpO1xuXG4gIHNlbGYucmUucHJldGVzdCAgICAgICA9IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLnNjaGVtYV90ZXN0LnNvdXJjZSArICcpfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaScpO1xuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKTtcbn1cblxuLyoqXG4gKiBjbGFzcyBNYXRjaFxuICpcbiAqIE1hdGNoIHJlc3VsdC4gU2luZ2xlIGVsZW1lbnQgb2YgYXJyYXksIHJldHVybmVkIGJ5IFtbTGlua2lmeUl0I21hdGNoXV1cbiAqKi9cbmZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBzdGFydCA9IHNlbGYuX19pbmRleF9fLFxuICAgICAgZW5kICAgPSBzZWxmLl9fbGFzdF9pbmRleF9fLFxuICAgICAgdGV4dCAgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIC8qKlxuICAgKiBNYXRjaCNzY2hlbWEgLT4gU3RyaW5nXG4gICAqXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnNjaGVtYSAgICA9IHNlbGYuX19zY2hlbWFfXy50b0xvd2VyQ2FzZSgpO1xuICAvKipcbiAgICogTWF0Y2gjaW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIEZpcnN0IHBvc2l0aW9uIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuaW5kZXggICAgID0gc3RhcnQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjcmF3IC0+IFN0cmluZ1xuICAgKlxuICAgKiBNYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnJhdyAgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN0ZXh0IC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy50ZXh0ICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdXJsIC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3JtYWxpemVkIHVybCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnVybCAgICAgICA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdCk7XG5cbiAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuXG4vKipcbiAqIGNsYXNzIExpbmtpZnlJdFxuICoqL1xuXG4vKipcbiAqIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucylcbiAqIC0gc2NoZW1hcyAoT2JqZWN0KTogT3B0aW9uYWwuIEFkZGl0aW9uYWwgc2NoZW1hcyB0byB2YWxpZGF0ZSAocHJlZml4L3ZhbGlkYXRvcilcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBDcmVhdGVzIG5ldyBsaW5raWZpZXIgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBhZGRpdGlvbmFsIHNjaGVtYXMuXG4gKiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2Aga2V5d29yZCBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQnkgZGVmYXVsdCB1bmRlcnN0YW5kczpcbiAqXG4gKiAtIGBodHRwKHMpOi8vLi4uYCAsIGBmdHA6Ly8uLi5gLCBgbWFpbHRvOi4uLmAgJiBgLy8uLi5gIGxpbmtzXG4gKiAtIFwiZnV6enlcIiBsaW5rcyBhbmQgZW1haWxzIChleGFtcGxlLmNvbSwgZm9vQGJhci5jb20pLlxuICpcbiAqIGBzY2hlbWFzYCBpcyBhbiBvYmplY3QsIHdoZXJlIGVhY2gga2V5L3ZhbHVlIGRlc2NyaWJlcyBwcm90b2NvbC9ydWxlOlxuICpcbiAqIC0gX19rZXlfXyAtIGxpbmsgcHJlZml4ICh1c3VhbGx5LCBwcm90b2NvbCBuYW1lIHdpdGggYDpgIGF0IHRoZSBlbmQsIGBza3lwZTpgXG4gKiAgIGZvciBleGFtcGxlKS4gYGxpbmtpZnktaXRgIG1ha2VzIHNodXJlIHRoYXQgcHJlZml4IGlzIG5vdCBwcmVjZWVkZWQgd2l0aFxuICogICBhbHBoYW51bWVyaWMgY2hhciBhbmQgc3ltYm9scy4gT25seSB3aGl0ZXNwYWNlcyBhbmQgcHVuY3R1YXRpb24gYWxsb3dlZC5cbiAqIC0gX192YWx1ZV9fIC0gcnVsZSB0byBjaGVjayB0YWlsIGFmdGVyIGxpbmsgcHJlZml4XG4gKiAgIC0gX1N0cmluZ18gLSBqdXN0IGFsaWFzIHRvIGV4aXN0aW5nIHJ1bGVcbiAqICAgLSBfT2JqZWN0X1xuICogICAgIC0gX3ZhbGlkYXRlXyAtIHZhbGlkYXRvciBmdW5jdGlvbiAoc2hvdWxkIHJldHVybiBtYXRjaGVkIGxlbmd0aCBvbiBzdWNjZXNzKSxcbiAqICAgICAgIG9yIGBSZWdFeHBgLlxuICogICAgIC0gX25vcm1hbGl6ZV8gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBub3JtYWxpemUgdGV4dCAmIHVybCBvZiBtYXRjaGVkIHJlc3VsdFxuICogICAgICAgKGZvciBleGFtcGxlLCBmb3IgQHR3aXR0ZXIgbWVudGlvbnMpLlxuICpcbiAqIGBvcHRpb25zYDpcbiAqXG4gKiAtIF9fZnV6enlMaW5rX18gLSByZWNvZ25pZ2UgVVJMLXMgd2l0aG91dCBgaHR0cChzKTpgIHByZWZpeC4gRGVmYXVsdCBgdHJ1ZWAuXG4gKiAtIF9fZnV6enlJUF9fIC0gYWxsb3cgSVBzIGluIGZ1enp5IGxpbmtzIGFib3ZlLiBDYW4gY29uZmxpY3Qgd2l0aCBzb21lIHRleHRzXG4gKiAgIGxpa2UgdmVyc2lvbiBudW1iZXJzLiBEZWZhdWx0IGBmYWxzZWAuXG4gKiAtIF9fZnV6enlFbWFpbF9fIC0gcmVjb2duaXplIGVtYWlscyB3aXRob3V0IGBtYWlsdG86YCBwcmVmaXguXG4gKlxuICoqL1xuZnVuY3Rpb24gTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICByZXR1cm4gbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmIChpc09wdGlvbnNPYmooc2NoZW1hcykpIHtcbiAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgc2NoZW1hcyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX19vcHRzX18gICAgICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyAgICAgICAgICA9IC0xO1xuICB0aGlzLl9fbGFzdF9pbmRleF9fICAgICA9IC0xOyAvLyBOZXh0IHNjYW4gcG9zaXRpb25cbiAgdGhpcy5fX3NjaGVtYV9fICAgICAgICAgPSAnJztcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyAgICAgPSAnJztcblxuICB0aGlzLl9fc2NoZW1hc19fICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdFNjaGVtYXMsIHNjaGVtYXMpO1xuICB0aGlzLl9fY29tcGlsZWRfXyAgICAgICA9IHt9O1xuXG4gIHRoaXMuX190bGRzX18gICAgICAgICAgID0gdGxkc19kZWZhdWx0O1xuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fICA9IGZhbHNlO1xuXG4gIHRoaXMucmUgPSB7fTtcblxuICBjb21waWxlKHRoaXMpO1xufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxuICogLSBzY2hlbWEgKFN0cmluZyk6IHJ1bGUgbmFtZSAoZml4ZWQgcGF0dGVybiBwcmVmaXgpXG4gKiAtIGRlZmluaXRpb24gKFN0cmluZ3xSZWdFeHB8T2JqZWN0KTogc2NoZW1hIGRlZmluaXRpb25cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgZGVmaW5pdGlvbi4gU2VlIGNvbnN0cnVjdG9yIGRlc2NyaXB0aW9uIGZvciBkZXRhaWxzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gIHRoaXMuX19zY2hlbWFzX19bc2NoZW1hXSA9IGRlZmluaXRpb247XG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjc2V0KG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogU2V0IHJlY29nbml0aW9uIG9wdGlvbnMgZm9yIGxpbmtzIHdpdGhvdXQgc2NoZW1hLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICB0aGlzLl9fb3B0c19fID0gYXNzaWduKHRoaXMuX19vcHRzX18sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogU2VhcmNoZXMgbGlua2lmaWFibGUgcGF0dGVybiBhbmQgcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2VzcyBvciBgZmFsc2VgIG9uIGZhaWwuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gICAgICA9IC0xO1xuXG4gIGlmICghdGV4dC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG0sIG1sLCBtZSwgbGVuLCBzaGlmdCwgbmV4dCwgcmUsIHRsZF9wb3MsIGF0X3BvcztcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9IG1bMl07XG4gICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5TGluayAmJiB0aGlzLl9fY29tcGlsZWRfX1snaHR0cDonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgbGlua3NcbiAgICB0bGRfcG9zID0gdGV4dC5zZWFyY2godGhpcy5yZS5ob3N0X2Z1enp5X3Rlc3QpO1xuICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgIC8vIGlmIHRsZCBpcyBsb2NhdGVkIGFmdGVyIGZvdW5kIGxpbmsgLSBubyBuZWVkIHRvIGNoZWNrIGZ1enp5IHBhdHRlcm5cbiAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgdGxkX3BvcyA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgIGlmICgobWwgPSB0ZXh0Lm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCAmJiB0aGlzLl9fY29tcGlsZWRfX1snbWFpbHRvOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBlbWFpbHNcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgIHNoaWZ0ID0gbWUuaW5kZXggKyBtZVsxXS5sZW5ndGg7XG4gICAgICAgIG5leHQgID0gbWUuaW5kZXggKyBtZVswXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XG4gICAgICAgICAgICAoc2hpZnQgPT09IHRoaXMuX19pbmRleF9fICYmIG5leHQgPiB0aGlzLl9fbGFzdF9pbmRleF9fKSkge1xuICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnbWFpbHRvOic7XG4gICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX19pbmRleF9fID49IDA7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCh0ZXh0KSB7XG4gIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcbiAqIC0gdGV4dCAoU3RyaW5nKTogdGV4dCB0byBzY2FuXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgKHNjaGVtYSkgbmFtZVxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxuICpcbiAqIFNpbWlsYXIgdG8gW1tMaW5raWZ5SXQjdGVzdF1dIGJ1dCBjaGVja3Mgb25seSBzcGVjaWZpYyBwcm90b2NvbCB0YWlsIGV4YWN0bHlcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0U2NoZW1hQXQgPSBmdW5jdGlvbiB0ZXN0U2NoZW1hQXQodGV4dCwgc2NoZW1hLCBwb3MpIHtcbiAgLy8gSWYgbm90IHN1cHBvcnRlZCBzY2hlbWEgY2hlY2sgcmVxdWVzdGVkIC0gdGVybWluYXRlXG4gIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0LCBwb3MsIHRoaXMpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNtYXRjaCh0ZXh0KSAtPiBBcnJheXxudWxsXG4gKlxuICogUmV0dXJucyBhcnJheSBvZiBmb3VuZCBsaW5rIGRlc2NyaXB0aW9ucyBvciBgbnVsbGAgb24gZmFpbC4gV2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCB0byB1c2UgW1tMaW5raWZ5SXQjdGVzdF1dIGZpcnN0LCBmb3IgYmVzdCBzcGVlZC5cbiAqXG4gKiAjIyMjIyBSZXN1bHQgbWF0Y2ggZGVzY3JpcHRpb25cbiAqXG4gKiAtIF9fc2NoZW1hX18gLSBsaW5rIHNjaGVtYSwgY2FuIGJlIGVtcHR5IGZvciBmdXp6eSBsaW5rcywgb3IgYC8vYCBmb3JcbiAqICAgcHJvdG9jb2wtbmV1dHJhbCAgbGlua3MuXG4gKiAtIF9faW5kZXhfXyAtIG9mZnNldCBvZiBtYXRjaGVkIHRleHRcbiAqIC0gX19sYXN0SW5kZXhfXyAtIGluZGV4IG9mIG5leHQgY2hhciBhZnRlciBtYXRoY2ggZW5kXG4gKiAtIF9fcmF3X18gLSBtYXRjaGVkIHRleHRcbiAqIC0gX190ZXh0X18gLSBub3JtYWxpemVkIHRleHRcbiAqIC0gX191cmxfXyAtIGxpbmssIGdlbmVyYXRlZCBmcm9tIG1hdGNoZWQgdGV4dFxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHRleHQpIHtcbiAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG5cbiAgLy8gVHJ5IHRvIHRha2UgcHJldmlvdXMgZWxlbWVudCBmcm9tIGNhY2hlLCBpZiAudGVzdCgpIGNhbGxlZCBiZWZvcmVcbiAgaWYgKHRoaXMuX19pbmRleF9fID49IDAgJiYgdGhpcy5fX3RleHRfY2FjaGVfXyA9PT0gdGV4dCkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgc2hpZnQgPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgLy8gQ3V0IGhlYWQgaWYgY2FjaGUgd2FzIHVzZWRcbiAgdmFyIHRhaWwgPSBzaGlmdCA/IHRleHQuc2xpY2Uoc2hpZnQpIDogdGV4dDtcblxuICAvLyBTY2FuIHN0cmluZyB1bnRpbCBlbmQgcmVhY2hlZFxuICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcblxuICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgIHNoaWZ0ICs9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xuICogLSBsaXN0IChBcnJheSk6IGxpc3Qgb2YgdGxkc1xuICogLSBrZWVwT2xkIChCb29sZWFuKTogbWVyZ2Ugd2l0aCBjdXJyZW50IGxpc3QgaWYgYHRydWVgIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gKlxuICogTG9hZCAob3IgbWVyZ2UpIG5ldyB0bGRzIGxpc3QuIFRob3NlIGFyZSB1c2VyIGZvciBmdXp6eSBsaW5rcyAod2l0aG91dCBwcmVmaXgpXG4gKiB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuIEJ5IGRlZmF1bHQgdGhpcyBhbGdvcnl0aG0gdXNlZDpcbiAqXG4gKiAtIGhvc3RuYW1lIHdpdGggYW55IDItbGV0dGVyIHJvb3Qgem9uZXMgYXJlIG9rLlxuICogLSBiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFxuICogICBhcmUgb2suXG4gKiAtIGVuY29kZWQgKGB4bi0tLi4uYCkgcm9vdCB6b25lcyBhcmUgb2suXG4gKlxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uIHRsZHMobGlzdCwga2VlcE9sZCkge1xuICBsaXN0ID0gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QgOiBbIGxpc3QgXTtcblxuICBpZiAoIWtlZXBPbGQpIHtcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlO1xuICAgIGNvbXBpbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG5cbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNub3JtYWxpemUobWF0Y2gpXG4gKlxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG5cbiAgLy8gRG8gbWluaW1hbCBwb3NzaWJsZSBjaGFuZ2VzIGJ5IGRlZmF1bHQuIE5lZWQgdG8gY29sbGVjdCBmZWVkYmFjayBwcmlvclxuICAvLyB0byBtb3ZlIGZvcndhcmQgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQvaXNzdWVzLzFcblxuICBpZiAoIW1hdGNoLnNjaGVtYSkgeyBtYXRjaC51cmwgPSAnaHR0cDovLycgKyBtYXRjaC51cmw7IH1cblxuICBpZiAobWF0Y2guc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QobWF0Y2gudXJsKSkge1xuICAgIG1hdGNoLnVybCA9ICdtYWlsdG86JyArIG1hdGNoLnVybDtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNvbkNvbXBpbGUoKVxuICpcbiAqIE92ZXJyaWRlIHRvIG1vZGlmeSBiYXNpYyBSZWdFeHAtcy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUub25Db21waWxlID0gZnVuY3Rpb24gb25Db21waWxlKCkge1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtpZnlJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbGlua2lmeS1pdC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57MiwzfVthLXpBLVowLTklL118JyArIC8vIGdpdGh1YiBoYXMgLi4uIGluIGNvbW1pdCByYW5nZSBsaW5rcy4gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgOlxuICAgICAgICAgICAgJ1xcXFwtK3wnXG4gICAgICAgICAgKSArXG4gICAgICAgICAgJ1xcXFwsKD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgLy8gYWxsb3cgYCwsLGAgaW4gcGF0aHNcbiAgICAgICAgICAnXFxcXCEoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdKS58JyArXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XSkuJyArXG4gICAgICAgICcpKycgK1xuICAgICAgJ3xcXFxcLycgK1xuICAgICcpPyc7XG5cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10rJztcblxuICByZS5zcmNfeG4gPVxuXG4gICAgJ3huLS1bYS16MC05XFxcXC1dezEsNTl9JztcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19kb21haW4gPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAgICd8JyArXG4gICAgICAvLyBkb24ndCBhbGxvdyBgLS1gIGluIGRvbWFpbiBuYW1lcywgYmVjYXVzZTpcbiAgICAgIC8vIC0gdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBtYXJrZG93biAmbWRhc2g7IC8gJm5kYXNoO1xuICAgICAgLy8gLSBub2JvZHkgdXNlIHRob3NlIGFueXdheVxuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotKD8hLSl8JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICcpJztcblxuICByZS5zcmNfaG9zdCA9XG5cbiAgICAnKD86JyArXG4gICAgLy8gRG9uJ3QgbmVlZCBJUCBjaGVjaywgYmVjYXVzZSBkaWdpdHMgYXJlIGFscmVhZHkgYWxsb3dlZCBpbiBub3JtYWwgZG9tYWluIG5hbWVzXG4gICAgLy8gICBzcmNfaXA0ICtcbiAgICAvLyAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikqJyArIHJlLnNyY19kb21haW4vKl9yb290Ki8gKyAnKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9mdXp6eSA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfaXA0ICtcbiAgICAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgPVxuXG4gICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikrKD86JVRMRFMlKSknO1xuXG4gIHJlLnNyY19ob3N0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE1haW4gcnVsZXNcblxuICAvLyBSdWRlIHRlc3QgZnV6enkgbGlua3MgYnkgaG9zdCwgZm9yIHF1aWNrIGRlbnlcbiAgcmUudHBsX2hvc3RfZnV6enlfdGVzdCA9XG5cbiAgICAnbG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OicgKyByZS5zcmNfWlBDYyArICd8PnwkKSknO1xuXG4gIHJlLnRwbF9lbWFpbF9mdXp6eSA9XG5cbiAgICAgICcoXnwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcXFxcKHwnICsgcmUuc3JjX1pDYyArICcpKCcgKyByZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCArICcpJztcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZXR1cm4gcmU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9saW5raWZ5LWl0L2xpYi9yZS5qcyIsIid1c2Ugc3RyaWN0J1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxudmFyIHRhZ0V4cHIgPSAvXjwhLS0gP1xceyg/OihbYS16MC05XSspKFxcXlswLTldKik/OiA/KT8oLiopXFx9ID8tLT5cXG4/JC9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzIChtZCkge1xuICBtZC5jb3JlLnJ1bGVyLnB1c2goJ2N1cmx5X2F0dHJpYnV0ZXMnLCBjdXJseUF0dHJzKVxufVxuXG4vKlxuICogTGlzdCBvZiB0YWcgLT4gdG9rZW4gdHlwZSBtYXBwaW5ncy4gRWcsIGA8bGk+YCBpcyBgbGlzdF9pdGVtX29wZW5gLlxuICovXG5cbnZhciBvcGVuaW5nID0ge1xuICBsaTogWydsaXN0X2l0ZW0nXSxcbiAgdWw6IFsnYnVsbGV0X2xpc3QnXSxcbiAgcDogWydwYXJhZ3JhcGgnXSxcbiAgb2w6IFsnb3JkZXJlZF9saXN0J10sXG4gIGJsb2NrcXVvdGU6IFsnYmxvY2txdW90ZSddLFxuICBoMTogWydoZWFkaW5nJ10sXG4gIGgyOiBbJ2hlYWRpbmcnXSxcbiAgaDM6IFsnaGVhZGluZyddLFxuICBoNDogWydoZWFkaW5nJ10sXG4gIGg1OiBbJ2hlYWRpbmcnXSxcbiAgaDY6IFsnaGVhZGluZyddLFxuICBhOiBbJ2xpbmsnXSxcbiAgY29kZTogWydjb2RlX2lubGluZScsICdjb2RlX2Jsb2NrJywgJ2ZlbmNlJ11cbn1cblxudmFyIHNlbGZDbG9zaW5nID0ge1xuICBocjogdHJ1ZSxcbiAgaW1hZ2U6IHRydWVcbn1cblxuLyoqXG4gKiAuLi5cbiAqL1xuXG5mdW5jdGlvbiBjdXJseUF0dHJzIChzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zXG4gIHZhciBvbWlzc2lvbnMgPSBbXVxuICB2YXIgcGFyZW50LCBtXG4gIHZhciBzdGFjayA9IHsgbGVuOiAwLCBjb250ZW50czogW10sIHR5cGVzOiB7fSB9XG5cbiAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuLCBpKSB7XG4gICAgLy8gU2F2ZSBicmVhZGNydW1icyBzbyBodG1sX2Jsb2NrIHdpbGwgcGljayBpdCB1cFxuICAgIGlmIChpc09wZW5lcih0b2tlbi50eXBlKSB8fCBzZWxmQ2xvc2luZ1t0b2tlbi50eXBlXSkge1xuICAgICAgc3B1c2goc3RhY2ssIHRva2VuKVxuICAgIH1cblxuICAgIC8vIFwiIyBIZWxsb1xcbjwhLS17LmNsYXNzbmFtZX0tLT5cIlxuICAgIC8vIC4uLnNlcXVlbmNlIG9mIFtoZWFkaW5nX29wZW4sIGlubGluZSwgaGVhZGluZ19jbG9zZSwgaHRtbF9ibG9ja11cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2h0bWxfYmxvY2snKSB7XG4gICAgICBtID0gdG9rZW4uY29udGVudC5tYXRjaCh0YWdFeHByKVxuICAgICAgaWYgKCFtKSByZXR1cm5cblxuICAgICAgcGFyZW50ID0gZmluZFBhcmVudChzdGFjaywgbVsxXSwgbVsyXSlcbiAgICAgIGlmIChwYXJlbnQgJiYgYXBwbHlUb1Rva2VuKHBhcmVudCwgbVszXSkpIHtcbiAgICAgICAgb21pc3Npb25zLnVuc2hpZnQoaSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBcIiMgSGVsbG8gPCEtLXsuY2xhc3NuYW1lfSAtLT5cIlxuICAgIC8vIHsgdHlwZTogJ2lubGluZScsIGNoaWxkcmVuOiB7IC4uLiwgJzwhLS17Li4ufS0tPicgfSB9XG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBjdXJseUlubGluZSh0b2tlbi5jaGlsZHJlbiwgc3RhY2spXG4gICAgfVxuICB9KVxuXG4gIC8vIFJlbW92ZSA8IS0tLi4uLS0+IGh0bWxfYmxvY2sgdG9rZW5zXG4gIG9taXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIHRva2Vucy5zcGxpY2UoaWR4LCAxKSB9KVxufVxuXG4vKipcbiAqIEludGVybmFsOiBjaGVja3MgaW4gYSB0b2tlbiB0eXBlIGlzIGEgYmxvY2sgb3BlbmVyXG4gKi9cblxuZnVuY3Rpb24gaXNPcGVuZXIgKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUubWF0Y2goL18ob3BlbnxzdGFydCkkLykgfHxcbiAgICB0eXBlID09PSAnZmVuY2UnIHx8IHR5cGUgPT09ICdjb2RlX2Jsb2NrJ1xufVxuXG4vKipcbiAqIEludGVybmFsOiBSdW4gdGhyb3VnaCBpbmxpbmUgYW5kIHN0dWZmXG4gKi9cblxuZnVuY3Rpb24gY3VybHlJbmxpbmUgKGNoaWxkcmVuLCBzdGFjaykge1xuICB2YXIgbGFzdFRleHQsIG0sIHBhcmVudFxuXG4gIC8vIEtlZXAgYSBsaXN0IG9mIHN1Yi10b2tlbnMgdG8gYmUgcmVtb3ZlZFxuICB2YXIgb21pc3Npb25zID0gW11cblxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgIGlmIChpc09wZW5lcihjaGlsZC50eXBlKSB8fFxuICAgICAgc2VsZkNsb3NpbmdbY2hpbGQudHlwZV0gfHxcbiAgICAgIGNoaWxkLnR5cGUgPT09ICdjb2RlX2lubGluZScpIHtcbiAgICAgIHNwdXNoKHN0YWNrLCBjaGlsZClcbiAgICB9XG5cbiAgICAvLyBEZWNvcmF0ZSB0YWdzIGFyZSBmb3VuZFxuICAgIGlmIChtID0gY2hpbGQuY29udGVudC5tYXRjaCh0YWdFeHByKSkge1xuICAgICAgdmFyIHRhZyA9IG1bMV1cbiAgICAgIHZhciBkZXB0aCA9IG1bMl1cbiAgICAgIHZhciBhdHRycyA9IG1bM11cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBjb21tZW50LCB0aGVuIHJlbW92ZSB0aGUgZXh0cmEgc3BhY2VcbiAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnQoc3RhY2ssIHRhZywgZGVwdGgpXG4gICAgICBpZiAocGFyZW50ICYmIGFwcGx5VG9Ub2tlbihwYXJlbnQsIGF0dHJzKSkge1xuICAgICAgICBvbWlzc2lvbnMudW5zaGlmdChpKVxuICAgICAgICBpZiAobGFzdFRleHQpIHRyaW1SaWdodChsYXN0VGV4dCwgJ2NvbnRlbnQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZC50eXBlID09PSAndGV4dCcpIGxhc3RUZXh0ID0gY2hpbGRcbiAgfSlcblxuICAvLyBSZW1vdmUgdGhlbSBpbiBhIHNlcGFyYXRlIHN0ZXAgc28gd2UgZG9uJ3RcbiAgb21pc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpXG4gIH0pXG59XG5cbi8qKlxuICogUHJpdmF0ZTogZ2l2ZW4gYSBsaXN0IG9mIHRva2VucyBgbGlzdGAgYW5kIGBsYXN0UGFyZW50YCwgZmluZCB0aGUgb25lIHRoYXRcbiAqIG1hdGNoZXMgYHRhZ2AuXG4gKi9cblxuZnVuY3Rpb24gZmluZFBhcmVudCAoc3RhY2ssIHRhZywgZGVwdGgpIHtcbiAgaWYgKCF0YWcpIHJldHVybiBzdGFjay5sYXN0XG5cbiAgaWYgKGRlcHRoID09PSAnXicpIHtcbiAgICBkZXB0aCA9IDFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVwdGggPT09ICdzdHJpbmcnKSB7IC8qICdeMicgKi9cbiAgICBkZXB0aCA9ICtkZXB0aC5zdWJzdHIoMSlcbiAgfSBlbHNlIHtcbiAgICBkZXB0aCA9IDBcbiAgfVxuXG4gIHZhciB0YXJnZXRzID0gb3BlbmluZ1t0YWcudG9Mb3dlckNhc2UoKV0gfHwgW3RhZy50b0xvd2VyQ2FzZSgpXVxuXG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHN0YWNrLnR5cGVzW3RhcmdldF1cbiAgfSlcblxuICB2YXIgbGlzdCA9IHN0YWNrLnR5cGVzW3RhcmdldF1cbiAgaWYgKCFsaXN0KSByZXR1cm4gLy8gQ2FuJ3QgZmluZCB0YWcgYHRhZ2BcblxuICByZXR1cm4gbGlzdFtsaXN0Lmxlbmd0aCAtIDEgLSBkZXB0aF1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiB0cmltIHRoZSByaWdodFxuICovXG5cbmZ1bmN0aW9uIHRyaW1SaWdodCAob2JqLCBhdHRyKSB7XG4gIG9ialthdHRyXSA9IG9ialthdHRyXS5yZXBsYWNlKC9cXHMqJC8sICcnKVxufVxuXG4vKipcbiAqIFByaXZhdGU6IGFwcGx5IHRhZyB0byB0b2tlblxuICpcbiAqICAgICBhcHBseVRvVG9rZW4odG9rZW4sICcuY2xhc3NuYW1lJylcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRvVG9rZW4gKHRva2VuLCBhdHRycykge1xuICB2YXIgbVxuICB2YXIgdG9kbyA9IFtdXG5cbiAgd2hpbGUgKGF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKlxcLihbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyAnY2xhc3MnLCBtWzFdLCB7IGFwcGVuZDogdHJ1ZSB9IF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqIyhbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyAnaWQnLCBtWzFdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPVwiKFteXCJdKilcIi8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPScoW14nXSopJy8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCBtWzJdIF0pXG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIGlmIChtID0gYXR0cnMubWF0Y2goL15cXHMqKFthLXpBLVowLTlcXC1fXSspPShbXiBdKikvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKS8pKSB7XG4gICAgICB0b2RvLnB1c2goWyBtWzFdLCAnJyBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKy8pKSB7XG4gICAgICBzaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHRvZG8uZm9yRWFjaChmdW5jdGlvbiAoYXJncykgeyBzZXRBdHRyLmFwcGx5KHRoaXMsIFt0b2tlbl0uY29uY2F0KGFyZ3MpKSB9KVxuICByZXR1cm4gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHNoaWZ0ICgpIHtcbiAgICBhdHRycyA9IGF0dHJzLnN1YnN0cihtWzBdLmxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHNldHMgYW4gYXR0cmlidXRlIGBhdHRyYCB0byBgdmFsdWVgIGluIGEgdG9rZW4uIElmIGBvcHRpb25zLmFwcGVuZGBcbiAqIGlzIHRydWUsIGFwcGVuZCB0byB0aGUgb2xkIHZhbHVlIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXQuXG4gKi9cblxuZnVuY3Rpb24gc2V0QXR0ciAodG9rZW4sIGF0dHIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBpZHggPSB0b2tlbi5hdHRySW5kZXgoYXR0cilcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRva2VuLmF0dHJQdXNoKFsgYXR0ciwgdmFsdWUgXSlcbiAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgdG9rZW4uYXR0cnNbaWR4XVsxXSA9XG4gICAgICB0b2tlbi5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0b2tlbi5hdHRyc1tpZHhdWzFdID0gdmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIFByaXZhdGU6IHB1c2hlcyBhIHRva2VuIHRvIHRoZSBzdGFja1xuICovXG5cbmZ1bmN0aW9uIHNwdXNoIChzdGFjaywgdG9rZW4pIHtcbiAgdmFyIHR5cGUgPSB0b2tlbi50eXBlLnJlcGxhY2UoL18ob3BlbnxzdGFydCkkLywgJycpXG4gIGlmICghc3RhY2sudHlwZXNbdHlwZV0pIHsgc3RhY2sudHlwZXNbdHlwZV0gPSBbXSB9XG4gIHN0YWNrLnR5cGVzW3R5cGVdLnB1c2godG9rZW4pXG4gIHN0YWNrLmxhc3QgPSB0b2tlblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC1kZWNvcmF0ZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9pbmRleC5qcyIsIi8vIExpc3Qgb2YgdmFsaWQgaHRtbCBibG9ja3MgbmFtZXMsIGFjY29ydGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2h0bWwtYmxvY2tzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdiYXNlJyxcbiAgJ2Jhc2Vmb250JyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdjYXB0aW9uJyxcbiAgJ2NlbnRlcicsXG4gICdjb2wnLFxuICAnY29sZ3JvdXAnLFxuICAnZGQnLFxuICAnZGV0YWlscycsXG4gICdkaWFsb2cnLFxuICAnZGlyJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdmcmFtZScsXG4gICdmcmFtZXNldCcsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkJyxcbiAgJ2hlYWRlcicsXG4gICdocicsXG4gICdodG1sJyxcbiAgJ2lmcmFtZScsXG4gICdsZWdlbmQnLFxuICAnbGknLFxuICAnbGluaycsXG4gICdtYWluJyxcbiAgJ21lbnUnLFxuICAnbWVudWl0ZW0nLFxuICAnbWV0YScsXG4gICduYXYnLFxuICAnbm9mcmFtZXMnLFxuICAnb2wnLFxuICAnb3B0Z3JvdXAnLFxuICAnb3B0aW9uJyxcbiAgJ3AnLFxuICAncGFyYW0nLFxuICAnc2VjdGlvbicsXG4gICdzb3VyY2UnLFxuICAnc3VtbWFyeScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0aGVhZCcsXG4gICd0aXRsZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd1bCdcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanMiLCIvLyBKdXN0IGEgc2hvcnRjdXQgZm9yIGJ1bGsgZXhwb3J0XG4ndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xuZXhwb3J0cy5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xuZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua190aXRsZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9pbmRleC5qcyIsIi8vIFBhcnNlIGxpbmsgZGVzdGluYXRpb25cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzU3BhY2UgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSwgbGV2ZWwsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDNDIC8qIDwgKi8pIHtcbiAgICBwb3MrKztcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlID09PSAweDBBIC8qIFxcbiAqLyB8fCBpc1NwYWNlKGNvZGUpKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgIGlmIChjb2RlID09PSAweDNFIC8qID4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICAvLyBubyBjbG9zaW5nICc+J1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyB0aGlzIHNob3VsZCBiZSAuLi4gfSBlbHNlIHsgLi4uIGJyYW5jaFxuXG4gIGxldmVsID0gMDtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWs7IH1cblxuICAgIC8vIGFzY2lpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMHgyMCB8fCBjb2RlID09PSAweDdGKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI4IC8qICggKi8pIHtcbiAgICAgIGxldmVsKys7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjkgLyogKSAqLykge1xuICAgICAgaWYgKGxldmVsID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICBsZXZlbC0tO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBwb3MpIHsgcmV0dXJuIHJlc3VsdDsgfVxuICBpZiAobGV2ZWwgIT09IDApIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgcmVzdWx0LnBvcyA9IHBvcztcbiAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanMiLCIvLyBQYXJzZSBsaW5rIGxhYmVsXG4vL1xuLy8gdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIChcIltcIikgYWxyZWFkeSBtYXRjaGVzO1xuLy8gcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbFxuLy9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQsIGRpc2FibGVOZXN0ZWQpIHtcbiAgdmFyIGxldmVsLCBmb3VuZCwgbWFya2VyLCBwcmV2UG9zLFxuICAgICAgbGFiZWxFbmQgPSAtMSxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcztcblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gIGxldmVsID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKTtcbiAgICBpZiAobWFya2VyID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2UG9zID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgaWYgKHByZXZQb3MgPT09IHN0YXRlLnBvcyAtIDEpIHtcbiAgICAgICAgLy8gaW5jcmVhc2UgbGV2ZWwgaWYgd2UgZmluZCB0ZXh0IGBbYCwgd2hpY2ggaXMgbm90IGEgcGFydCBvZiBhbnkgdG9rZW5cbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH0gZWxzZSBpZiAoZGlzYWJsZU5lc3RlZCkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmQpIHtcbiAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvcztcblxuICByZXR1cm4gbGFiZWxFbmQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzIiwiLy8gUGFyc2UgbGluayB0aXRsZVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsXG4gICAgICBtYXJrZXIsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBtYXJrZXIgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4MjIgLyogXCIgKi8gJiYgbWFya2VyICE9PSAweDI3IC8qICcgKi8gJiYgbWFya2VyICE9PSAweDI4IC8qICggKi8pIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIHBvcysrO1xuXG4gIC8vIGlmIG9wZW5pbmcgbWFya2VyIGlzIFwiKFwiLCBzd2l0Y2ggaXQgdG8gY2xvc2luZyBtYXJrZXIgXCIpXCJcbiAgaWYgKG1hcmtlciA9PT0gMHgyOCkgeyBtYXJrZXIgPSAweDI5OyB9XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcbiAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwiLy8gTWFpbiBwYXJzZXIgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpO1xudmFyIGhlbHBlcnMgICAgICA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIFJlbmRlcmVyICAgICA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcbnZhciBQYXJzZXJDb3JlICAgPSByZXF1aXJlKCcuL3BhcnNlcl9jb3JlJyk7XG52YXIgUGFyc2VyQmxvY2sgID0gcmVxdWlyZSgnLi9wYXJzZXJfYmxvY2snKTtcbnZhciBQYXJzZXJJbmxpbmUgPSByZXF1aXJlKCcuL3BhcnNlcl9pbmxpbmUnKTtcbnZhciBMaW5raWZ5SXQgICAgPSByZXF1aXJlKCdsaW5raWZ5LWl0Jyk7XG52YXIgbWR1cmwgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbnZhciBwdW55Y29kZSAgICAgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5cbnZhciBjb25maWcgPSB7XG4gICdkZWZhdWx0JzogcmVxdWlyZSgnLi9wcmVzZXRzL2RlZmF1bHQnKSxcbiAgemVybzogcmVxdWlyZSgnLi9wcmVzZXRzL3plcm8nKSxcbiAgY29tbW9ubWFyazogcmVxdWlyZSgnLi9wcmVzZXRzL2NvbW1vbm1hcmsnKVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyBUaGlzIHZhbGlkYXRvciBjYW4gcHJvaGliaXQgbW9yZSB0aGFuIHJlYWxseSBuZWVkZWQgdG8gcHJldmVudCBYU1MuIEl0J3MgYVxuLy8gdHJhZGVvZmYgdG8ga2VlcCBjb2RlIHNpbXBsZSBhbmQgdG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQuXG4vL1xuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBkdW1teSBmdW5jdGlvbiBhbmQgdXNlIGV4dGVybmFsIHNhbml0aXplci5cbi8vXG5cbnZhciBCQURfUFJPVE9fUkUgPSAvXih2YnNjcmlwdHxqYXZhc2NyaXB0fGZpbGV8ZGF0YSk6LztcbnZhciBHT09EX0RBVEFfUkUgPSAvXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGluayh1cmwpIHtcbiAgLy8gdXJsIHNob3VsZCBiZSBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQsIGFuZCBleGlzdGluZyBlbnRpdGllcyBhcmUgZGVjb2RlZFxuICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBCQURfUFJPVE9fUkUudGVzdChzdHIpID8gKEdPT0RfREFUQV9SRS50ZXN0KHN0cikgPyB0cnVlIDogZmFsc2UpIDogdHJ1ZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgUkVDT0RFX0hPU1ROQU1FX0ZPUiA9IFsgJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JyBdO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rKHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5lbmNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rVGV4dCh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b1VuaWNvZGUocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5kZWNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5cbi8qKlxuICogY2xhc3MgTWFya2Rvd25JdFxuICpcbiAqIE1haW4gcGFyc2VyL3JlbmRlcmVyIGNsYXNzLlxuICpcbiAqICMjIyMjIFVzYWdlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gbm9kZS5qcywgXCJjbGFzc2ljXCIgd2F5OlxuICogdmFyIE1hcmtkb3duSXQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpLFxuICogICAgIG1kID0gbmV3IE1hcmtkb3duSXQoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICpcbiAqIC8vIG5vZGUuanMsIHRoZSBzYW1lLCBidXQgd2l0aCBzdWdhcjpcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICpcbiAqIC8vIGJyb3dzZXIgd2l0aG91dCBBTUQsIGFkZGVkIHRvIFwid2luZG93XCIgb24gc2NyaXB0IGxvYWRcbiAqIC8vIE5vdGUsIHRoZXJlIGFyZSBubyBkYXNoLlxuICogdmFyIG1kID0gd2luZG93Lm1hcmtkb3duaXQoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXIoJyMgbWFya2Rvd24taXQgcnVsZXp6IScpO1xuICogYGBgXG4gKlxuICogU2luZ2xlIGxpbmUgcmVuZGVyaW5nLCB3aXRob3V0IHBhcmFncmFwaCB3cmFwOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoJ19fbWFya2Rvd24taXRfXyBydWxlenohJyk7XG4gKiBgYGBcbiAqKi9cblxuLyoqXG4gKiBuZXcgTWFya2Rvd25JdChbcHJlc2V0TmFtZSwgb3B0aW9uc10pXG4gKiAtIHByZXNldE5hbWUgKFN0cmluZyk6IG9wdGlvbmFsLCBgY29tbW9ubWFya2AgLyBgemVyb2BcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KVxuICpcbiAqIENyZWF0ZXMgcGFyc2VyIGluc3RhbnNlIHdpdGggZ2l2ZW4gY29uZmlnLiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2AuXG4gKlxuICogIyMjIyMgcHJlc2V0TmFtZVxuICpcbiAqIE1hcmtkb3duSXQgcHJvdmlkZXMgbmFtZWQgcHJlc2V0cyBhcyBhIGNvbnZlbmllbmNlIHRvIHF1aWNrbHlcbiAqIGVuYWJsZS9kaXNhYmxlIGFjdGl2ZSBzeW50YXggcnVsZXMgYW5kIG9wdGlvbnMgZm9yIGNvbW1vbiB1c2UgY2FzZXMuXG4gKlxuICogLSBbXCJjb21tb25tYXJrXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzKSAtXG4gKiAgIGNvbmZpZ3VyZXMgcGFyc2VyIHRvIHN0cmljdCBbQ29tbW9uTWFya10oaHR0cDovL2NvbW1vbm1hcmsub3JnLykgbW9kZS5cbiAqIC0gW2RlZmF1bHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9kZWZhdWx0LmpzKSAtXG4gKiAgIHNpbWlsYXIgdG8gR0ZNLCB1c2VkIHdoZW4gbm8gcHJlc2V0IG5hbWUgZ2l2ZW4uIEVuYWJsZXMgYWxsIGF2YWlsYWJsZSBydWxlcyxcbiAqICAgYnV0IHN0aWxsIHdpdGhvdXQgaHRtbCwgdHlwb2dyYXBoZXIgJiBhdXRvbGlua2VyLlxuICogLSBbXCJ6ZXJvXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy96ZXJvLmpzKSAtXG4gKiAgIGFsbCBydWxlcyBkaXNhYmxlZC4gVXNlZnVsIHRvIHF1aWNrbHkgc2V0dXAgeW91ciBjb25maWcgdmlhIGAuZW5hYmxlKClgLlxuICogICBGb3IgZXhhbXBsZSwgd2hlbiB5b3UgbmVlZCBvbmx5IGBib2xkYCBhbmQgYGl0YWxpY2AgbWFya3VwIGFuZCBub3RoaW5nIGVsc2UuXG4gKlxuICogIyMjIyMgb3B0aW9uczpcbiAqXG4gKiAtIF9faHRtbF9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZS4gQmUgY2FyZWZ1bCFcbiAqICAgVGhhdCdzIG5vdCBzYWZlISBZb3UgbWF5IG5lZWQgZXh0ZXJuYWwgc2FuaXRpemVyIHRvIHByb3RlY3Qgb3V0cHV0IGZyb20gWFNTLlxuICogICBJdCdzIGJldHRlciB0byBleHRlbmQgZmVhdHVyZXMgdmlhIHBsdWdpbnMsIGluc3RlYWQgb2YgZW5hYmxpbmcgSFRNTC5cbiAqIC0gX194aHRtbE91dF9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhZGQgJy8nIHdoZW4gY2xvc2luZyBzaW5nbGUgdGFnc1xuICogICAoYDxiciAvPmApLiBUaGlzIGlzIG5lZWRlZCBvbmx5IGZvciBmdWxsIENvbW1vbk1hcmsgY29tcGF0aWJpbGl0eS4gSW4gcmVhbFxuICogICB3b3JsZCB5b3Ugd2lsbCBuZWVkIEhUTUwgb3V0cHV0LlxuICogLSBfX2JyZWFrc19fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBjb252ZXJ0IGBcXG5gIGluIHBhcmFncmFwaHMgaW50byBgPGJyPmAuXG4gKiAtIF9fbGFuZ1ByZWZpeF9fIC0gYGxhbmd1YWdlLWAuIENTUyBsYW5ndWFnZSBjbGFzcyBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3MuXG4gKiAgIENhbiBiZSB1c2VmdWwgZm9yIGV4dGVybmFsIGhpZ2hsaWdodGVycy5cbiAqIC0gX19saW5raWZ5X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHQgdG8gbGlua3MuXG4gKiAtIF9fdHlwb2dyYXBoZXJfXyAgLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBbc29tZSBsYW5ndWFnZS1uZXV0cmFsXG4gKiAgIHJlcGxhY2VtZW50XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzKSArXG4gKiAgIHF1b3RlcyBiZWF1dGlmaWNhdGlvbiAoc21hcnRxdW90ZXMpLlxuICogLSBfX3F1b3Rlc19fIC0gYOKAnOKAneKAmOKAmWAsIFN0cmluZyBvciBBcnJheS4gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudFxuICogICBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkIGFuZCBzbWFydHF1b3RlcyBvbi4gRm9yIGV4YW1wbGUsIHlvdSBjYW5cbiAqICAgdXNlIGAnwqvCu+KAnuKAnCdgIGZvciBSdXNzaWFuLCBgJ+KAnuKAnOKAmuKAmCdgIGZvciBHZXJtYW4sIGFuZFxuICogICBgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXWAgZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICogLSBfX2hpZ2hsaWdodF9fIC0gYG51bGxgLiBIaWdobGlnaHRlciBmdW5jdGlvbiBmb3IgZmVuY2VkIGNvZGUgYmxvY2tzLlxuICogICBIaWdobGlnaHRlciBgZnVuY3Rpb24gKHN0ciwgbGFuZylgIHNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLiBJdCBjYW4gYWxzb1xuICogICByZXR1cm4gZW1wdHkgc3RyaW5nIGlmIHRoZSBzb3VyY2Ugd2FzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZFxuICogICBleHRlcm5hbHkuIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gY29tbW9ubWFyayBtb2RlXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCdjb21tb25tYXJrJyk7XG4gKlxuICogLy8gZGVmYXVsdCBtb2RlXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBodG1sOiB0cnVlLFxuICogICBsaW5raWZ5OiB0cnVlLFxuICogICB0eXBvZ3JhcGhlcjogdHJ1ZVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMjIyBTeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogYGBganNcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHN0ciwgbGFuZykge1xuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcbiAqICAgICAgIHRyeSB7XG4gKiAgICAgICAgIHJldHVybiBobGpzLmhpZ2hsaWdodChsYW5nLCBzdHIsIHRydWUpLnZhbHVlO1xuICogICAgICAgfSBjYXRjaCAoX18pIHt9XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gJyc7IC8vIHVzZSBleHRlcm5hbCBkZWZhdWx0IGVzY2FwaW5nXG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogT3Igd2l0aCBmdWxsIHdyYXBwZXIgb3ZlcnJpZGUgKGlmIHlvdSBuZWVkIGFzc2lnbiBjbGFzcyB0byBgPHByZT5gKTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuICpcbiAqIC8vIEFjdHVhbCBkZWZhdWx0IHZhbHVlc1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHN0ciwgbGFuZykge1xuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcbiAqICAgICAgIHRyeSB7XG4gKiAgICAgICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICtcbiAqICAgICAgICAgICAgICAgIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWUgK1xuICogICAgICAgICAgICAgICAgJzwvY29kZT48L3ByZT4nO1xuICogICAgICAgfSBjYXRjaCAoX18pIHt9XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gJzxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+JyArIG1kLnV0aWxzLmVzY2FwZUh0bWwoc3RyKSArICc8L2NvZGU+PC9wcmU+JztcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiovXG5mdW5jdGlvbiBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcmtkb3duSXQpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyhwcmVzZXROYW1lKSkge1xuICAgICAgb3B0aW9ucyA9IHByZXNldE5hbWUgfHwge307XG4gICAgICBwcmVzZXROYW1lID0gJ2RlZmF1bHQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2lubGluZSAtPiBQYXJzZXJJbmxpbmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJJbmxpbmVdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuaW5saW5lID0gbmV3IFBhcnNlcklubGluZSgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2Jsb2NrIC0+IFBhcnNlckJsb2NrXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VyQmxvY2tdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuYmxvY2sgPSBuZXcgUGFyc2VyQmxvY2soKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNjb3JlIC0+IENvcmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tDb3JlXV0gY2hhaW4gZXhlY3V0b3IuIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmNvcmUgPSBuZXcgUGFyc2VyQ29yZSgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3JlbmRlcmVyIC0+IFJlbmRlcmVyXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUmVuZGVyZXJdXS4gVXNlIGl0IHRvIG1vZGlmeSBvdXRwdXQgbG9vay4gT3IgdG8gYWRkIHJlbmRlcmluZ1xuICAgKiBydWxlcyBmb3IgbmV3IHRva2VuIHR5cGVzLCBnZW5lcmF0ZWQgYnkgcGx1Z2lucy5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogZnVuY3Rpb24gbXlUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzZWxmKSB7XG4gICAqICAgLy8uLi5cbiAgICogICByZXR1cm4gcmVzdWx0O1xuICAgKiB9O1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlc1snbXlfdG9rZW4nXSA9IG15VG9rZW5cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbW1JlbmRlcmVyXV0gZG9jcyBhbmQgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKS5cbiAgICoqL1xuICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbGlua2lmeSAtPiBMaW5raWZ5SXRcbiAgICpcbiAgICogW2xpbmtpZnktaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0KSBpbnN0YW5jZS5cbiAgICogVXNlZCBieSBbbGlua2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMpXG4gICAqIHJ1bGUuXG4gICAqKi9cbiAgdGhpcy5saW5raWZ5ID0gbmV3IExpbmtpZnlJdCgpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3ZhbGlkYXRlTGluayh1cmwpIC0+IEJvb2xlYW5cbiAgICpcbiAgICogTGluayB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBDb21tb25NYXJrIGFsbG93cyB0b28gbXVjaCBpbiBsaW5rcy4gQnkgZGVmYXVsdFxuICAgKiB3ZSBkaXNhYmxlIGBqYXZhc2NyaXB0OmAsIGB2YnNjcmlwdDpgLCBgZmlsZTpgIHNjaGVtYXMsIGFuZCBhbG1vc3QgYWxsIGBkYXRhOi4uLmAgc2NoZW1hc1xuICAgKiBleGNlcHQgc29tZSBlbWJlZGRlZCBpbWFnZSB0eXBlcy5cbiAgICpcbiAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXI6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICAgKiBtZC52YWxpZGF0ZUxpbmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAqIGBgYFxuICAgKiovXG4gIHRoaXMudmFsaWRhdGVMaW5rID0gdmFsaWRhdGVMaW5rO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmsodXJsKSAtPiBTdHJpbmdcbiAgICpcbiAgICogRnVuY3Rpb24gdXNlZCB0byBlbmNvZGUgbGluayB1cmwgdG8gYSBtYWNoaW5lLXJlYWRhYmxlIGZvcm1hdCxcbiAgICogd2hpY2ggaW5jbHVkZXMgdXJsLWVuY29kaW5nLCBwdW55Y29kZSwgZXRjLlxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGluayA9IG5vcm1hbGl6ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGlua1RleHQodXJsKSAtPiBTdHJpbmdcbiAgICpcbiAgICogRnVuY3Rpb24gdXNlZCB0byBkZWNvZGUgbGluayB1cmwgdG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXRgXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rVGV4dCA9IG5vcm1hbGl6ZUxpbmtUZXh0O1xuXG5cbiAgLy8gRXhwb3NlIHV0aWxzICYgaGVscGVycyBmb3IgZWFzeSBhY2NlcyBmcm9tIHBsdWdpbnNcblxuICAvKipcbiAgICogTWFya2Rvd25JdCN1dGlscyAtPiB1dGlsc1xuICAgKlxuICAgKiBBc3NvcnRlZCB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXG4gICAqIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL2NvbW1vbi91dGlscy5qcykuXG4gICAqKi9cbiAgdGhpcy51dGlscyA9IHV0aWxzO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2hlbHBlcnMgLT4gaGVscGVyc1xuICAgKlxuICAgKiBMaW5rIGNvbXBvbmVudHMgcGFyc2VyIGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXG4gICAqIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL2hlbHBlcnMpLlxuICAgKiovXG4gIHRoaXMuaGVscGVycyA9IHV0aWxzLmFzc2lnbih7fSwgaGVscGVycyk7XG5cblxuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgdGhpcy5jb25maWd1cmUocHJlc2V0TmFtZSk7XG5cbiAgaWYgKG9wdGlvbnMpIHsgdGhpcy5zZXQob3B0aW9ucyk7IH1cbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LnNldChvcHRpb25zKVxuICpcbiAqIFNldCBwYXJzZXIgb3B0aW9ucyAoaW4gdGhlIHNhbWUgZm9ybWF0IGFzIGluIGNvbnN0cnVjdG9yKS4gUHJvYmFibHksIHlvdVxuICogd2lsbCBuZXZlciBuZWVkIGl0LCBidXQgeW91IGNhbiBjaGFuZ2Ugb3B0aW9ucyBhZnRlciBjb25zdHJ1Y3RvciBjYWxsLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC5zZXQoeyBodG1sOiB0cnVlLCBicmVha3M6IHRydWUgfSlcbiAqICAgICAgICAgICAgIC5zZXQoeyB0eXBvZ3JhcGhlciwgdHJ1ZSB9KTtcbiAqIGBgYFxuICpcbiAqIF9fTm90ZTpfXyBUbyBhY2hpZXZlIHRoZSBiZXN0IHBvc3NpYmxlIHBlcmZvcm1hbmNlLCBkb24ndCBtb2RpZnkgYVxuICogYG1hcmtkb3duLWl0YCBpbnN0YW5jZSBvcHRpb25zIG9uIHRoZSBmbHkuIElmIHlvdSBuZWVkIG11bHRpcGxlIGNvbmZpZ3VyYXRpb25zXG4gKiBpdCdzIGJlc3QgdG8gY3JlYXRlIG11bHRpcGxlIGluc3RhbmNlcyBhbmQgaW5pdGlhbGl6ZSBlYWNoIHdpdGggc2VwYXJhdGVcbiAqIGNvbmZpZy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHV0aWxzLmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZSwgaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQuY29uZmlndXJlKHByZXNldHMpXG4gKlxuICogQmF0Y2ggbG9hZCBvZiBhbGwgb3B0aW9ucyBhbmQgY29tcGVuZW50IHNldHRpbmdzLiBUaGlzIGlzIGludGVybmFsIG1ldGhvZCxcbiAqIGFuZCB5b3UgcHJvYmFibHkgd2lsbCBub3QgbmVlZCBpdC4gQnV0IGlmIHlvdSB3aXRoIC0gc2VlIGF2YWlsYWJsZSBwcmVzZXRzXG4gKiBhbmQgZGF0YSBzdHJ1Y3R1cmUgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC90cmVlL21hc3Rlci9saWIvcHJlc2V0cylcbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIHByZXNldHMgaW5zdGVhZCBvZiBkaXJlY3QgY29uZmlnIGxvYWRzLiBUaGF0XG4gKiB3aWxsIGdpdmUgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBuZXh0IHZlcnNpb25zLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHByZXNldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBwcmVzZXROYW1lO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhwcmVzZXRzKSkge1xuICAgIHByZXNldE5hbWUgPSBwcmVzZXRzO1xuICAgIHByZXNldHMgPSBjb25maWdbcHJlc2V0TmFtZV07XG4gICAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQgXCInICsgcHJlc2V0TmFtZSArICdcIiwgY2hlY2sgbmFtZScpOyB9XG4gIH1cblxuICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCwgY2FuXFwndCBiZSBlbXB0eScpOyB9XG5cbiAgaWYgKHByZXNldHMub3B0aW9ucykgeyBzZWxmLnNldChwcmVzZXRzLm9wdGlvbnMpOyB9XG5cbiAgaWYgKHByZXNldHMuY29tcG9uZW50cykge1xuICAgIE9iamVjdC5rZXlzKHByZXNldHMuY29tcG9uZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcykge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyLmVuYWJsZU9ubHkocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIyLmVuYWJsZU9ubHkocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZW5hYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgbGlzdCBvciBydWxlcy4gSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGZpbmQgYXBwcm9wcmlhdGUgY29tcG9uZW50cyxcbiAqIGNvbnRhaW5pbmcgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgcnVsZSBub3QgZm91bmQsIGFuZCBgaWdub3JlSW52YWxpZGBcbiAqIG5vdCBzZXQgLSB0aHJvd3MgZXhjZXB0aW9uLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC5lbmFibGUoWydzdWInLCAnc3VwJ10pXG4gKiAgICAgICAgICAgICAuZGlzYWJsZSgnc21hcnRxdW90ZXMnKTtcbiAqIGBgYFxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZW5hYmxlKGxpc3QsIHRydWUpKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZW5hYmxlKGxpc3QsIHRydWUpKTtcblxuICB2YXIgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDsgfSk7XG5cbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtkb3duSXQuIEZhaWxlZCB0byBlbmFibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmRpc2FibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LmVuYWJsZV1dLCBidXQgdHVybiBzcGVjaWZpZWQgcnVsZXMgb2ZmLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5kaXNhYmxlKGxpc3QsIHRydWUpKTtcblxuICB2YXIgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDsgfSk7XG5cbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtkb3duSXQuIEZhaWxlZCB0byBkaXNhYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQudXNlKHBsdWdpbiwgcGFyYW1zKVxuICpcbiAqIExvYWQgc3BlY2lmaWVkIHBsdWdpbiB3aXRoIGdpdmVuIHBhcmFtcyBpbnRvIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlLlxuICogSXQncyBqdXN0IGEgc3VnYXIgdG8gY2FsbCBgcGx1Z2luKG1kLCBwYXJhbXMpYCB3aXRoIGN1cnJpbmcuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBpdGVyYXRvciA9IHJlcXVpcmUoJ21hcmtkb3duLWl0LWZvci1pbmxpbmUnKTtcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnVzZShpdGVyYXRvciwgJ2Zvb19yZXBsYWNlJywgJ3RleHQnLCBmdW5jdGlvbiAodG9rZW5zLCBpZHgpIHtcbiAqICAgICAgICAgICAgICAgdG9rZW5zW2lkeF0uY29udGVudCA9IHRva2Vuc1tpZHhdLmNvbnRlbnQucmVwbGFjZSgvZm9vL2csICdiYXInKTtcbiAqICAgICAgICAgICAgIH0pO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luIC8qLCBwYXJhbXMsIC4uLiAqLykge1xuICB2YXIgYXJncyA9IFsgdGhpcyBdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgcGx1Z2luLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2Uoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBQYXJzZSBpbnB1dCBzdHJpbmcgYW5kIHJldHVybnMgbGlzdCBvZiBibG9jayB0b2tlbnMgKHNwZWNpYWwgdG9rZW4gdHlwZVxuICogXCJpbmxpbmVcIiB3aWxsIGNvbnRhaW4gbGlzdCBvZiBpbmxpbmUgdG9rZW5zKS4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzXG4gKiBtZXRob2QgZGlyZWN0bHksIHVudGlsIHlvdSB3cml0ZSBjdXN0b20gcmVuZGVyZXIgKGZvciBleGFtcGxlLCB0byBwcm9kdWNlXG4gKiBBU1QpLlxuICpcbiAqIGBlbnZgIGlzIHVzZWQgdG8gcGFzcyBkYXRhIGJldHdlZW4gXCJkaXN0cmlidXRlZFwiIHJ1bGVzIGFuZCByZXR1cm4gYWRkaXRpb25hbFxuICogbWV0YWRhdGEgbGlrZSByZWZlcmVuY2UgaW5mbywgbmVlZGVkIGZvciB0aGUgcmVuZGVyZXIuIEl0IGFsc28gY2FuIGJlIHVzZWQgdG9cbiAqIGluamVjdCBkYXRhIGluIHNwZWNpZmljIGNhc2VzLiBVc3VhbGx5LCB5b3Ugd2lsbCBiZSBvayB0byBwYXNzIGB7fWAsXG4gKiBhbmQgdGhlbiBwYXNzIHVwZGF0ZWQgb2JqZWN0IHRvIHJlbmRlcmVyLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHNob3VsZCBiZSBhIFN0cmluZycpO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG5cbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXIoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUmVuZGVyIG1hcmtkb3duIHN0cmluZyBpbnRvIGh0bWwuIEl0IGRvZXMgYWxsIG1hZ2ljIGZvciB5b3UgOikuXG4gKlxuICogYGVudmAgY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGFkZGl0aW9uYWwgbWV0YWRhdGEgKGB7fWAgYnkgZGVmYXVsdCkuXG4gKiBCdXQgeW91IHdpbGwgbm90IG5lZWQgaXQgd2l0aCBoaWdoIHByb2JhYmlsaXR5LiBTZWUgYWxzbyBjb21tZW50XG4gKiBpbiBbW01hcmtkb3duSXQucGFyc2VdXS5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2Uoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZUlubGluZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5wYXJzZV1dIGJ1dCBza2lwIGFsbCBibG9jayBydWxlcy4gSXQgcmV0dXJucyB0aGVcbiAqIGJsb2NrIHRva2VucyBsaXN0IHdpdGggdGhlIHNpbmdsZSBgaW5saW5lYCBlbGVtZW50LCBjb250YWluaW5nIHBhcnNlZCBpbmxpbmVcbiAqIHRva2VucyBpbiBgY2hpbGRyZW5gIHByb3BlcnR5LiBBbHNvIHVwZGF0ZXMgYGVudmAgb2JqZWN0LlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG5cbiAgc3RhdGUuaW5saW5lTW9kZSA9IHRydWU7XG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVySW5saW5lKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFNpbWlsYXIgdG8gW1tNYXJrZG93bkl0LnJlbmRlcl1dIGJ1dCBmb3Igc2luZ2xlIHBhcmFncmFwaCBjb250ZW50LiBSZXN1bHRcbiAqIHdpbGwgTk9UIGJlIHdyYXBwZWQgaW50byBgPHA+YCB0YWdzLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZUlubGluZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bkl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvaW5kZXguanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlckJsb2NrXG4gKlxuICogQmxvY2stbGV2ZWwgdG9rZW5pemVyLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgLy8gRmlyc3QgMiBwYXJhbXMgLSBydWxlIG5hbWUgJiBzb3VyY2UuIFNlY29uZGFyeSBhcnJheSAtIGxpc3Qgb2YgcnVsZXMsXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnIF0gXSxcbiAgWyAnY29kZScsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svY29kZScpIF0sXG4gIFsgJ2ZlbmNlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnYmxvY2txdW90ZScsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svYmxvY2txdW90ZScpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdocicsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ocicpLCAgICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2xpc3QnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xpc3QnKSwgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3JlZmVyZW5jZScsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZScpIF0sXG4gIFsgJ2hlYWRpbmcnLCAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hlYWRpbmcnKSwgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ2xoZWFkaW5nJywgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncGFyYWdyYXBoJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcGFyYWdyYXBoJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJCbG9jaygpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgLyoqXG4gICAqIFBhcnNlckJsb2NrI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gIH1cbn1cblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGxpbmUgPSBzdGFydExpbmUsXG4gICAgICBoYXNFbXB0eUxpbmVzID0gZmFsc2UsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXG4gICAgLy8gTmVzdGVkIGNhbGxzIGN1cnJlbnRseSB1c2VkIGZvciBibG9ja3F1b3RlcyAmIGxpc3RzXG4gICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gSWYgbmVzdGluZyBsZXZlbCBleGNlZWRlZCAtIHNraXAgdGFpbCB0byB0aGUgZW5kLiBUaGF0J3Mgbm90IG9yZGluYXJ5XG4gICAgLy8gc2l0dWF0aW9uIGFuZCB3ZSBzaG91bGQgbm90IGNhcmUgYWJvdXQgY29udGVudC5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPj0gbWF4TmVzdGluZykge1xuICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLmxpbmVgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGxpbmUsIGVuZExpbmUsIGZhbHNlKTtcbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZS50aWdodCBpZiB3ZSBoYWQgYW4gZW1wdHkgbGluZSBiZWZvcmUgY3VycmVudCB0YWdcbiAgICAvLyBpLmUuIGxhdGVzdCBlbXB0eSBsaW5lIHNob3VsZCBub3QgY291bnRcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsaW5lID0gc3RhdGUubGluZTtcblxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICAgIGxpbmUrKztcbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlckJsb2NrLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGJsb2NrIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJCbG9jay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3JjKSB7IHJldHVybjsgfVxuXG4gIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xufTtcblxuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9ibG9jay5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgQ29yZVxuICpcbiAqIFRvcC1sZXZlbCBydWxlcyBleGVjdXRvci4gR2x1ZXMgYmxvY2svaW5saW5lIHBhcnNlcnMgYW5kIGRvZXMgaW50ZXJtZWRpYXRlXG4gKiB0cmFuc2Zvcm1hdGlvbnMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICBbICdub3JtYWxpemUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ub3JtYWxpemUnKSAgICAgIF0sXG4gIFsgJ2Jsb2NrJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2Jsb2NrJykgICAgICAgICAgXSxcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxuICBbICdsaW5raWZ5JywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9saW5raWZ5JykgICAgICAgIF0sXG4gIFsgJ3JlcGxhY2VtZW50cycsICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cycpICAgXSxcbiAgWyAnc21hcnRxdW90ZXMnLCAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMnKSAgICBdXG5dO1xuXG5cbi8qKlxuICogbmV3IENvcmUoKVxuICoqL1xuZnVuY3Rpb24gQ29yZSgpIHtcbiAgLyoqXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgY29yZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBDb3JlLnByb2Nlc3Moc3RhdGUpXG4gKlxuICogRXhlY3V0ZXMgY29yZSBjaGFpbiBydWxlcy5cbiAqKi9cbkNvcmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIGksIGwsIHJ1bGVzO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuQ29yZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJJbmxpbmVcbiAqXG4gKiBUb2tlbml6ZXMgcGFyYWdyYXBoIGNvbnRlbnQuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIHJ1bGVzXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ3RleHQnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHQnKSBdLFxuICBbICduZXdsaW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9uZXdsaW5lJykgXSxcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcbiAgWyAnYmFja3RpY2tzJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnRva2VuaXplIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykudG9rZW5pemUgXSxcbiAgWyAnbGluaycsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbGluaycpIF0sXG4gIFsgJ2ltYWdlJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2ltYWdlJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sX2lubGluZScsICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sX2lubGluZScpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbnZhciBfcnVsZXMyID0gW1xuICBbICdiYWxhbmNlX3BhaXJzJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykucG9zdFByb2Nlc3MgXSxcbiAgWyAndGV4dF9jb2xsYXBzZScsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZScpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VySW5saW5lKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgdmFyIGk7XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBpbmxpbmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlcjIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBTZWNvbmQgcnVsZXIgdXNlZCBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAqIChlLmcuIGluIGVtcGhhc2lzLWxpa2UgcnVsZXMpLlxuICAgKiovXG4gIHRoaXMucnVsZXIyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlczIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyMi5wdXNoKF9ydWxlczJbaV1bMF0sIF9ydWxlczJbaV1bMV0pO1xuICB9XG59XG5cblxuLy8gU2tpcCBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlO1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0ZWQgc3VjY2Vzc1xuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXG4gICAgICBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gSW5jcmVtZW50IHN0YXRlLmxldmVsIGFuZCBkZWNyZW1lbnQgaXQgbGF0ZXIgdG8gbGltaXQgcmVjdXJzaW9uLlxuICAgICAgLy8gSXQncyBoYXJtbGVzcyB0byBkbyBoZXJlLCBiZWNhdXNlIG5vIHRva2VucyBhcmUgY3JlYXRlZC4gQnV0IGlkZWFsbHksXG4gICAgICAvLyB3ZSdkIG5lZWQgYSBzZXBhcmF0ZSBwcml2YXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAvL1xuICAgICAgc3RhdGUubGV2ZWwrKztcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpO1xuICAgICAgc3RhdGUubGV2ZWwtLTtcblxuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heDtcbiAgfVxuXG4gIGlmICghb2spIHsgc3RhdGUucG9zKys7IH1cbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcbn07XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGVuZCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VySW5saW5lLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgaSwgcnVsZXMsIGxlbjtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpO1xuICBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9pbmxpbmUuanMiLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMiLCIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMTAwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcyIsIi8vIFwiWmVyb1wiIHByZXNldCwgd2l0aCBub3RoaW5nIGVuYWJsZWQuIFVzZWZ1bCBmb3IgbWFudWFsIGNvbmZpZ3VyaW5nIG9mIHNpbXBsZVxuLy8gbW9kZXMuIEZvciBleGFtcGxlLCB0byBwYXJzZSBib2xkL2l0YWxpYyBvbmx5LlxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanMiLCIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xudmFyIGVzY2FwZUh0bWwgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuZXNjYXBlSHRtbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+Jztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXG4gICAgICBpbmZvID0gdG9rZW4uaW5mbyA/IHVuZXNjYXBlQWxsKHRva2VuLmluZm8pLnRyaW0oKSA6ICcnLFxuICAgICAgbGFuZ05hbWUgPSAnJyxcbiAgICAgIGhpZ2hsaWdodGVkLCBpLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBsYW5nTmFtZSA9IGluZm8uc3BsaXQoL1xccysvZylbMF07XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtb2RpZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuY2xvbmUoKSBmb3IgdG9rZW4gYW5kIHNpbXBsaWZ5IHRoaXMgcGFydCwgYnV0XG4gIC8vIG5vdyB3ZSBwcmVmZXIgdG8ga2VlcCB0aGluZ3MgbG9jYWwuXG4gIGlmIChpbmZvKSB7XG4gICAgaSAgICAgICAgPSB0b2tlbi5hdHRySW5kZXgoJ2NsYXNzJyk7XG4gICAgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdG1wQXR0cnMucHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBBdHRyc1tpXVsxXSArPSAnICcgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH07XG5cbiAgICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyAnPidcbiAgICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuXG4gIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG5cbiAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5kZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5kZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcblxuICAvKipcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XG4gICAqXG4gICAqIENvbnRhaW5zIHJlbmRlciBydWxlcyBmb3IgdG9rZW5zLiBDYW4gYmUgdXBkYXRlZCBhbmQgZXh0ZW5kZWQuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPC9iPic7IH07XG4gICAqXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlbnQgc3RhdGljIGZ1bmN0aW9uIHdpdGggZml4ZWQgc2lnbmF0dXJlOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGZ1bmN0aW9uIG15X3Rva2VuX3JlbmRlcih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCByZW5kZXJlcikge1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIHJldHVybiByZW5kZXJlZEhUTUw7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpO1xufVxuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xuICpcbiAqIFJlbmRlciB0b2tlbiBhdHRyaWJ1dGVzIHRvIHN0cmluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJBdHRycyA9IGZ1bmN0aW9uIHJlbmRlckF0dHJzKHRva2VuKSB7XG4gIHZhciBpLCBsLCByZXN1bHQ7XG5cbiAgaWYgKCF0b2tlbi5hdHRycykgeyByZXR1cm4gJyc7IH1cblxuICByZXN1bHQgPSAnJztcblxuICBmb3IgKGkgPSAwLCBsID0gdG9rZW4uYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb2YgdG9rZW5zXG4gKiAtIGlkeCAoTnVtYmVkKTogdG9rZW4gaW5kZXggdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiBEZWZhdWx0IHRva2VuIHJlbmRlcmVyLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBmdW5jdGlvblxuICogaW4gW1tSZW5kZXJlciNydWxlc11dLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRva2VuID0gZnVuY3Rpb24gcmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgdmFyIG5leHRUb2tlbixcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbmVlZExmID0gZmFsc2UsXG4gICAgICB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFRpZ2h0IGxpc3QgcGFyYWdyYXBoc1xuICBpZiAodG9rZW4uaGlkZGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xuICAvLyBibG9jay1sZXZlbCB0YWcuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxuICAvLyAgLSBhXG4gIC8vICAgID5cbiAgLy9cbiAgaWYgKHRva2VuLmJsb2NrICYmIHRva2VuLm5lc3RpbmcgIT09IC0xICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0uaGlkZGVuKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgLy8gQWRkIHRva2VuIG5hbWUsIGUuZy4gYDxpbWdgXG4gIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyAnPC8nIDogJzwnKSArIHRva2VuLnRhZztcblxuICAvLyBFbmNvZGUgYXR0cmlidXRlcywgZS5nLiBgPGltZyBzcmM9XCJmb29cImBcbiAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xuXG4gIC8vIEFkZCBhIHNsYXNoIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZS5nLiBgPGltZyBzcmM9XCJmb29cIiAvYFxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgcmVzdWx0ICs9ICcgLyc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBhIG5ld2xpbmUgYWZ0ZXIgdGhpcyB0YWdcbiAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgbmVlZExmID0gdHJ1ZTtcblxuICAgIGlmICh0b2tlbi5uZXN0aW5nID09PSAxKSB7XG4gICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5zW2lkeCArIDFdO1xuXG4gICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJ2lubGluZScgfHwgbmV4dFRva2VuLmhpZGRlbikge1xuICAgICAgICAgIC8vIEJsb2NrLWxldmVsIHRhZyBjb250YWluaW5nIGFuIGlubGluZSB0YWcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi5uZXN0aW5nID09PSAtMSAmJiBuZXh0VG9rZW4udGFnID09PSB0b2tlbi50YWcpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIHRhZyArIGNsb3NpbmcgdGFnIG9mIHRoZSBzYW1lIHR5cGUuIEUuZy4gYDxsaT48L2xpPmAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCArPSBuZWVkTGYgPyAnPlxcbicgOiAnPic7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmUodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRoZSBzYW1lIGFzIFtbUmVuZGVyZXIucmVuZGVyXV0sIGJ1dCBmb3Igc2luZ2xlIHRva2VuIG9mIGBpbmxpbmVgIHR5cGUuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogUmVuZGVyZXIucmVuZGVySW5saW5lQXNUZXh0KHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBTcGVjaWFsIGtsdWRnZSBmb3IgaW1hZ2UgYGFsdGAgYXR0cmlidXRlcyB0byBjb25mb3JtIENvbW1vbk1hcmsgc3BlYy5cbiAqIERvbid0IHRyeSB0byB1c2UgaXQhIFNwZWMgcmVxdWlyZXMgdG8gc2hvdyBgYWx0YCBjb250ZW50IHdpdGggc3RyaXBwZWQgbWFya3VwLFxuICogaW5zdGVhZCBvZiBzaW1wbGUgZXNjYXBpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qcyIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgbCxcbiAgICAgIGxhc3RMaW5lRW1wdHksXG4gICAgICBsaW5lcyxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkQk1hcmtzLFxuICAgICAgb2xkQlNDb3VudCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRTQ291bnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBzcGFjZUFmdGVyTWFya2VyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICB3YXNPdXRkZW50ZWQsXG4gICAgICBvbGRMaW5lTWF4ID0gc3RhdGUubGluZU1heCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjaGVjayB0aGUgYmxvY2sgcXVvdGUgbWFya2VyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgIT09IDB4M0UvKiA+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHdlIGtub3cgdGhhdCBpdCdzIGdvaW5nIHRvIGJlIGEgdmFsaWQgYmxvY2txdW90ZSxcbiAgLy8gc28gbm8gcG9pbnQgdHJ5aW5nIHRvIGZpbmQgdGhlIGVuZCBvZiBpdCBpbiBzaWxlbnQgbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICBwb3MrKztcbiAgICBpbml0aWFsKys7XG4gICAgb2Zmc2V0Kys7XG4gICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgcG9zKys7XG4gICAgICBpbml0aWFsKys7XG4gICAgICBvZmZzZXQrKztcbiAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gIH1cblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBvbGRCU0NvdW50ID0gWyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgb2xkU0NvdW50ID0gWyBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgb2xkVFNoaWZ0ID0gWyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG4gIHdhc091dGRlbnRlZCA9IGZhbHNlO1xuXG4gIC8vIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBibG9ja1xuICAvL1xuICAvLyBCbG9jayBlbmRzIHdpdGggZWl0aGVyOlxuICAvLyAgMS4gYW4gZW1wdHkgbGluZSBvdXRzaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy9cbiAgLy8gICAgIGBgYFxuICAvLyAgMi4gYW4gZW1wdHkgbGluZSBpbnNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID5cbiAgLy8gICAgIHRlc3RcbiAgLy8gICAgIGBgYFxuICAvLyAgMy4gYW5vdGhlciB0YWc6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHdhc091dGRlbnRlZCA9IHRydWU7XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIXdhc091dGRlbnRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrKztcbiAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBDYXNlIDM6IGFub3RoZXIgdGFnIGZvdW5kLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgLy8gUXVpcmsgdG8gZW5mb3JjZSBcImhhcmQgdGVybWluYXRpb24gbW9kZVwiIGZvciBwYXJhZ3JhcGhzO1xuICAgICAgLy8gbm9ybWFsbHkgaWYgeW91IGNhbGwgYHRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKWAsXG4gICAgICAvLyBwYXJhZ3JhcGhzIHdpbGwgbG9vayBiZWxvdyBuZXh0TGluZSBmb3IgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbixcbiAgICAgIC8vIGJ1dCBpZiBibG9ja3F1b3RlIGlzIHRlcm1pbmF0ZWQgYnkgYW5vdGhlciB0YWcsIHRoZXkgc2hvdWxkbid0XG4gICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuXG4gICAgLy8gQSBuZWdhdGl2ZSBpbmRlbnRhdGlvbiBtZWFucyB0aGF0IHRoaXMgaXMgYSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgLy9cbiAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gLTE7XG4gIH1cblxuICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gIHN0YXRlLmJsa0luZGVudCA9IDA7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9vcGVuJywgJ2Jsb2NrcXVvdGUnLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuICB0b2tlbi5tYXAgICAgPSBsaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfY2xvc2UnLCAnYmxvY2txdW90ZScsIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuXG4gIHN0YXRlLmxpbmVNYXggPSBvbGRMaW5lTWF4O1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgbGluZXNbMV0gPSBzdGF0ZS5saW5lO1xuXG4gIC8vIFJlc3RvcmUgb3JpZ2luYWwgdFNoaWZ0OyB0aGlzIG1pZ2h0IG5vdCBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIHBhcnNlclxuICAvLyBoYXMgYWxyZWFkeSBiZWVuIGhlcmUsIGJ1dCBqdXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gZG8gdGhhdC5cbiAgZm9yIChpID0gMDsgaSA8IG9sZFRTaGlmdC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcbiAgICBzdGF0ZS50U2hpZnRbaSArIHN0YXJ0TGluZV0gPSBvbGRUU2hpZnRbaV07XG4gICAgc3RhdGUuc0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkU0NvdW50W2ldO1xuICAgIHN0YXRlLmJzQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRCU0NvdW50W2ldO1xuICB9XG4gIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9ibG9ja3F1b3RlLmpzIiwiLy8gQ29kZSBibG9jayAoNCBzcGFjZXMgcGFkZGVkKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIG5leHRMaW5lLCBsYXN0LCB0b2tlbjtcblxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPCA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3QgPSBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBsYXN0ID0gbmV4dExpbmU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbGFzdDtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9ibG9jaycsICdjb2RlJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIGxhc3QsIDQgKyBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBpZiAocGFyYW1zLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKSA+PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbmNlIHN0YXJ0IGlzIGZvdW5kLCB3ZSBjYW4gcmVwb3J0IHN1Y2Nlc3MgaGVyZSBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNlYXJjaCBlbmQgb2YgYmxvY2tcbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG5cbiAgZm9yICg7Oykge1xuICAgIG5leHRMaW5lKys7XG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgIC8vIHVuY2xvc2VkIGJsb2NrIHNob3VsZCBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBkb2N1bWVudC5cbiAgICAgIC8vIGFsc28gYmxvY2sgc2VlbXMgdG8gYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgcGFyZW50XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgPSBtZW0gPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAvLyBub24tZW1wdHkgbGluZSB3aXRoIG5lZ2F0aXZlIGluZGVudCBzaG91bGQgc3RvcCB0aGUgbGlzdDpcbiAgICAgIC8vIC0gYGBgXG4gICAgICAvLyAgdGVzdFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IG1hcmtlcikgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgLy8gY2xvc2luZyBmZW5jZSBzaG91bGQgYmUgaW5kZW50ZWQgbGVzcyB0aGFuIDQgc3BhY2VzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gICAgLy8gY2xvc2luZyBjb2RlIGZlbmNlIG11c3QgYmUgYXQgbGVhc3QgYXMgbG9uZyBhcyB0aGUgb3BlbmluZyBvbmVcbiAgICBpZiAocG9zIC0gbWVtIDwgbGVuKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGFpbCBoYXMgc3BhY2VzIG9ubHlcbiAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICBpZiAocG9zIDwgbWF4KSB7IGNvbnRpbnVlOyB9XG5cbiAgICBoYXZlRW5kTWFya2VyID0gdHJ1ZTtcbiAgICAvLyBmb3VuZCFcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIElmIGEgZmVuY2UgaGFzIGhlYWRpbmcgc3BhY2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGZyb20gaXRzIGlubmVyIGJsb2NrXG4gIGxlbiA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIChoYXZlRW5kTWFya2VyID8gMSA6IDApO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdmZW5jZScsICdjb2RlJywgMCk7XG4gIHRva2VuLmluZm8gICAgPSBwYXJhbXM7XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUgKyAxLCBuZXh0TGluZSwgbGVuLCB0cnVlKTtcbiAgdG9rZW4ubWFya3VwICA9IG1hcmt1cDtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCIvLyBoZWFkaW5nICgjLCAjIywgLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGV2ZWwsIHRtcCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4MjMvKiAjICovIHx8IHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXZlbCA9IDE7XG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XG4gICAgbGV2ZWwrKztcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiAhaXNTcGFjZShjaCkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBMZXQncyBjdXQgdGFpbHMgbGlrZSAnICAgICMjIyAgJyBmcm9tIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgbWF4ID0gc3RhdGUuc2tpcFNwYWNlc0JhY2sobWF4LCBwb3MpO1xuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xuICBpZiAodG1wID4gcG9zICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkpKSB7XG4gICAgbWF4ID0gdG1wO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkudHJpbSgpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaGVhZGluZy5qcyIsIi8vIEhvcml6b250YWwgcnVsZVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBjbnQsIGNoLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgLy8gQ2hlY2sgaHIgbWFya2VyXG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4NUYvKiBfICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbWFya2VycyBjYW4gYmUgbWl4ZWQgd2l0aCBzcGFjZXMsIGJ1dCB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3QgMyBvZiB0aGVtXG5cbiAgY250ID0gMTtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgIGlmIChjaCAhPT0gbWFya2VyICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoY2ggPT09IG1hcmtlcikgeyBjbnQrKzsgfVxuICB9XG5cbiAgaWYgKGNudCA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hyJywgJ2hyJywgMCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLm1hcmt1cCA9IEFycmF5KGNudCArIDEpLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qcyIsIi8vIEhUTUwgYmxvY2tcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cbi8vIEFuIGFycmF5IG9mIG9wZW5pbmcgYW5kIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBzZXF1ZW5jZXMgZm9yIGh0bWwgdGFncyxcbi8vIGxhc3QgYXJndW1lbnQgZGVmaW5lcyB3aGV0aGVyIGl0IGNhbiB0ZXJtaW5hdGUgYSBwYXJhZ3JhcGggb3Igbm90XG4vL1xudmFyIEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbIC9ePChzY3JpcHR8cHJlfHN0eWxlKSg/PShcXHN8PnwkKSkvaSwgLzxcXC8oc2NyaXB0fHByZXxzdHlsZSk+L2ksIHRydWUgXSxcbiAgWyAvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZSBdLFxuICBbIC9ePFxcPy8sICAgICAgICAgL1xcPz4vLCAgIHRydWUgXSxcbiAgWyAvXjwhW0EtWl0vLCAgICAgLz4vLCAgICAgdHJ1ZSBdLFxuICBbIC9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoJ148Lz8oJyArIGJsb2NrX25hbWVzLmpvaW4oJ3wnKSArICcpKD89KFxcXFxzfC8/PnwkKSknLCAnaScpLCAvXiQvLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cChIVE1MX09QRU5fQ0xPU0VfVEFHX1JFLnNvdXJjZSArICdcXFxccyokJyksICAvXiQvLCBmYWxzZSBdXG5dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9ibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMF0udGVzdChsaW5lVGV4dCkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkge1xuICAgIC8vIHRydWUgaWYgdGhpcyBzZXF1ZW5jZSBjYW4gYmUgYSB0ZXJtaW5hdG9yLCBmYWxzZSBvdGhlcndpc2VcbiAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7IG5leHRMaW5lKys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2Jsb2NrJywgJycsIDApO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIG5leHRMaW5lIF07XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCIvLyBsaGVhZGluZyAoLS0tLCA9PT0pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIHBvcywgbWF4LCBsZXZlbCwgbWFya2VyLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7IC8vIHVzZSBwYXJhZ3JhcGggdG8gbWF0Y2ggdGVybWluYXRvclJ1bGVzXG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vXG4gICAgLy8gQ2hlY2sgZm9yIHVuZGVybGluZSBpbiBzZXRleHQgaGVhZGVyXG4gICAgLy9cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4MkQvKiAtICovIHx8IG1hcmtlciA9PT0gMHgzRC8qID0gKi8pIHtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgICAgICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAgICAgICBsZXZlbCA9IChtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKCFsZXZlbCkge1xuICAgIC8vIERpZG4ndCBmaW5kIHZhbGlkIHVuZGVybGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgLSAxIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcyIsIi8vIExpc3RzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbi8vIFNlYXJjaCBgWy0rKl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgbWFya2VyLCBwb3MsIG1heCwgY2g7XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgLXRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG4vLyBTZWFyY2ggYFxcZCtbLildW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhZnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIHBvcyA9IHN0YXJ0LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiBjaGFycyAoZGlnaXQgKyBkb3QpXG4gIGlmIChwb3MgKyAxID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoY2ggPj0gMHgzMC8qIDAgKi8gJiYgY2ggPD0gMHgzOS8qIDkgKi8pIHtcblxuICAgICAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgbm8gbW9yZSB0aGFuIDkgZGlnaXRzXG4gICAgICAvLyAocHJldmVudHMgaW50ZWdlciBvdmVyZmxvdyBpbiBicm93c2VycylcbiAgICAgIGlmIChwb3MgLSBzdGFydCA+PSAxMCkgeyByZXR1cm4gLTE7IH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZm91bmQgdmFsaWQgbWFya2VyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjb250ZW50U3RhcnQsXG4gICAgICBpLFxuICAgICAgaW5kZW50LFxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIsXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPcmRlcmVkLFxuICAgICAgaXRlbUxpbmVzLFxuICAgICAgbCxcbiAgICAgIGxpc3RMaW5lcyxcbiAgICAgIGxpc3RUb2tJZHgsXG4gICAgICBtYXJrZXJDaGFyQ29kZSxcbiAgICAgIG1hcmtlclZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRMSW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIG9sZFRpZ2h0LFxuICAgICAgcG9zLFxuICAgICAgcG9zQWZ0ZXJNYXJrZXIsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICBzdGFydCxcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlLFxuICAgICAgdGlnaHQgPSB0cnVlO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGxpbWl0IGNvbmRpdGlvbnMgd2hlbiBsaXN0IGNhbiBpbnRlcnJ1cHRcbiAgLy8gYSBwYXJhZ3JhcGggKHZhbGlkYXRpb24gbW9kZSBvbmx5KVxuICBpZiAoc2lsZW50ICYmIHN0YXRlLnBhcmVudFR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgLy8gTmV4dCBsaXN0IGl0ZW0gc2hvdWxkIHN0aWxsIHRlcm1pbmF0ZSBwcmV2aW91cyBsaXN0IGl0ZW07XG4gICAgLy9cbiAgICAvLyBUaGlzIGNvZGUgY2FuIGZhaWwgaWYgcGx1Z2lucyB1c2UgYmxrSW5kZW50IGFzIHdlbGwgYXMgbGlzdHMsXG4gICAgLy8gYnV0IEkgaG9wZSB0aGUgc3BlYyBnZXRzIGZpeGVkIGxvbmcgYmVmb3JlIHRoYXQgaGFwcGVucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIERldGVjdCBsaXN0IHR5cGUgYW5kIHBvc2l0aW9uIGFmdGVyIG1hcmtlclxuICBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gdHJ1ZTtcbiAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgbWFya2VyVmFsdWUgPSBOdW1iZXIoc3RhdGUuc3JjLnN1YnN0cihzdGFydCwgcG9zQWZ0ZXJNYXJrZXIgLSBzdGFydCAtIDEpKTtcblxuICAgIC8vIElmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IG9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAgIC8vIGEgcGFyYWdyYXBoLCBpdCBzaG91bGQgc3RhcnQgd2l0aCAxLlxuICAgIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoICYmIG1hcmtlclZhbHVlICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgfSBlbHNlIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IGZhbHNlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgdW5vcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgLy8gYSBwYXJhZ3JhcGgsIGZpcnN0IGxpbmUgc2hvdWxkIG5vdCBiZSBlbXB0eS5cbiAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGgpIHtcbiAgICBpZiAoc3RhdGUuc2tpcFNwYWNlcyhwb3NBZnRlck1hcmtlcikgPj0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIHNob3VsZCB0ZXJtaW5hdGUgbGlzdCBvbiBzdHlsZSBjaGFuZ2UuIFJlbWVtYmVyIGZpcnN0IG9uZSB0byBjb21wYXJlLlxuICBtYXJrZXJDaGFyQ29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSk7XG5cbiAgLy8gRm9yIHZhbGlkYXRpb24gbW9kZSB3ZSBjYW4gdGVybWluYXRlIGltbWVkaWF0ZWx5XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBTdGFydCBsaXN0XG4gIGxpc3RUb2tJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9vcGVuJywgJ29sJywgMSk7XG4gICAgaWYgKG1hcmtlclZhbHVlICE9PSAxKSB7XG4gICAgICB0b2tlbi5hdHRycyA9IFsgWyAnc3RhcnQnLCBtYXJrZXJWYWx1ZSBdIF07XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gICAgICAgPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9vcGVuJywgJ3VsJywgMSk7XG4gIH1cblxuICB0b2tlbi5tYXAgICAgPSBsaXN0TGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAvL1xuICAvLyBJdGVyYXRlIGxpc3QgaXRlbXNcbiAgLy9cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcbiAgcHJldkVtcHR5RW5kID0gZmFsc2U7XG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdsaXN0Jyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnbGlzdCc7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIHBvcyA9IHBvc0FmdGVyTWFya2VyO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvc0FmdGVyTWFya2VyIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pICUgNDtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjApIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgY29udGVudFN0YXJ0ID0gcG9zO1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcbiAgICAgIC8vIHRyaW1taW5nIHNwYWNlIGluIFwiLSAgICBcXG4gIDNcIiBjYXNlLCBpbmRlbnQgaXMgMSBoZXJlXG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiA0IHNwYWNlcywgdGhlIGluZGVudCBpcyAxXG4gICAgLy8gKHRoZSByZXN0IGlzIGp1c3QgaW5kZW50ZWQgY29kZSBibG9jaylcbiAgICBpZiAoaW5kZW50QWZ0ZXJNYXJrZXIgPiA0KSB7IGluZGVudEFmdGVyTWFya2VyID0gMTsgfVxuXG4gICAgLy8gXCIgIC0gIHRlc3RcIlxuICAgIC8vICBeXl5eXiAtIGNhbGN1bGF0aW5nIHRvdGFsIGxlbmd0aCBvZiB0aGlzIHRoaW5nXG4gICAgaW5kZW50ID0gaW5pdGlhbCArIGluZGVudEFmdGVyTWFya2VyO1xuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9vcGVuJywgJ2xpJywgMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgdG9rZW4ubWFwICAgID0gaXRlbUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG9sZExJbmRlbnQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBpbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvbGRMSW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBsaXN0XG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9jbG9zZScsICdvbCcsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X2Nsb3NlJywgJ3VsJywgLTEpO1xuICB9XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCIvLyBQYXJhZ3JhcGhcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyYWdyYXBoKHN0YXRlLCBzdGFydExpbmUvKiwgZW5kTGluZSovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpLFxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJztcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfb3BlbicsICdwJywgMSk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBfZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGRlc3RFbmRQb3MsXG4gICAgICBkZXN0RW5kTGluZU5vLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGhyZWYsXG4gICAgICBpLFxuICAgICAgbCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgcmVzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdHIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2ltcGxlIGNoZWNrIHRvIHF1aWNrbHkgaW50ZXJydXB0IHNjYW4gb24gW2xpbmtdKHVybCkgYXQgdGhlIHN0YXJ0IG9mIGxpbmUuXG4gIC8vIENhbiBiZSB1c2VmdWwgb24gcHJhY3RpY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9pc3N1ZXMvNTRcbiAgd2hpbGUgKCsrcG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLyAmJlxuICAgICAgICBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBpZiAocG9zICsgMSA9PT0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3JlZmVyZW5jZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3JlZmVyZW5jZSc7XG5cbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBzdHIgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gIG1heCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsYWJlbEVuZCA9IHBvcztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MEEgLyogXFxuICovKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8pIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgIF5eXiBza2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAoIXJlcy5vaykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gcmVzLnBvcztcbiAgbGluZXMgKz0gcmVzLmxpbmVzO1xuXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXG4gIGRlc3RFbmRQb3MgPSBwb3M7XG4gIGRlc3RFbmRMaW5lTm8gPSBsaW5lcztcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXl5eIHNraXBwaW5nIHRob3NlIHNwYWNlc1xuICBzdGFydCA9IHBvcztcbiAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCk7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgcG9zID0gcmVzLnBvcztcbiAgICBsaW5lcyArPSByZXMubGluZXM7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSAnJztcbiAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgfVxuXG4gIC8vIHNraXAgdHJhaWxpbmcgc3BhY2VzIHVudGlsIHRoZSByZXN0IG9mIHRoZSBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGl0bGUsXG4gICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSB2YWxpZCByZWZlcmVuY2UgaWYgd2Ugcm9sbCBiYWNrXG4gICAgICB0aXRsZSA9ICcnO1xuICAgICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpO1xuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gQ29tbW9uTWFyayAwLjIwIGRpc2FsbG93cyBlbXB0eSBsYWJlbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZWZlcmVuY2UgY2FuIG5vdCB0ZXJtaW5hdGUgYW55dGhpbmcuIFRoaXMgY2hlY2sgaXMgZm9yIHNhZmV0eSBvbmx5LlxuICAvKmlzdGFuYnVsIGlnbm9yZSBpZiovXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID0geyB0aXRsZTogdGl0bGUsIGhyZWY6IGhyZWYgfTtcbiAgfVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvciBleGFtcGxlLCBpZiB3ZSBhcmUgaW4gbGlzdClcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG5cbiAgLy8gY2FuIGJlICdibG9ja3F1b3RlJywgJ2xpc3QnLCAncm9vdCcsICdwYXJhZ3JhcGgnIG9yICdyZWZlcmVuY2UnXG4gIC8vIHVzZWQgaW4gbGlzdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgaW50ZXJydXB0IGEgcGFyYWdyYXBoXG4gIHRoaXMucGFyZW50VHlwZSA9ICdyb290JztcblxuICB0aGlzLmxldmVsID0gMDtcblxuICAvLyByZW5kZXJlclxuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIC8vIENyZWF0ZSBjYWNoZXNcbiAgLy8gR2VuZXJhdGUgbWFya2Vycy5cbiAgcyA9IHRoaXMuc3JjO1xuICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcblxuICBmb3IgKHN0YXJ0ID0gcG9zID0gaW5kZW50ID0gb2Zmc2V0ID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICBjaCA9IHMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpbmRlbnQrKztcblxuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNCAtIG9mZnNldCAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnRfZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSB8fCBwb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgIGlmIChjaCAhPT0gMHgwQSkgeyBwb3MrKzsgfVxuICAgICAgdGhpcy5iTWFya3MucHVzaChzdGFydCk7XG4gICAgICB0aGlzLmVNYXJrcy5wdXNoKHBvcyk7XG4gICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKG9mZnNldCk7XG4gICAgICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICAgICAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGZha2UgZW50cnkgdG8gc2ltcGxpZnkgY2FjaGUgYm91bmRzIGNoZWNrc1xuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy5lTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gIHRoaXMuc0NvdW50LnB1c2goMCk7XG4gIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuXG4gIHRoaXMubGluZU1heCA9IHRoaXMuYk1hcmtzLmxlbmd0aCAtIDE7IC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vL1xuU3RhdGVCbG9jay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG4gIHRva2VuLmJsb2NrID0gdHJ1ZTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShsaW5lKSB7XG4gIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XG4gICAgaWYgKHRoaXMuYk1hcmtzW2Zyb21dICsgdGhpcy50U2hpZnRbZnJvbV0gPCB0aGlzLmVNYXJrc1tmcm9tXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbi5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xuICB2YXIgY2g7XG5cbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGluIHJldmVyc2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKCFpc1NwYWNlKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzKHBvcywgY29kZSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyByZXZlcnNlIGZyb20gZ2l2ZW4gcG9zaXRpb24gLSAxXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmIChjb2RlICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJlZ2luLCBlbmQsIGluZGVudCwga2VlcExhc3RMRikge1xuICB2YXIgaSwgbGluZUluZGVudCwgY2gsIGZpcnN0LCBsYXN0LCBxdWV1ZSwgbGluZVN0YXJ0LFxuICAgICAgbGluZSA9IGJlZ2luO1xuXG4gIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG5cbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcbiAgICBsaW5lSW5kZW50ID0gMDtcbiAgICBsaW5lU3RhcnQgPSBmaXJzdCA9IHRoaXMuYk1hcmtzW2xpbmVdO1xuXG4gICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH1cblxuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QgJiYgbGluZUluZGVudCA8IGluZGVudCkge1xuICAgICAgY2ggPSB0aGlzLnNyYy5jaGFyQ29kZUF0KGZpcnN0KTtcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0IC0gbGluZVN0YXJ0IDwgdGhpcy50U2hpZnRbbGluZV0pIHtcbiAgICAgICAgLy8gcGF0Y2hlZCB0U2hpZnQgbWFza2VkIGNoYXJhY3RlcnMgdG8gbG9vayBsaWtlIHNwYWNlcyAoYmxvY2txdW90ZXMsIGxpc3QgbWFya2VycylcbiAgICAgICAgbGluZUluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Kys7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVJbmRlbnQgPiBpbmRlbnQpIHtcbiAgICAgIC8vIHBhcnRpYWxseSBleHBhbmRpbmcgdGFicyBpbiBjb2RlIGJsb2NrcywgZS5nICdcXHRcXHRmb29iYXInXG4gICAgICAvLyB3aXRoIGluZGVudD0yIGJlY29tZXMgJyAgXFx0Zm9vYmFyJ1xuICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oJyAnKSArIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXVlLmpvaW4oJycpO1xufTtcblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVCbG9jay5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qcyIsIi8vIEdGTSB0YWJsZSwgbm9uLXN0YW5kYXJkXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLmJsa0luZGVudCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcblxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcG9zID0gMCxcbiAgICAgIG1heCA9IHN0ci5sZW5ndGgsXG4gICAgICBjaCxcbiAgICAgIGVzY2FwZXMgPSAwLFxuICAgICAgbGFzdFBvcyA9IDAsXG4gICAgICBiYWNrVGlja2VkID0gZmFsc2UsXG4gICAgICBsYXN0QmFja1RpY2sgPSAwO1xuXG4gIGNoICA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGlmIChjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICAgIGlmIChiYWNrVGlja2VkKSB7XG4gICAgICAgIC8vIG1ha2UgXFxgIGNsb3NlIGNvZGUgc2VxdWVuY2UsIGJ1dCBub3Qgb3BlbiBpdDtcbiAgICAgICAgLy8gdGhlIHJlYXNvbiBpczogYFxcYCBpcyBjb3JyZWN0IGNvZGUgYmxvY2tcbiAgICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgICBsYXN0QmFja1RpY2sgPSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZXMgJSAyID09PSAwKSB7XG4gICAgICAgIGJhY2tUaWNrZWQgPSB0cnVlO1xuICAgICAgICBsYXN0QmFja1RpY2sgPSBwb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Yy8qIHwgKi8gJiYgKGVzY2FwZXMgJSAyID09PSAwKSAmJiAhYmFja1RpY2tlZCkge1xuICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zLCBwb3MpKTtcbiAgICAgIGxhc3RQb3MgPSBwb3MgKyAxO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHg1Yy8qIFxcICovKSB7XG4gICAgICBlc2NhcGVzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVzY2FwZXMgPSAwO1xuICAgIH1cblxuICAgIHBvcysrO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFuIHVuLWNsb3NlZCBiYWNrdGljaywgZ28gYmFjayB0byBqdXN0IGFmdGVyXG4gICAgLy8gdGhlIGxhc3QgYmFja3RpY2ssIGJ1dCBhcyBpZiBpdCB3YXMgYSBub3JtYWwgY2hhcmFjdGVyXG4gICAgaWYgKHBvcyA9PT0gbWF4ICYmIGJhY2tUaWNrZWQpIHtcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgIHBvcyA9IGxhc3RCYWNrVGljayArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICB9XG5cbiAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIG5leHRMaW5lLCBjb2x1bW5zLCBjb2x1bW5Db3VudCwgdG9rZW4sXG4gICAgICBhbGlnbnMsIHQsIHRhYmxlTGluZXMsIHRib2R5TGluZXM7XG5cbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcsICctJywgJzonLFxuICAvLyBhbmQgbm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCBidXQgc3BhY2VzO1xuICAvLyBiYXNpY2FsbHksIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgL15bLTp8XVstOnxcXHNdKiQvIHJlZ2V4cFxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICB3aGlsZSAocG9zIDwgc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLyAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lICsgMSk7XG5cbiAgY29sdW1ucyA9IGxpbmVUZXh0LnNwbGl0KCd8Jyk7XG4gIGFsaWducyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHQgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIC8vIGFsbG93IGVtcHR5IGNvbHVtbnMgYmVmb3JlIGFuZCBhZnRlciB0YWJsZSwgYnV0IG5vdCBpbiBiZXR3ZWVuIGNvbHVtbnM7XG4gICAgICAvLyBlLmcuIGFsbG93IGAgfC0tLXwgYCwgZGlzYWxsb3cgYCAtLS18fC0tLSBgXG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBjb2x1bW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXjo/LSs6PyQvLnRlc3QodCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2godC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLyA/ICdjZW50ZXInIDogJ3JpZ2h0Jyk7XG4gICAgfSBlbHNlIGlmICh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCgnbGVmdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGlnbnMucHVzaCgnJyk7XG4gICAgfVxuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUpLnRyaW0oKTtcbiAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xuXG4gIC8vIGhlYWRlciByb3cgd2lsbCBkZWZpbmUgYW4gYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGVudGlyZSB0YWJsZSxcbiAgLy8gYW5kIGFsaWduIHJvdyBzaG91bGRuJ3QgYmUgc21hbGxlciB0aGFuIHRoYXQgKHRoZSByZXN0IG9mIHRoZSByb3dzIGNhbilcbiAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID4gYWxpZ25zLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGFibGVfb3BlbicsICd0YWJsZScsIDEpO1xuICB0b2tlbi5tYXAgPSB0YWJsZUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9vcGVuJywgJ3RoZWFkJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9vcGVuJywgJ3RoJywgMSk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9jbG9zZScsICd0aCcsIC0xKTtcbiAgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9jbG9zZScsICd0aGVhZCcsIC0xKTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0Ym9keV9vcGVuJywgJ3Rib2R5JywgMSk7XG4gIHRva2VuLm1hcCA9IHRib2R5TGluZXMgPSBbIHN0YXJ0TGluZSArIDIsIDAgXTtcblxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMjsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgbmV4dExpbmUpLnRyaW0oKTtcbiAgICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyBicmVhazsgfVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgYnJlYWs7IH1cbiAgICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xuXG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGRfb3BlbicsICd0ZCcsIDEpO1xuICAgICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgICB9XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldID8gY29sdW1uc1tpXS50cmltKCkgOiAnJztcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGRfY2xvc2UnLCAndGQnLCAtMSk7XG4gICAgfVxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIH1cbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0Ym9keV9jbG9zZScsICd0Ym9keScsIC0xKTtcbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0YWJsZV9jbG9zZScsICd0YWJsZScsIC0xKTtcblxuICB0YWJsZUxpbmVzWzFdID0gdGJvZHlMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5saW5lKHN0YXRlKSB7XG4gIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIHRvaywgaSwgbDtcblxuICAvLyBQYXJzZSBpbmxpbmVzXG4gIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rID0gdG9rZW5zW2ldO1xuICAgIGlmICh0b2sudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZSh0b2suY29udGVudCwgc3RhdGUubWQsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV0/fFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcdTAwMDAvZztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgc3RyO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsICdcXHVGRkZEJyk7XG5cbiAgc3RhdGUuc3JjID0gc3RyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwiLy8gU2ltcGxlIHR5cG9ncmFwaHljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy0vZywgJ8KxJylcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLnsyLH0vZywgJ+KApicpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCAnJDEuLicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLV0pLS0tKFteLV18JCkvbWcsICckMVxcdTIwMTQkMicpXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLShcXHN8JCkvbWcsICckMVxcdTIwMTMkMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKFteLVxcc118JCkvbWcsICckMVxcdTIwMTMkMicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIGlmIChTQ09QRURfQUJCUl9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2Vfc2NvcGVkKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoUkFSRV9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3JhcmUoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCIvLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbnZhciBRVU9URV9SRSA9IC9bJ1wiXS9nO1xudmFyIEFQT1NUUk9QSEUgPSAnXFx1MjAxOSc7IC8qIOKAmSAqL1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VBdChzdHIsIGluZGV4LCBjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyBjaCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzKHRva2Vucywgc3RhdGUpIHtcbiAgdmFyIGksIHRva2VuLCB0ZXh0LCB0LCBwb3MsIG1heCwgdGhpc0xldmVsLCBpdGVtLCBsYXN0Q2hhciwgbmV4dENoYXIsXG4gICAgICBpc0xhc3RQdW5jdENoYXIsIGlzTmV4dFB1bmN0Q2hhciwgaXNMYXN0V2hpdGVTcGFjZSwgaXNOZXh0V2hpdGVTcGFjZSxcbiAgICAgIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2ssIG9wZW5RdW90ZSwgY2xvc2VRdW90ZTtcblxuICBzdGFjayA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcblxuICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IGogKyAxO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgcG9zID0gMDtcbiAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gICAgT1VURVI6XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dCk7XG4gICAgICBpZiAoIXQpIHsgYnJlYWs7IH1cblxuICAgICAgY2FuT3BlbiA9IGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgaXNTaW5nbGUgPSAodFswXSA9PT0gXCInXCIpO1xuXG4gICAgICAvLyBGaW5kIHByZXZpb3VzIGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGFzdENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICBsYXN0Q2hhciA9IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgPT09ICdzb2Z0YnJlYWsnIHx8IHRva2Vuc1tqXS50eXBlID09PSAnaGFyZGJyZWFrJykgYnJlYWs7IC8vIGxhc3RDaGFyIGRlZmF1bHRzIHRvIDB4MjBcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgIT09ICd0ZXh0JykgY29udGludWU7XG5cbiAgICAgICAgICBsYXN0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQodG9rZW5zW2pdLmNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbmV4dENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG5leHRDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSA9PT0gJ3NvZnRicmVhaycgfHwgdG9rZW5zW2pdLnR5cGUgPT09ICdoYXJkYnJlYWsnKSBicmVhazsgLy8gbmV4dENoYXIgZGVmYXVsdHMgdG8gMHgyMFxuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSBjb250aW51ZTtcblxuICAgICAgICAgIG5leHRDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gICAgICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICAgICAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gMHgyMiAvKiBcIiAqLyAmJiB0WzBdID09PSAnXCInKSB7XG4gICAgICAgIGlmIChsYXN0Q2hhciA+PSAweDMwIC8qIDAgKi8gJiYgbGFzdENoYXIgPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiAxXCJcIiAtIGNvdW50IGZpcnN0IHF1b3RlIGFzIGFuIGluY2hcbiAgICAgICAgICBjYW5DbG9zZSA9IGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xuICAgICAgICAvLyB0cmVhdCB0aGlzIGFzIHRoZSBtaWRkbGUgb2YgdGhlIHdvcmRcbiAgICAgICAgY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwiLy8gQ29yZSBzdGF0ZSBvYmplY3Rcbi8vXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG5cblxuZnVuY3Rpb24gU3RhdGVDb3JlKHNyYywgbWQsIGVudikge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMuaW5saW5lTW9kZSA9IGZhbHNlO1xuICB0aGlzLm1kID0gbWQ7IC8vIGxpbmsgdG8gcGFyc2VyIGluc3RhbmNlXG59XG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gY29yZSBydWxlc1xuU3RhdGVDb3JlLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVDb3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwiLy8gUHJvY2VzcyBhdXRvbGlua3MgJzxwcm90b2NvbDouLi4+J1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyplc2xpbnQgbWF4LWxlbjowKi9cbnZhciBFTUFJTF9SRSAgICA9IC9ePChbYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqKT4vO1xudmFyIEFVVE9MSU5LX1JFID0gL148KFthLXpBLVpdW2EtekEtWjAtOSsuXFwtXXsxLDMxfSk6KFtePD5cXHgwMC1cXHgyMF0qKT4vO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXV0b2xpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgdGFpbCwgbGlua01hdGNoLCBlbWFpbE1hdGNoLCB1cmwsIGZ1bGxVcmwsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICB0YWlsID0gc3RhdGUuc3JjLnNsaWNlKHBvcyk7XG5cbiAgaWYgKHRhaWwuaW5kZXhPZignPicpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoQVVUT0xJTktfUkUudGVzdCh0YWlsKSkge1xuICAgIGxpbmtNYXRjaCA9IHRhaWwubWF0Y2goQVVUT0xJTktfUkUpO1xuXG4gICAgdXJsID0gbGlua01hdGNoWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHN0YXRlLnBvcyArPSBsaW5rTWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEVNQUlMX1JFLnRlc3QodGFpbCkpIHtcbiAgICBlbWFpbE1hdGNoID0gdGFpbC5tYXRjaChFTUFJTF9SRSk7XG5cbiAgICB1cmwgPSBlbWFpbE1hdGNoWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluaygnbWFpbHRvOicgKyB1cmwpO1xuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xuXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHN0YXRlLnBvcyArPSBlbWFpbE1hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCIvLyBQYXJzZSBiYWNrdGlja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhY2t0aWNrKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHN0YXJ0LCBtYXgsIG1hcmtlciwgbWF0Y2hTdGFydCwgbWF0Y2hFbmQsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zLFxuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHg2MC8qIGAgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc3RhcnQgPSBwb3M7XG4gIHBvcysrO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDYwLyogYCAqLykgeyBwb3MrKzsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKTtcblxuICBtYXRjaFN0YXJ0ID0gbWF0Y2hFbmQgPSBwb3M7XG5cbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDE7XG5cbiAgICB3aGlsZSAobWF0Y2hFbmQgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQobWF0Y2hFbmQpID09PSAweDYwLyogYCAqLykgeyBtYXRjaEVuZCsrOyB9XG5cbiAgICBpZiAobWF0Y2hFbmQgLSBtYXRjaFN0YXJ0ID09PSBtYXJrZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnY29kZV9pbmxpbmUnLCAnY29kZScsIDApO1xuICAgICAgICB0b2tlbi5tYXJrdXAgID0gbWFya2VyO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF0Y2hTdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcbl0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBtYXRjaEVuZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gbWFya2VyOyB9XG4gIHN0YXRlLnBvcyArPSBtYXJrZXIubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsYXN0RGVsaW0sIGN1cnJEZWxpbSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgbGFzdERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmICghbGFzdERlbGltLmNsb3NlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBqID0gaSAtIGxhc3REZWxpbS5qdW1wIC0gMTtcblxuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIGN1cnJEZWxpbSA9IGRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChjdXJyRGVsaW0ub3BlbiAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5tYXJrZXIgPT09IGxhc3REZWxpbS5tYXJrZXIgJiZcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kIDwgMCAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5sZXZlbCA9PT0gbGFzdERlbGltLmxldmVsKSB7XG5cbiAgICAgICAgLy8gdHlwZW9mcyBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBwbHVnaW5zXG4gICAgICAgIHZhciBvZGRfbWF0Y2ggPSAoY3VyckRlbGltLmNsb3NlIHx8IGxhc3REZWxpbS5vcGVuKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJEZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdERlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyRGVsaW0ubGVuZ3RoICsgbGFzdERlbGltLmxlbmd0aCkgJSAzID09PSAwO1xuXG4gICAgICAgIGlmICghb2RkX21hdGNoKSB7XG4gICAgICAgICAgbGFzdERlbGltLmp1bXAgPSBpIC0gajtcbiAgICAgICAgICBsYXN0RGVsaW0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgID0gaTtcbiAgICAgICAgICBjdXJyRGVsaW0uanVtcCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiAtPSBjdXJyRGVsaW0uanVtcCArIDE7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanMiLCIvLyBQcm9jZXNzIGh0bWwgZW50aXR5IC0gJiMxMjM7LCAmI3hBRjssICZxdW90OywgLi4uXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0aWVzICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL2VudGl0aWVzJyk7XG52YXIgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5oYXM7XG52YXIgaXNWYWxpZEVudGl0eUNvZGUgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1ZhbGlkRW50aXR5Q29kZTtcbnZhciBmcm9tQ29kZVBvaW50ICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmZyb21Db2RlUG9pbnQ7XG5cblxudmFyIERJR0lUQUxfUkUgPSAvXiYjKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKTsvaTtcbnZhciBOQU1FRF9SRSAgID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBjb2RlLCBtYXRjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjYvKiAmICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAxIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMyAvKiAjICovKSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgY29kZSA9IG1hdGNoWzFdWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gaXNWYWxpZEVudGl0eUNvZGUoY29kZSkgPyBmcm9tQ29kZVBvaW50KGNvZGUpIDogZnJvbUNvZGVQb2ludCgweEZGRkQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKE5BTUVEX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoaGFzKGVudGl0aWVzLCBtYXRjaFsxXSkpIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IGVudGl0aWVzW21hdGNoWzFdXTsgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICcmJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5qcyIsIi8vIFByb2Nlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxudmFyIEVTQ0FQRUQgPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykgeyBFU0NBUEVELnB1c2goMCk7IH1cblxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xuICAuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxOyB9KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUMvKiBcXCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1twb3NdOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgICAgLy8gc2tpcCBsZWFkaW5nIHdoaXRlc3BhY2VzIGZyb20gbmV4dCBsaW5lXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnXFxcXCc7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLmpzIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcywgdHJ1ZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBtaWdodCBoYXZlIGZvdW5kIGEgdmFsaWQgc2hvcnRjdXQgbGluaywgZGlzYWJsZSByZWZlcmVuY2UgcGFyc2luZ1xuICAgIHBhcnNlUmVmZXJlbmNlID0gZmFsc2U7XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLmpzIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXdsaW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBtYXggPSBzdGF0ZS5wZW5kaW5nLmxlbmd0aCAtIDE7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyAnICBcXG4nIC0+IGhhcmRicmVha1xuICAvLyBMb29rdXAgaW4gcGVuZGluZyBjaGFycyBpcyBiYWQgcHJhY3RpY2UhIERvbid0IGNvcHkgdG8gb3RoZXIgcnVsZXMhXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcbiAgLy8gY29udmVydGlvbiB0byBmbGF0IG1vZGUuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMHgyMCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qcyIsIi8vIElubGluZSBwYXJzZXIgc3RhdGVcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUb2tlbiAgICAgICAgICA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG5cbmZ1bmN0aW9uIFN0YXRlSW5saW5lKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy5tZCA9IG1kO1xuICB0aGlzLnRva2VucyA9IG91dFRva2VucztcblxuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMucG9zTWF4ID0gdGhpcy5zcmMubGVuZ3RoO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gMDtcblxuICB0aGlzLmNhY2hlID0ge307ICAgICAgICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuXG4gIHRoaXMuZGVsaW1pdGVycyA9IFtdOyAgIC8vIEVtcGhhc2lzLWxpa2UgZGVsaW1pdGVyc1xufVxuXG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICB0aGlzLnB1c2hQZW5kaW5nKCk7XG4gIH1cblxuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcblxuICBpZiAobmVzdGluZyA8IDApIHsgdGhpcy5sZXZlbC0tOyB9XG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxuXG4gIHRoaXMucGVuZGluZ0xldmVsID0gdGhpcy5sZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGVtcGhhc2lzLWxpa2UgbWFya2VycywgYW5kIGRldGVybWluZSB3aGV0aGVyXG4vLyBpdCBjYW4gc3RhcnQgYW4gZW1waGFzaXMgc2VxdWVuY2Ugb3IgZW5kIGFuIGVtcGhhc2lzIHNlcXVlbmNlLlxuLy9cbi8vICAtIHN0YXJ0IC0gcG9zaXRpb24gdG8gc2NhbiBmcm9tIChpdCBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXIpO1xuLy8gIC0gY2FuU3BsaXRXb3JkIC0gZGV0ZXJtaW5lIGlmIHRoZXNlIG1hcmtlcnMgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHdvcmRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChzdGFydCwgY2FuU3BsaXRXb3JkKSB7XG4gIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCwgY2FuX29wZW4sIGNhbl9jbG9zZSxcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UsIGlzTGFzdFB1bmN0Q2hhcixcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UsIGlzTmV4dFB1bmN0Q2hhcixcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgcmlnaHRfZmxhbmtpbmcgPSB0cnVlLFxuICAgICAgbWF4ID0gdGhpcy5wb3NNYXgsXG4gICAgICBtYXJrZXIgPSB0aGlzLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAvLyB0cmVhdCBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogMHgyMDtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gbWFya2VyKSB7IHBvcysrOyB9XG5cbiAgY291bnQgPSBwb3MgLSBzdGFydDtcblxuICAvLyB0cmVhdCBlbmQgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXG4gIG5leHRDaGFyID0gcG9zIDwgbWF4ID8gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpIDogMHgyMDtcblxuICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcblxuICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcbiAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgIGxlZnRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY2FuU3BsaXRXb3JkKSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZyAgJiYgKCFyaWdodF9mbGFua2luZyB8fCBpc0xhc3RQdW5jdENoYXIpO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nICYmICghbGVmdF9mbGFua2luZyAgfHwgaXNOZXh0UHVuY3RDaGFyKTtcbiAgfSBlbHNlIHtcbiAgICBjYW5fb3BlbiAgPSBsZWZ0X2ZsYW5raW5nO1xuICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYW5fb3BlbjogIGNhbl9vcGVuLFxuICAgIGNhbl9jbG9zZTogY2FuX2Nsb3NlLFxuICAgIGxlbmd0aDogICAgY291bnRcbiAgfTtcbn07XG5cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCIvLyBTa2lwIHRleHQgY2hhcmFjdGVycyBmb3IgdGV4dCB0b2tlbiwgcGxhY2UgdGhvc2UgdG8gcGVuZGluZyBidWZmZXJcbi8vIGFuZCBpbmNyZW1lbnQgY3VycmVudCBwb3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFJ1bGUgdG8gc2tpcCBwdXJlIHRleHRcbi8vICd7fSQlQH4rPTonIHJlc2VydmVkIGZvciBleHRlbnRpb25zXG5cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuXG4vLyAhISEhIERvbid0IGNvbmZ1c2Ugd2l0aCBcIk1hcmtkb3duIEFTQ0lJIFB1bmN0dWF0aW9uXCIgY2hhcnNcbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuZnVuY3Rpb24gaXNUZXJtaW5hdG9yQ2hhcihjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDBBLyogXFxuICovOlxuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zO1xuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5wb3NNYXggJiYgIWlzVGVybWluYXRvckNoYXIoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPT09IHN0YXRlLnBvcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgZm9yIG1lbW9yeS5cbi8vXG4vLyBJdCBjb3N0cyAxMCUgb2YgcGVyZm9ybWFuY2UsIGJ1dCBhbGxvd3MgZXh0ZW5kIHRlcm1pbmF0b3JzIGxpc3QsIGlmIHBsYWNlIGl0XG4vLyB0byBgUGFyY2VySW5saW5lYCBwcm9wZXJ0eS4gUHJvYmFibHksIHdpbGwgc3dpdGNoIHRvIGl0IHNvbWV0aW1lLCBzdWNoXG4vLyBmbGV4aWJpbGl0eSByZXF1aXJlZC5cblxuLypcbnZhciBURVJNSU5BVE9SX1JFID0gL1tcXG4hIyQlJiorXFwtOjw9PkBbXFxcXFxcXV5fYHt9fl0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zLFxuICAgICAgaWR4ID0gc3RhdGUuc3JjLnNsaWNlKHBvcykuc2VhcmNoKFRFUk1JTkFUT1JfUkUpO1xuXG4gIC8vIGZpcnN0IGNoYXIgaXMgdGVybWluYXRvciAtPiBlbXB0eSB0ZXh0XG4gIGlmIChpZHggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbm8gdGVybWluYXRvciAtPiB0ZXh0IHRpbGwgZW5kIG9mIHN0cmluZ1xuICBpZiAoaWR4IDwgMCkge1xuICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcyk7IH1cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5zcmMubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBpZHgpOyB9XG5cbiAgc3RhdGUucG9zICs9IGlkeDtcblxuICByZXR1cm4gdHJ1ZTtcbn07Ki9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwiLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBpbnRvIG9uZSwgYW5kIHJlLWNhbGN1bGF0ZSBhbGwgdG9rZW4gbGV2ZWxzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dF9jb2xsYXBzZShzdGF0ZSkge1xuICB2YXIgY3VyciwgbGFzdCxcbiAgICAgIGxldmVsID0gMCxcbiAgICAgIHRva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIC8vIHJlLWNhbGN1bGF0ZSBsZXZlbHNcbiAgICBsZXZlbCArPSB0b2tlbnNbY3Vycl0ubmVzdGluZztcbiAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcblxuICAgIGlmICh0b2tlbnNbY3Vycl0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIGN1cnIgKyAxIDwgbWF4ICYmXG4gICAgICAgIHRva2Vuc1tjdXJyICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG5cbiAgICAgIC8vIGNvbGxhcHNlIHR3byBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQgPSB0b2tlbnNbY3Vycl0uY29udGVudCArIHRva2Vuc1tjdXJyICsgMV0uY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHsgdG9rZW5zW2xhc3RdID0gdG9rZW5zW2N1cnJdOyB9XG5cbiAgICAgIGxhc3QrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY3VyciAhPT0gbGFzdCkge1xuICAgIHRva2Vucy5sZW5ndGggPSBsYXN0O1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgY2FjaGUucHVzaChjaCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIERlY29kZSBwZXJjZW50LWVuY29kZWQgc3RyaW5nLlxuLy9cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgdmFyIGNhY2hlO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xuICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBiMSA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMSwgaSArIDMpLCAxNik7XG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEUwKSA9PT0gMHhDMCAmJiAoaSArIDMgPCBsKSkge1xuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGMCkgPT09IDB4RTAgJiYgKGkgKyA2IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxMikgJiAweEYwMDApIHwgKChiMiA8PCA2KSAmIDB4RkMwKSB8IChiMyAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4ODAwIHx8IChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERGRkYpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY2hyID0gKChiMSA8PCAxOCkgJiAweDFDMDAwMCkgfCAoKGIyIDw8IDEyKSAmIDB4M0YwMDApIHwgKChiMyA8PCA2KSAmIDB4RkMwKSB8IChiNCAmIDB4M0YpO1xuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKGNociA+PiAxMCksIDB4REMwMCArIChjaHIgJiAweDNGRikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJ1xcdWZmZmQnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5cbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XG5kZWNvZGUuY29tcG9uZW50Q2hhcnMgPSAnJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWR1cmwvZGVjb2RlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGVuY29kZUNhY2hlID0ge307XG5cblxuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG5cbiAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSxcbiAgICAgIHJlc3VsdCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICBrZWVwRXNjYXBlZCAgPSBleGNsdWRlO1xuICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZS5kZWZhdWx0Q2hhcnMgICA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21kdXJsL2VuY29kZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0KHVybCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zbGFzaGVzID8gJy8vJyA6ICcnO1xuICByZXN1bHQgKz0gdXJsLmF1dGggPyB1cmwuYXV0aCArICdAJyA6ICcnO1xuXG4gIGlmICh1cmwuaG9zdG5hbWUgJiYgdXJsLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAvLyBpcHY2IGFkZHJlc3NcbiAgICByZXN1bHQgKz0gJ1snICsgdXJsLmhvc3RuYW1lICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB1cmwuaG9zdG5hbWUgfHwgJyc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnO1xuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNlYXJjaCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5oYXNoIHx8ICcnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tZHVybC9mb3JtYXQuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWR1cmwvcGFyc2UuanMiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRcXHVEQ0JEfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQW55ID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzL0FueS9yZWdleCcpO1xuZXhwb3J0cy5DYyAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKTtcbmV4cG9ydHMuQ2YgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NmL3JlZ2V4Jyk7XG5leHBvcnRzLlAgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5leHBvcnRzLlogICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9aL3JlZ2V4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3VjLm1pY3JvL2luZGV4LmpzIiwiaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnbWFya2Rvd24taXQnO1xuaW1wb3J0IE1hcmtkb3duSXREZWNvcmF0ZSBmcm9tICdtYXJrZG93bi1pdC1kZWNvcmF0ZSc7XG5pbXBvcnQgaGlnaGxpZ2h0IGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvaGlnaGxpZ2h0JztcbmltcG9ydCBsSmF2YXNjcmlwdCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0JztcbmltcG9ydCBsQ3NzIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcyc7XG5pbXBvcnQgbFhtbCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwnO1xuaW1wb3J0IGxCYXNoIGZyb20gJ2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Jhc2gnO1xuXG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgnYmFzaCcsIGxCYXNoKTtcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdjc3MnLCBsQ3NzKTtcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCdqYXZhc2NyaXB0JywgbEphdmFzY3JpcHQpO1xuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ3htbCcsIGxYbWwpO1xuXG53aW5kb3cuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG5jb25zdCBtYXJrZWQgPSBNYXJrZG93bkl0KHtcbiAgICBodG1sOiB0cnVlLFxuICAgIGJyZWFrczogZmFsc2UgXG59KS51c2UoTWFya2Rvd25JdERlY29yYXRlKTtcbi8vIOWOu+aOieauteiQvXNvZnRicmVha1xubWFya2VkLnJlbmRlcmVyLnJ1bGVzLnNvZnRicmVhayA9ICgpID0+ICcnO1xuXG5leHBvcnQge2hpZ2hsaWdodCwgbWFya2VkfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvbGliL3V0aWxzLmpzIiwiaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vbGF5b3V0LnZkdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgSW50YWN0IHtcbiAgICBASW50YWN0LnRlbXBsYXRlKClcbiAgICBzdGF0aWMgdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgIF9tb3VudCgpIHtcbiAgICAgICAgdGhpcy4kYm9yZGVyID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJy5ib3JkZXInKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm9yZGVyKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUJvcmRlcigpIHtcbiAgICAgICAgY29uc3QgJG5hdiA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuYWN0aXZlJyk7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgaWYgKCRuYXYubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gJG5hdi5wb3NpdGlvbigpLmxlZnQ7XG4gICAgICAgICAgICB3aWR0aCA9ICRuYXYub3V0ZXJXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGJvcmRlci5hZGRDbGFzcygndHJhbnNpdGlvbicpO1xuICAgICAgICB0aGlzLiRib3JkZXIuY3NzKHt3aWR0aDogd2lkdGgsIGxlZnQ6IGxlZnR9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaXRlL3BhZ2VzL2xheW91dC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1wiQWFjdXRlXCI6XCLDgVwiLFwiYWFjdXRlXCI6XCLDoVwiLFwiQWJyZXZlXCI6XCLEglwiLFwiYWJyZXZlXCI6XCLEg1wiLFwiYWNcIjpcIuKIvlwiLFwiYWNkXCI6XCLiiL9cIixcImFjRVwiOlwi4oi+zLNcIixcIkFjaXJjXCI6XCLDglwiLFwiYWNpcmNcIjpcIsOiXCIsXCJhY3V0ZVwiOlwiwrRcIixcIkFjeVwiOlwi0JBcIixcImFjeVwiOlwi0LBcIixcIkFFbGlnXCI6XCLDhlwiLFwiYWVsaWdcIjpcIsOmXCIsXCJhZlwiOlwi4oGhXCIsXCJBZnJcIjpcIvCdlIRcIixcImFmclwiOlwi8J2UnlwiLFwiQWdyYXZlXCI6XCLDgFwiLFwiYWdyYXZlXCI6XCLDoFwiLFwiYWxlZnN5bVwiOlwi4oS1XCIsXCJhbGVwaFwiOlwi4oS1XCIsXCJBbHBoYVwiOlwizpFcIixcImFscGhhXCI6XCLOsVwiLFwiQW1hY3JcIjpcIsSAXCIsXCJhbWFjclwiOlwixIFcIixcImFtYWxnXCI6XCLiqL9cIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJhbmRhbmRcIjpcIuKplVwiLFwiQW5kXCI6XCLiqZNcIixcImFuZFwiOlwi4oinXCIsXCJhbmRkXCI6XCLiqZxcIixcImFuZHNsb3BlXCI6XCLiqZhcIixcImFuZHZcIjpcIuKpmlwiLFwiYW5nXCI6XCLiiKBcIixcImFuZ2VcIjpcIuKmpFwiLFwiYW5nbGVcIjpcIuKIoFwiLFwiYW5nbXNkYWFcIjpcIuKmqFwiLFwiYW5nbXNkYWJcIjpcIuKmqVwiLFwiYW5nbXNkYWNcIjpcIuKmqlwiLFwiYW5nbXNkYWRcIjpcIuKmq1wiLFwiYW5nbXNkYWVcIjpcIuKmrFwiLFwiYW5nbXNkYWZcIjpcIuKmrVwiLFwiYW5nbXNkYWdcIjpcIuKmrlwiLFwiYW5nbXNkYWhcIjpcIuKmr1wiLFwiYW5nbXNkXCI6XCLiiKFcIixcImFuZ3J0XCI6XCLiiJ9cIixcImFuZ3J0dmJcIjpcIuKKvlwiLFwiYW5ncnR2YmRcIjpcIuKmnVwiLFwiYW5nc3BoXCI6XCLiiKJcIixcImFuZ3N0XCI6XCLDhVwiLFwiYW5nemFyclwiOlwi4o28XCIsXCJBb2dvblwiOlwixIRcIixcImFvZ29uXCI6XCLEhVwiLFwiQW9wZlwiOlwi8J2UuFwiLFwiYW9wZlwiOlwi8J2VklwiLFwiYXBhY2lyXCI6XCLiqa9cIixcImFwXCI6XCLiiYhcIixcImFwRVwiOlwi4qmwXCIsXCJhcGVcIjpcIuKJilwiLFwiYXBpZFwiOlwi4omLXCIsXCJhcG9zXCI6XCInXCIsXCJBcHBseUZ1bmN0aW9uXCI6XCLigaFcIixcImFwcHJveFwiOlwi4omIXCIsXCJhcHByb3hlcVwiOlwi4omKXCIsXCJBcmluZ1wiOlwiw4VcIixcImFyaW5nXCI6XCLDpVwiLFwiQXNjclwiOlwi8J2SnFwiLFwiYXNjclwiOlwi8J2StlwiLFwiQXNzaWduXCI6XCLiiZRcIixcImFzdFwiOlwiKlwiLFwiYXN5bXBcIjpcIuKJiFwiLFwiYXN5bXBlcVwiOlwi4omNXCIsXCJBdGlsZGVcIjpcIsODXCIsXCJhdGlsZGVcIjpcIsOjXCIsXCJBdW1sXCI6XCLDhFwiLFwiYXVtbFwiOlwiw6RcIixcImF3Y29uaW50XCI6XCLiiLNcIixcImF3aW50XCI6XCLiqJFcIixcImJhY2tjb25nXCI6XCLiiYxcIixcImJhY2tlcHNpbG9uXCI6XCLPtlwiLFwiYmFja3ByaW1lXCI6XCLigLVcIixcImJhY2tzaW1cIjpcIuKIvVwiLFwiYmFja3NpbWVxXCI6XCLii41cIixcIkJhY2tzbGFzaFwiOlwi4oiWXCIsXCJCYXJ2XCI6XCLiq6dcIixcImJhcnZlZVwiOlwi4oq9XCIsXCJiYXJ3ZWRcIjpcIuKMhVwiLFwiQmFyd2VkXCI6XCLijIZcIixcImJhcndlZGdlXCI6XCLijIVcIixcImJicmtcIjpcIuKOtVwiLFwiYmJya3RicmtcIjpcIuKOtlwiLFwiYmNvbmdcIjpcIuKJjFwiLFwiQmN5XCI6XCLQkVwiLFwiYmN5XCI6XCLQsVwiLFwiYmRxdW9cIjpcIuKAnlwiLFwiYmVjYXVzXCI6XCLiiLVcIixcImJlY2F1c2VcIjpcIuKItVwiLFwiQmVjYXVzZVwiOlwi4oi1XCIsXCJiZW1wdHl2XCI6XCLiprBcIixcImJlcHNpXCI6XCLPtlwiLFwiYmVybm91XCI6XCLihKxcIixcIkJlcm5vdWxsaXNcIjpcIuKErFwiLFwiQmV0YVwiOlwizpJcIixcImJldGFcIjpcIs6yXCIsXCJiZXRoXCI6XCLihLZcIixcImJldHdlZW5cIjpcIuKJrFwiLFwiQmZyXCI6XCLwnZSFXCIsXCJiZnJcIjpcIvCdlJ9cIixcImJpZ2NhcFwiOlwi4ouCXCIsXCJiaWdjaXJjXCI6XCLil69cIixcImJpZ2N1cFwiOlwi4ouDXCIsXCJiaWdvZG90XCI6XCLiqIBcIixcImJpZ29wbHVzXCI6XCLiqIFcIixcImJpZ290aW1lc1wiOlwi4qiCXCIsXCJiaWdzcWN1cFwiOlwi4qiGXCIsXCJiaWdzdGFyXCI6XCLimIVcIixcImJpZ3RyaWFuZ2xlZG93blwiOlwi4pa9XCIsXCJiaWd0cmlhbmdsZXVwXCI6XCLilrNcIixcImJpZ3VwbHVzXCI6XCLiqIRcIixcImJpZ3ZlZVwiOlwi4ouBXCIsXCJiaWd3ZWRnZVwiOlwi4ouAXCIsXCJia2Fyb3dcIjpcIuKkjVwiLFwiYmxhY2tsb3plbmdlXCI6XCLip6tcIixcImJsYWNrc3F1YXJlXCI6XCLilqpcIixcImJsYWNrdHJpYW5nbGVcIjpcIuKWtFwiLFwiYmxhY2t0cmlhbmdsZWRvd25cIjpcIuKWvlwiLFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIuKXglwiLFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCLilrhcIixcImJsYW5rXCI6XCLikKNcIixcImJsazEyXCI6XCLilpJcIixcImJsazE0XCI6XCLilpFcIixcImJsazM0XCI6XCLilpNcIixcImJsb2NrXCI6XCLilohcIixcImJuZVwiOlwiPeKDpVwiLFwiYm5lcXVpdlwiOlwi4omh4oOlXCIsXCJiTm90XCI6XCLiq61cIixcImJub3RcIjpcIuKMkFwiLFwiQm9wZlwiOlwi8J2UuVwiLFwiYm9wZlwiOlwi8J2Vk1wiLFwiYm90XCI6XCLiiqVcIixcImJvdHRvbVwiOlwi4oqlXCIsXCJib3d0aWVcIjpcIuKLiFwiLFwiYm94Ym94XCI6XCLip4lcIixcImJveGRsXCI6XCLilJBcIixcImJveGRMXCI6XCLilZVcIixcImJveERsXCI6XCLilZZcIixcImJveERMXCI6XCLilZdcIixcImJveGRyXCI6XCLilIxcIixcImJveGRSXCI6XCLilZJcIixcImJveERyXCI6XCLilZNcIixcImJveERSXCI6XCLilZRcIixcImJveGhcIjpcIuKUgFwiLFwiYm94SFwiOlwi4pWQXCIsXCJib3hoZFwiOlwi4pSsXCIsXCJib3hIZFwiOlwi4pWkXCIsXCJib3hoRFwiOlwi4pWlXCIsXCJib3hIRFwiOlwi4pWmXCIsXCJib3hodVwiOlwi4pS0XCIsXCJib3hIdVwiOlwi4pWnXCIsXCJib3hoVVwiOlwi4pWoXCIsXCJib3hIVVwiOlwi4pWpXCIsXCJib3htaW51c1wiOlwi4oqfXCIsXCJib3hwbHVzXCI6XCLiip5cIixcImJveHRpbWVzXCI6XCLiiqBcIixcImJveHVsXCI6XCLilJhcIixcImJveHVMXCI6XCLilZtcIixcImJveFVsXCI6XCLilZxcIixcImJveFVMXCI6XCLilZ1cIixcImJveHVyXCI6XCLilJRcIixcImJveHVSXCI6XCLilZhcIixcImJveFVyXCI6XCLilZlcIixcImJveFVSXCI6XCLilZpcIixcImJveHZcIjpcIuKUglwiLFwiYm94VlwiOlwi4pWRXCIsXCJib3h2aFwiOlwi4pS8XCIsXCJib3h2SFwiOlwi4pWqXCIsXCJib3hWaFwiOlwi4pWrXCIsXCJib3hWSFwiOlwi4pWsXCIsXCJib3h2bFwiOlwi4pSkXCIsXCJib3h2TFwiOlwi4pWhXCIsXCJib3hWbFwiOlwi4pWiXCIsXCJib3hWTFwiOlwi4pWjXCIsXCJib3h2clwiOlwi4pScXCIsXCJib3h2UlwiOlwi4pWeXCIsXCJib3hWclwiOlwi4pWfXCIsXCJib3hWUlwiOlwi4pWgXCIsXCJicHJpbWVcIjpcIuKAtVwiLFwiYnJldmVcIjpcIsuYXCIsXCJCcmV2ZVwiOlwiy5hcIixcImJydmJhclwiOlwiwqZcIixcImJzY3JcIjpcIvCdkrdcIixcIkJzY3JcIjpcIuKErFwiLFwiYnNlbWlcIjpcIuKBj1wiLFwiYnNpbVwiOlwi4oi9XCIsXCJic2ltZVwiOlwi4ouNXCIsXCJic29sYlwiOlwi4qeFXCIsXCJic29sXCI6XCJcXFxcXCIsXCJic29saHN1YlwiOlwi4p+IXCIsXCJidWxsXCI6XCLigKJcIixcImJ1bGxldFwiOlwi4oCiXCIsXCJidW1wXCI6XCLiiY5cIixcImJ1bXBFXCI6XCLiqq5cIixcImJ1bXBlXCI6XCLiiY9cIixcIkJ1bXBlcVwiOlwi4omOXCIsXCJidW1wZXFcIjpcIuKJj1wiLFwiQ2FjdXRlXCI6XCLEhlwiLFwiY2FjdXRlXCI6XCLEh1wiLFwiY2FwYW5kXCI6XCLiqYRcIixcImNhcGJyY3VwXCI6XCLiqYlcIixcImNhcGNhcFwiOlwi4qmLXCIsXCJjYXBcIjpcIuKIqVwiLFwiQ2FwXCI6XCLii5JcIixcImNhcGN1cFwiOlwi4qmHXCIsXCJjYXBkb3RcIjpcIuKpgFwiLFwiQ2FwaXRhbERpZmZlcmVudGlhbERcIjpcIuKFhVwiLFwiY2Fwc1wiOlwi4oip77iAXCIsXCJjYXJldFwiOlwi4oGBXCIsXCJjYXJvblwiOlwiy4dcIixcIkNheWxleXNcIjpcIuKErVwiLFwiY2NhcHNcIjpcIuKpjVwiLFwiQ2Nhcm9uXCI6XCLEjFwiLFwiY2Nhcm9uXCI6XCLEjVwiLFwiQ2NlZGlsXCI6XCLDh1wiLFwiY2NlZGlsXCI6XCLDp1wiLFwiQ2NpcmNcIjpcIsSIXCIsXCJjY2lyY1wiOlwixIlcIixcIkNjb25pbnRcIjpcIuKIsFwiLFwiY2N1cHNcIjpcIuKpjFwiLFwiY2N1cHNzbVwiOlwi4qmQXCIsXCJDZG90XCI6XCLEilwiLFwiY2RvdFwiOlwixItcIixcImNlZGlsXCI6XCLCuFwiLFwiQ2VkaWxsYVwiOlwiwrhcIixcImNlbXB0eXZcIjpcIuKmslwiLFwiY2VudFwiOlwiwqJcIixcImNlbnRlcmRvdFwiOlwiwrdcIixcIkNlbnRlckRvdFwiOlwiwrdcIixcImNmclwiOlwi8J2UoFwiLFwiQ2ZyXCI6XCLihK1cIixcIkNIY3lcIjpcItCnXCIsXCJjaGN5XCI6XCLRh1wiLFwiY2hlY2tcIjpcIuKck1wiLFwiY2hlY2ttYXJrXCI6XCLinJNcIixcIkNoaVwiOlwizqdcIixcImNoaVwiOlwiz4dcIixcImNpcmNcIjpcIsuGXCIsXCJjaXJjZXFcIjpcIuKJl1wiLFwiY2lyY2xlYXJyb3dsZWZ0XCI6XCLihrpcIixcImNpcmNsZWFycm93cmlnaHRcIjpcIuKGu1wiLFwiY2lyY2xlZGFzdFwiOlwi4oqbXCIsXCJjaXJjbGVkY2lyY1wiOlwi4oqaXCIsXCJjaXJjbGVkZGFzaFwiOlwi4oqdXCIsXCJDaXJjbGVEb3RcIjpcIuKKmVwiLFwiY2lyY2xlZFJcIjpcIsKuXCIsXCJjaXJjbGVkU1wiOlwi4pOIXCIsXCJDaXJjbGVNaW51c1wiOlwi4oqWXCIsXCJDaXJjbGVQbHVzXCI6XCLiipVcIixcIkNpcmNsZVRpbWVzXCI6XCLiipdcIixcImNpclwiOlwi4peLXCIsXCJjaXJFXCI6XCLip4NcIixcImNpcmVcIjpcIuKJl1wiLFwiY2lyZm5pbnRcIjpcIuKokFwiLFwiY2lybWlkXCI6XCLiq69cIixcImNpcnNjaXJcIjpcIuKnglwiLFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCLiiLJcIixcIkNsb3NlQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCdXCIsXCJDbG9zZUN1cmx5UXVvdGVcIjpcIuKAmVwiLFwiY2x1YnNcIjpcIuKZo1wiLFwiY2x1YnN1aXRcIjpcIuKZo1wiLFwiY29sb25cIjpcIjpcIixcIkNvbG9uXCI6XCLiiLdcIixcIkNvbG9uZVwiOlwi4qm0XCIsXCJjb2xvbmVcIjpcIuKJlFwiLFwiY29sb25lcVwiOlwi4omUXCIsXCJjb21tYVwiOlwiLFwiLFwiY29tbWF0XCI6XCJAXCIsXCJjb21wXCI6XCLiiIFcIixcImNvbXBmblwiOlwi4oiYXCIsXCJjb21wbGVtZW50XCI6XCLiiIFcIixcImNvbXBsZXhlc1wiOlwi4oSCXCIsXCJjb25nXCI6XCLiiYVcIixcImNvbmdkb3RcIjpcIuKprVwiLFwiQ29uZ3J1ZW50XCI6XCLiiaFcIixcImNvbmludFwiOlwi4oiuXCIsXCJDb25pbnRcIjpcIuKIr1wiLFwiQ29udG91ckludGVncmFsXCI6XCLiiK5cIixcImNvcGZcIjpcIvCdlZRcIixcIkNvcGZcIjpcIuKEglwiLFwiY29wcm9kXCI6XCLiiJBcIixcIkNvcHJvZHVjdFwiOlwi4oiQXCIsXCJjb3B5XCI6XCLCqVwiLFwiQ09QWVwiOlwiwqlcIixcImNvcHlzclwiOlwi4oSXXCIsXCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCLiiLNcIixcImNyYXJyXCI6XCLihrVcIixcImNyb3NzXCI6XCLinJdcIixcIkNyb3NzXCI6XCLiqK9cIixcIkNzY3JcIjpcIvCdkp5cIixcImNzY3JcIjpcIvCdkrhcIixcImNzdWJcIjpcIuKrj1wiLFwiY3N1YmVcIjpcIuKrkVwiLFwiY3N1cFwiOlwi4quQXCIsXCJjc3VwZVwiOlwi4quSXCIsXCJjdGRvdFwiOlwi4ouvXCIsXCJjdWRhcnJsXCI6XCLipLhcIixcImN1ZGFycnJcIjpcIuKktVwiLFwiY3VlcHJcIjpcIuKLnlwiLFwiY3Vlc2NcIjpcIuKLn1wiLFwiY3VsYXJyXCI6XCLihrZcIixcImN1bGFycnBcIjpcIuKkvVwiLFwiY3VwYnJjYXBcIjpcIuKpiFwiLFwiY3VwY2FwXCI6XCLiqYZcIixcIkN1cENhcFwiOlwi4omNXCIsXCJjdXBcIjpcIuKIqlwiLFwiQ3VwXCI6XCLii5NcIixcImN1cGN1cFwiOlwi4qmKXCIsXCJjdXBkb3RcIjpcIuKKjVwiLFwiY3Vwb3JcIjpcIuKphVwiLFwiY3Vwc1wiOlwi4oiq77iAXCIsXCJjdXJhcnJcIjpcIuKGt1wiLFwiY3VyYXJybVwiOlwi4qS8XCIsXCJjdXJseWVxcHJlY1wiOlwi4oueXCIsXCJjdXJseWVxc3VjY1wiOlwi4oufXCIsXCJjdXJseXZlZVwiOlwi4ouOXCIsXCJjdXJseXdlZGdlXCI6XCLii49cIixcImN1cnJlblwiOlwiwqRcIixcImN1cnZlYXJyb3dsZWZ0XCI6XCLihrZcIixcImN1cnZlYXJyb3dyaWdodFwiOlwi4oa3XCIsXCJjdXZlZVwiOlwi4ouOXCIsXCJjdXdlZFwiOlwi4ouPXCIsXCJjd2NvbmludFwiOlwi4oiyXCIsXCJjd2ludFwiOlwi4oixXCIsXCJjeWxjdHlcIjpcIuKMrVwiLFwiZGFnZ2VyXCI6XCLigKBcIixcIkRhZ2dlclwiOlwi4oChXCIsXCJkYWxldGhcIjpcIuKEuFwiLFwiZGFyclwiOlwi4oaTXCIsXCJEYXJyXCI6XCLihqFcIixcImRBcnJcIjpcIuKHk1wiLFwiZGFzaFwiOlwi4oCQXCIsXCJEYXNodlwiOlwi4qukXCIsXCJkYXNodlwiOlwi4oqjXCIsXCJkYmthcm93XCI6XCLipI9cIixcImRibGFjXCI6XCLLnVwiLFwiRGNhcm9uXCI6XCLEjlwiLFwiZGNhcm9uXCI6XCLEj1wiLFwiRGN5XCI6XCLQlFwiLFwiZGN5XCI6XCLQtFwiLFwiZGRhZ2dlclwiOlwi4oChXCIsXCJkZGFyclwiOlwi4oeKXCIsXCJERFwiOlwi4oWFXCIsXCJkZFwiOlwi4oWGXCIsXCJERG90cmFoZFwiOlwi4qSRXCIsXCJkZG90c2VxXCI6XCLiqbdcIixcImRlZ1wiOlwiwrBcIixcIkRlbFwiOlwi4oiHXCIsXCJEZWx0YVwiOlwizpRcIixcImRlbHRhXCI6XCLOtFwiLFwiZGVtcHR5dlwiOlwi4qaxXCIsXCJkZmlzaHRcIjpcIuKlv1wiLFwiRGZyXCI6XCLwnZSHXCIsXCJkZnJcIjpcIvCdlKFcIixcImRIYXJcIjpcIuKlpVwiLFwiZGhhcmxcIjpcIuKHg1wiLFwiZGhhcnJcIjpcIuKHglwiLFwiRGlhY3JpdGljYWxBY3V0ZVwiOlwiwrRcIixcIkRpYWNyaXRpY2FsRG90XCI6XCLLmVwiLFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOlwiy51cIixcIkRpYWNyaXRpY2FsR3JhdmVcIjpcImBcIixcIkRpYWNyaXRpY2FsVGlsZGVcIjpcIsucXCIsXCJkaWFtXCI6XCLii4RcIixcImRpYW1vbmRcIjpcIuKLhFwiLFwiRGlhbW9uZFwiOlwi4ouEXCIsXCJkaWFtb25kc3VpdFwiOlwi4pmmXCIsXCJkaWFtc1wiOlwi4pmmXCIsXCJkaWVcIjpcIsKoXCIsXCJEaWZmZXJlbnRpYWxEXCI6XCLihYZcIixcImRpZ2FtbWFcIjpcIs+dXCIsXCJkaXNpblwiOlwi4ouyXCIsXCJkaXZcIjpcIsO3XCIsXCJkaXZpZGVcIjpcIsO3XCIsXCJkaXZpZGVvbnRpbWVzXCI6XCLii4dcIixcImRpdm9ueFwiOlwi4ouHXCIsXCJESmN5XCI6XCLQglwiLFwiZGpjeVwiOlwi0ZJcIixcImRsY29yblwiOlwi4oyeXCIsXCJkbGNyb3BcIjpcIuKMjVwiLFwiZG9sbGFyXCI6XCIkXCIsXCJEb3BmXCI6XCLwnZS7XCIsXCJkb3BmXCI6XCLwnZWVXCIsXCJEb3RcIjpcIsKoXCIsXCJkb3RcIjpcIsuZXCIsXCJEb3REb3RcIjpcIuKDnFwiLFwiZG90ZXFcIjpcIuKJkFwiLFwiZG90ZXFkb3RcIjpcIuKJkVwiLFwiRG90RXF1YWxcIjpcIuKJkFwiLFwiZG90bWludXNcIjpcIuKIuFwiLFwiZG90cGx1c1wiOlwi4oiUXCIsXCJkb3RzcXVhcmVcIjpcIuKKoVwiLFwiZG91YmxlYmFyd2VkZ2VcIjpcIuKMhlwiLFwiRG91YmxlQ29udG91ckludGVncmFsXCI6XCLiiK9cIixcIkRvdWJsZURvdFwiOlwiwqhcIixcIkRvdWJsZURvd25BcnJvd1wiOlwi4oeTXCIsXCJEb3VibGVMZWZ0QXJyb3dcIjpcIuKHkFwiLFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjpcIuKHlFwiLFwiRG91YmxlTGVmdFRlZVwiOlwi4qukXCIsXCJEb3VibGVMb25nTGVmdEFycm93XCI6XCLin7hcIixcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+6XCIsXCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOlwi4p+5XCIsXCJEb3VibGVSaWdodEFycm93XCI6XCLih5JcIixcIkRvdWJsZVJpZ2h0VGVlXCI6XCLiiqhcIixcIkRvdWJsZVVwQXJyb3dcIjpcIuKHkVwiLFwiRG91YmxlVXBEb3duQXJyb3dcIjpcIuKHlVwiLFwiRG91YmxlVmVydGljYWxCYXJcIjpcIuKIpVwiLFwiRG93bkFycm93QmFyXCI6XCLipJNcIixcImRvd25hcnJvd1wiOlwi4oaTXCIsXCJEb3duQXJyb3dcIjpcIuKGk1wiLFwiRG93bmFycm93XCI6XCLih5NcIixcIkRvd25BcnJvd1VwQXJyb3dcIjpcIuKHtVwiLFwiRG93bkJyZXZlXCI6XCLMkVwiLFwiZG93bmRvd25hcnJvd3NcIjpcIuKHilwiLFwiZG93bmhhcnBvb25sZWZ0XCI6XCLih4NcIixcImRvd25oYXJwb29ucmlnaHRcIjpcIuKHglwiLFwiRG93bkxlZnRSaWdodFZlY3RvclwiOlwi4qWQXCIsXCJEb3duTGVmdFRlZVZlY3RvclwiOlwi4qWeXCIsXCJEb3duTGVmdFZlY3RvckJhclwiOlwi4qWWXCIsXCJEb3duTGVmdFZlY3RvclwiOlwi4oa9XCIsXCJEb3duUmlnaHRUZWVWZWN0b3JcIjpcIuKln1wiLFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6XCLipZdcIixcIkRvd25SaWdodFZlY3RvclwiOlwi4oeBXCIsXCJEb3duVGVlQXJyb3dcIjpcIuKGp1wiLFwiRG93blRlZVwiOlwi4oqkXCIsXCJkcmJrYXJvd1wiOlwi4qSQXCIsXCJkcmNvcm5cIjpcIuKMn1wiLFwiZHJjcm9wXCI6XCLijIxcIixcIkRzY3JcIjpcIvCdkp9cIixcImRzY3JcIjpcIvCdkrlcIixcIkRTY3lcIjpcItCFXCIsXCJkc2N5XCI6XCLRlVwiLFwiZHNvbFwiOlwi4qe2XCIsXCJEc3Ryb2tcIjpcIsSQXCIsXCJkc3Ryb2tcIjpcIsSRXCIsXCJkdGRvdFwiOlwi4ouxXCIsXCJkdHJpXCI6XCLilr9cIixcImR0cmlmXCI6XCLilr5cIixcImR1YXJyXCI6XCLih7VcIixcImR1aGFyXCI6XCLipa9cIixcImR3YW5nbGVcIjpcIuKmplwiLFwiRFpjeVwiOlwi0I9cIixcImR6Y3lcIjpcItGfXCIsXCJkemlncmFyclwiOlwi4p+/XCIsXCJFYWN1dGVcIjpcIsOJXCIsXCJlYWN1dGVcIjpcIsOpXCIsXCJlYXN0ZXJcIjpcIuKprlwiLFwiRWNhcm9uXCI6XCLEmlwiLFwiZWNhcm9uXCI6XCLEm1wiLFwiRWNpcmNcIjpcIsOKXCIsXCJlY2lyY1wiOlwiw6pcIixcImVjaXJcIjpcIuKJllwiLFwiZWNvbG9uXCI6XCLiiZVcIixcIkVjeVwiOlwi0K1cIixcImVjeVwiOlwi0Y1cIixcImVERG90XCI6XCLiqbdcIixcIkVkb3RcIjpcIsSWXCIsXCJlZG90XCI6XCLEl1wiLFwiZURvdFwiOlwi4omRXCIsXCJlZVwiOlwi4oWHXCIsXCJlZkRvdFwiOlwi4omSXCIsXCJFZnJcIjpcIvCdlIhcIixcImVmclwiOlwi8J2UolwiLFwiZWdcIjpcIuKqmlwiLFwiRWdyYXZlXCI6XCLDiFwiLFwiZWdyYXZlXCI6XCLDqFwiLFwiZWdzXCI6XCLiqpZcIixcImVnc2RvdFwiOlwi4qqYXCIsXCJlbFwiOlwi4qqZXCIsXCJFbGVtZW50XCI6XCLiiIhcIixcImVsaW50ZXJzXCI6XCLij6dcIixcImVsbFwiOlwi4oSTXCIsXCJlbHNcIjpcIuKqlVwiLFwiZWxzZG90XCI6XCLiqpdcIixcIkVtYWNyXCI6XCLEklwiLFwiZW1hY3JcIjpcIsSTXCIsXCJlbXB0eVwiOlwi4oiFXCIsXCJlbXB0eXNldFwiOlwi4oiFXCIsXCJFbXB0eVNtYWxsU3F1YXJlXCI6XCLil7tcIixcImVtcHR5dlwiOlwi4oiFXCIsXCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOlwi4parXCIsXCJlbXNwMTNcIjpcIuKAhFwiLFwiZW1zcDE0XCI6XCLigIVcIixcImVtc3BcIjpcIuKAg1wiLFwiRU5HXCI6XCLFilwiLFwiZW5nXCI6XCLFi1wiLFwiZW5zcFwiOlwi4oCCXCIsXCJFb2dvblwiOlwixJhcIixcImVvZ29uXCI6XCLEmVwiLFwiRW9wZlwiOlwi8J2UvFwiLFwiZW9wZlwiOlwi8J2VllwiLFwiZXBhclwiOlwi4ouVXCIsXCJlcGFyc2xcIjpcIuKno1wiLFwiZXBsdXNcIjpcIuKpsVwiLFwiZXBzaVwiOlwizrVcIixcIkVwc2lsb25cIjpcIs6VXCIsXCJlcHNpbG9uXCI6XCLOtVwiLFwiZXBzaXZcIjpcIs+1XCIsXCJlcWNpcmNcIjpcIuKJllwiLFwiZXFjb2xvblwiOlwi4omVXCIsXCJlcXNpbVwiOlwi4omCXCIsXCJlcXNsYW50Z3RyXCI6XCLiqpZcIixcImVxc2xhbnRsZXNzXCI6XCLiqpVcIixcIkVxdWFsXCI6XCLiqbVcIixcImVxdWFsc1wiOlwiPVwiLFwiRXF1YWxUaWxkZVwiOlwi4omCXCIsXCJlcXVlc3RcIjpcIuKJn1wiLFwiRXF1aWxpYnJpdW1cIjpcIuKHjFwiLFwiZXF1aXZcIjpcIuKJoVwiLFwiZXF1aXZERFwiOlwi4qm4XCIsXCJlcXZwYXJzbFwiOlwi4qelXCIsXCJlcmFyclwiOlwi4qWxXCIsXCJlckRvdFwiOlwi4omTXCIsXCJlc2NyXCI6XCLihK9cIixcIkVzY3JcIjpcIuKEsFwiLFwiZXNkb3RcIjpcIuKJkFwiLFwiRXNpbVwiOlwi4qmzXCIsXCJlc2ltXCI6XCLiiYJcIixcIkV0YVwiOlwizpdcIixcImV0YVwiOlwizrdcIixcIkVUSFwiOlwiw5BcIixcImV0aFwiOlwiw7BcIixcIkV1bWxcIjpcIsOLXCIsXCJldW1sXCI6XCLDq1wiLFwiZXVyb1wiOlwi4oKsXCIsXCJleGNsXCI6XCIhXCIsXCJleGlzdFwiOlwi4oiDXCIsXCJFeGlzdHNcIjpcIuKIg1wiLFwiZXhwZWN0YXRpb25cIjpcIuKEsFwiLFwiZXhwb25lbnRpYWxlXCI6XCLihYdcIixcIkV4cG9uZW50aWFsRVwiOlwi4oWHXCIsXCJmYWxsaW5nZG90c2VxXCI6XCLiiZJcIixcIkZjeVwiOlwi0KRcIixcImZjeVwiOlwi0YRcIixcImZlbWFsZVwiOlwi4pmAXCIsXCJmZmlsaWdcIjpcIu+sg1wiLFwiZmZsaWdcIjpcIu+sgFwiLFwiZmZsbGlnXCI6XCLvrIRcIixcIkZmclwiOlwi8J2UiVwiLFwiZmZyXCI6XCLwnZSjXCIsXCJmaWxpZ1wiOlwi76yBXCIsXCJGaWxsZWRTbWFsbFNxdWFyZVwiOlwi4pe8XCIsXCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjpcIuKWqlwiLFwiZmpsaWdcIjpcImZqXCIsXCJmbGF0XCI6XCLima1cIixcImZsbGlnXCI6XCLvrIJcIixcImZsdG5zXCI6XCLilrFcIixcImZub2ZcIjpcIsaSXCIsXCJGb3BmXCI6XCLwnZS9XCIsXCJmb3BmXCI6XCLwnZWXXCIsXCJmb3JhbGxcIjpcIuKIgFwiLFwiRm9yQWxsXCI6XCLiiIBcIixcImZvcmtcIjpcIuKLlFwiLFwiZm9ya3ZcIjpcIuKrmVwiLFwiRm91cmllcnRyZlwiOlwi4oSxXCIsXCJmcGFydGludFwiOlwi4qiNXCIsXCJmcmFjMTJcIjpcIsK9XCIsXCJmcmFjMTNcIjpcIuKFk1wiLFwiZnJhYzE0XCI6XCLCvFwiLFwiZnJhYzE1XCI6XCLihZVcIixcImZyYWMxNlwiOlwi4oWZXCIsXCJmcmFjMThcIjpcIuKFm1wiLFwiZnJhYzIzXCI6XCLihZRcIixcImZyYWMyNVwiOlwi4oWWXCIsXCJmcmFjMzRcIjpcIsK+XCIsXCJmcmFjMzVcIjpcIuKFl1wiLFwiZnJhYzM4XCI6XCLihZxcIixcImZyYWM0NVwiOlwi4oWYXCIsXCJmcmFjNTZcIjpcIuKFmlwiLFwiZnJhYzU4XCI6XCLihZ1cIixcImZyYWM3OFwiOlwi4oWeXCIsXCJmcmFzbFwiOlwi4oGEXCIsXCJmcm93blwiOlwi4oyiXCIsXCJmc2NyXCI6XCLwnZK7XCIsXCJGc2NyXCI6XCLihLFcIixcImdhY3V0ZVwiOlwix7VcIixcIkdhbW1hXCI6XCLOk1wiLFwiZ2FtbWFcIjpcIs6zXCIsXCJHYW1tYWRcIjpcIs+cXCIsXCJnYW1tYWRcIjpcIs+dXCIsXCJnYXBcIjpcIuKqhlwiLFwiR2JyZXZlXCI6XCLEnlwiLFwiZ2JyZXZlXCI6XCLEn1wiLFwiR2NlZGlsXCI6XCLEolwiLFwiR2NpcmNcIjpcIsScXCIsXCJnY2lyY1wiOlwixJ1cIixcIkdjeVwiOlwi0JNcIixcImdjeVwiOlwi0LNcIixcIkdkb3RcIjpcIsSgXCIsXCJnZG90XCI6XCLEoVwiLFwiZ2VcIjpcIuKJpVwiLFwiZ0VcIjpcIuKJp1wiLFwiZ0VsXCI6XCLiqoxcIixcImdlbFwiOlwi4oubXCIsXCJnZXFcIjpcIuKJpVwiLFwiZ2VxcVwiOlwi4omnXCIsXCJnZXFzbGFudFwiOlwi4qm+XCIsXCJnZXNjY1wiOlwi4qqpXCIsXCJnZXNcIjpcIuKpvlwiLFwiZ2VzZG90XCI6XCLiqoBcIixcImdlc2RvdG9cIjpcIuKqglwiLFwiZ2VzZG90b2xcIjpcIuKqhFwiLFwiZ2VzbFwiOlwi4oub77iAXCIsXCJnZXNsZXNcIjpcIuKqlFwiLFwiR2ZyXCI6XCLwnZSKXCIsXCJnZnJcIjpcIvCdlKRcIixcImdnXCI6XCLiiatcIixcIkdnXCI6XCLii5lcIixcImdnZ1wiOlwi4ouZXCIsXCJnaW1lbFwiOlwi4oS3XCIsXCJHSmN5XCI6XCLQg1wiLFwiZ2pjeVwiOlwi0ZNcIixcImdsYVwiOlwi4qqlXCIsXCJnbFwiOlwi4om3XCIsXCJnbEVcIjpcIuKqklwiLFwiZ2xqXCI6XCLiqqRcIixcImduYXBcIjpcIuKqilwiLFwiZ25hcHByb3hcIjpcIuKqilwiLFwiZ25lXCI6XCLiqohcIixcImduRVwiOlwi4ompXCIsXCJnbmVxXCI6XCLiqohcIixcImduZXFxXCI6XCLiialcIixcImduc2ltXCI6XCLii6dcIixcIkdvcGZcIjpcIvCdlL5cIixcImdvcGZcIjpcIvCdlZhcIixcImdyYXZlXCI6XCJgXCIsXCJHcmVhdGVyRXF1YWxcIjpcIuKJpVwiLFwiR3JlYXRlckVxdWFsTGVzc1wiOlwi4oubXCIsXCJHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiadcIixcIkdyZWF0ZXJHcmVhdGVyXCI6XCLiqqJcIixcIkdyZWF0ZXJMZXNzXCI6XCLiibdcIixcIkdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb5cIixcIkdyZWF0ZXJUaWxkZVwiOlwi4omzXCIsXCJHc2NyXCI6XCLwnZKiXCIsXCJnc2NyXCI6XCLihIpcIixcImdzaW1cIjpcIuKJs1wiLFwiZ3NpbWVcIjpcIuKqjlwiLFwiZ3NpbWxcIjpcIuKqkFwiLFwiZ3RjY1wiOlwi4qqnXCIsXCJndGNpclwiOlwi4qm6XCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIkd0XCI6XCLiiatcIixcImd0ZG90XCI6XCLii5dcIixcImd0bFBhclwiOlwi4qaVXCIsXCJndHF1ZXN0XCI6XCLiqbxcIixcImd0cmFwcHJveFwiOlwi4qqGXCIsXCJndHJhcnJcIjpcIuKluFwiLFwiZ3RyZG90XCI6XCLii5dcIixcImd0cmVxbGVzc1wiOlwi4oubXCIsXCJndHJlcXFsZXNzXCI6XCLiqoxcIixcImd0cmxlc3NcIjpcIuKJt1wiLFwiZ3Ryc2ltXCI6XCLiibNcIixcImd2ZXJ0bmVxcVwiOlwi4omp77iAXCIsXCJndm5FXCI6XCLiianvuIBcIixcIkhhY2VrXCI6XCLLh1wiLFwiaGFpcnNwXCI6XCLigIpcIixcImhhbGZcIjpcIsK9XCIsXCJoYW1pbHRcIjpcIuKEi1wiLFwiSEFSRGN5XCI6XCLQqlwiLFwiaGFyZGN5XCI6XCLRilwiLFwiaGFycmNpclwiOlwi4qWIXCIsXCJoYXJyXCI6XCLihpRcIixcImhBcnJcIjpcIuKHlFwiLFwiaGFycndcIjpcIuKGrVwiLFwiSGF0XCI6XCJeXCIsXCJoYmFyXCI6XCLihI9cIixcIkhjaXJjXCI6XCLEpFwiLFwiaGNpcmNcIjpcIsSlXCIsXCJoZWFydHNcIjpcIuKZpVwiLFwiaGVhcnRzdWl0XCI6XCLimaVcIixcImhlbGxpcFwiOlwi4oCmXCIsXCJoZXJjb25cIjpcIuKKuVwiLFwiaGZyXCI6XCLwnZSlXCIsXCJIZnJcIjpcIuKEjFwiLFwiSGlsYmVydFNwYWNlXCI6XCLihItcIixcImhrc2Vhcm93XCI6XCLipKVcIixcImhrc3dhcm93XCI6XCLipKZcIixcImhvYXJyXCI6XCLih79cIixcImhvbXRodFwiOlwi4oi7XCIsXCJob29rbGVmdGFycm93XCI6XCLihqlcIixcImhvb2tyaWdodGFycm93XCI6XCLihqpcIixcImhvcGZcIjpcIvCdlZlcIixcIkhvcGZcIjpcIuKEjVwiLFwiaG9yYmFyXCI6XCLigJVcIixcIkhvcml6b250YWxMaW5lXCI6XCLilIBcIixcImhzY3JcIjpcIvCdkr1cIixcIkhzY3JcIjpcIuKEi1wiLFwiaHNsYXNoXCI6XCLihI9cIixcIkhzdHJva1wiOlwixKZcIixcImhzdHJva1wiOlwixKdcIixcIkh1bXBEb3duSHVtcFwiOlwi4omOXCIsXCJIdW1wRXF1YWxcIjpcIuKJj1wiLFwiaHlidWxsXCI6XCLigYNcIixcImh5cGhlblwiOlwi4oCQXCIsXCJJYWN1dGVcIjpcIsONXCIsXCJpYWN1dGVcIjpcIsOtXCIsXCJpY1wiOlwi4oGjXCIsXCJJY2lyY1wiOlwiw45cIixcImljaXJjXCI6XCLDrlwiLFwiSWN5XCI6XCLQmFwiLFwiaWN5XCI6XCLQuFwiLFwiSWRvdFwiOlwixLBcIixcIklFY3lcIjpcItCVXCIsXCJpZWN5XCI6XCLQtVwiLFwiaWV4Y2xcIjpcIsKhXCIsXCJpZmZcIjpcIuKHlFwiLFwiaWZyXCI6XCLwnZSmXCIsXCJJZnJcIjpcIuKEkVwiLFwiSWdyYXZlXCI6XCLDjFwiLFwiaWdyYXZlXCI6XCLDrFwiLFwiaWlcIjpcIuKFiFwiLFwiaWlpaW50XCI6XCLiqIxcIixcImlpaW50XCI6XCLiiK1cIixcImlpbmZpblwiOlwi4qecXCIsXCJpaW90YVwiOlwi4oSpXCIsXCJJSmxpZ1wiOlwixLJcIixcImlqbGlnXCI6XCLEs1wiLFwiSW1hY3JcIjpcIsSqXCIsXCJpbWFjclwiOlwixKtcIixcImltYWdlXCI6XCLihJFcIixcIkltYWdpbmFyeUlcIjpcIuKFiFwiLFwiaW1hZ2xpbmVcIjpcIuKEkFwiLFwiaW1hZ3BhcnRcIjpcIuKEkVwiLFwiaW1hdGhcIjpcIsSxXCIsXCJJbVwiOlwi4oSRXCIsXCJpbW9mXCI6XCLiirdcIixcImltcGVkXCI6XCLGtVwiLFwiSW1wbGllc1wiOlwi4oeSXCIsXCJpbmNhcmVcIjpcIuKEhVwiLFwiaW5cIjpcIuKIiFwiLFwiaW5maW5cIjpcIuKInlwiLFwiaW5maW50aWVcIjpcIuKnnVwiLFwiaW5vZG90XCI6XCLEsVwiLFwiaW50Y2FsXCI6XCLiirpcIixcImludFwiOlwi4oirXCIsXCJJbnRcIjpcIuKIrFwiLFwiaW50ZWdlcnNcIjpcIuKEpFwiLFwiSW50ZWdyYWxcIjpcIuKIq1wiLFwiaW50ZXJjYWxcIjpcIuKKulwiLFwiSW50ZXJzZWN0aW9uXCI6XCLii4JcIixcImludGxhcmhrXCI6XCLiqJdcIixcImludHByb2RcIjpcIuKovFwiLFwiSW52aXNpYmxlQ29tbWFcIjpcIuKBo1wiLFwiSW52aXNpYmxlVGltZXNcIjpcIuKBolwiLFwiSU9jeVwiOlwi0IFcIixcImlvY3lcIjpcItGRXCIsXCJJb2dvblwiOlwixK5cIixcImlvZ29uXCI6XCLEr1wiLFwiSW9wZlwiOlwi8J2VgFwiLFwiaW9wZlwiOlwi8J2VmlwiLFwiSW90YVwiOlwizplcIixcImlvdGFcIjpcIs65XCIsXCJpcHJvZFwiOlwi4qi8XCIsXCJpcXVlc3RcIjpcIsK/XCIsXCJpc2NyXCI6XCLwnZK+XCIsXCJJc2NyXCI6XCLihJBcIixcImlzaW5cIjpcIuKIiFwiLFwiaXNpbmRvdFwiOlwi4ou1XCIsXCJpc2luRVwiOlwi4ou5XCIsXCJpc2luc1wiOlwi4ou0XCIsXCJpc2luc3ZcIjpcIuKLs1wiLFwiaXNpbnZcIjpcIuKIiFwiLFwiaXRcIjpcIuKBolwiLFwiSXRpbGRlXCI6XCLEqFwiLFwiaXRpbGRlXCI6XCLEqVwiLFwiSXVrY3lcIjpcItCGXCIsXCJpdWtjeVwiOlwi0ZZcIixcIkl1bWxcIjpcIsOPXCIsXCJpdW1sXCI6XCLDr1wiLFwiSmNpcmNcIjpcIsS0XCIsXCJqY2lyY1wiOlwixLVcIixcIkpjeVwiOlwi0JlcIixcImpjeVwiOlwi0LlcIixcIkpmclwiOlwi8J2UjVwiLFwiamZyXCI6XCLwnZSnXCIsXCJqbWF0aFwiOlwiyLdcIixcIkpvcGZcIjpcIvCdlYFcIixcImpvcGZcIjpcIvCdlZtcIixcIkpzY3JcIjpcIvCdkqVcIixcImpzY3JcIjpcIvCdkr9cIixcIkpzZXJjeVwiOlwi0IhcIixcImpzZXJjeVwiOlwi0ZhcIixcIkp1a2N5XCI6XCLQhFwiLFwianVrY3lcIjpcItGUXCIsXCJLYXBwYVwiOlwizppcIixcImthcHBhXCI6XCLOulwiLFwia2FwcGF2XCI6XCLPsFwiLFwiS2NlZGlsXCI6XCLEtlwiLFwia2NlZGlsXCI6XCLEt1wiLFwiS2N5XCI6XCLQmlwiLFwia2N5XCI6XCLQulwiLFwiS2ZyXCI6XCLwnZSOXCIsXCJrZnJcIjpcIvCdlKhcIixcImtncmVlblwiOlwixLhcIixcIktIY3lcIjpcItClXCIsXCJraGN5XCI6XCLRhVwiLFwiS0pjeVwiOlwi0IxcIixcImtqY3lcIjpcItGcXCIsXCJLb3BmXCI6XCLwnZWCXCIsXCJrb3BmXCI6XCLwnZWcXCIsXCJLc2NyXCI6XCLwnZKmXCIsXCJrc2NyXCI6XCLwnZOAXCIsXCJsQWFyclwiOlwi4oeaXCIsXCJMYWN1dGVcIjpcIsS5XCIsXCJsYWN1dGVcIjpcIsS6XCIsXCJsYWVtcHR5dlwiOlwi4qa0XCIsXCJsYWdyYW5cIjpcIuKEklwiLFwiTGFtYmRhXCI6XCLOm1wiLFwibGFtYmRhXCI6XCLOu1wiLFwibGFuZ1wiOlwi4p+oXCIsXCJMYW5nXCI6XCLin6pcIixcImxhbmdkXCI6XCLippFcIixcImxhbmdsZVwiOlwi4p+oXCIsXCJsYXBcIjpcIuKqhVwiLFwiTGFwbGFjZXRyZlwiOlwi4oSSXCIsXCJsYXF1b1wiOlwiwqtcIixcImxhcnJiXCI6XCLih6RcIixcImxhcnJiZnNcIjpcIuKkn1wiLFwibGFyclwiOlwi4oaQXCIsXCJMYXJyXCI6XCLihp5cIixcImxBcnJcIjpcIuKHkFwiLFwibGFycmZzXCI6XCLipJ1cIixcImxhcnJoa1wiOlwi4oapXCIsXCJsYXJybHBcIjpcIuKGq1wiLFwibGFycnBsXCI6XCLipLlcIixcImxhcnJzaW1cIjpcIuKls1wiLFwibGFycnRsXCI6XCLihqJcIixcImxhdGFpbFwiOlwi4qSZXCIsXCJsQXRhaWxcIjpcIuKkm1wiLFwibGF0XCI6XCLiqqtcIixcImxhdGVcIjpcIuKqrVwiLFwibGF0ZXNcIjpcIuKqre+4gFwiLFwibGJhcnJcIjpcIuKkjFwiLFwibEJhcnJcIjpcIuKkjlwiLFwibGJicmtcIjpcIuKdslwiLFwibGJyYWNlXCI6XCJ7XCIsXCJsYnJhY2tcIjpcIltcIixcImxicmtlXCI6XCLipotcIixcImxicmtzbGRcIjpcIuKmj1wiLFwibGJya3NsdVwiOlwi4qaNXCIsXCJMY2Fyb25cIjpcIsS9XCIsXCJsY2Fyb25cIjpcIsS+XCIsXCJMY2VkaWxcIjpcIsS7XCIsXCJsY2VkaWxcIjpcIsS8XCIsXCJsY2VpbFwiOlwi4oyIXCIsXCJsY3ViXCI6XCJ7XCIsXCJMY3lcIjpcItCbXCIsXCJsY3lcIjpcItC7XCIsXCJsZGNhXCI6XCLipLZcIixcImxkcXVvXCI6XCLigJxcIixcImxkcXVvclwiOlwi4oCeXCIsXCJsZHJkaGFyXCI6XCLipadcIixcImxkcnVzaGFyXCI6XCLipYtcIixcImxkc2hcIjpcIuKGslwiLFwibGVcIjpcIuKJpFwiLFwibEVcIjpcIuKJplwiLFwiTGVmdEFuZ2xlQnJhY2tldFwiOlwi4p+oXCIsXCJMZWZ0QXJyb3dCYXJcIjpcIuKHpFwiLFwibGVmdGFycm93XCI6XCLihpBcIixcIkxlZnRBcnJvd1wiOlwi4oaQXCIsXCJMZWZ0YXJyb3dcIjpcIuKHkFwiLFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOlwi4oeGXCIsXCJsZWZ0YXJyb3d0YWlsXCI6XCLihqJcIixcIkxlZnRDZWlsaW5nXCI6XCLijIhcIixcIkxlZnREb3VibGVCcmFja2V0XCI6XCLin6ZcIixcIkxlZnREb3duVGVlVmVjdG9yXCI6XCLipaFcIixcIkxlZnREb3duVmVjdG9yQmFyXCI6XCLipZlcIixcIkxlZnREb3duVmVjdG9yXCI6XCLih4NcIixcIkxlZnRGbG9vclwiOlwi4oyKXCIsXCJsZWZ0aGFycG9vbmRvd25cIjpcIuKGvVwiLFwibGVmdGhhcnBvb251cFwiOlwi4oa8XCIsXCJsZWZ0bGVmdGFycm93c1wiOlwi4oeHXCIsXCJsZWZ0cmlnaHRhcnJvd1wiOlwi4oaUXCIsXCJMZWZ0UmlnaHRBcnJvd1wiOlwi4oaUXCIsXCJMZWZ0cmlnaHRhcnJvd1wiOlwi4oeUXCIsXCJsZWZ0cmlnaHRhcnJvd3NcIjpcIuKHhlwiLFwibGVmdHJpZ2h0aGFycG9vbnNcIjpcIuKHi1wiLFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOlwi4oatXCIsXCJMZWZ0UmlnaHRWZWN0b3JcIjpcIuKljlwiLFwiTGVmdFRlZUFycm93XCI6XCLihqRcIixcIkxlZnRUZWVcIjpcIuKKo1wiLFwiTGVmdFRlZVZlY3RvclwiOlwi4qWaXCIsXCJsZWZ0dGhyZWV0aW1lc1wiOlwi4ouLXCIsXCJMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj1wiLFwiTGVmdFRyaWFuZ2xlXCI6XCLiirJcIixcIkxlZnRUcmlhbmdsZUVxdWFsXCI6XCLiirRcIixcIkxlZnRVcERvd25WZWN0b3JcIjpcIuKlkVwiLFwiTGVmdFVwVGVlVmVjdG9yXCI6XCLipaBcIixcIkxlZnRVcFZlY3RvckJhclwiOlwi4qWYXCIsXCJMZWZ0VXBWZWN0b3JcIjpcIuKGv1wiLFwiTGVmdFZlY3RvckJhclwiOlwi4qWSXCIsXCJMZWZ0VmVjdG9yXCI6XCLihrxcIixcImxFZ1wiOlwi4qqLXCIsXCJsZWdcIjpcIuKLmlwiLFwibGVxXCI6XCLiiaRcIixcImxlcXFcIjpcIuKJplwiLFwibGVxc2xhbnRcIjpcIuKpvVwiLFwibGVzY2NcIjpcIuKqqFwiLFwibGVzXCI6XCLiqb1cIixcImxlc2RvdFwiOlwi4qm/XCIsXCJsZXNkb3RvXCI6XCLiqoFcIixcImxlc2RvdG9yXCI6XCLiqoNcIixcImxlc2dcIjpcIuKLmu+4gFwiLFwibGVzZ2VzXCI6XCLiqpNcIixcImxlc3NhcHByb3hcIjpcIuKqhVwiLFwibGVzc2RvdFwiOlwi4ouWXCIsXCJsZXNzZXFndHJcIjpcIuKLmlwiLFwibGVzc2VxcWd0clwiOlwi4qqLXCIsXCJMZXNzRXF1YWxHcmVhdGVyXCI6XCLii5pcIixcIkxlc3NGdWxsRXF1YWxcIjpcIuKJplwiLFwiTGVzc0dyZWF0ZXJcIjpcIuKJtlwiLFwibGVzc2d0clwiOlwi4om2XCIsXCJMZXNzTGVzc1wiOlwi4qqhXCIsXCJsZXNzc2ltXCI6XCLiibJcIixcIkxlc3NTbGFudEVxdWFsXCI6XCLiqb1cIixcIkxlc3NUaWxkZVwiOlwi4omyXCIsXCJsZmlzaHRcIjpcIuKlvFwiLFwibGZsb29yXCI6XCLijIpcIixcIkxmclwiOlwi8J2Uj1wiLFwibGZyXCI6XCLwnZSpXCIsXCJsZ1wiOlwi4om2XCIsXCJsZ0VcIjpcIuKqkVwiLFwibEhhclwiOlwi4qWiXCIsXCJsaGFyZFwiOlwi4oa9XCIsXCJsaGFydVwiOlwi4oa8XCIsXCJsaGFydWxcIjpcIuKlqlwiLFwibGhibGtcIjpcIuKWhFwiLFwiTEpjeVwiOlwi0IlcIixcImxqY3lcIjpcItGZXCIsXCJsbGFyclwiOlwi4oeHXCIsXCJsbFwiOlwi4omqXCIsXCJMbFwiOlwi4ouYXCIsXCJsbGNvcm5lclwiOlwi4oyeXCIsXCJMbGVmdGFycm93XCI6XCLih5pcIixcImxsaGFyZFwiOlwi4qWrXCIsXCJsbHRyaVwiOlwi4pe6XCIsXCJMbWlkb3RcIjpcIsS/XCIsXCJsbWlkb3RcIjpcIsWAXCIsXCJsbW91c3RhY2hlXCI6XCLijrBcIixcImxtb3VzdFwiOlwi4o6wXCIsXCJsbmFwXCI6XCLiqolcIixcImxuYXBwcm94XCI6XCLiqolcIixcImxuZVwiOlwi4qqHXCIsXCJsbkVcIjpcIuKJqFwiLFwibG5lcVwiOlwi4qqHXCIsXCJsbmVxcVwiOlwi4omoXCIsXCJsbnNpbVwiOlwi4oumXCIsXCJsb2FuZ1wiOlwi4p+sXCIsXCJsb2FyclwiOlwi4oe9XCIsXCJsb2Jya1wiOlwi4p+mXCIsXCJsb25nbGVmdGFycm93XCI6XCLin7VcIixcIkxvbmdMZWZ0QXJyb3dcIjpcIuKftVwiLFwiTG9uZ2xlZnRhcnJvd1wiOlwi4p+4XCIsXCJsb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKft1wiLFwiTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7dcIixcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+6XCIsXCJsb25nbWFwc3RvXCI6XCLin7xcIixcImxvbmdyaWdodGFycm93XCI6XCLin7ZcIixcIkxvbmdSaWdodEFycm93XCI6XCLin7ZcIixcIkxvbmdyaWdodGFycm93XCI6XCLin7lcIixcImxvb3BhcnJvd2xlZnRcIjpcIuKGq1wiLFwibG9vcGFycm93cmlnaHRcIjpcIuKGrFwiLFwibG9wYXJcIjpcIuKmhVwiLFwiTG9wZlwiOlwi8J2Vg1wiLFwibG9wZlwiOlwi8J2VnVwiLFwibG9wbHVzXCI6XCLiqK1cIixcImxvdGltZXNcIjpcIuKotFwiLFwibG93YXN0XCI6XCLiiJdcIixcImxvd2JhclwiOlwiX1wiLFwiTG93ZXJMZWZ0QXJyb3dcIjpcIuKGmVwiLFwiTG93ZXJSaWdodEFycm93XCI6XCLihphcIixcImxvelwiOlwi4peKXCIsXCJsb3plbmdlXCI6XCLil4pcIixcImxvemZcIjpcIuKnq1wiLFwibHBhclwiOlwiKFwiLFwibHBhcmx0XCI6XCLippNcIixcImxyYXJyXCI6XCLih4ZcIixcImxyY29ybmVyXCI6XCLijJ9cIixcImxyaGFyXCI6XCLih4tcIixcImxyaGFyZFwiOlwi4qWtXCIsXCJscm1cIjpcIuKAjlwiLFwibHJ0cmlcIjpcIuKKv1wiLFwibHNhcXVvXCI6XCLigLlcIixcImxzY3JcIjpcIvCdk4FcIixcIkxzY3JcIjpcIuKEklwiLFwibHNoXCI6XCLihrBcIixcIkxzaFwiOlwi4oawXCIsXCJsc2ltXCI6XCLiibJcIixcImxzaW1lXCI6XCLiqo1cIixcImxzaW1nXCI6XCLiqo9cIixcImxzcWJcIjpcIltcIixcImxzcXVvXCI6XCLigJhcIixcImxzcXVvclwiOlwi4oCaXCIsXCJMc3Ryb2tcIjpcIsWBXCIsXCJsc3Ryb2tcIjpcIsWCXCIsXCJsdGNjXCI6XCLiqqZcIixcImx0Y2lyXCI6XCLiqblcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwiTHRcIjpcIuKJqlwiLFwibHRkb3RcIjpcIuKLllwiLFwibHRocmVlXCI6XCLii4tcIixcImx0aW1lc1wiOlwi4ouJXCIsXCJsdGxhcnJcIjpcIuKltlwiLFwibHRxdWVzdFwiOlwi4qm7XCIsXCJsdHJpXCI6XCLil4NcIixcImx0cmllXCI6XCLiirRcIixcImx0cmlmXCI6XCLil4JcIixcImx0clBhclwiOlwi4qaWXCIsXCJsdXJkc2hhclwiOlwi4qWKXCIsXCJsdXJ1aGFyXCI6XCLipaZcIixcImx2ZXJ0bmVxcVwiOlwi4omo77iAXCIsXCJsdm5FXCI6XCLiiajvuIBcIixcIm1hY3JcIjpcIsKvXCIsXCJtYWxlXCI6XCLimYJcIixcIm1hbHRcIjpcIuKcoFwiLFwibWFsdGVzZVwiOlwi4pygXCIsXCJNYXBcIjpcIuKkhVwiLFwibWFwXCI6XCLihqZcIixcIm1hcHN0b1wiOlwi4oamXCIsXCJtYXBzdG9kb3duXCI6XCLihqdcIixcIm1hcHN0b2xlZnRcIjpcIuKGpFwiLFwibWFwc3RvdXBcIjpcIuKGpVwiLFwibWFya2VyXCI6XCLilq5cIixcIm1jb21tYVwiOlwi4qipXCIsXCJNY3lcIjpcItCcXCIsXCJtY3lcIjpcItC8XCIsXCJtZGFzaFwiOlwi4oCUXCIsXCJtRERvdFwiOlwi4oi6XCIsXCJtZWFzdXJlZGFuZ2xlXCI6XCLiiKFcIixcIk1lZGl1bVNwYWNlXCI6XCLigZ9cIixcIk1lbGxpbnRyZlwiOlwi4oSzXCIsXCJNZnJcIjpcIvCdlJBcIixcIm1mclwiOlwi8J2UqlwiLFwibWhvXCI6XCLihKdcIixcIm1pY3JvXCI6XCLCtVwiLFwibWlkYXN0XCI6XCIqXCIsXCJtaWRjaXJcIjpcIuKrsFwiLFwibWlkXCI6XCLiiKNcIixcIm1pZGRvdFwiOlwiwrdcIixcIm1pbnVzYlwiOlwi4oqfXCIsXCJtaW51c1wiOlwi4oiSXCIsXCJtaW51c2RcIjpcIuKIuFwiLFwibWludXNkdVwiOlwi4qiqXCIsXCJNaW51c1BsdXNcIjpcIuKIk1wiLFwibWxjcFwiOlwi4qubXCIsXCJtbGRyXCI6XCLigKZcIixcIm1ucGx1c1wiOlwi4oiTXCIsXCJtb2RlbHNcIjpcIuKKp1wiLFwiTW9wZlwiOlwi8J2VhFwiLFwibW9wZlwiOlwi8J2VnlwiLFwibXBcIjpcIuKIk1wiLFwibXNjclwiOlwi8J2TglwiLFwiTXNjclwiOlwi4oSzXCIsXCJtc3Rwb3NcIjpcIuKIvlwiLFwiTXVcIjpcIs6cXCIsXCJtdVwiOlwizrxcIixcIm11bHRpbWFwXCI6XCLiirhcIixcIm11bWFwXCI6XCLiirhcIixcIm5hYmxhXCI6XCLiiIdcIixcIk5hY3V0ZVwiOlwixYNcIixcIm5hY3V0ZVwiOlwixYRcIixcIm5hbmdcIjpcIuKIoOKDklwiLFwibmFwXCI6XCLiiYlcIixcIm5hcEVcIjpcIuKpsMy4XCIsXCJuYXBpZFwiOlwi4omLzLhcIixcIm5hcG9zXCI6XCLFiVwiLFwibmFwcHJveFwiOlwi4omJXCIsXCJuYXR1cmFsXCI6XCLima5cIixcIm5hdHVyYWxzXCI6XCLihJVcIixcIm5hdHVyXCI6XCLima5cIixcIm5ic3BcIjpcIsKgXCIsXCJuYnVtcFwiOlwi4omOzLhcIixcIm5idW1wZVwiOlwi4omPzLhcIixcIm5jYXBcIjpcIuKpg1wiLFwiTmNhcm9uXCI6XCLFh1wiLFwibmNhcm9uXCI6XCLFiFwiLFwiTmNlZGlsXCI6XCLFhVwiLFwibmNlZGlsXCI6XCLFhlwiLFwibmNvbmdcIjpcIuKJh1wiLFwibmNvbmdkb3RcIjpcIuKprcy4XCIsXCJuY3VwXCI6XCLiqYJcIixcIk5jeVwiOlwi0J1cIixcIm5jeVwiOlwi0L1cIixcIm5kYXNoXCI6XCLigJNcIixcIm5lYXJoa1wiOlwi4qSkXCIsXCJuZWFyclwiOlwi4oaXXCIsXCJuZUFyclwiOlwi4oeXXCIsXCJuZWFycm93XCI6XCLihpdcIixcIm5lXCI6XCLiiaBcIixcIm5lZG90XCI6XCLiiZDMuFwiLFwiTmVnYXRpdmVNZWRpdW1TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGluU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlXCI6XCLigItcIixcIm5lcXVpdlwiOlwi4omiXCIsXCJuZXNlYXJcIjpcIuKkqFwiLFwibmVzaW1cIjpcIuKJgsy4XCIsXCJOZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4omrXCIsXCJOZXN0ZWRMZXNzTGVzc1wiOlwi4omqXCIsXCJOZXdMaW5lXCI6XCJcXG5cIixcIm5leGlzdFwiOlwi4oiEXCIsXCJuZXhpc3RzXCI6XCLiiIRcIixcIk5mclwiOlwi8J2UkVwiLFwibmZyXCI6XCLwnZSrXCIsXCJuZ0VcIjpcIuKJp8y4XCIsXCJuZ2VcIjpcIuKJsVwiLFwibmdlcVwiOlwi4omxXCIsXCJuZ2VxcVwiOlwi4omnzLhcIixcIm5nZXFzbGFudFwiOlwi4qm+zLhcIixcIm5nZXNcIjpcIuKpvsy4XCIsXCJuR2dcIjpcIuKLmcy4XCIsXCJuZ3NpbVwiOlwi4om1XCIsXCJuR3RcIjpcIuKJq+KDklwiLFwibmd0XCI6XCLiia9cIixcIm5ndHJcIjpcIuKJr1wiLFwibkd0dlwiOlwi4omrzLhcIixcIm5oYXJyXCI6XCLihq5cIixcIm5oQXJyXCI6XCLih45cIixcIm5ocGFyXCI6XCLiq7JcIixcIm5pXCI6XCLiiItcIixcIm5pc1wiOlwi4ou8XCIsXCJuaXNkXCI6XCLii7pcIixcIm5pdlwiOlwi4oiLXCIsXCJOSmN5XCI6XCLQilwiLFwibmpjeVwiOlwi0ZpcIixcIm5sYXJyXCI6XCLihppcIixcIm5sQXJyXCI6XCLih41cIixcIm5sZHJcIjpcIuKApVwiLFwibmxFXCI6XCLiiabMuFwiLFwibmxlXCI6XCLiibBcIixcIm5sZWZ0YXJyb3dcIjpcIuKGmlwiLFwibkxlZnRhcnJvd1wiOlwi4oeNXCIsXCJubGVmdHJpZ2h0YXJyb3dcIjpcIuKGrlwiLFwibkxlZnRyaWdodGFycm93XCI6XCLih45cIixcIm5sZXFcIjpcIuKJsFwiLFwibmxlcXFcIjpcIuKJpsy4XCIsXCJubGVxc2xhbnRcIjpcIuKpvcy4XCIsXCJubGVzXCI6XCLiqb3MuFwiLFwibmxlc3NcIjpcIuKJrlwiLFwibkxsXCI6XCLii5jMuFwiLFwibmxzaW1cIjpcIuKJtFwiLFwibkx0XCI6XCLiiarig5JcIixcIm5sdFwiOlwi4omuXCIsXCJubHRyaVwiOlwi4ouqXCIsXCJubHRyaWVcIjpcIuKLrFwiLFwibkx0dlwiOlwi4omqzLhcIixcIm5taWRcIjpcIuKIpFwiLFwiTm9CcmVha1wiOlwi4oGgXCIsXCJOb25CcmVha2luZ1NwYWNlXCI6XCLCoFwiLFwibm9wZlwiOlwi8J2Vn1wiLFwiTm9wZlwiOlwi4oSVXCIsXCJOb3RcIjpcIuKrrFwiLFwibm90XCI6XCLCrFwiLFwiTm90Q29uZ3J1ZW50XCI6XCLiiaJcIixcIk5vdEN1cENhcFwiOlwi4omtXCIsXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwi4oimXCIsXCJOb3RFbGVtZW50XCI6XCLiiIlcIixcIk5vdEVxdWFsXCI6XCLiiaBcIixcIk5vdEVxdWFsVGlsZGVcIjpcIuKJgsy4XCIsXCJOb3RFeGlzdHNcIjpcIuKIhFwiLFwiTm90R3JlYXRlclwiOlwi4omvXCIsXCJOb3RHcmVhdGVyRXF1YWxcIjpcIuKJsVwiLFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnzLhcIixcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCLiiavMuFwiLFwiTm90R3JlYXRlckxlc3NcIjpcIuKJuVwiLFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvsy4XCIsXCJOb3RHcmVhdGVyVGlsZGVcIjpcIuKJtVwiLFwiTm90SHVtcERvd25IdW1wXCI6XCLiiY7MuFwiLFwiTm90SHVtcEVxdWFsXCI6XCLiiY/MuFwiLFwibm90aW5cIjpcIuKIiVwiLFwibm90aW5kb3RcIjpcIuKLtcy4XCIsXCJub3RpbkVcIjpcIuKLucy4XCIsXCJub3RpbnZhXCI6XCLiiIlcIixcIm5vdGludmJcIjpcIuKLt1wiLFwibm90aW52Y1wiOlwi4ou2XCIsXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj8y4XCIsXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIuKLqlwiLFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKLrFwiLFwiTm90TGVzc1wiOlwi4omuXCIsXCJOb3RMZXNzRXF1YWxcIjpcIuKJsFwiLFwiTm90TGVzc0dyZWF0ZXJcIjpcIuKJuFwiLFwiTm90TGVzc0xlc3NcIjpcIuKJqsy4XCIsXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwi4qm9zLhcIixcIk5vdExlc3NUaWxkZVwiOlwi4om0XCIsXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4qqizLhcIixcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCLiqqHMuFwiLFwibm90bmlcIjpcIuKIjFwiLFwibm90bml2YVwiOlwi4oiMXCIsXCJub3RuaXZiXCI6XCLii75cIixcIm5vdG5pdmNcIjpcIuKLvVwiLFwiTm90UHJlY2VkZXNcIjpcIuKKgFwiLFwiTm90UHJlY2VkZXNFcXVhbFwiOlwi4qqvzLhcIixcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4ougXCIsXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwi4oiMXCIsXCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5DMuFwiLFwiTm90UmlnaHRUcmlhbmdsZVwiOlwi4ourXCIsXCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKLrVwiLFwiTm90U3F1YXJlU3Vic2V0XCI6XCLiio/MuFwiLFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKLolwiLFwiTm90U3F1YXJlU3VwZXJzZXRcIjpcIuKKkMy4XCIsXCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLii6NcIixcIk5vdFN1YnNldFwiOlwi4oqC4oOSXCIsXCJOb3RTdWJzZXRFcXVhbFwiOlwi4oqIXCIsXCJOb3RTdWNjZWVkc1wiOlwi4oqBXCIsXCJOb3RTdWNjZWVkc0VxdWFsXCI6XCLiqrDMuFwiLFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCLii6FcIixcIk5vdFN1Y2NlZWRzVGlsZGVcIjpcIuKJv8y4XCIsXCJOb3RTdXBlcnNldFwiOlwi4oqD4oOSXCIsXCJOb3RTdXBlcnNldEVxdWFsXCI6XCLiiolcIixcIk5vdFRpbGRlXCI6XCLiiYFcIixcIk5vdFRpbGRlRXF1YWxcIjpcIuKJhFwiLFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIuKJh1wiLFwiTm90VGlsZGVUaWxkZVwiOlwi4omJXCIsXCJOb3RWZXJ0aWNhbEJhclwiOlwi4oikXCIsXCJucGFyYWxsZWxcIjpcIuKIplwiLFwibnBhclwiOlwi4oimXCIsXCJucGFyc2xcIjpcIuKrveKDpVwiLFwibnBhcnRcIjpcIuKIgsy4XCIsXCJucG9saW50XCI6XCLiqJRcIixcIm5wclwiOlwi4oqAXCIsXCJucHJjdWVcIjpcIuKLoFwiLFwibnByZWNcIjpcIuKKgFwiLFwibnByZWNlcVwiOlwi4qqvzLhcIixcIm5wcmVcIjpcIuKqr8y4XCIsXCJucmFycmNcIjpcIuKks8y4XCIsXCJucmFyclwiOlwi4oabXCIsXCJuckFyclwiOlwi4oePXCIsXCJucmFycndcIjpcIuKGncy4XCIsXCJucmlnaHRhcnJvd1wiOlwi4oabXCIsXCJuUmlnaHRhcnJvd1wiOlwi4oePXCIsXCJucnRyaVwiOlwi4ourXCIsXCJucnRyaWVcIjpcIuKLrVwiLFwibnNjXCI6XCLiioFcIixcIm5zY2N1ZVwiOlwi4ouhXCIsXCJuc2NlXCI6XCLiqrDMuFwiLFwiTnNjclwiOlwi8J2SqVwiLFwibnNjclwiOlwi8J2Tg1wiLFwibnNob3J0bWlkXCI6XCLiiKRcIixcIm5zaG9ydHBhcmFsbGVsXCI6XCLiiKZcIixcIm5zaW1cIjpcIuKJgVwiLFwibnNpbWVcIjpcIuKJhFwiLFwibnNpbWVxXCI6XCLiiYRcIixcIm5zbWlkXCI6XCLiiKRcIixcIm5zcGFyXCI6XCLiiKZcIixcIm5zcXN1YmVcIjpcIuKLolwiLFwibnNxc3VwZVwiOlwi4oujXCIsXCJuc3ViXCI6XCLiioRcIixcIm5zdWJFXCI6XCLiq4XMuFwiLFwibnN1YmVcIjpcIuKKiFwiLFwibnN1YnNldFwiOlwi4oqC4oOSXCIsXCJuc3Vic2V0ZXFcIjpcIuKKiFwiLFwibnN1YnNldGVxcVwiOlwi4quFzLhcIixcIm5zdWNjXCI6XCLiioFcIixcIm5zdWNjZXFcIjpcIuKqsMy4XCIsXCJuc3VwXCI6XCLiioVcIixcIm5zdXBFXCI6XCLiq4bMuFwiLFwibnN1cGVcIjpcIuKKiVwiLFwibnN1cHNldFwiOlwi4oqD4oOSXCIsXCJuc3Vwc2V0ZXFcIjpcIuKKiVwiLFwibnN1cHNldGVxcVwiOlwi4quGzLhcIixcIm50Z2xcIjpcIuKJuVwiLFwiTnRpbGRlXCI6XCLDkVwiLFwibnRpbGRlXCI6XCLDsVwiLFwibnRsZ1wiOlwi4om4XCIsXCJudHJpYW5nbGVsZWZ0XCI6XCLii6pcIixcIm50cmlhbmdsZWxlZnRlcVwiOlwi4ousXCIsXCJudHJpYW5nbGVyaWdodFwiOlwi4ourXCIsXCJudHJpYW5nbGVyaWdodGVxXCI6XCLii61cIixcIk51XCI6XCLOnVwiLFwibnVcIjpcIs69XCIsXCJudW1cIjpcIiNcIixcIm51bWVyb1wiOlwi4oSWXCIsXCJudW1zcFwiOlwi4oCHXCIsXCJudmFwXCI6XCLiiY3ig5JcIixcIm52ZGFzaFwiOlwi4oqsXCIsXCJudkRhc2hcIjpcIuKKrVwiLFwiblZkYXNoXCI6XCLiiq5cIixcIm5WRGFzaFwiOlwi4oqvXCIsXCJudmdlXCI6XCLiiaXig5JcIixcIm52Z3RcIjpcIj7ig5JcIixcIm52SGFyclwiOlwi4qSEXCIsXCJudmluZmluXCI6XCLip55cIixcIm52bEFyclwiOlwi4qSCXCIsXCJudmxlXCI6XCLiiaTig5JcIixcIm52bHRcIjpcIjzig5JcIixcIm52bHRyaWVcIjpcIuKKtOKDklwiLFwibnZyQXJyXCI6XCLipINcIixcIm52cnRyaWVcIjpcIuKKteKDklwiLFwibnZzaW1cIjpcIuKIvOKDklwiLFwibndhcmhrXCI6XCLipKNcIixcIm53YXJyXCI6XCLihpZcIixcIm53QXJyXCI6XCLih5ZcIixcIm53YXJyb3dcIjpcIuKGllwiLFwibnduZWFyXCI6XCLipKdcIixcIk9hY3V0ZVwiOlwiw5NcIixcIm9hY3V0ZVwiOlwiw7NcIixcIm9hc3RcIjpcIuKKm1wiLFwiT2NpcmNcIjpcIsOUXCIsXCJvY2lyY1wiOlwiw7RcIixcIm9jaXJcIjpcIuKKmlwiLFwiT2N5XCI6XCLQnlwiLFwib2N5XCI6XCLQvlwiLFwib2Rhc2hcIjpcIuKKnVwiLFwiT2RibGFjXCI6XCLFkFwiLFwib2RibGFjXCI6XCLFkVwiLFwib2RpdlwiOlwi4qi4XCIsXCJvZG90XCI6XCLiiplcIixcIm9kc29sZFwiOlwi4qa8XCIsXCJPRWxpZ1wiOlwixZJcIixcIm9lbGlnXCI6XCLFk1wiLFwib2ZjaXJcIjpcIuKmv1wiLFwiT2ZyXCI6XCLwnZSSXCIsXCJvZnJcIjpcIvCdlKxcIixcIm9nb25cIjpcIsubXCIsXCJPZ3JhdmVcIjpcIsOSXCIsXCJvZ3JhdmVcIjpcIsOyXCIsXCJvZ3RcIjpcIuKngVwiLFwib2hiYXJcIjpcIuKmtVwiLFwib2htXCI6XCLOqVwiLFwib2ludFwiOlwi4oiuXCIsXCJvbGFyclwiOlwi4oa6XCIsXCJvbGNpclwiOlwi4qa+XCIsXCJvbGNyb3NzXCI6XCLiprtcIixcIm9saW5lXCI6XCLigL5cIixcIm9sdFwiOlwi4qeAXCIsXCJPbWFjclwiOlwixYxcIixcIm9tYWNyXCI6XCLFjVwiLFwiT21lZ2FcIjpcIs6pXCIsXCJvbWVnYVwiOlwiz4lcIixcIk9taWNyb25cIjpcIs6fXCIsXCJvbWljcm9uXCI6XCLOv1wiLFwib21pZFwiOlwi4qa2XCIsXCJvbWludXNcIjpcIuKKllwiLFwiT29wZlwiOlwi8J2VhlwiLFwib29wZlwiOlwi8J2VoFwiLFwib3BhclwiOlwi4qa3XCIsXCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCcXCIsXCJPcGVuQ3VybHlRdW90ZVwiOlwi4oCYXCIsXCJvcGVycFwiOlwi4qa5XCIsXCJvcGx1c1wiOlwi4oqVXCIsXCJvcmFyclwiOlwi4oa7XCIsXCJPclwiOlwi4qmUXCIsXCJvclwiOlwi4oioXCIsXCJvcmRcIjpcIuKpnVwiLFwib3JkZXJcIjpcIuKEtFwiLFwib3JkZXJvZlwiOlwi4oS0XCIsXCJvcmRmXCI6XCLCqlwiLFwib3JkbVwiOlwiwrpcIixcIm9yaWdvZlwiOlwi4oq2XCIsXCJvcm9yXCI6XCLiqZZcIixcIm9yc2xvcGVcIjpcIuKpl1wiLFwib3J2XCI6XCLiqZtcIixcIm9TXCI6XCLik4hcIixcIk9zY3JcIjpcIvCdkqpcIixcIm9zY3JcIjpcIuKEtFwiLFwiT3NsYXNoXCI6XCLDmFwiLFwib3NsYXNoXCI6XCLDuFwiLFwib3NvbFwiOlwi4oqYXCIsXCJPdGlsZGVcIjpcIsOVXCIsXCJvdGlsZGVcIjpcIsO1XCIsXCJvdGltZXNhc1wiOlwi4qi2XCIsXCJPdGltZXNcIjpcIuKot1wiLFwib3RpbWVzXCI6XCLiipdcIixcIk91bWxcIjpcIsOWXCIsXCJvdW1sXCI6XCLDtlwiLFwib3ZiYXJcIjpcIuKMvVwiLFwiT3ZlckJhclwiOlwi4oC+XCIsXCJPdmVyQnJhY2VcIjpcIuKPnlwiLFwiT3ZlckJyYWNrZXRcIjpcIuKOtFwiLFwiT3ZlclBhcmVudGhlc2lzXCI6XCLij5xcIixcInBhcmFcIjpcIsK2XCIsXCJwYXJhbGxlbFwiOlwi4oilXCIsXCJwYXJcIjpcIuKIpVwiLFwicGFyc2ltXCI6XCLiq7NcIixcInBhcnNsXCI6XCLiq71cIixcInBhcnRcIjpcIuKIglwiLFwiUGFydGlhbERcIjpcIuKIglwiLFwiUGN5XCI6XCLQn1wiLFwicGN5XCI6XCLQv1wiLFwicGVyY250XCI6XCIlXCIsXCJwZXJpb2RcIjpcIi5cIixcInBlcm1pbFwiOlwi4oCwXCIsXCJwZXJwXCI6XCLiiqVcIixcInBlcnRlbmtcIjpcIuKAsVwiLFwiUGZyXCI6XCLwnZSTXCIsXCJwZnJcIjpcIvCdlK1cIixcIlBoaVwiOlwizqZcIixcInBoaVwiOlwiz4ZcIixcInBoaXZcIjpcIs+VXCIsXCJwaG1tYXRcIjpcIuKEs1wiLFwicGhvbmVcIjpcIuKYjlwiLFwiUGlcIjpcIs6gXCIsXCJwaVwiOlwiz4BcIixcInBpdGNoZm9ya1wiOlwi4ouUXCIsXCJwaXZcIjpcIs+WXCIsXCJwbGFuY2tcIjpcIuKEj1wiLFwicGxhbmNraFwiOlwi4oSOXCIsXCJwbGFua3ZcIjpcIuKEj1wiLFwicGx1c2FjaXJcIjpcIuKoo1wiLFwicGx1c2JcIjpcIuKKnlwiLFwicGx1c2NpclwiOlwi4qiiXCIsXCJwbHVzXCI6XCIrXCIsXCJwbHVzZG9cIjpcIuKIlFwiLFwicGx1c2R1XCI6XCLiqKVcIixcInBsdXNlXCI6XCLiqbJcIixcIlBsdXNNaW51c1wiOlwiwrFcIixcInBsdXNtblwiOlwiwrFcIixcInBsdXNzaW1cIjpcIuKoplwiLFwicGx1c3R3b1wiOlwi4qinXCIsXCJwbVwiOlwiwrFcIixcIlBvaW5jYXJlcGxhbmVcIjpcIuKEjFwiLFwicG9pbnRpbnRcIjpcIuKolVwiLFwicG9wZlwiOlwi8J2VoVwiLFwiUG9wZlwiOlwi4oSZXCIsXCJwb3VuZFwiOlwiwqNcIixcInByYXBcIjpcIuKqt1wiLFwiUHJcIjpcIuKqu1wiLFwicHJcIjpcIuKJulwiLFwicHJjdWVcIjpcIuKJvFwiLFwicHJlY2FwcHJveFwiOlwi4qq3XCIsXCJwcmVjXCI6XCLiibpcIixcInByZWNjdXJseWVxXCI6XCLiibxcIixcIlByZWNlZGVzXCI6XCLiibpcIixcIlByZWNlZGVzRXF1YWxcIjpcIuKqr1wiLFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCLiibxcIixcIlByZWNlZGVzVGlsZGVcIjpcIuKJvlwiLFwicHJlY2VxXCI6XCLiqq9cIixcInByZWNuYXBwcm94XCI6XCLiqrlcIixcInByZWNuZXFxXCI6XCLiqrVcIixcInByZWNuc2ltXCI6XCLii6hcIixcInByZVwiOlwi4qqvXCIsXCJwckVcIjpcIuKqs1wiLFwicHJlY3NpbVwiOlwi4om+XCIsXCJwcmltZVwiOlwi4oCyXCIsXCJQcmltZVwiOlwi4oCzXCIsXCJwcmltZXNcIjpcIuKEmVwiLFwicHJuYXBcIjpcIuKquVwiLFwicHJuRVwiOlwi4qq1XCIsXCJwcm5zaW1cIjpcIuKLqFwiLFwicHJvZFwiOlwi4oiPXCIsXCJQcm9kdWN0XCI6XCLiiI9cIixcInByb2ZhbGFyXCI6XCLijK5cIixcInByb2ZsaW5lXCI6XCLijJJcIixcInByb2ZzdXJmXCI6XCLijJNcIixcInByb3BcIjpcIuKInVwiLFwiUHJvcG9ydGlvbmFsXCI6XCLiiJ1cIixcIlByb3BvcnRpb25cIjpcIuKIt1wiLFwicHJvcHRvXCI6XCLiiJ1cIixcInByc2ltXCI6XCLiib5cIixcInBydXJlbFwiOlwi4oqwXCIsXCJQc2NyXCI6XCLwnZKrXCIsXCJwc2NyXCI6XCLwnZOFXCIsXCJQc2lcIjpcIs6oXCIsXCJwc2lcIjpcIs+IXCIsXCJwdW5jc3BcIjpcIuKAiFwiLFwiUWZyXCI6XCLwnZSUXCIsXCJxZnJcIjpcIvCdlK5cIixcInFpbnRcIjpcIuKojFwiLFwicW9wZlwiOlwi8J2VolwiLFwiUW9wZlwiOlwi4oSaXCIsXCJxcHJpbWVcIjpcIuKBl1wiLFwiUXNjclwiOlwi8J2SrFwiLFwicXNjclwiOlwi8J2ThlwiLFwicXVhdGVybmlvbnNcIjpcIuKEjVwiLFwicXVhdGludFwiOlwi4qiWXCIsXCJxdWVzdFwiOlwiP1wiLFwicXVlc3RlcVwiOlwi4omfXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyQWFyclwiOlwi4oebXCIsXCJyYWNlXCI6XCLiiL3MsVwiLFwiUmFjdXRlXCI6XCLFlFwiLFwicmFjdXRlXCI6XCLFlVwiLFwicmFkaWNcIjpcIuKImlwiLFwicmFlbXB0eXZcIjpcIuKms1wiLFwicmFuZ1wiOlwi4p+pXCIsXCJSYW5nXCI6XCLin6tcIixcInJhbmdkXCI6XCLippJcIixcInJhbmdlXCI6XCLipqVcIixcInJhbmdsZVwiOlwi4p+pXCIsXCJyYXF1b1wiOlwiwrtcIixcInJhcnJhcFwiOlwi4qW1XCIsXCJyYXJyYlwiOlwi4oelXCIsXCJyYXJyYmZzXCI6XCLipKBcIixcInJhcnJjXCI6XCLipLNcIixcInJhcnJcIjpcIuKGklwiLFwiUmFyclwiOlwi4oagXCIsXCJyQXJyXCI6XCLih5JcIixcInJhcnJmc1wiOlwi4qSeXCIsXCJyYXJyaGtcIjpcIuKGqlwiLFwicmFycmxwXCI6XCLihqxcIixcInJhcnJwbFwiOlwi4qWFXCIsXCJyYXJyc2ltXCI6XCLipbRcIixcIlJhcnJ0bFwiOlwi4qSWXCIsXCJyYXJydGxcIjpcIuKGo1wiLFwicmFycndcIjpcIuKGnVwiLFwicmF0YWlsXCI6XCLipJpcIixcInJBdGFpbFwiOlwi4qScXCIsXCJyYXRpb1wiOlwi4oi2XCIsXCJyYXRpb25hbHNcIjpcIuKEmlwiLFwicmJhcnJcIjpcIuKkjVwiLFwickJhcnJcIjpcIuKkj1wiLFwiUkJhcnJcIjpcIuKkkFwiLFwicmJicmtcIjpcIuKds1wiLFwicmJyYWNlXCI6XCJ9XCIsXCJyYnJhY2tcIjpcIl1cIixcInJicmtlXCI6XCLipoxcIixcInJicmtzbGRcIjpcIuKmjlwiLFwicmJya3NsdVwiOlwi4qaQXCIsXCJSY2Fyb25cIjpcIsWYXCIsXCJyY2Fyb25cIjpcIsWZXCIsXCJSY2VkaWxcIjpcIsWWXCIsXCJyY2VkaWxcIjpcIsWXXCIsXCJyY2VpbFwiOlwi4oyJXCIsXCJyY3ViXCI6XCJ9XCIsXCJSY3lcIjpcItCgXCIsXCJyY3lcIjpcItGAXCIsXCJyZGNhXCI6XCLipLdcIixcInJkbGRoYXJcIjpcIuKlqVwiLFwicmRxdW9cIjpcIuKAnVwiLFwicmRxdW9yXCI6XCLigJ1cIixcInJkc2hcIjpcIuKGs1wiLFwicmVhbFwiOlwi4oScXCIsXCJyZWFsaW5lXCI6XCLihJtcIixcInJlYWxwYXJ0XCI6XCLihJxcIixcInJlYWxzXCI6XCLihJ1cIixcIlJlXCI6XCLihJxcIixcInJlY3RcIjpcIuKWrVwiLFwicmVnXCI6XCLCrlwiLFwiUkVHXCI6XCLCrlwiLFwiUmV2ZXJzZUVsZW1lbnRcIjpcIuKIi1wiLFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6XCLih4tcIixcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6XCLipa9cIixcInJmaXNodFwiOlwi4qW9XCIsXCJyZmxvb3JcIjpcIuKMi1wiLFwicmZyXCI6XCLwnZSvXCIsXCJSZnJcIjpcIuKEnFwiLFwickhhclwiOlwi4qWkXCIsXCJyaGFyZFwiOlwi4oeBXCIsXCJyaGFydVwiOlwi4oeAXCIsXCJyaGFydWxcIjpcIuKlrFwiLFwiUmhvXCI6XCLOoVwiLFwicmhvXCI6XCLPgVwiLFwicmhvdlwiOlwiz7FcIixcIlJpZ2h0QW5nbGVCcmFja2V0XCI6XCLin6lcIixcIlJpZ2h0QXJyb3dCYXJcIjpcIuKHpVwiLFwicmlnaHRhcnJvd1wiOlwi4oaSXCIsXCJSaWdodEFycm93XCI6XCLihpJcIixcIlJpZ2h0YXJyb3dcIjpcIuKHklwiLFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOlwi4oeEXCIsXCJyaWdodGFycm93dGFpbFwiOlwi4oajXCIsXCJSaWdodENlaWxpbmdcIjpcIuKMiVwiLFwiUmlnaHREb3VibGVCcmFja2V0XCI6XCLin6dcIixcIlJpZ2h0RG93blRlZVZlY3RvclwiOlwi4qWdXCIsXCJSaWdodERvd25WZWN0b3JCYXJcIjpcIuKllVwiLFwiUmlnaHREb3duVmVjdG9yXCI6XCLih4JcIixcIlJpZ2h0Rmxvb3JcIjpcIuKMi1wiLFwicmlnaHRoYXJwb29uZG93blwiOlwi4oeBXCIsXCJyaWdodGhhcnBvb251cFwiOlwi4oeAXCIsXCJyaWdodGxlZnRhcnJvd3NcIjpcIuKHhFwiLFwicmlnaHRsZWZ0aGFycG9vbnNcIjpcIuKHjFwiLFwicmlnaHRyaWdodGFycm93c1wiOlwi4oeJXCIsXCJyaWdodHNxdWlnYXJyb3dcIjpcIuKGnVwiLFwiUmlnaHRUZWVBcnJvd1wiOlwi4oamXCIsXCJSaWdodFRlZVwiOlwi4oqiXCIsXCJSaWdodFRlZVZlY3RvclwiOlwi4qWbXCIsXCJyaWdodHRocmVldGltZXNcIjpcIuKLjFwiLFwiUmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQXCIsXCJSaWdodFRyaWFuZ2xlXCI6XCLiirNcIixcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4oq1XCIsXCJSaWdodFVwRG93blZlY3RvclwiOlwi4qWPXCIsXCJSaWdodFVwVGVlVmVjdG9yXCI6XCLipZxcIixcIlJpZ2h0VXBWZWN0b3JCYXJcIjpcIuKllFwiLFwiUmlnaHRVcFZlY3RvclwiOlwi4oa+XCIsXCJSaWdodFZlY3RvckJhclwiOlwi4qWTXCIsXCJSaWdodFZlY3RvclwiOlwi4oeAXCIsXCJyaW5nXCI6XCLLmlwiLFwicmlzaW5nZG90c2VxXCI6XCLiiZNcIixcInJsYXJyXCI6XCLih4RcIixcInJsaGFyXCI6XCLih4xcIixcInJsbVwiOlwi4oCPXCIsXCJybW91c3RhY2hlXCI6XCLijrFcIixcInJtb3VzdFwiOlwi4o6xXCIsXCJybm1pZFwiOlwi4quuXCIsXCJyb2FuZ1wiOlwi4p+tXCIsXCJyb2FyclwiOlwi4oe+XCIsXCJyb2Jya1wiOlwi4p+nXCIsXCJyb3BhclwiOlwi4qaGXCIsXCJyb3BmXCI6XCLwnZWjXCIsXCJSb3BmXCI6XCLihJ1cIixcInJvcGx1c1wiOlwi4qiuXCIsXCJyb3RpbWVzXCI6XCLiqLVcIixcIlJvdW5kSW1wbGllc1wiOlwi4qWwXCIsXCJycGFyXCI6XCIpXCIsXCJycGFyZ3RcIjpcIuKmlFwiLFwicnBwb2xpbnRcIjpcIuKoklwiLFwicnJhcnJcIjpcIuKHiVwiLFwiUnJpZ2h0YXJyb3dcIjpcIuKHm1wiLFwicnNhcXVvXCI6XCLigLpcIixcInJzY3JcIjpcIvCdk4dcIixcIlJzY3JcIjpcIuKEm1wiLFwicnNoXCI6XCLihrFcIixcIlJzaFwiOlwi4oaxXCIsXCJyc3FiXCI6XCJdXCIsXCJyc3F1b1wiOlwi4oCZXCIsXCJyc3F1b3JcIjpcIuKAmVwiLFwicnRocmVlXCI6XCLii4xcIixcInJ0aW1lc1wiOlwi4ouKXCIsXCJydHJpXCI6XCLilrlcIixcInJ0cmllXCI6XCLiirVcIixcInJ0cmlmXCI6XCLilrhcIixcInJ0cmlsdHJpXCI6XCLip45cIixcIlJ1bGVEZWxheWVkXCI6XCLip7RcIixcInJ1bHVoYXJcIjpcIuKlqFwiLFwicnhcIjpcIuKEnlwiLFwiU2FjdXRlXCI6XCLFmlwiLFwic2FjdXRlXCI6XCLFm1wiLFwic2JxdW9cIjpcIuKAmlwiLFwic2NhcFwiOlwi4qq4XCIsXCJTY2Fyb25cIjpcIsWgXCIsXCJzY2Fyb25cIjpcIsWhXCIsXCJTY1wiOlwi4qq8XCIsXCJzY1wiOlwi4om7XCIsXCJzY2N1ZVwiOlwi4om9XCIsXCJzY2VcIjpcIuKqsFwiLFwic2NFXCI6XCLiqrRcIixcIlNjZWRpbFwiOlwixZ5cIixcInNjZWRpbFwiOlwixZ9cIixcIlNjaXJjXCI6XCLFnFwiLFwic2NpcmNcIjpcIsWdXCIsXCJzY25hcFwiOlwi4qq6XCIsXCJzY25FXCI6XCLiqrZcIixcInNjbnNpbVwiOlwi4oupXCIsXCJzY3BvbGludFwiOlwi4qiTXCIsXCJzY3NpbVwiOlwi4om/XCIsXCJTY3lcIjpcItChXCIsXCJzY3lcIjpcItGBXCIsXCJzZG90YlwiOlwi4oqhXCIsXCJzZG90XCI6XCLii4VcIixcInNkb3RlXCI6XCLiqaZcIixcInNlYXJoa1wiOlwi4qSlXCIsXCJzZWFyclwiOlwi4oaYXCIsXCJzZUFyclwiOlwi4oeYXCIsXCJzZWFycm93XCI6XCLihphcIixcInNlY3RcIjpcIsKnXCIsXCJzZW1pXCI6XCI7XCIsXCJzZXN3YXJcIjpcIuKkqVwiLFwic2V0bWludXNcIjpcIuKIllwiLFwic2V0bW5cIjpcIuKIllwiLFwic2V4dFwiOlwi4py2XCIsXCJTZnJcIjpcIvCdlJZcIixcInNmclwiOlwi8J2UsFwiLFwic2Zyb3duXCI6XCLijKJcIixcInNoYXJwXCI6XCLima9cIixcIlNIQ0hjeVwiOlwi0KlcIixcInNoY2hjeVwiOlwi0YlcIixcIlNIY3lcIjpcItCoXCIsXCJzaGN5XCI6XCLRiFwiLFwiU2hvcnREb3duQXJyb3dcIjpcIuKGk1wiLFwiU2hvcnRMZWZ0QXJyb3dcIjpcIuKGkFwiLFwic2hvcnRtaWRcIjpcIuKIo1wiLFwic2hvcnRwYXJhbGxlbFwiOlwi4oilXCIsXCJTaG9ydFJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiU2hvcnRVcEFycm93XCI6XCLihpFcIixcInNoeVwiOlwiwq1cIixcIlNpZ21hXCI6XCLOo1wiLFwic2lnbWFcIjpcIs+DXCIsXCJzaWdtYWZcIjpcIs+CXCIsXCJzaWdtYXZcIjpcIs+CXCIsXCJzaW1cIjpcIuKIvFwiLFwic2ltZG90XCI6XCLiqapcIixcInNpbWVcIjpcIuKJg1wiLFwic2ltZXFcIjpcIuKJg1wiLFwic2ltZ1wiOlwi4qqeXCIsXCJzaW1nRVwiOlwi4qqgXCIsXCJzaW1sXCI6XCLiqp1cIixcInNpbWxFXCI6XCLiqp9cIixcInNpbW5lXCI6XCLiiYZcIixcInNpbXBsdXNcIjpcIuKopFwiLFwic2ltcmFyclwiOlwi4qWyXCIsXCJzbGFyclwiOlwi4oaQXCIsXCJTbWFsbENpcmNsZVwiOlwi4oiYXCIsXCJzbWFsbHNldG1pbnVzXCI6XCLiiJZcIixcInNtYXNocFwiOlwi4qizXCIsXCJzbWVwYXJzbFwiOlwi4qekXCIsXCJzbWlkXCI6XCLiiKNcIixcInNtaWxlXCI6XCLijKNcIixcInNtdFwiOlwi4qqqXCIsXCJzbXRlXCI6XCLiqqxcIixcInNtdGVzXCI6XCLiqqzvuIBcIixcIlNPRlRjeVwiOlwi0KxcIixcInNvZnRjeVwiOlwi0YxcIixcInNvbGJhclwiOlwi4oy/XCIsXCJzb2xiXCI6XCLip4RcIixcInNvbFwiOlwiL1wiLFwiU29wZlwiOlwi8J2VilwiLFwic29wZlwiOlwi8J2VpFwiLFwic3BhZGVzXCI6XCLimaBcIixcInNwYWRlc3VpdFwiOlwi4pmgXCIsXCJzcGFyXCI6XCLiiKVcIixcInNxY2FwXCI6XCLiipNcIixcInNxY2Fwc1wiOlwi4oqT77iAXCIsXCJzcWN1cFwiOlwi4oqUXCIsXCJzcWN1cHNcIjpcIuKKlO+4gFwiLFwiU3FydFwiOlwi4oiaXCIsXCJzcXN1YlwiOlwi4oqPXCIsXCJzcXN1YmVcIjpcIuKKkVwiLFwic3FzdWJzZXRcIjpcIuKKj1wiLFwic3FzdWJzZXRlcVwiOlwi4oqRXCIsXCJzcXN1cFwiOlwi4oqQXCIsXCJzcXN1cGVcIjpcIuKKklwiLFwic3FzdXBzZXRcIjpcIuKKkFwiLFwic3FzdXBzZXRlcVwiOlwi4oqSXCIsXCJzcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZUludGVyc2VjdGlvblwiOlwi4oqTXCIsXCJTcXVhcmVTdWJzZXRcIjpcIuKKj1wiLFwiU3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKKkVwiLFwiU3F1YXJlU3VwZXJzZXRcIjpcIuKKkFwiLFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oqSXCIsXCJTcXVhcmVVbmlvblwiOlwi4oqUXCIsXCJzcXVhcmZcIjpcIuKWqlwiLFwic3F1XCI6XCLilqFcIixcInNxdWZcIjpcIuKWqlwiLFwic3JhcnJcIjpcIuKGklwiLFwiU3NjclwiOlwi8J2SrlwiLFwic3NjclwiOlwi8J2TiFwiLFwic3NldG1uXCI6XCLiiJZcIixcInNzbWlsZVwiOlwi4oyjXCIsXCJzc3RhcmZcIjpcIuKLhlwiLFwiU3RhclwiOlwi4ouGXCIsXCJzdGFyXCI6XCLimIZcIixcInN0YXJmXCI6XCLimIVcIixcInN0cmFpZ2h0ZXBzaWxvblwiOlwiz7VcIixcInN0cmFpZ2h0cGhpXCI6XCLPlVwiLFwic3RybnNcIjpcIsKvXCIsXCJzdWJcIjpcIuKKglwiLFwiU3ViXCI6XCLii5BcIixcInN1YmRvdFwiOlwi4qq9XCIsXCJzdWJFXCI6XCLiq4VcIixcInN1YmVcIjpcIuKKhlwiLFwic3ViZWRvdFwiOlwi4quDXCIsXCJzdWJtdWx0XCI6XCLiq4FcIixcInN1Ym5FXCI6XCLiq4tcIixcInN1Ym5lXCI6XCLiiopcIixcInN1YnBsdXNcIjpcIuKqv1wiLFwic3VicmFyclwiOlwi4qW5XCIsXCJzdWJzZXRcIjpcIuKKglwiLFwiU3Vic2V0XCI6XCLii5BcIixcInN1YnNldGVxXCI6XCLiioZcIixcInN1YnNldGVxcVwiOlwi4quFXCIsXCJTdWJzZXRFcXVhbFwiOlwi4oqGXCIsXCJzdWJzZXRuZXFcIjpcIuKKilwiLFwic3Vic2V0bmVxcVwiOlwi4quLXCIsXCJzdWJzaW1cIjpcIuKrh1wiLFwic3Vic3ViXCI6XCLiq5VcIixcInN1YnN1cFwiOlwi4quTXCIsXCJzdWNjYXBwcm94XCI6XCLiqrhcIixcInN1Y2NcIjpcIuKJu1wiLFwic3VjY2N1cmx5ZXFcIjpcIuKJvVwiLFwiU3VjY2VlZHNcIjpcIuKJu1wiLFwiU3VjY2VlZHNFcXVhbFwiOlwi4qqwXCIsXCJTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKJvVwiLFwiU3VjY2VlZHNUaWxkZVwiOlwi4om/XCIsXCJzdWNjZXFcIjpcIuKqsFwiLFwic3VjY25hcHByb3hcIjpcIuKqulwiLFwic3VjY25lcXFcIjpcIuKqtlwiLFwic3VjY25zaW1cIjpcIuKLqVwiLFwic3VjY3NpbVwiOlwi4om/XCIsXCJTdWNoVGhhdFwiOlwi4oiLXCIsXCJzdW1cIjpcIuKIkVwiLFwiU3VtXCI6XCLiiJFcIixcInN1bmdcIjpcIuKZqlwiLFwic3VwMVwiOlwiwrlcIixcInN1cDJcIjpcIsKyXCIsXCJzdXAzXCI6XCLCs1wiLFwic3VwXCI6XCLiioNcIixcIlN1cFwiOlwi4ouRXCIsXCJzdXBkb3RcIjpcIuKqvlwiLFwic3VwZHN1YlwiOlwi4quYXCIsXCJzdXBFXCI6XCLiq4ZcIixcInN1cGVcIjpcIuKKh1wiLFwic3VwZWRvdFwiOlwi4quEXCIsXCJTdXBlcnNldFwiOlwi4oqDXCIsXCJTdXBlcnNldEVxdWFsXCI6XCLiiodcIixcInN1cGhzb2xcIjpcIuKfiVwiLFwic3VwaHN1YlwiOlwi4quXXCIsXCJzdXBsYXJyXCI6XCLipbtcIixcInN1cG11bHRcIjpcIuKrglwiLFwic3VwbkVcIjpcIuKrjFwiLFwic3VwbmVcIjpcIuKKi1wiLFwic3VwcGx1c1wiOlwi4quAXCIsXCJzdXBzZXRcIjpcIuKKg1wiLFwiU3Vwc2V0XCI6XCLii5FcIixcInN1cHNldGVxXCI6XCLiiodcIixcInN1cHNldGVxcVwiOlwi4quGXCIsXCJzdXBzZXRuZXFcIjpcIuKKi1wiLFwic3Vwc2V0bmVxcVwiOlwi4quMXCIsXCJzdXBzaW1cIjpcIuKriFwiLFwic3Vwc3ViXCI6XCLiq5RcIixcInN1cHN1cFwiOlwi4quWXCIsXCJzd2FyaGtcIjpcIuKkplwiLFwic3dhcnJcIjpcIuKGmVwiLFwic3dBcnJcIjpcIuKHmVwiLFwic3dhcnJvd1wiOlwi4oaZXCIsXCJzd253YXJcIjpcIuKkqlwiLFwic3psaWdcIjpcIsOfXCIsXCJUYWJcIjpcIlxcdFwiLFwidGFyZ2V0XCI6XCLijJZcIixcIlRhdVwiOlwizqRcIixcInRhdVwiOlwiz4RcIixcInRicmtcIjpcIuKOtFwiLFwiVGNhcm9uXCI6XCLFpFwiLFwidGNhcm9uXCI6XCLFpVwiLFwiVGNlZGlsXCI6XCLFolwiLFwidGNlZGlsXCI6XCLFo1wiLFwiVGN5XCI6XCLQolwiLFwidGN5XCI6XCLRglwiLFwidGRvdFwiOlwi4oObXCIsXCJ0ZWxyZWNcIjpcIuKMlVwiLFwiVGZyXCI6XCLwnZSXXCIsXCJ0ZnJcIjpcIvCdlLFcIixcInRoZXJlNFwiOlwi4oi0XCIsXCJ0aGVyZWZvcmVcIjpcIuKItFwiLFwiVGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXRhXCI6XCLOmFwiLFwidGhldGFcIjpcIs64XCIsXCJ0aGV0YXN5bVwiOlwiz5FcIixcInRoZXRhdlwiOlwiz5FcIixcInRoaWNrYXBwcm94XCI6XCLiiYhcIixcInRoaWNrc2ltXCI6XCLiiLxcIixcIlRoaWNrU3BhY2VcIjpcIuKBn+KAilwiLFwiVGhpblNwYWNlXCI6XCLigIlcIixcInRoaW5zcFwiOlwi4oCJXCIsXCJ0aGthcFwiOlwi4omIXCIsXCJ0aGtzaW1cIjpcIuKIvFwiLFwiVEhPUk5cIjpcIsOeXCIsXCJ0aG9yblwiOlwiw75cIixcInRpbGRlXCI6XCLLnFwiLFwiVGlsZGVcIjpcIuKIvFwiLFwiVGlsZGVFcXVhbFwiOlwi4omDXCIsXCJUaWxkZUZ1bGxFcXVhbFwiOlwi4omFXCIsXCJUaWxkZVRpbGRlXCI6XCLiiYhcIixcInRpbWVzYmFyXCI6XCLiqLFcIixcInRpbWVzYlwiOlwi4oqgXCIsXCJ0aW1lc1wiOlwiw5dcIixcInRpbWVzZFwiOlwi4qiwXCIsXCJ0aW50XCI6XCLiiK1cIixcInRvZWFcIjpcIuKkqFwiLFwidG9wYm90XCI6XCLijLZcIixcInRvcGNpclwiOlwi4quxXCIsXCJ0b3BcIjpcIuKKpFwiLFwiVG9wZlwiOlwi8J2Vi1wiLFwidG9wZlwiOlwi8J2VpVwiLFwidG9wZm9ya1wiOlwi4quaXCIsXCJ0b3NhXCI6XCLipKlcIixcInRwcmltZVwiOlwi4oC0XCIsXCJ0cmFkZVwiOlwi4oSiXCIsXCJUUkFERVwiOlwi4oSiXCIsXCJ0cmlhbmdsZVwiOlwi4pa1XCIsXCJ0cmlhbmdsZWRvd25cIjpcIuKWv1wiLFwidHJpYW5nbGVsZWZ0XCI6XCLil4NcIixcInRyaWFuZ2xlbGVmdGVxXCI6XCLiirRcIixcInRyaWFuZ2xlcVwiOlwi4omcXCIsXCJ0cmlhbmdsZXJpZ2h0XCI6XCLilrlcIixcInRyaWFuZ2xlcmlnaHRlcVwiOlwi4oq1XCIsXCJ0cmlkb3RcIjpcIuKXrFwiLFwidHJpZVwiOlwi4omcXCIsXCJ0cmltaW51c1wiOlwi4qi6XCIsXCJUcmlwbGVEb3RcIjpcIuKDm1wiLFwidHJpcGx1c1wiOlwi4qi5XCIsXCJ0cmlzYlwiOlwi4qeNXCIsXCJ0cml0aW1lXCI6XCLiqLtcIixcInRycGV6aXVtXCI6XCLij6JcIixcIlRzY3JcIjpcIvCdkq9cIixcInRzY3JcIjpcIvCdk4lcIixcIlRTY3lcIjpcItCmXCIsXCJ0c2N5XCI6XCLRhlwiLFwiVFNIY3lcIjpcItCLXCIsXCJ0c2hjeVwiOlwi0ZtcIixcIlRzdHJva1wiOlwixaZcIixcInRzdHJva1wiOlwixadcIixcInR3aXh0XCI6XCLiiaxcIixcInR3b2hlYWRsZWZ0YXJyb3dcIjpcIuKGnlwiLFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIuKGoFwiLFwiVWFjdXRlXCI6XCLDmlwiLFwidWFjdXRlXCI6XCLDulwiLFwidWFyclwiOlwi4oaRXCIsXCJVYXJyXCI6XCLihp9cIixcInVBcnJcIjpcIuKHkVwiLFwiVWFycm9jaXJcIjpcIuKliVwiLFwiVWJyY3lcIjpcItCOXCIsXCJ1YnJjeVwiOlwi0Z5cIixcIlVicmV2ZVwiOlwixaxcIixcInVicmV2ZVwiOlwixa1cIixcIlVjaXJjXCI6XCLDm1wiLFwidWNpcmNcIjpcIsO7XCIsXCJVY3lcIjpcItCjXCIsXCJ1Y3lcIjpcItGDXCIsXCJ1ZGFyclwiOlwi4oeFXCIsXCJVZGJsYWNcIjpcIsWwXCIsXCJ1ZGJsYWNcIjpcIsWxXCIsXCJ1ZGhhclwiOlwi4qWuXCIsXCJ1ZmlzaHRcIjpcIuKlvlwiLFwiVWZyXCI6XCLwnZSYXCIsXCJ1ZnJcIjpcIvCdlLJcIixcIlVncmF2ZVwiOlwiw5lcIixcInVncmF2ZVwiOlwiw7lcIixcInVIYXJcIjpcIuKlo1wiLFwidWhhcmxcIjpcIuKGv1wiLFwidWhhcnJcIjpcIuKGvlwiLFwidWhibGtcIjpcIuKWgFwiLFwidWxjb3JuXCI6XCLijJxcIixcInVsY29ybmVyXCI6XCLijJxcIixcInVsY3JvcFwiOlwi4oyPXCIsXCJ1bHRyaVwiOlwi4pe4XCIsXCJVbWFjclwiOlwixapcIixcInVtYWNyXCI6XCLFq1wiLFwidW1sXCI6XCLCqFwiLFwiVW5kZXJCYXJcIjpcIl9cIixcIlVuZGVyQnJhY2VcIjpcIuKPn1wiLFwiVW5kZXJCcmFja2V0XCI6XCLijrVcIixcIlVuZGVyUGFyZW50aGVzaXNcIjpcIuKPnVwiLFwiVW5pb25cIjpcIuKLg1wiLFwiVW5pb25QbHVzXCI6XCLiio5cIixcIlVvZ29uXCI6XCLFslwiLFwidW9nb25cIjpcIsWzXCIsXCJVb3BmXCI6XCLwnZWMXCIsXCJ1b3BmXCI6XCLwnZWmXCIsXCJVcEFycm93QmFyXCI6XCLipJJcIixcInVwYXJyb3dcIjpcIuKGkVwiLFwiVXBBcnJvd1wiOlwi4oaRXCIsXCJVcGFycm93XCI6XCLih5FcIixcIlVwQXJyb3dEb3duQXJyb3dcIjpcIuKHhVwiLFwidXBkb3duYXJyb3dcIjpcIuKGlVwiLFwiVXBEb3duQXJyb3dcIjpcIuKGlVwiLFwiVXBkb3duYXJyb3dcIjpcIuKHlVwiLFwiVXBFcXVpbGlicml1bVwiOlwi4qWuXCIsXCJ1cGhhcnBvb25sZWZ0XCI6XCLihr9cIixcInVwaGFycG9vbnJpZ2h0XCI6XCLihr5cIixcInVwbHVzXCI6XCLiio5cIixcIlVwcGVyTGVmdEFycm93XCI6XCLihpZcIixcIlVwcGVyUmlnaHRBcnJvd1wiOlwi4oaXXCIsXCJ1cHNpXCI6XCLPhVwiLFwiVXBzaVwiOlwiz5JcIixcInVwc2loXCI6XCLPklwiLFwiVXBzaWxvblwiOlwizqVcIixcInVwc2lsb25cIjpcIs+FXCIsXCJVcFRlZUFycm93XCI6XCLihqVcIixcIlVwVGVlXCI6XCLiiqVcIixcInVwdXBhcnJvd3NcIjpcIuKHiFwiLFwidXJjb3JuXCI6XCLijJ1cIixcInVyY29ybmVyXCI6XCLijJ1cIixcInVyY3JvcFwiOlwi4oyOXCIsXCJVcmluZ1wiOlwixa5cIixcInVyaW5nXCI6XCLFr1wiLFwidXJ0cmlcIjpcIuKXuVwiLFwiVXNjclwiOlwi8J2SsFwiLFwidXNjclwiOlwi8J2TilwiLFwidXRkb3RcIjpcIuKLsFwiLFwiVXRpbGRlXCI6XCLFqFwiLFwidXRpbGRlXCI6XCLFqVwiLFwidXRyaVwiOlwi4pa1XCIsXCJ1dHJpZlwiOlwi4pa0XCIsXCJ1dWFyclwiOlwi4oeIXCIsXCJVdW1sXCI6XCLDnFwiLFwidXVtbFwiOlwiw7xcIixcInV3YW5nbGVcIjpcIuKmp1wiLFwidmFuZ3J0XCI6XCLippxcIixcInZhcmVwc2lsb25cIjpcIs+1XCIsXCJ2YXJrYXBwYVwiOlwiz7BcIixcInZhcm5vdGhpbmdcIjpcIuKIhVwiLFwidmFycGhpXCI6XCLPlVwiLFwidmFycGlcIjpcIs+WXCIsXCJ2YXJwcm9wdG9cIjpcIuKInVwiLFwidmFyclwiOlwi4oaVXCIsXCJ2QXJyXCI6XCLih5VcIixcInZhcnJob1wiOlwiz7FcIixcInZhcnNpZ21hXCI6XCLPglwiLFwidmFyc3Vic2V0bmVxXCI6XCLiiorvuIBcIixcInZhcnN1YnNldG5lcXFcIjpcIuKri++4gFwiLFwidmFyc3Vwc2V0bmVxXCI6XCLiiovvuIBcIixcInZhcnN1cHNldG5lcXFcIjpcIuKrjO+4gFwiLFwidmFydGhldGFcIjpcIs+RXCIsXCJ2YXJ0cmlhbmdsZWxlZnRcIjpcIuKKslwiLFwidmFydHJpYW5nbGVyaWdodFwiOlwi4oqzXCIsXCJ2QmFyXCI6XCLiq6hcIixcIlZiYXJcIjpcIuKrq1wiLFwidkJhcnZcIjpcIuKrqVwiLFwiVmN5XCI6XCLQklwiLFwidmN5XCI6XCLQslwiLFwidmRhc2hcIjpcIuKKolwiLFwidkRhc2hcIjpcIuKKqFwiLFwiVmRhc2hcIjpcIuKKqVwiLFwiVkRhc2hcIjpcIuKKq1wiLFwiVmRhc2hsXCI6XCLiq6ZcIixcInZlZWJhclwiOlwi4oq7XCIsXCJ2ZWVcIjpcIuKIqFwiLFwiVmVlXCI6XCLii4FcIixcInZlZWVxXCI6XCLiiZpcIixcInZlbGxpcFwiOlwi4ouuXCIsXCJ2ZXJiYXJcIjpcInxcIixcIlZlcmJhclwiOlwi4oCWXCIsXCJ2ZXJ0XCI6XCJ8XCIsXCJWZXJ0XCI6XCLigJZcIixcIlZlcnRpY2FsQmFyXCI6XCLiiKNcIixcIlZlcnRpY2FsTGluZVwiOlwifFwiLFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIuKdmFwiLFwiVmVydGljYWxUaWxkZVwiOlwi4omAXCIsXCJWZXJ5VGhpblNwYWNlXCI6XCLigIpcIixcIlZmclwiOlwi8J2UmVwiLFwidmZyXCI6XCLwnZSzXCIsXCJ2bHRyaVwiOlwi4oqyXCIsXCJ2bnN1YlwiOlwi4oqC4oOSXCIsXCJ2bnN1cFwiOlwi4oqD4oOSXCIsXCJWb3BmXCI6XCLwnZWNXCIsXCJ2b3BmXCI6XCLwnZWnXCIsXCJ2cHJvcFwiOlwi4oidXCIsXCJ2cnRyaVwiOlwi4oqzXCIsXCJWc2NyXCI6XCLwnZKxXCIsXCJ2c2NyXCI6XCLwnZOLXCIsXCJ2c3VibkVcIjpcIuKri++4gFwiLFwidnN1Ym5lXCI6XCLiiorvuIBcIixcInZzdXBuRVwiOlwi4quM77iAXCIsXCJ2c3VwbmVcIjpcIuKKi++4gFwiLFwiVnZkYXNoXCI6XCLiiqpcIixcInZ6aWd6YWdcIjpcIuKmmlwiLFwiV2NpcmNcIjpcIsW0XCIsXCJ3Y2lyY1wiOlwixbVcIixcIndlZGJhclwiOlwi4qmfXCIsXCJ3ZWRnZVwiOlwi4oinXCIsXCJXZWRnZVwiOlwi4ouAXCIsXCJ3ZWRnZXFcIjpcIuKJmVwiLFwid2VpZXJwXCI6XCLihJhcIixcIldmclwiOlwi8J2UmlwiLFwid2ZyXCI6XCLwnZS0XCIsXCJXb3BmXCI6XCLwnZWOXCIsXCJ3b3BmXCI6XCLwnZWoXCIsXCJ3cFwiOlwi4oSYXCIsXCJ3clwiOlwi4omAXCIsXCJ3cmVhdGhcIjpcIuKJgFwiLFwiV3NjclwiOlwi8J2SslwiLFwid3NjclwiOlwi8J2TjFwiLFwieGNhcFwiOlwi4ouCXCIsXCJ4Y2lyY1wiOlwi4pevXCIsXCJ4Y3VwXCI6XCLii4NcIixcInhkdHJpXCI6XCLilr1cIixcIlhmclwiOlwi8J2Um1wiLFwieGZyXCI6XCLwnZS1XCIsXCJ4aGFyclwiOlwi4p+3XCIsXCJ4aEFyclwiOlwi4p+6XCIsXCJYaVwiOlwizp5cIixcInhpXCI6XCLOvlwiLFwieGxhcnJcIjpcIuKftVwiLFwieGxBcnJcIjpcIuKfuFwiLFwieG1hcFwiOlwi4p+8XCIsXCJ4bmlzXCI6XCLii7tcIixcInhvZG90XCI6XCLiqIBcIixcIlhvcGZcIjpcIvCdlY9cIixcInhvcGZcIjpcIvCdlalcIixcInhvcGx1c1wiOlwi4qiBXCIsXCJ4b3RpbWVcIjpcIuKoglwiLFwieHJhcnJcIjpcIuKftlwiLFwieHJBcnJcIjpcIuKfuVwiLFwiWHNjclwiOlwi8J2Ss1wiLFwieHNjclwiOlwi8J2TjVwiLFwieHNxY3VwXCI6XCLiqIZcIixcInh1cGx1c1wiOlwi4qiEXCIsXCJ4dXRyaVwiOlwi4pazXCIsXCJ4dmVlXCI6XCLii4FcIixcInh3ZWRnZVwiOlwi4ouAXCIsXCJZYWN1dGVcIjpcIsOdXCIsXCJ5YWN1dGVcIjpcIsO9XCIsXCJZQWN5XCI6XCLQr1wiLFwieWFjeVwiOlwi0Y9cIixcIlljaXJjXCI6XCLFtlwiLFwieWNpcmNcIjpcIsW3XCIsXCJZY3lcIjpcItCrXCIsXCJ5Y3lcIjpcItGLXCIsXCJ5ZW5cIjpcIsKlXCIsXCJZZnJcIjpcIvCdlJxcIixcInlmclwiOlwi8J2UtlwiLFwiWUljeVwiOlwi0IdcIixcInlpY3lcIjpcItGXXCIsXCJZb3BmXCI6XCLwnZWQXCIsXCJ5b3BmXCI6XCLwnZWqXCIsXCJZc2NyXCI6XCLwnZK0XCIsXCJ5c2NyXCI6XCLwnZOOXCIsXCJZVWN5XCI6XCLQrlwiLFwieXVjeVwiOlwi0Y5cIixcInl1bWxcIjpcIsO/XCIsXCJZdW1sXCI6XCLFuFwiLFwiWmFjdXRlXCI6XCLFuVwiLFwiemFjdXRlXCI6XCLFulwiLFwiWmNhcm9uXCI6XCLFvVwiLFwiemNhcm9uXCI6XCLFvlwiLFwiWmN5XCI6XCLQl1wiLFwiemN5XCI6XCLQt1wiLFwiWmRvdFwiOlwixbtcIixcInpkb3RcIjpcIsW8XCIsXCJ6ZWV0cmZcIjpcIuKEqFwiLFwiWmVyb1dpZHRoU3BhY2VcIjpcIuKAi1wiLFwiWmV0YVwiOlwizpZcIixcInpldGFcIjpcIs62XCIsXCJ6ZnJcIjpcIvCdlLdcIixcIlpmclwiOlwi4oSoXCIsXCJaSGN5XCI6XCLQllwiLFwiemhjeVwiOlwi0LZcIixcInppZ3JhcnJcIjpcIuKHnVwiLFwiem9wZlwiOlwi8J2Vq1wiLFwiWm9wZlwiOlwi4oSkXCIsXCJac2NyXCI6XCLwnZK1XCIsXCJ6c2NyXCI6XCLwnZOPXCIsXCJ6d2pcIjpcIuKAjVwiLFwiendualwiOlwi4oCMXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VudGl0aWVzL21hcHMvZW50aXRpZXMuanNvblxuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqLCBfVmR0LCBibG9ja3MsICRjYWxsZWUpIHtcbiAgICBfVmR0IHx8IChfVmR0ID0gVmR0KTtcbiAgICBvYmogfHwgKG9iaiA9IHt9KTtcbiAgICBibG9ja3MgfHwgKGJsb2NrcyA9IHt9KTtcbiAgICB2YXIgaCA9IF9WZHQubWlzcy5oLCBoYyA9IF9WZHQubWlzcy5oYywgaHUgPSBfVmR0Lm1pc3MuaHUsIHdpZGdldHMgPSB0aGlzICYmIHRoaXMud2lkZ2V0cyB8fCB7fSwgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IHt9LFxuICAgICAgICBfX3UgPSBfVmR0LnV0aWxzLCBleHRlbmQgPSBfX3UuZXh0ZW5kLCBfZSA9IF9fdS5lcnJvciwgX2NsYXNzTmFtZSA9IF9fdS5jbGFzc05hbWUsIF9fc2xpY2UgPSBfX3Uuc2xpY2UsIF9fbm9vcCA9IF9fdS5ub29wLFxuICAgICAgICBfX20gPSBfX3UubWFwLCBfX28gPSBfX3UuT3B0aW9ucywgX2dldE1vZGVsID0gX19vLmdldE1vZGVsLCBfc2V0TW9kZWwgPSBfX28uc2V0TW9kZWwsXG4gICAgICAgIF9zZXRDaGVja2JveE1vZGVsID0gX191LnNldENoZWNrYm94TW9kZWwsIF9kZXRlY3RDaGVja2JveENoZWNrZWQgPSBfX3UuZGV0ZWN0Q2hlY2tib3hDaGVja2VkLFxuICAgICAgICBfc2V0U2VsZWN0TW9kZWwgPSBfX3Uuc2V0U2VsZWN0TW9kZWwsXG4gICAgICAgIHNlbGYgPSB0aGlzLmRhdGEsICR0aGlzID0gdGhpcywgc2NvcGUgPSBvYmosIEFuaW1hdGUgPSBzZWxmICYmIHNlbGYuQW5pbWF0ZSwgcGFyZW50ID0gKCRjYWxsZWUgfHwge30pLl9zdXBlcjtcblxuICAgIGNvbnN0IGNhdGFsb2dzID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6ICfln7rnoYAnLFxuICAgICAgICBzdWJDYXRhbG9nczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5byA5aeLJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnc3RhcnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnSW50YWN05a6e5L6LJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnaW5zdGFuY2UnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn57uE5Lu255Sf5ZG95ZGo5pyfJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnbGlmZWN5Y2xlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+aooeadv+ivreazlScsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3N5bnRheCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfkuovku7blpITnkIYnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdldmVudCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfooajljZXlpITnkIYnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdmb3JtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+e7hOS7ticsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2NvbXBvbmVudCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfnu4Tku7bnu6fmib8nLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdleHRlbmQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICfov5vpmLYnLFxuICAgICAgICBzdWJDYXRhbG9nczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5Yqo55S7JyxcbiAgICAgICAgICAgICAgICBocmVmOiAnYW5pbWF0aW9uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+aooeadv3RlbXBsYXRlJyxcbiAgICAgICAgICAgICAgICBocmVmOiAndGVtcGxhdGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn6Lev55SxJyxcbiAgICAgICAgICAgICAgICBocmVmOiAncm91dGVyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ3dlYnBhY2vlrp7ot7UnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdwcm9qZWN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+acjeWKoeWZqOerr+a4suafkycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3NzcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ+WFtuWugycsXG4gICAgICAgIHN1YkNhdGFsb2dzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfmm7TmlrDml6Xlv5cnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdjaGFuZ2Vsb2cnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xubGV0IGN1cnJlbnROYXYgPSB7fTtcblxuY29uc3QgU3VicyA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKGF0dHIuc3Vicyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpID9cbiAgICAgICAgaCgndWwnLCBudWxsLCBfX20oZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKGF0dHIuc3Vicyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaCgnbGknLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgaCgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2V2LWNsaWNrJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHNlbGYuc2Nyb2xsVG8uYmluZChzZWxmLCB2YWx1ZS50aXRsZSwgYXR0ci5zdWJzLmFjdGl2ZSkpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh2YWx1ZS50aXRsZSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpKSxcbiAgICAgICAgICAgICAgICBoKFN1YnMsIHtcbiAgICAgICAgICAgICAgICAgICAgJ3N1YnMnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUuc3Vicyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAnX2NvbnRleHQnOiAkdGhpc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh7XG4gICAgICAgICAgICBhY3RpdmU6IHNlbGYuZ2V0KGF0dHIuc3Vicy5hY3RpdmUpID09PSB2YWx1ZS50aXRsZVxuICAgICAgICB9KX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpKTtcbiAgICAgICAgfSwgJHRoaXMpLCAnc3ViLWNhdGFsb2dzJykgOlxuICAgICAgICB1bmRlZmluZWRcbn07XG4gICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9vYmogPSB7XG4gICAgICAgICAgICAnbmF2SW5kZXgnOiAnZG9jdW1lbnQnLFxuICAgICAgICAgICAgJ2NsYXNzTmFtZSc6ICdkb2N1bWVudC1wYWdlJyxcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChzY29wZSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJlbnQuY2FsbCgkdGhpcywgX29iaiwgX1ZkdCwgZnVuY3Rpb24oYmxvY2tzKSB7XG4gICAgICAgICAgICB2YXIgX2Jsb2NrcyA9IHt9LCBfX2Jsb2NrcyA9IGV4dGVuZCh7fSwgYmxvY2tzKTtcbiAgICAgICAgICAgIHJldHVybiAoKF9ibG9ja3NbJ2NvbnRlbnQnXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGgoJ2FzaWRlJywgbnVsbCwgaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX19tKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChjYXRhbG9ncyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoJ2RpdicsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnaDUnLCBudWxsLCBmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUudGl0bGUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ3VsJywgbnVsbCwgX19tKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh2YWx1ZS5zdWJDYXRhbG9ncyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaCgnbGknLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5ocmVmID09PSBzZWxmLmdldCgndGl0bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5hdiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdocmVmJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKCcjL2RvY3VtZW50LycgKyB2YWx1ZS5ocmVmKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUudGl0bGUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHZhbHVlLmhyZWYgPT09IHNlbGYuZ2V0KCd0aXRsZScpKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKFN1YnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJzJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHNlbGYuZ2V0KCdzdWJDYXRhbG9ncycpKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnX2NvbnRleHQnOiAkdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdmFsdWUuaHJlZiA9PT0gc2VsZi5nZXQoJ3RpdGxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAkdGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgJ2NhdGFsb2ctc2VjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgbnVsbCwgJ2FzaWRlLWJvcmRlciB0cmFuc2l0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgXSwgJ2FzaWRlLXdyYXBwZXInKSksXG4gICAgICAgICAgICAgICAgICAgIGgoJ2FydGljbGUnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKGN1cnJlbnROYXYudGl0bGUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSwgJ3RpdGxlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuICAgICAgICAgICAgICAgICAgICDlpoLmnpzkvaDlj5HnjrDmlofmoaPmnInpl67popjvvIzor7fluK7lv5nlnKhcXG4gICAgICAgICAgICAgICAgICAgICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGFyZ2V0JzogJ19ibGFuaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChgaHR0cHM6Ly9naXRodWIuY29tL0phdmV5L0ludGFjdC9ibG9iL21hc3Rlci9kb2NzLyR7c2VsZi5nZXQoJ3RpdGxlJyl9Lm1kYCl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sICdnaXRodWInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbiAgICAgICAgICAgICAgICAgICAg5LiK5L+u5q2j6K+l5paH5qGjXFxuICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCAnZWRpdC1saW5rJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sICdhcnRpY2xlLWhlYWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5uZXJIVE1MJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHNlbGYuZ2V0KCdjb250ZW50JykpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSkgJiYgKF9fYmxvY2tzWydjb250ZW50J10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tzWydjb250ZW50J10gPyBibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgW2Z1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3MsIDEpKSkgOiBfYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSksIF9fYmxvY2tzKTtcbiAgICAgICAgfS5jYWxsKCR0aGlzLCBibG9ja3MpLCBwYXJlbnQpXG4gICAgfSkuY2FsbCgkdGhpcylcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnZkdCIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheU1hcC5qcyIsInZhciBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBzaHVmZmxlU2VsZiA9IHJlcXVpcmUoJy4vX3NodWZmbGVTZWxmJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTaHVmZmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FycmF5U2h1ZmZsZS5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlS2V5cy5qcyIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5kb207XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVJhbmRvbS5qcyIsInZhciBzaHVmZmxlU2VsZiA9IHJlcXVpcmUoJy4vX3NodWZmbGVTZWxmJyksXG4gICAgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTaHVmZmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTaHVmZmxlLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY29weUFycmF5LmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX25vZGVVdGlsLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX292ZXJBcmcuanMiLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2tleXMuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9ub3cuanMiLCJ2YXIgYXJyYXlTaHVmZmxlID0gcmVxdWlyZSgnLi9fYXJyYXlTaHVmZmxlJyksXG4gICAgYmFzZVNodWZmbGUgPSByZXF1aXJlKCcuL19iYXNlU2h1ZmZsZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaHVmZmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvc2h1ZmZsZS5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9zdHViRmFsc2UuanMiLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC90aHJvdHRsZS5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3ZhbHVlcy5qcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhsanMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgY29sb3I6ICM1MjUyNTI7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG4uaGxqcy1kb2N0eXBlIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4uaGxqcy10YWcge1xcbiAgY29sb3I6ICMzZTc2ZjY7XFxufVxcbi5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmhsanMtdmFsdWUge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5obGpzLWtleXdvcmQge1xcbiAgY29sb3I6ICNlOTY5MDA7XFxufVxcbi5obGpzLXN0cmluZyB7XFxuICBjb2xvcjogIzQyYjk4MztcXG59XFxuLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogI2IzYjNiMztcXG59XFxuLmhsanMtb3BlcmF0b3IgLmhsanMtY29tbWVudCB7XFxuICBjb2xvcjogIzUyNTI1MjtcXG59XFxuLmhsanMtcmVnZXhwIHtcXG4gIGNvbG9yOiAjYWY3ZGZmO1xcbn1cXG4uaGxqcy1idWlsdF9pbiB7XFxuICBjb2xvcjogIzJkYjdmNTtcXG59XFxuLmNzcyAuaGxqcy1jbGFzcyB7XFxuICBjb2xvcjogI2U5NjkwMDtcXG59XFxuLmNzcyAuaGxqcy1udW1iZXIsXFxuLmphdmFzY3JpcHQgLmhsanMtbnVtYmVyIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG4uY3NzIC5obGpzLWF0dHJpYnV0ZSB7XFxuICBjb2xvcjogI2FmN2RmZjtcXG59XFxuLmNzcyAuaGxqcy1pbXBvcnRhbnQge1xcbiAgY29sb3I6ICNkMDQ7XFxufVxcbi5hY3Rpb25zY3JpcHQgLmhsanMtbGl0ZXJhbCxcXG4uamF2YXNjcmlwdCAuaGxqcy1saXRlcmFsIHtcXG4gIGNvbG9yOiAjZmMxZTcwO1xcbn1cXG5wcmUge1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG59XFxuY29kZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBiYWNrZ3JvdW5kOiAjZjdmN2Y3O1xcbiAgZm9udC1mYW1pbHk6IENvbnNvbGFzLCBNb25hY28sIEFuZGFsZSBNb25vLCBVYnVudHUgTW9ubywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiAzcHg7XFxuICBwYWRkaW5nOiAxcHggNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgY29sb3I6ICM2NjY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5kb2N1bWVudC1wYWdlIHtcXG4gIHBhZGRpbmctdG9wOiA5NXB4O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlci5maXhlZCB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyLmZpeGVkIC5hc2lkZS13cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogODBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDgwcHgpO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgd2lkdGg6IDIwMHB4O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIHtcXG4gIHdpZHRoOiAxMDgwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4wOCk7XFxuICBtaW4taGVpZ2h0OiBjYWxjKDEwMCUgLSAxNXB4KTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhc2lkZSB7XFxuICB3aWR0aDogMjAwcHg7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZWVlO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciBoNSB7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBtYXJnaW46IDI1cHggMCAxNXB4IDIwcHg7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciBhIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDI1cHg7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciBhOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6ICNmM2YzZjM7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgLmFjdGl2ZSA+IGEge1xcbiAgY29sb3I6ICNmZTQ0NDQ7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgLnN1Yi1jYXRhbG9ncyB7XFxuICBtYXJnaW4tbGVmdDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciAuYXNpZGUtYm9yZGVyIHtcXG4gIGJvcmRlci1yaWdodDogMnB4IHNvbGlkICNmZTQ0NDQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIHtcXG4gIGZsZXg6IDE7XFxuICBwYWRkaW5nOiAxMHB4IDIwcHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXJ0aWNsZS1oZWFkIC50aXRsZSB7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBmb250LXNpemU6IDIuMmVtO1xcbiAgY29sb3I6ICMwMDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFydGljbGUtaGVhZCAuZWRpdC1saW5rIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAyMHB4O1xcbiAgY29sb3I6ICM5OTk7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSBoMSB7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG4gIG1hcmdpbjogMjBweCAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgaDIsXFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIGgzIHtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG4gIG1hcmdpbjogMTVweCAwO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgcCB7XFxuICBsaW5lLWhlaWdodDogMjVweDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIC5vdXRwdXQge1xcbiAgcGFkZGluZzogMjBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXJnaW46IDIwcHggMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3N0eWx1cy1sb2FkZXI/e1wiaW5jbHVkZSBjc3NcIjp0cnVlfSEuL3NpdGUvcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQuc3R5bFxuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vZG9jdW1lbnQuc3R5bFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vZG9jdW1lbnQuc3R5bFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vZG9jdW1lbnQuc3R5bFwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWxcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmosIF9WZHQsIGJsb2NrcywgJGNhbGxlZSkge1xuICAgIF9WZHQgfHwgKF9WZHQgPSBWZHQpO1xuICAgIG9iaiB8fCAob2JqID0ge30pO1xuICAgIGJsb2NrcyB8fCAoYmxvY2tzID0ge30pO1xuICAgIHZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG4gICAgICAgIF9fdSA9IF9WZHQudXRpbHMsIGV4dGVuZCA9IF9fdS5leHRlbmQsIF9lID0gX191LmVycm9yLCBfY2xhc3NOYW1lID0gX191LmNsYXNzTmFtZSwgX19zbGljZSA9IF9fdS5zbGljZSwgX19ub29wID0gX191Lm5vb3AsXG4gICAgICAgIF9fbSA9IF9fdS5tYXAsIF9fbyA9IF9fdS5PcHRpb25zLCBfZ2V0TW9kZWwgPSBfX28uZ2V0TW9kZWwsIF9zZXRNb2RlbCA9IF9fby5zZXRNb2RlbCxcbiAgICAgICAgX3NldENoZWNrYm94TW9kZWwgPSBfX3Uuc2V0Q2hlY2tib3hNb2RlbCwgX2RldGVjdENoZWNrYm94Q2hlY2tlZCA9IF9fdS5kZXRlY3RDaGVja2JveENoZWNrZWQsXG4gICAgICAgIF9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbiAgICAgICAgc2VsZiA9IHRoaXMuZGF0YSwgJHRoaXMgPSB0aGlzLCBzY29wZSA9IG9iaiwgQW5pbWF0ZSA9IHNlbGYgJiYgc2VsZi5BbmltYXRlLCBwYXJlbnQgPSAoJGNhbGxlZSB8fCB7fSkuX3N1cGVyO1xuXG4gICAgY29uc3QgU3VicyA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKGF0dHIuc3Vicyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpID9cbiAgICAgICAgaCgndWwnLCBudWxsLCBfX20oZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKGF0dHIuc3Vicyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaCgnbGknLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgaCgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2V2LWNsaWNrJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHNlbGYuc2Nyb2xsVG8uYmluZChzZWxmLCB2YWx1ZS50aXRsZSwgYXR0ci5zdWJzLmFjdGl2ZSkpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh2YWx1ZS50aXRsZSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpKSxcbiAgICAgICAgICAgICAgICBoKFN1YnMsIHtcbiAgICAgICAgICAgICAgICAgICAgJ3N1YnMnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUuc3Vicyl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAnX2NvbnRleHQnOiAkdGhpc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh7XG4gICAgICAgICAgICBhY3RpdmU6IHNlbGYuZ2V0KGF0dHIuc3Vicy5hY3RpdmUpID09PSB2YWx1ZS50aXRsZVxuICAgICAgICB9KX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpKTtcbiAgICAgICAgfSwgJHRoaXMpLCBfY2xhc3NOYW1lKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh7XCJzdWItY2F0YWxvZ3NcIjogIWF0dHIuaXNGaXJzdH0pfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSkpIDpcbiAgICAgICAgdW5kZWZpbmVkXG59O1xuICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfb2JqID0ge1xuICAgICAgICAgICAgJ25hdkluZGV4JzogJ2FwaScsXG4gICAgICAgICAgICAnY2xhc3NOYW1lJzogJ2RvY3VtZW50LXBhZ2UgYXBpLXBhZ2UnLFxuICAgICAgICAgICAgLi4uZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHNjb3BlKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jYWxsKCR0aGlzLCBfb2JqLCBfVmR0LCBmdW5jdGlvbihibG9ja3MpIHtcbiAgICAgICAgICAgIHZhciBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0gZXh0ZW5kKHt9LCBibG9ja3MpO1xuICAgICAgICAgICAgcmV0dXJuICgoX2Jsb2Nrc1snY29udGVudCddID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgaCgnYXNpZGUnLCBudWxsLCBoKCdkaXYnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoKFN1YnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Vicyc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChzZWxmLmdldCgnc3ViQ2F0YWxvZ3MnKSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpc0ZpcnN0JzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHRydWUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnX2NvbnRleHQnOiAkdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCBudWxsLCBudWxsLCAnYXNpZGUtYm9yZGVyIHRyYW5zaXRpb24nKVxuICAgICAgICAgICAgICAgICAgICBdLCAnYXNpZGUtd3JhcHBlcicpKSxcbiAgICAgICAgICAgICAgICAgICAgaCgnYXJ0aWNsZScsIG51bGwsIGgoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbm5lckhUTUwnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiAoc2VsZi5nZXQoJ2NvbnRlbnQnKSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KSAmJiAoX19ibG9ja3NbJ2NvbnRlbnQnXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja3NbJ2NvbnRlbnQnXSA/IGJsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBbZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1dLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJncywgMSkpKSA6IF9ibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9KSwgX19ibG9ja3MpO1xuICAgICAgICB9LmNhbGwoJHRoaXMsIGJsb2NrcyksIHBhcmVudClcbiAgICB9KS5jYWxsKCR0aGlzKVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvcGFnZXMvYXBpL2FwaS52ZHQiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hcGktcGFnZSAuY29udGVudC13cmFwcGVyIGFzaWRlIHtcXG4gIHBhZGRpbmc6IDIwcHggMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3N0eWx1cy1sb2FkZXI/e1wiaW5jbHVkZSBjc3NcIjp0cnVlfSEuL3NpdGUvcGFnZXMvYXBpL2FwaS5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vYXBpLnN0eWxcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2FwaS5zdHlsXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0yLTIhLi9hcGkuc3R5bFwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zaXRlL3BhZ2VzL2FwaS9hcGkuc3R5bFxuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmosIF9WZHQsIGJsb2NrcywgJGNhbGxlZSkge1xuICAgIF9WZHQgfHwgKF9WZHQgPSBWZHQpO1xuICAgIG9iaiB8fCAob2JqID0ge30pO1xuICAgIGJsb2NrcyB8fCAoYmxvY2tzID0ge30pO1xuICAgIHZhciBoID0gX1ZkdC5taXNzLmgsIGhjID0gX1ZkdC5taXNzLmhjLCBodSA9IF9WZHQubWlzcy5odSwgd2lkZ2V0cyA9IHRoaXMgJiYgdGhpcy53aWRnZXRzIHx8IHt9LCBfYmxvY2tzID0ge30sIF9fYmxvY2tzID0ge30sXG4gICAgICAgIF9fdSA9IF9WZHQudXRpbHMsIGV4dGVuZCA9IF9fdS5leHRlbmQsIF9lID0gX191LmVycm9yLCBfY2xhc3NOYW1lID0gX191LmNsYXNzTmFtZSwgX19zbGljZSA9IF9fdS5zbGljZSwgX19ub29wID0gX191Lm5vb3AsXG4gICAgICAgIF9fbSA9IF9fdS5tYXAsIF9fbyA9IF9fdS5PcHRpb25zLCBfZ2V0TW9kZWwgPSBfX28uZ2V0TW9kZWwsIF9zZXRNb2RlbCA9IF9fby5zZXRNb2RlbCxcbiAgICAgICAgX3NldENoZWNrYm94TW9kZWwgPSBfX3Uuc2V0Q2hlY2tib3hNb2RlbCwgX2RldGVjdENoZWNrYm94Q2hlY2tlZCA9IF9fdS5kZXRlY3RDaGVja2JveENoZWNrZWQsXG4gICAgICAgIF9zZXRTZWxlY3RNb2RlbCA9IF9fdS5zZXRTZWxlY3RNb2RlbCxcbiAgICAgICAgc2VsZiA9IHRoaXMuZGF0YSwgJHRoaXMgPSB0aGlzLCBzY29wZSA9IG9iaiwgQW5pbWF0ZSA9IHNlbGYgJiYgc2VsZi5BbmltYXRlLCBwYXJlbnQgPSAoJGNhbGxlZSB8fCB7fSkuX3N1cGVyO1xuXG4gICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9vYmogPSB7XG4gICAgICAgICAgICAnbmF2SW5kZXgnOiAnYmxvZycsXG4gICAgICAgICAgICAnY2xhc3NOYW1lJzogJ2RvY3VtZW50LXBhZ2UgYmxvZy1wYWdlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyZW50LmNhbGwoJHRoaXMsIF9vYmosIF9WZHQsIGJsb2NrcywgcGFyZW50KVxuICAgIH0pLmNhbGwoJHRoaXMpXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS9wYWdlcy9ibG9nL2luZGV4LnZkdCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmJsb2ctcGFnZSAuY29udGVudC13cmFwcGVyIHtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XFxufVxcbi5ibG9nLXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhc2lkZSB7XFxuICB3aWR0aDogMzUwcHg7XFxuICBib3JkZXI6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcbn1cXG4uYmxvZy1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSB7XFxuICBib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgwLDAsMCwwLjA4KTtcXG59XFxuLmJsb2ctcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIHtcXG4gIG1hcmdpbjogMzBweDtcXG59XFxuLmJsb2ctcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIC5hc2lkZS1ib3JkZXIge1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxufVxcbi5ibG9nLXBhZ2UgLmNvbnRlbnQtd3JhcHBlci5maXhlZCAuYXNpZGUtd3JhcHBlciB7XFxuICBtYXJnaW4tcmlnaHQ6IC05OTlweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDk5OXB4O1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIHdpZHRoOiBhdXRvO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vc3R5bHVzLWxvYWRlcj97XCJpbmNsdWRlIGNzc1wiOnRydWV9IS4vc2l0ZS9wYWdlcy9ibG9nL2luZGV4LnN0eWxcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vaW5kZXguc3R5bFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vaW5kZXguc3R5bFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMi0yIS4vaW5kZXguc3R5bFwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zaXRlL3BhZ2VzL2Jsb2cvaW5kZXguc3R5bFxuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=