webpackJsonp([2],Array(27).concat([
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _document = __webpack_require__(140);

var _document2 = _interopRequireDefault(_document);

var _document3 = __webpack_require__(174);

var _document4 = _interopRequireDefault(_document3);

var _throttle = __webpack_require__(170);

var _throttle2 = _interopRequireDefault(_throttle);

var _shuffle = __webpack_require__(168);

var _shuffle2 = _interopRequireDefault(_shuffle);

var _debounce = __webpack_require__(73);

var _debounce2 = _interopRequireDefault(_debounce);

var _utils = __webpack_require__(137);

var _layout = __webpack_require__(138);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

// for debug
window.Intact = Intact;
window._ = { throttle: _throttle2['default'], shuffle: _shuffle2['default'], debounce: _debounce2['default'] };
window.$ = $;

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Layout) {
    _inherits(_default, _Layout);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Layout.apply(this, arguments));
    }

    _default.prototype.defaults = function defaults() {
        return {
            docPath: './docs'
        };
    };

    _default.prototype._init = function _init() {
        var _this2 = this;

        return fetch(this.get('docPath') + '/' + this.get('title') + '.md').then(function (response) {
            return response.text();
        }).then(function (md) {
            _this2.set('content', _utils.marked.render(md));
        });
    };

    _default.prototype._mount = function _mount() {
        _Layout.prototype._mount.call(this);
        var codes = this.element.querySelectorAll('pre code');
        codes.forEach(function (item) {
            _utils.highlight.highlightBlock(item);
        });
        var catalogs = [];
        catalogs.active = 'active1';
        this.element.querySelectorAll('h1').forEach(function (item) {
            var catalog = { title: item.innerText };
            var nextSibling = item.nextSibling;
            while (nextSibling) {
                var tagName = (nextSibling.tagName || '').toLowerCase();
                if (tagName === 'h1') break;
                if (tagName === 'h2') {
                    if (!catalog.subs) {
                        catalog.subs = [];
                        catalog.subs.active = 'active2';
                    }
                    catalog.subs.push({
                        title: nextSibling.innerText
                    });
                }
                nextSibling = nextSibling.nextSibling;
            }
            catalogs.push(catalog);
        });
        this.set('subCatalogs', catalogs);

        this.evalScript();
        this.onScroll();
    };

    _default.prototype.evalScript = function evalScript() {
        var $examples = $(this.element).find('.example');
        var template = void 0;
        for (var i = 0; i < $examples.length; i++) {
            var $example = $examples.eq(i);
            var code = $example.text();
            if ($example.hasClass('auto')) {
                var _C = void 0;
                if ($example.hasClass('language-html')) {
                    template = Intact.Vdt.compile(code);
                    _C = Intact.extend({
                        template: template
                    });
                } else if ($example.hasClass('javascript')) {
                    _C = eval(code);
                }
                var $container = $('<div class="output"></div>');
                $example.parent().after($container);
                Intact.mount(_C, $container[0]);
            } else if ($example.hasClass('manual')) {
                var $button = $('<button>点击运行</button>');
                var $p = $('<p></p>').append($button);
                $example.parent().after($p);
                $button.on('click', function (code) {
                    return function () {
                        eval(code);
                    };
                }(code));
            } else if ($example.hasClass('language-html')) {
                template = Intact.Vdt.compile(code);
            } else if ($example.hasClass('javascript')) {
                eval(code);
            } else if ($example.hasClass('language-css')) {
                $example.parent().after('<style>' + code + '</style>');
            }
        }

        // 执行script标签
        var $scripts = $(this.element).find('script');
        for (var _i = 0; _i < $scripts.length; _i++) {
            var $script = $scripts.eq(_i);
            var _code = $script.text();
            eval(_code);
        }
    };

    _default.prototype.onScroll = function onScroll() {
        var _this3 = this;

        var $wrapper = $(this.element).find('.content-wrapper');
        var $article = $(this.element).find('article');
        var $h1s = $article.find('h1');
        var $h2s = $article.find('h2');
        var $aside = $(this.element).find('aside');
        var $border = $aside.find('.aside-border');
        var $window = $(window);
        $window.off('scroll');
        $window.on('scroll.fix', function () {
            var scrollTop = $(window).scrollTop();
            $wrapper[scrollTop >= 15 ? 'addClass' : 'removeClass']('fixed');
        });
        $window.on('scroll.active', (0, _throttle2['default'])(function () {
            var scrollTop = $(window).scrollTop();

            function findActive($hs) {
                var minTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                for (var i = $hs.length - 1; i >= 0; i--) {
                    var $h = $hs.eq(i);
                    var top = $h.position().top;
                    if (top > minTop && scrollTop >= top - 60) {
                        return {
                            text: $h.text(),
                            top: top
                        };
                    }
                }
                return { text: '', top: 0 };
            }

            var active1 = findActive($h1s);
            var active2 = findActive($h2s, active1.top);

            _this3.set({
                active2: active2.text,
                active1: active1.text
            });

            var $activeA = $aside.find('.active').last().children('a');
            if ($activeA.length) {
                var height = $activeA.height();
                var top = $activeA.position().top;
                $border.css({ height: height, top: top });
            }
        }, 50));
        $window.trigger('scroll');
    };

    _default.prototype.scrollTo = function scrollTo(text, type) {
        var _this4 = this;

        var $article = $(this.element).find('article');
        var $hs = $article.find(type === 'active1' ? 'h1' : 'h2');

        for (var i = 0; i < $hs.length; i++) {
            var $h = $hs.eq(i);
            if ($h.text() === text) {
                var top = $h.position().top;
                $(window).off('scroll.active');
                $('html, body').animate({
                    scrollTop: top - 60
                }, {
                    complete: function complete() {
                        _this4.onScroll();
                    }
                });
                break;
            }
        }
    };

    _default.prototype._destroy = function _destroy() {
        $(window).off('scroll');
    };

    return _default;
}(_layout2['default']), _class2.template = _document2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)["default"], __webpack_require__(26)))

/***/ }),
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  }
  // control codes
  if (c >= 0x00 && c <= 0x08) {
    return false;
  }
  if (c === 0x0B) {
    return false;
  }
  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }
  if (c >= 0x7F && c <= 0x9F) {
    return false;
  }
  // out of range
  if (c > 0x10FFFF) {
    return false;
  }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(60);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __webpack_require__(55);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}

// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21 /* ! */:
    case 0x22 /* " */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x27 /* ' */:
    case 0x28 /* ( */:
    case 0x29 /* ) */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2C /* , */:
    case 0x2D /* - */:
    case 0x2E /* . */:
    case 0x2F /* / */:
    case 0x3A /* : */:
    case 0x3B /* ; */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x3F /* ? */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7C /* | */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib = {};
exports.lib.mdurl = __webpack_require__(64);
exports.lib.ucmicro = __webpack_require__(136);

exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),
/* 53 */
/***/ (function(module, exports) {



/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};

// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [''];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};

/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};

/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),
/* 54 */
/***/ (function(module, exports) {



/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden = false;
}

/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};

/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};

/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};

/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E49\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(70),
    getRawTag = __webpack_require__(153),
    objectToString = __webpack_require__(158);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(71);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {



/*eslint quotes:0*/
module.exports = __webpack_require__(139);

/***/ }),
/* 61 */
/***/ (function(module, exports) {



var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),
/* 62 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,

      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,

      // Token level.
      //
      level: state.level,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
        continue;
      }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
};

/***/ }),
/* 63 */
/***/ (function(module, exports) {



// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E /* ~ */) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};

// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E /* ~ */) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';

    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {



module.exports.encode = __webpack_require__(131);
module.exports.decode = __webpack_require__(130);
module.exports.format = __webpack_require__(132);
module.exports.parse = __webpack_require__(133);

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 69 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(59);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(69)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom = __webpack_require__(147);

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
    var index = -1,
        length = array.length,
        lastIndex = length - 1;

    size = size === undefined ? length : size;
    while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
    }
    array.length = size;
    return array;
}

module.exports = shuffleSelf;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(57),
    now = __webpack_require__(167),
    toNumber = __webpack_require__(171);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    var nav = [{
        title: '教程',
        href: 'document'
    }, {
        title: 'API',
        href: 'api'
    }, {
        title: 'Blog',
        href: 'blog'
    }];
    return h('div', null, [h('div', null, h('header', null, (_blocks['header'] = function (parent) {
        return [h('a', {
            'href': '#/'
        }, 'Intact', 'logo'), h('nav', null, [__m(function () {
            try {
                return nav;
            } catch (e) {
                _e(e);
            }
        }.call($this), function (value, key) {
            return h('a', {
                'href': function () {
                    try {
                        return '#/' + value.href;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this)
            }, function () {
                try {
                    return value.title;
                } catch (e) {
                    _e(e);
                }
            }.call($this), _className(function () {
                try {
                    return {
                        active: value.href === scope.navIndex
                    };
                } catch (e) {
                    _e(e);
                }
            }.call($this)));
        }, $this), h('div', null, null, 'border')])];
    }) && (__blocks['header'] = function (parent) {
        var args = arguments;
        return blocks['header'] ? blocks['header'].apply($this, [function () {
            return _blocks['header'].apply($this, args);
        }].concat(__slice.call(args, 1))) : _blocks['header'].apply($this, args);
    }) && __blocks['header'].apply($this, [__noop])), 'header-wrapper'), h('div', null, (_blocks['content'] = function (parent) {
        return null;
    }) && (__blocks['content'] = function (parent) {
        var args = arguments;
        return blocks['content'] ? blocks['content'].apply($this, [function () {
            return _blocks['content'].apply($this, args);
        }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
    }) && __blocks['content'].apply($this, [__noop]), 'content-wrapper')], _className(function () {
        try {
            return 'main-wrapper ' + (scope.className || '');
        } catch (e) {
            _e(e);
        }
    }.call($this)));
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function (factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if (true) {
    factory(exports);
  } else if (globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return globalObject.hljs;
      });
    }
  }
})(function (hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i];

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent) {
    // inherit(parent, override_obj, override_obj, ...)
    var key;
    var result = {};
    var objects = Array.prototype.slice.call(arguments, 1);

    for (key in parent) {
      result[key] = parent[key];
    }objects.forEach(function (obj) {
      for (key in obj) {
        result[key] = obj[key];
      }
    });
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:
       if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;
       ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {
        return ' ' + a.nodeName + '="' + escape(a.value).replace('"', '&quot;') + '"';
      }
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function expand_mode(mode) {
    if (mode.variants && !mode.cached_variants) {
      mode.cached_variants = mode.variants.map(function (variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];
  }

  function compileLanguage(language) {

    function reStr(re) {
      return re && re.source || re;
    }

    function langRe(value, global) {
      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }

    function compileMode(mode, parent) {
      if (mode.compiled) return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function flatten(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function (kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') {
          // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin) mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null) mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {
        return expand_mode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function (c) {
        compileMode(c, mode);
      });

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators = mode.contains.map(function (c) {
        return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function exec() /*s*/{
          return null;
        } };
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:
   - relevance (int)
  - value (an HTML string with highlighting markup)
   */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan = '<span class="' + classPrefix,
          closeSpan = leaveOpen ? '' : spanEndTag;

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords) return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substring(last_index, match.index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += top.subLanguage != null ? processSubLanguage() : processKeywords();
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className ? buildSpan(mode.className, '', true) : '';
      top = Object.create(mode, { parent: { value: top } });
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '',
        current;
    for (current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match,
          count,
          index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match) break;
        count = processLexeme(value.substring(index, match.index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for (current = top; current.parent; current = current.parent) {
        // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:
   - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)
   */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:
   - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers
   */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {
      if (options.useBR && match === '\n') {
        return '<br>';
      } else if (options.tabReplace) {
        return p1.replace(/\t/g, options.tabReplace);
      }
      return '';
    });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language)) return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function (alias) {
        aliases[alias] = name;
      });
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
      className: 'comment',
      begin: begin, end: end,
      contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [hljs.BACKSLASH_ESCAPE, {
      begin: /\[/, end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
});

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var VAR = {
    className: 'variable',
    variants: [{ begin: /\$[\w\d#@][\w\d_]*/ }, { begin: /\$\{(.*?)}/ }]
  };
  var QUOTE_STRING = {
    className: 'string',
    begin: /"/, end: /"/,
    contains: [hljs.BACKSLASH_ESCAPE, VAR, {
      className: 'variable',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    }]
  };
  var APOS_STRING = {
    className: 'string',
    begin: /'/, end: /'/
  };

  return {
    aliases: ['sh', 'zsh'],
    lexemes: /\b-?[a-z\._]+\b/,
    keywords: {
      keyword: 'if then else elif fi for while in do done case esac function',
      literal: 'true false',
      built_in:
      // Shell built-ins
      // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' + 'trap umask unset ' +
      // Bash built-ins
      'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' + 'read readarray source type typeset ulimit unalias ' +
      // Shell modifiers
      'set shopt ' +
      // Zsh built-ins
      'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' + 'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' + 'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' + 'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' + 'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' + 'zpty zregexparse zsocket zstyle ztcp',
      _: '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster
    },
    contains: [{
      className: 'meta',
      begin: /^#![^\n]+sh\s*$/,
      relevance: 10
    }, {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, hljs.HASH_COMMENT_MODE, QUOTE_STRING, APOS_STRING, VAR]
  };
};

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  var RULE = {
    begin: /[A-Z\_\.\-]+\s*:/, returnBegin: true, end: ';', endsWithParent: true,
    contains: [{
      className: 'attribute',
      begin: /\S/, end: ':', excludeEnd: true,
      starts: {
        endsWithParent: true, excludeEnd: true,
        contains: [{
          begin: /[\w-]+\(/, returnBegin: true,
          contains: [{
            className: 'built_in',
            begin: /[\w-]+/
          }, {
            begin: /\(/, end: /\)/,
            contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
          }]
        }, hljs.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, hljs.C_BLOCK_COMMENT_MODE, {
          className: 'number', begin: '#[0-9A-Fa-f]+'
        }, {
          className: 'meta', begin: '!important'
        }]
      }
    }]
  };

  return {
    case_insensitive: true,
    illegal: /[=\/|'\$]/,
    contains: [hljs.C_BLOCK_COMMENT_MODE, {
      className: 'selector-id', begin: /#[A-Za-z0-9_-]+/
    }, {
      className: 'selector-class', begin: /\.[A-Za-z0-9_-]+/
    }, {
      className: 'selector-attr',
      begin: /\[/, end: /\]/,
      illegal: '$'
    }, {
      className: 'selector-pseudo',
      begin: /:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/
    }, {
      begin: '@(font-face|page)',
      lexemes: '[a-z-]+',
      keywords: 'font-face page'
    }, {
      begin: '@', end: '[{;]', // at_rule eating first "{" is a good thing
      // because it doesn’t let it to be parsed as
      // a rule set but instead drops parser into
      // the default mode which is how it should be.
      illegal: /:/, // break on Less variables @var: ...
      contains: [{
        className: 'keyword',
        begin: /\w+/
      }, {
        begin: /\s/, endsWithParent: true, excludeEnd: true,
        relevance: 0,
        contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, hljs.CSS_NUMBER_MODE]
      }]
    }, {
      className: 'selector-tag', begin: IDENT_RE,
      relevance: 0
    }, {
      begin: '{', end: '}',
      illegal: /\S/,
      contains: [hljs.C_BLOCK_COMMENT_MODE, RULE]
    }]
  };
};

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
  var KEYWORDS = {
    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' +
    // ECMAScript 6 modules import
    'import from as',

    literal: 'true false null undefined NaN Infinity',
    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'
  };
  var EXPRESSIONS;
  var NUMBER = {
    className: 'number',
    variants: [{ begin: '\\b(0[bB][01]+)' }, { begin: '\\b(0[oO][0-7]+)' }, { begin: hljs.C_NUMBER_RE }],
    relevance: 0
  };
  var SUBST = {
    className: 'subst',
    begin: '\\$\\{', end: '\\}',
    keywords: KEYWORDS,
    contains: [] // defined later
  };
  var TEMPLATE_STRING = {
    className: 'string',
    begin: '`', end: '`',
    contains: [hljs.BACKSLASH_ESCAPE, SUBST]
  };
  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];
  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);

  return {
    aliases: ['js', 'jsx'],
    keywords: KEYWORDS,
    contains: [{
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, {
      className: 'meta',
      begin: /^#!/, end: /$/
    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, { // object attr container
      begin: /[{,]\s*/, relevance: 0,
      contains: [{
        begin: IDENT_RE + '\\s*:', returnBegin: true,
        relevance: 0,
        contains: [{ className: 'attr', begin: IDENT_RE, relevance: 0 }]
      }]
    }, { // "value" container
      begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
      keywords: 'return throw case',
      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {
        className: 'function',
        begin: '(\\(.*?\\)|' + IDENT_RE + ')\\s*=>', returnBegin: true,
        end: '\\s*=>',
        contains: [{
          className: 'params',
          variants: [{
            begin: IDENT_RE
          }, {
            begin: /\(\s*\)/
          }, {
            begin: /\(/, end: /\)/,
            excludeBegin: true, excludeEnd: true,
            keywords: KEYWORDS,
            contains: PARAMS_CONTAINS
          }]
        }]
      }, { // E4X / JSX
        begin: /</, end: /(\/\w+|\w+\/)>/,
        subLanguage: 'xml',
        contains: [{ begin: /<\w+\s*\/>/, skip: true }, {
          begin: /<\w+/, end: /(\/\w+|\w+\/)>/, skip: true,
          contains: [{ begin: /<\w+\s*\/>/, skip: true }, 'self']
        }]
      }],
      relevance: 0
    }, {
      className: 'function',
      beginKeywords: 'function', end: /\{/, excludeEnd: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }), {
        className: 'params',
        begin: /\(/, end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        contains: PARAMS_CONTAINS
      }],
      illegal: /\[|%/
    }, {
      begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
    }, hljs.METHOD_GUARD, { // ES6 class
      className: 'class',
      beginKeywords: 'class', end: /[{;=]/, excludeEnd: true,
      illegal: /[:"\[\]]/,
      contains: [{ beginKeywords: 'extends' }, hljs.UNDERSCORE_TITLE_MODE]
    }, {
      beginKeywords: 'constructor', end: /\{/, excludeEnd: true
    }],
    illegal: /#(?!!)/
  };
};

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = function (hljs) {
  var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
  var TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [{
      className: 'attr',
      begin: XML_IDENT_RE,
      relevance: 0
    }, {
      begin: /=\s*/,
      relevance: 0,
      contains: [{
        className: 'string',
        endsParent: true,
        variants: [{ begin: /"/, end: /"/ }, { begin: /'/, end: /'/ }, { begin: /[^\s"'=<>`]+/ }]
      }]
    }]
  };
  return {
    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
    case_insensitive: true,
    contains: [{
      className: 'meta',
      begin: '<!DOCTYPE', end: '>',
      relevance: 10,
      contains: [{ begin: '\\[', end: '\\]' }]
    }, hljs.COMMENT('<!--', '-->', {
      relevance: 10
    }), {
      begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
      relevance: 10
    }, {
      begin: /<\?(php)?/, end: /\?>/,
      subLanguage: 'php',
      contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
    }, {
      className: 'tag',
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending braket. The '$' is needed for the lexeme to be recognized
      by hljs.subMode() that tests lexemes outside the stream.
      */
      begin: '<style(?=\\s|>|$)', end: '>',
      keywords: { name: 'style' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '</style>', returnEnd: true,
        subLanguage: ['css', 'xml']
      }
    }, {
      className: 'tag',
      // See the comment in the <style tag about the lookahead pattern
      begin: '<script(?=\\s|>|$)', end: '>',
      keywords: { name: 'script' },
      contains: [TAG_INTERNALS],
      starts: {
        end: '\<\/script\>', returnEnd: true,
        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
      }
    }, {
      className: 'meta',
      variants: [{ begin: /<\?xml/, end: /\?>/, relevance: 10 }, { begin: /<\?\w+/, end: /\?>/ }]
    }, {
      className: 'tag',
      begin: '</?', end: '/?>',
      contains: [{
        className: 'name', begin: /[^\/><\s]+/, relevance: 0
      }, TAG_INTERNALS]
    }]
  };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {



////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === '[object String]';
}
function isObject(obj) {
  return _class(obj) === '[object Object]';
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}
function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth +
        // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function validate(text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(83)(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) {
      return;
    }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uFF5C]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = '';
  this.__text_cache__ = '';

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};

/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};

/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};

/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = __webpack_require__(67).source;
  re.src_Cc = __webpack_require__(65).source;
  re.src_Z = __webpack_require__(66).source;
  re.src_P = __webpack_require__(55).source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uFF5C]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

  re.src_xn = 'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

  // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';

  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' +
  // don't allow `--` in domain names, because:
  // - that can conflict with markdown &mdash; / &ndash;
  // - nobody use those anyway
  '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';

  re.src_host = '(?:' +
  // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain /*_root*/ + ')' + ')';

  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';

  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict = re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
  // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uFF5C])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

/***/ }),
/* 84 */
/***/ (function(module, exports) {


/* eslint-disable no-cond-assign */

var tagExpr = /^<!-- ?\{(?:([a-z0-9]+)(\^[0-9]*)?: ?)?(.*)\} ?-->\n?$/;

module.exports = function attributes(md) {
  md.core.ruler.push('curly_attributes', curlyAttrs);
};

/*
 * List of tag -> token type mappings. Eg, `<li>` is `list_item_open`.
 */

var opening = {
  li: ['list_item'],
  ul: ['bullet_list'],
  p: ['paragraph'],
  ol: ['ordered_list'],
  blockquote: ['blockquote'],
  h1: ['heading'],
  h2: ['heading'],
  h3: ['heading'],
  h4: ['heading'],
  h5: ['heading'],
  h6: ['heading'],
  a: ['link'],
  code: ['code_inline', 'code_block', 'fence']
};

var selfClosing = {
  hr: true,
  image: true

  /**
   * ...
   */

};function curlyAttrs(state) {
  var tokens = state.tokens;
  var omissions = [];
  var parent, m;
  var stack = { len: 0, contents: [], types: {} };

  tokens.forEach(function (token, i) {
    // Save breadcrumbs so html_block will pick it up
    if (isOpener(token.type) || selfClosing[token.type]) {
      spush(stack, token);
    }

    // "# Hello\n<!--{.classname}-->"
    // ...sequence of [heading_open, inline, heading_close, html_block]
    if (token.type === 'html_block') {
      m = token.content.match(tagExpr);
      if (!m) return;

      parent = findParent(stack, m[1], m[2]);
      if (parent && applyToToken(parent, m[3])) {
        omissions.unshift(i);
      }
    }

    // "# Hello <!--{.classname} -->"
    // { type: 'inline', children: { ..., '<!--{...}-->' } }
    if (token.type === 'inline') {
      curlyInline(token.children, stack);
    }
  });

  // Remove <!--...--> html_block tokens
  omissions.forEach(function (idx) {
    return tokens.splice(idx, 1);
  });
}

/**
 * Internal: checks in a token type is a block opener
 */

function isOpener(type) {
  return type.match(/_(open|start)$/) || type === 'fence' || type === 'code_block';
}

/**
 * Internal: Run through inline and stuff
 */

function curlyInline(children, stack) {
  var lastText, m, parent;

  // Keep a list of sub-tokens to be removed
  var omissions = [];

  children.forEach(function (child, i) {
    if (isOpener(child.type) || selfClosing[child.type] || child.type === 'code_inline') {
      spush(stack, child);
    }

    // Decorate tags are found
    if (m = child.content.match(tagExpr)) {
      var tag = m[1];
      var depth = m[2];
      var attrs = m[3];

      // Remove the comment, then remove the extra space
      parent = findParent(stack, tag, depth);
      if (parent && applyToToken(parent, attrs)) {
        omissions.unshift(i);
        if (lastText) trimRight(lastText, 'content');
      }
    }

    if (child.type === 'text') lastText = child;
  });

  // Remove them in a separate step so we don't
  omissions.forEach(function (idx) {
    children.splice(idx, 1);
  });
}

/**
 * Private: given a list of tokens `list` and `lastParent`, find the one that
 * matches `tag`.
 */

function findParent(stack, tag, depth) {
  if (!tag) return stack.last;

  if (depth === '^') {
    depth = 1;
  } else if (typeof depth === 'string') {
    /* '^2' */
    depth = +depth.substr(1);
  } else {
    depth = 0;
  }

  var targets = opening[tag.toLowerCase()] || [tag.toLowerCase()];

  var target = targets.filter(function (target) {
    return stack.types[target];
  });

  var list = stack.types[target];
  if (!list) return; // Can't find tag `tag`

  return list[list.length - 1 - depth];
}

/**
 * Private: trim the right
 */

function trimRight(obj, attr) {
  obj[attr] = obj[attr].replace(/\s*$/, '');
}

/**
 * Private: apply tag to token
 *
 *     applyToToken(token, '.classname')
 */

function applyToToken(token, attrs) {
  var m;
  var todo = [];

  while (attrs.length > 0) {
    if (m = attrs.match(/^\s*\.([a-zA-Z0-9\-_]+)/)) {
      todo.push(['class', m[1], { append: true }]);
      shift();
    } else if (m = attrs.match(/^\s*#([a-zA-Z0-9\-_]+)/)) {
      todo.push(['id', m[1]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)="([^"]*)"/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)='([^']*)'/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)=([^ ]*)/)) {
      todo.push([m[1], m[2]]);
      shift();
    } else if (m = attrs.match(/^\s*([a-zA-Z0-9\-_]+)/)) {
      todo.push([m[1], '']);
      shift();
    } else if (m = attrs.match(/^\s+/)) {
      shift();
    } else {
      return;
    }
  }

  todo.forEach(function (args) {
    setAttr.apply(this, [token].concat(args));
  });
  return true;

  function shift() {
    attrs = attrs.substr(m[0].length);
  }
}

/**
 * Private: sets an attribute `attr` to `value` in a token. If `options.append`
 * is true, append to the old value instead of overwriting it.
 */

function setAttr(token, attr, value, options) {
  var idx = token.attrIndex(attr);

  if (idx === -1) {
    token.attrPush([attr, value]);
  } else if (options && options.append) {
    token.attrs[idx][1] = token.attrs[idx][1] + ' ' + value;
  } else {
    token.attrs[idx][1] = value;
  }
}

/**
 * Private: pushes a token to the stack
 */

function spush(stack, token) {
  var type = token.type.replace(/_(open|start)$/, '');
  if (!stack.types[type]) {
    stack.types[type] = [];
  }
  stack.types[type].push(token);
  stack.last = token;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {



module.exports = __webpack_require__(91);

/***/ }),
/* 86 */
/***/ (function(module, exports) {



module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {



exports.parseLinkLabel = __webpack_require__(89);
exports.parseLinkDestination = __webpack_require__(88);
exports.parseLinkTitle = __webpack_require__(90);

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;
var unescapeAll = __webpack_require__(52).unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */ || isSpace(code)) {
          return result;
        }
        if (code === 0x3E /* > */) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
        level++;
      }

    if (code === 0x29 /* ) */) {
        if (level === 0) {
          break;
        }
        level--;
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),
/* 89 */
/***/ (function(module, exports) {



module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {



var unescapeAll = __webpack_require__(52).unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
      return result;
    }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {



var utils = __webpack_require__(52);
var helpers = __webpack_require__(87);
var Renderer = __webpack_require__(98);
var ParserCore = __webpack_require__(93);
var ParserBlock = __webpack_require__(92);
var ParserInline = __webpack_require__(94);
var LinkifyIt = __webpack_require__(82);
var mdurl = __webpack_require__(64);
var punycode = __webpack_require__(134);

var config = {
  'default': __webpack_require__(96),
  zero: __webpack_require__(97),
  commonmark: __webpack_require__(95)
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {/**/}
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}

/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;

  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);

  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}

/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};

/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};

/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};

/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};

/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};

/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};

/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};

/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

var _rules = [
// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(110), ['paragraph', 'reference']], ['code', __webpack_require__(100)], ['fence', __webpack_require__(101), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(99), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(103), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(106), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(108)], ['heading', __webpack_require__(102), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(105)], ['html_block', __webpack_require__(104), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(107)]];

/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}

// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) {
      break;
    }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};

/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(109);

module.exports = ParserBlock;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

var _rules = [['normalize', __webpack_require__(114)], ['block', __webpack_require__(111)], ['inline', __webpack_require__(112)], ['linkify', __webpack_require__(113)], ['replacements', __webpack_require__(115)], ['smartquotes', __webpack_require__(116)]];

/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(117);

module.exports = Core;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {



var Ruler = __webpack_require__(53);

////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [['text', __webpack_require__(128)], ['newline', __webpack_require__(126)], ['escape', __webpack_require__(122)], ['backticks', __webpack_require__(119)], ['strikethrough', __webpack_require__(63).tokenize], ['emphasis', __webpack_require__(62).tokenize], ['link', __webpack_require__(125)], ['image', __webpack_require__(124)], ['autolink', __webpack_require__(118)], ['html_inline', __webpack_require__(123)], ['entity', __webpack_require__(121)]];

var _rules2 = [['balance_pairs', __webpack_require__(120)], ['strikethrough', __webpack_require__(63).postProcess], ['emphasis', __webpack_require__(62).postProcess], ['text_collapse', __webpack_require__(129)]];

/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(127);

module.exports = ParserInline;

/***/ }),
/* 95 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: true, // Enable HTML tags in source
    xhtmlOut: true, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },

    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),
/* 96 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 100 // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),
/* 97 */
/***/ (function(module, exports) {



module.exports = {
  options: {
    html: false, // Enable HTML tags in source
    xhtmlOut: false, // Use '/' to close single tags (<br />)
    breaks: false, // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-', // CSS language prefix for fenced blocks
    linkify: false, // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer: false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201C\u201D\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting: 20 // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: ['normalize', 'block', 'inline']
    },

    block: {
      rules: ['paragraph']
    },

    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {



var assign = __webpack_require__(52).assign;
var unescapeAll = __webpack_require__(52).unescapeAll;
var escapeHtml = __webpack_require__(52).escapeHtml;

////////////////////////////////////////////////////////////////////////////////

var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}

/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};

/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};

/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};

/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};

/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
      return false;
    }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) {
    return true;
  }

  // skip spaces after ">" and re-calculate offset
  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;

  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false;

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E /* > */ && !wasOutdented) {
      // This line is inside the blockquote.

      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) {
      break;
    }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];

  state.md.block.tokenize(state, startLine, nextLine);

  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

/***/ }),
/* 100 */
/***/ (function(module, exports) {



module.exports = function code(state, startLine, endLine /*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {



module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  }

  // Since start is found, we can report success here in validation mode
  if (silent) {
    return true;
  }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) {
      continue;
    }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];

  return true;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23 /* # */ || pos >= max) {
    return false;
  }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
      return false;
    }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;

  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {



var block_names = __webpack_require__(86);
var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(61).HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }

  state.line = nextLine;

  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

/***/ }),
/* 105 */
/***/ (function(module, exports) {



module.exports = function lheading(state, startLine, endLine /*, silent*/) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D /* - */ || marker === 0x3D /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D /* = */ ? 1 : 2;
              break;
            }
          }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];

  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      }

    // found valid marker
    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) {
    return true;
  }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;

    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),
/* 107 */
/***/ (function(module, exports) {



module.exports = function paragraph(state, startLine /*, endLine*/) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];

  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];

  token = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
      return false;
    }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
            return false;
          }
        break;
      }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) {
      continue;
    }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
      return false;
    }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);
var isSpace = __webpack_require__(52).isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = []; // line begin offsets for fast jumps
  this.eMarks = []; // line end offsets for fast jumps
  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
  this.sCount = []; // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)
  this.line = 0; // line index in src
  this.lineMax = 0; // lines count
  this.tight = false; // loose/tight mode for lists
  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;

module.exports = StateBlock;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;

  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60 /* ` */) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c /* \ */) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++;

    // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character
    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));

  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;

  // should have at least two lines
  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A /* : */) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

  // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)
  columnCount = columns.length;
  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];

  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];

  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];
    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];

    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);

  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));

    token = state.push('tr_open', 'tr', 1);
    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }
  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {



module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports) {



module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {



var arrayReplaceAt = __webpack_require__(52).arrayReplaceAt;

function isLinkOpen(str) {
  return (/^<a[>\s]/i.test(str)
  );
}
function isLinkClose(str) {
  return (/^<\/a\s*>/i.test(str)
  );
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);

          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),
/* 114 */
/***/ (function(module, exports) {



var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

/***/ }),
/* 115 */
/***/ (function(module, exports) {



// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±')
        // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
        // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
        // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {



var isWhiteSpace = __webpack_require__(52).isWhiteSpace;
var isPunctChar = __webpack_require__(52).isPunctChar;
var isMdAsciiPunct = __webpack_require__(52).isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'";

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (tokens[j].type !== 'text') continue;

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (tokens[j].type !== 'text') continue;

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) {
            break;
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;

module.exports = StateCore;

/***/ }),
/* 118 */
/***/ (function(module, exports) {



/*eslint max-len:0*/
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);

    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);

    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';

      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),
/* 119 */
/***/ (function(module, exports) {



module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60 /* ` */) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
    pos++;
  }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }
  state.pos += marker.length;
  return true;
};

/***/ }),
/* 120 */
/***/ (function(module, exports) {



module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {



var entities = __webpack_require__(60);
var has = __webpack_require__(52).has;
var isValidEntityCode = __webpack_require__(52).isValidEntityCode;
var fromCodePoint = __webpack_require__(52).fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }
  state.pos++;
  return true;
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {



var HTML_TAG_RE = __webpack_require__(61).HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
      return false;
    }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          state.pos = oldPos;
          return false;
        }
      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(content, state.md, state.env, tokens = []);

    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {



var normalizeReference = __webpack_require__(52).normalizeReference;
var isSpace = __webpack_require__(52).isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }
      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];
    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);

    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {



var isSpace = __webpack_require__(52).isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {



var Token = __webpack_require__(54);
var isWhiteSpace = __webpack_require__(52).isWhiteSpace;
var isPunctChar = __webpack_require__(52).isPunctChar;
var isMdAsciiPunct = __webpack_require__(52).isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
};

// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
};

// re-export Token class to use in block rules
StateInline.prototype.Token = Token;

module.exports = StateInline;

/***/ }),
/* 128 */
/***/ (function(module, exports) {



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A /* \n */:
    case 0x21 /* ! */:
    case 0x23 /* # */:
    case 0x24 /* $ */:
    case 0x25 /* % */:
    case 0x26 /* & */:
    case 0x2A /* * */:
    case 0x2B /* + */:
    case 0x2D /* - */:
    case 0x3A /* : */:
    case 0x3C /* < */:
    case 0x3D /* = */:
    case 0x3E /* > */:
    case 0x40 /* @ */:
    case 0x5B /* [ */:
    case 0x5C /* \ */:
    case 0x5D /* ] */:
    case 0x5E /* ^ */:
    case 0x5F /* _ */:
    case 0x60 /* ` */:
    case 0x7B /* { */:
    case 0x7D /* } */:
    case 0x7E /* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),
/* 129 */
/***/ (function(module, exports) {



module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),
/* 130 */
/***/ (function(module, exports) {



/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}

// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\uFFFD\uFFFD\uFFFD';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\uFFFD\uFFFD\uFFFD\uFFFD';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\uFFFD';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';

module.exports = decode;

/***/ }),
/* 131 */
/***/ (function(module, exports) {



var encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";

module.exports = encode;

/***/ }),
/* 132 */
/***/ (function(module, exports) {



module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

/***/ }),
/* 133 */
/***/ (function(module, exports) {



//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(68)) == 'object' && __webpack_require__(68)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module), __webpack_require__(69)))

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {



exports.Any = __webpack_require__(67);
exports.Cc = __webpack_require__(65);
exports.Cf = __webpack_require__(135);
exports.P = __webpack_require__(55);
exports.Z = __webpack_require__(66);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

exports.__esModule = true;
exports.marked = exports.highlight = undefined;

var _markdownIt = __webpack_require__(85);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _markdownItDecorate = __webpack_require__(84);

var _markdownItDecorate2 = _interopRequireDefault(_markdownItDecorate);

var _highlight = __webpack_require__(77);

var _highlight2 = _interopRequireDefault(_highlight);

var _javascript = __webpack_require__(80);

var _javascript2 = _interopRequireDefault(_javascript);

var _css = __webpack_require__(79);

var _css2 = _interopRequireDefault(_css);

var _xml = __webpack_require__(81);

var _xml2 = _interopRequireDefault(_xml);

var _bash = __webpack_require__(78);

var _bash2 = _interopRequireDefault(_bash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_highlight2['default'].registerLanguage('bash', _bash2['default']);
_highlight2['default'].registerLanguage('css', _css2['default']);
_highlight2['default'].registerLanguage('javascript', _javascript2['default']);
_highlight2['default'].registerLanguage('xml', _xml2['default']);

window.highlight = _highlight2['default'];

var marked = (0, _markdownIt2['default'])({
    html: true,
    breaks: false
}).use(_markdownItDecorate2['default']);
// 去掉段落softbreak
marked.renderer.rules.softbreak = function () {
    return '';
};

exports.highlight = _highlight2['default'];
exports.marked = marked;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Intact, $) {exports.__esModule = true;
exports['default'] = undefined;

var _dec, _desc, _value, _class, _init, _class2, _temp;

var _layout = __webpack_require__(76);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

var _default = (_dec = Intact.template(), (_class = (_temp = _class2 = function (_Intact) {
    _inherits(_default, _Intact);

    function _default() {
        _classCallCheck(this, _default);

        return _possibleConstructorReturn(this, _Intact.apply(this, arguments));
    }

    _default.prototype._mount = function _mount() {
        this.$border = $(this.element).find('.border');
        this._updateBorder();
    };

    _default.prototype._updateBorder = function _updateBorder() {
        var $nav = $(this.element).find('.active');
        var width = 0;
        var left = 0;
        if ($nav.length) {
            left = $nav.position().left;
            width = $nav.outerWidth();
        }
        this.$border.addClass('transition');
        this.$border.css({ width: width, left: left });
    };

    return _default;
}(Intact), _class2.template = _layout2['default'], _temp), (_applyDecoratedDescriptor(_class, 'template', [_dec], (_init = Object.getOwnPropertyDescriptor(_class, 'template'), _init = _init ? _init.value : undefined, {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function initializer() {
        return _init;
    }
}), _class)), _class));

exports['default'] = _default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)["default"], __webpack_require__(26)))

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = function (obj, _Vdt, blocks, $callee) {
    _Vdt || (_Vdt = Vdt);
    obj || (obj = {});
    blocks || (blocks = {});
    var h = _Vdt.miss.h,
        hc = _Vdt.miss.hc,
        hu = _Vdt.miss.hu,
        widgets = this && this.widgets || {},
        _blocks = {},
        __blocks = {},
        __u = _Vdt.utils,
        extend = __u.extend,
        _e = __u.error,
        _className = __u.className,
        __slice = __u.slice,
        __noop = __u.noop,
        __m = __u.map,
        __o = __u.Options,
        _getModel = __o.getModel,
        _setModel = __o.setModel,
        _setCheckboxModel = __u.setCheckboxModel,
        _detectCheckboxChecked = __u.detectCheckboxChecked,
        _setSelectModel = __u.setSelectModel,
        self = this.data,
        $this = this,
        scope = obj,
        Animate = self && self.Animate,
        parent = ($callee || {})._super;

    var catalogs = [{
        title: '基础',
        subCatalogs: [{
            title: '开始',
            href: 'start'
        }, {
            title: 'Intact实例',
            href: 'instance'
        }, {
            title: '组件生命周期',
            href: 'lifecycle'
        }, {
            title: '模板语法',
            href: 'syntax'
        }, {
            title: '事件处理',
            href: 'event'
        }, {
            title: '表单处理',
            href: 'form'
        }, {
            title: '组件',
            href: 'component'
        }, {
            title: '组件继承',
            href: 'extend'
        }]
    }, {
        title: '进阶',
        subCatalogs: [{
            title: '动画',
            href: 'animation'
        }, {
            title: '模板template',
            href: 'template'
        }, {
            title: '路由',
            href: 'router'
        }, {
            title: 'webpack实践',
            href: 'project'
        }, {
            title: '服务器端渲染',
            href: 'ssr'
        }]
    }, {
        title: '其它',
        subCatalogs: [{
            title: '更新日志',
            href: 'changelog'
        }]
    }];
    var currentNav = {};

    var Subs = function Subs(attr) {
        return function () {
            try {
                return attr.subs;
            } catch (e) {
                _e(e);
            }
        }.call($this) ? h('ul', null, __m(function () {
            try {
                return attr.subs;
            } catch (e) {
                _e(e);
            }
        }.call($this), function (value, key) {
            return h('li', null, [h('a', {
                'ev-click': function () {
                    try {
                        return self.scrollTo.bind(self, value.title, attr.subs.active);
                    } catch (e) {
                        _e(e);
                    }
                }.call($this)
            }, function () {
                try {
                    return value.title;
                } catch (e) {
                    _e(e);
                }
            }.call($this)), h(Subs, {
                'subs': function () {
                    try {
                        return value.subs;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this),
                '_context': $this
            })], _className(function () {
                try {
                    return {
                        active: self.get(attr.subs.active) === value.title
                    };
                } catch (e) {
                    _e(e);
                }
            }.call($this)));
        }, $this), 'sub-catalogs') : undefined;
    };
    return function () {
        var _obj = _extends({
            'navIndex': 'document',
            'className': 'document-page'
        }, function () {
            try {
                return scope;
            } catch (e) {
                _e(e);
            }
        }.call($this));
        return parent.call($this, _obj, _Vdt, function (blocks) {
            var _blocks = {},
                __blocks = extend({}, blocks);
            return (_blocks['content'] = function (parent) {
                return [h('aside', null, h('div', null, [__m(function () {
                    try {
                        return catalogs;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this), function (value, key) {
                    return h('div', null, [h('h5', null, function () {
                        try {
                            return value.title;
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)), h('ul', null, __m(function () {
                        try {
                            return value.subCatalogs;
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this), function (value, key) {
                        return h('li', null, [function () {
                            try {
                                return function () {
                                    if (value.href === self.get('title')) {
                                        currentNav = value;
                                    }
                                }();
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this), h('a', {
                            'href': function () {
                                try {
                                    return '#/document/' + value.href;
                                } catch (e) {
                                    _e(e);
                                }
                            }.call($this)
                        }, function () {
                            try {
                                return value.title;
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this)), function () {
                            try {
                                return value.href === self.get('title');
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this) ? h(Subs, {
                            'subs': function () {
                                try {
                                    return self.get('subCatalogs');
                                } catch (e) {
                                    _e(e);
                                }
                            }.call($this),
                            '_context': $this
                        }) : undefined], _className(function () {
                            try {
                                return {
                                    active: value.href === self.get('title')
                                };
                            } catch (e) {
                                _e(e);
                            }
                        }.call($this)));
                    }, $this))], 'catalog-section');
                }, $this), h('div', null, null, 'aside-border transition')], 'aside-wrapper')), h('article', null, [h('div', null, [h('div', null, function () {
                    try {
                        return currentNav.title;
                    } catch (e) {
                        _e(e);
                    }
                }.call($this), 'title'), h('div', null, ['\n                    如果你发现文档有问题，请帮忙在\n                    ', h('a', {
                    'target': '_blank',
                    'href': function () {
                        try {
                            return 'https://github.com/Javey/Intact/blob/master/docs/' + self.get('title') + '.md';
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)
                }, 'github'), '\n                    上修正该文档\n                '], 'edit-link')], 'article-head'), h('div', {
                    'innerHTML': function () {
                        try {
                            return self.get('content');
                        } catch (e) {
                            _e(e);
                        }
                    }.call($this)
                })])];
            }) && (__blocks['content'] = function (parent) {
                var args = arguments;
                return blocks['content'] ? blocks['content'].apply($this, [function () {
                    return _blocks['content'].apply($this, args);
                }].concat(__slice.call(args, 1))) : _blocks['content'].apply($this, args);
            }), __blocks;
        }.call($this, blocks), parent);
    }.call($this);
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(149),
    isArguments = __webpack_require__(160),
    isArray = __webpack_require__(74),
    isBuffer = __webpack_require__(162),
    isIndex = __webpack_require__(154),
    isTypedArray = __webpack_require__(165);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray = __webpack_require__(152),
    shuffleSelf = __webpack_require__(72);

/**
 * A specialized version of `_.shuffle` for arrays.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function arrayShuffle(array) {
  return shuffleSelf(copyArray(array));
}

module.exports = arrayShuffle;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(56),
    isObjectLike = __webpack_require__(58);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(56),
    isLength = __webpack_require__(75),
    isObjectLike = __webpack_require__(58);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(155),
    nativeKeys = __webpack_require__(156);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 147 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var shuffleSelf = __webpack_require__(72),
    values = __webpack_require__(172);

/**
 * The base implementation of `_.shuffle`.
 *
 * @private
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 */
function baseShuffle(collection) {
  return shuffleSelf(values(collection));
}

module.exports = baseShuffle;

/***/ }),
/* 149 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(142);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(70);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(159);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(71);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module)))

/***/ }),
/* 158 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(144),
    isObjectLike = __webpack_require__(58);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(163),
    isLength = __webpack_require__(75);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(59),
    stubFalse = __webpack_require__(169);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(56),
    isObject = __webpack_require__(57);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(56),
    isObjectLike = __webpack_require__(58);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(145),
    baseUnary = __webpack_require__(150),
    nodeUtil = __webpack_require__(157);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(141),
    baseKeys = __webpack_require__(146),
    isArrayLike = __webpack_require__(161);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(59);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var arrayShuffle = __webpack_require__(143),
    baseShuffle = __webpack_require__(148),
    isArray = __webpack_require__(74);

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  var func = isArray(collection) ? arrayShuffle : baseShuffle;
  return func(collection);
}

module.exports = shuffle;

/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(73),
    isObject = __webpack_require__(57);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(57),
    isSymbol = __webpack_require__(164);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(151),
    keys = __webpack_require__(166);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(15)(false);
// imports


// module
exports.push([module.i, ".hljs {\n  display: block;\n  overflow-x: auto;\n  color: #525252;\n  padding: 15px;\n  -webkit-text-size-adjust: none;\n  margin: 0;\n}\n.hljs-doctype {\n  color: #999;\n}\n.hljs-tag {\n  color: #3e76f6;\n}\n.hljs-attribute {\n  color: #e96900;\n}\n.hljs-value {\n  color: #42b983;\n}\n.hljs-keyword {\n  color: #e96900;\n}\n.hljs-string {\n  color: #42b983;\n}\n.hljs-comment {\n  color: #b3b3b3;\n}\n.hljs-operator .hljs-comment {\n  color: #525252;\n}\n.hljs-regexp {\n  color: #af7dff;\n}\n.hljs-built_in {\n  color: #2db7f5;\n}\n.css .hljs-class {\n  color: #e96900;\n}\n.css .hljs-number,\n.javascript .hljs-number {\n  color: #fc1e70;\n}\n.css .hljs-attribute {\n  color: #af7dff;\n}\n.css .hljs-important {\n  color: #d04;\n}\n.actionscript .hljs-literal,\n.javascript .hljs-literal {\n  color: #fc1e70;\n}\npre {\n  padding: 0;\n  margin: 0;\n}\ncode {\n  display: inline-block;\n  background: #f7f7f7;\n  font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;\n  margin: 3px;\n  padding: 1px 5px;\n  border-radius: 3px;\n  color: #666;\n  border: 1px solid #eee;\n  line-height: 20px;\n}\n.document-page {\n  padding-top: 95px;\n  box-sizing: border-box;\n}\n.document-page .content-wrapper.fixed {\n  margin-bottom: 0;\n}\n.document-page .content-wrapper.fixed .aside-wrapper {\n  position: fixed;\n  top: 80px;\n  background: #fff;\n  height: calc(100% - 80px);\n  overflow: auto;\n  box-sizing: border-box;\n  width: 200px;\n}\n.document-page .content-wrapper {\n  width: 1080px;\n  display: flex;\n  background: #fff;\n  margin: 0 auto;\n  border-radius: 5px;\n  box-shadow: 0 1px 1px rgba(0,0,0,0.08);\n  min-height: calc(100% - 15px);\n}\n.document-page .content-wrapper aside {\n  width: 200px;\n  border-right: 1px solid #eee;\n}\n.document-page .content-wrapper .aside-wrapper {\n  position: relative;\n}\n.document-page .content-wrapper .aside-wrapper h5 {\n  font-size: 16px;\n  margin: 25px 0 15px 20px;\n  color: #999;\n}\n.document-page .content-wrapper .aside-wrapper ul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.document-page .content-wrapper .aside-wrapper a {\n  display: block;\n  height: 30px;\n  line-height: 30px;\n  padding-left: 25px;\n  color: #333;\n}\n.document-page .content-wrapper .aside-wrapper a:hover {\n  background: #f3f3f3;\n}\n.document-page .content-wrapper .aside-wrapper .active > a {\n  color: #fe4444;\n}\n.document-page .content-wrapper .aside-wrapper .sub-catalogs {\n  margin-left: 10px;\n  font-size: 12px;\n}\n.document-page .content-wrapper .aside-wrapper .aside-border {\n  border-right: 2px solid #fe4444;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.document-page .content-wrapper article {\n  flex: 1;\n  padding: 10px 20px;\n  overflow: auto;\n}\n.document-page .content-wrapper .article-head .title {\n  padding: 10px 0;\n  font-size: 2.2em;\n  color: #000;\n  display: inline-block;\n}\n.document-page .content-wrapper .article-head .edit-link {\n  display: inline-block;\n  margin-left: 20px;\n  color: #999;\n  font-style: italic;\n}\n.document-page .content-wrapper article h1 {\n  padding: 10px 0;\n  border-bottom: 1px solid #eee;\n  margin: 20px 0;\n}\n.document-page .content-wrapper article h2,\n.document-page .content-wrapper article h3 {\n  padding: 10px 0;\n  margin: 15px 0;\n}\n.document-page .content-wrapper article p {\n  line-height: 25px;\n}\n.document-page .content-wrapper article .output {\n  padding: 20px;\n  border: 1px solid #eee;\n  margin: 20px 0;\n}\n", ""]);

// exports


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(173);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(16)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/stylus-loader/index.js??ref--2-2!./document.styl");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
]));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2luZGV4LmpzPzg0ZWQqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qcz83ZjExKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlci5qcz9mZTk4KiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcz8zNmExKiIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qcz8xOWM0KiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldFRhZy5qcz8wZDA3KiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc09iamVjdC5qcz9lODg0KiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanM/MzZiZSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Jvb3QuanM/YzBiZCoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzP2JiNmUqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzPzhmMzMqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcz9jNTE3KiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcz80OWRmKiIsIndlYnBhY2s6Ly8vLi9+L21kdXJsL2luZGV4LmpzP2UxMGEqIiwid2VicGFjazovLy8uL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcz9mNjY4KiIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcz9iMzdmKiIsIndlYnBhY2s6Ly8vLi9+L3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzPzdjYmMqIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxKiIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgqIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TeW1ib2wuanM/ZGZlNSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2ZyZWVHbG9iYWwuanM/ZTg0OSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NodWZmbGVTZWxmLmpzPzU2N2MqIiwid2VicGFjazovLy8uL34vbG9kYXNoL2RlYm91bmNlLmpzPzNjYjUqIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJyYXkuanM/MGQyMCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNMZW5ndGguanM/NzcwNioiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9sYXlvdXQudmR0PzQyYTAqIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9oaWdobGlnaHQuanM/YmNiYioiLCJ3ZWJwYWNrOi8vLy4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9iYXNoLmpzPzc4ZDgqIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzLmpzP2VmODMqIiwid2VicGFjazovLy8uL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvamF2YXNjcmlwdC5qcz9kZTc3KiIsIndlYnBhY2s6Ly8vLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbC5qcz8zNmM0KiIsIndlYnBhY2s6Ly8vLi9+L2xpbmtpZnktaXQvaW5kZXguanM/YzA3NioiLCJ3ZWJwYWNrOi8vLy4vfi9saW5raWZ5LWl0L2xpYi9yZS5qcz9iMWMxKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0LWRlY29yYXRlL2luZGV4LmpzPzhmNDAqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvaW5kZXguanM/NjFiYSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzPzAzOWYqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanM/OWRlZCoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzPzA5YjkqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcz8xNGU5KiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanM/NmE1NyoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvaW5kZXguanM/ZGZiZCoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzPzc3YmEqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzPzdiNDkqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3BhcnNlcl9pbmxpbmUuanM/ZTY0MioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzP2ZlNDEqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qcz8zNTNhKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanM/ZmMzZSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanM/YWY5OSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcz9lN2NmKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzP2YyOGIqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzPzNiN2IqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanM/NjRiYyoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanM/MDU4ZSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5qcz8wMWQ5KiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qcz81M2ZjKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzPzU2OWIqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qcz9iZjIzKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanM/ZWQ2YSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanM/YTQ5YyoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanM/NzdkMioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qcz8zYWU0KiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcz81NWIyKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanM/NTExMyoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanM/NTc4MyoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanM/NTZhMCoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcz9hN2YzKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanM/NGEyZSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzPzVlZjUqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanM/NTc5ZSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanM/YzI5YioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5qcz8yM2RhKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzPzMyMzEqIiwid2VicGFjazovLy8uL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcz8xNGNlKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanM/ZjlhZioiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanM/YTdmZSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanM/MTgzMSoiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5qcz9kYWU5KiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5qcz8yZTgzKiIsIndlYnBhY2s6Ly8vLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcz83MjgyKiIsIndlYnBhY2s6Ly8vLi9+L21kdXJsL2RlY29kZS5qcz9jYzYwKiIsIndlYnBhY2s6Ly8vLi9+L21kdXJsL2VuY29kZS5qcz9kOGUxKiIsIndlYnBhY2s6Ly8vLi9+L21kdXJsL2Zvcm1hdC5qcz81Y2U3KiIsIndlYnBhY2s6Ly8vLi9+L21kdXJsL3BhcnNlLmpzPzVjZWIqIiwid2VicGFjazovLy8uL34vcHVueWNvZGUvcHVueWNvZGUuanM/NDc0ZioiLCJ3ZWJwYWNrOi8vLy4vfi91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzPzBhZDcqIiwid2VicGFjazovLy8uL34vdWMubWljcm8vaW5kZXguanM/YTYzZSoiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9saWIvdXRpbHMuanM/ZDMwZioiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9sYXlvdXQuanM/NjE2OSoiLCJ3ZWJwYWNrOi8vLy4vfi9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24/MTNiYioiLCJ3ZWJwYWNrOi8vLy4vc2l0ZS9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC52ZHQ/MWQ1NioiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanM/MWIxOCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TWFwLmpzPzMyMjMqIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheVNodWZmbGUuanM/MjRlNioiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcz8wOTBiKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcz83MjkxKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUtleXMuanM/OWM4NyoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VSYW5kb20uanM/YmU5NCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTaHVmZmxlLmpzP2FiMjMqIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVGltZXMuanM/N2EzMCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VVbmFyeS5qcz9iMzRmKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVZhbHVlcy5qcz9jZmFiKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY29weUFycmF5LmpzP2RjMWUqIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRSYXdUYWcuanM/OWI4ZSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSW5kZXguanM/Yzg1ZioiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzP2RhZmQqIiwid2VicGFjazovLy8uL34vbG9kYXNoL19uYXRpdmVLZXlzLmpzPzZkMTQqIiwid2VicGFjazovLy8uL34vbG9kYXNoL19ub2RlVXRpbC5qcz82ZjFmKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanM/ZTkwMSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX292ZXJBcmcuanM/MTJkNSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanM/YjRjMCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanM/NTdhYioiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNCdWZmZXIuanM/NmUxZCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qcz8yYWFhKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1N5bWJvbC5qcz83YWI5KiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanM/NGEwZSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gva2V5cy5qcz9iYTgzKiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9ub3cuanM/ZWE3NCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc2h1ZmZsZS5qcz9jY2E5KiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9zdHViRmFsc2UuanM/YjhiZCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdGhyb3R0bGUuanM/MThlZCoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9OdW1iZXIuanM/NTYxZSoiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdmFsdWVzLmpzPzFlOTIqIiwid2VicGFjazovLy8uL3NpdGUvcGFnZXMvZG9jdW1lbnQvZG9jdW1lbnQuc3R5bD80OGYwKiIsIndlYnBhY2s6Ly8vLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWw/YmM5MioqIl0sIm5hbWVzIjpbIndpbmRvdyIsIkludGFjdCIsIl8iLCJ0aHJvdHRsZSIsInNodWZmbGUiLCJkZWJvdW5jZSIsIiQiLCJ0ZW1wbGF0ZSIsImRlZmF1bHRzIiwiZG9jUGF0aCIsIl9pbml0IiwiZmV0Y2giLCJnZXQiLCJ0aGVuIiwicmVzcG9uc2UiLCJ0ZXh0Iiwic2V0IiwibWFya2VkIiwicmVuZGVyIiwibWQiLCJfbW91bnQiLCJjb2RlcyIsImVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImhpZ2hsaWdodCIsImhpZ2hsaWdodEJsb2NrIiwiaXRlbSIsImNhdGFsb2dzIiwiYWN0aXZlIiwiY2F0YWxvZyIsInRpdGxlIiwiaW5uZXJUZXh0IiwibmV4dFNpYmxpbmciLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJzdWJzIiwicHVzaCIsImV2YWxTY3JpcHQiLCJvblNjcm9sbCIsIiRleGFtcGxlcyIsImZpbmQiLCJpIiwibGVuZ3RoIiwiJGV4YW1wbGUiLCJlcSIsImNvZGUiLCJoYXNDbGFzcyIsIl9DIiwiVmR0IiwiY29tcGlsZSIsImV4dGVuZCIsImV2YWwiLCIkY29udGFpbmVyIiwicGFyZW50IiwiYWZ0ZXIiLCJtb3VudCIsIiRidXR0b24iLCIkcCIsImFwcGVuZCIsIm9uIiwiJHNjcmlwdHMiLCIkc2NyaXB0IiwiJHdyYXBwZXIiLCIkYXJ0aWNsZSIsIiRoMXMiLCIkaDJzIiwiJGFzaWRlIiwiJGJvcmRlciIsIiR3aW5kb3ciLCJvZmYiLCJzY3JvbGxUb3AiLCJmaW5kQWN0aXZlIiwiJGhzIiwibWluVG9wIiwiJGgiLCJ0b3AiLCJwb3NpdGlvbiIsImFjdGl2ZTEiLCJhY3RpdmUyIiwiJGFjdGl2ZUEiLCJsYXN0IiwiY2hpbGRyZW4iLCJoZWlnaHQiLCJjc3MiLCJ0cmlnZ2VyIiwic2Nyb2xsVG8iLCJ0eXBlIiwiYW5pbWF0ZSIsImNvbXBsZXRlIiwiX2Rlc3Ryb3kiLCJMYXlvdXQiLCJfY2xhc3MiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0Iiwia2V5IiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJUeXBlRXJyb3IiLCJrZXlzIiwiYXJyYXlSZXBsYWNlQXQiLCJzcmMiLCJwb3MiLCJuZXdFbGVtZW50cyIsImNvbmNhdCIsImlzVmFsaWRFbnRpdHlDb2RlIiwiYyIsImZyb21Db2RlUG9pbnQiLCJzdXJyb2dhdGUxIiwic3Vycm9nYXRlMiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVORVNDQVBFX01EX1JFIiwiRU5USVRZX1JFIiwiVU5FU0NBUEVfQUxMX1JFIiwiUmVnRXhwIiwiRElHSVRBTF9FTlRJVFlfVEVTVF9SRSIsImVudGl0aWVzIiwicmVxdWlyZSIsInJlcGxhY2VFbnRpdHlQYXR0ZXJuIiwibWF0Y2giLCJuYW1lIiwiY2hhckNvZGVBdCIsInRlc3QiLCJwYXJzZUludCIsInVuZXNjYXBlTWQiLCJzdHIiLCJpbmRleE9mIiwicmVwbGFjZSIsInVuZXNjYXBlQWxsIiwiZXNjYXBlZCIsImVudGl0eSIsIkhUTUxfRVNDQVBFX1RFU1RfUkUiLCJIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFIiwiSFRNTF9SRVBMQUNFTUVOVFMiLCJyZXBsYWNlVW5zYWZlQ2hhciIsImNoIiwiZXNjYXBlSHRtbCIsIlJFR0VYUF9FU0NBUEVfUkUiLCJlc2NhcGVSRSIsImlzU3BhY2UiLCJpc1doaXRlU3BhY2UiLCJVTklDT0RFX1BVTkNUX1JFIiwiaXNQdW5jdENoYXIiLCJpc01kQXNjaWlQdW5jdCIsIm5vcm1hbGl6ZVJlZmVyZW5jZSIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImV4cG9ydHMiLCJsaWIiLCJtZHVybCIsInVjbWljcm8iLCJSdWxlciIsIl9fcnVsZXNfXyIsIl9fY2FjaGVfXyIsIl9fZmluZF9fIiwiX19jb21waWxlX18iLCJzZWxmIiwiY2hhaW5zIiwicnVsZSIsImVuYWJsZWQiLCJhbHQiLCJhbHROYW1lIiwiY2hhaW4iLCJmbiIsImF0Iiwib3B0aW9ucyIsImluZGV4Iiwib3B0IiwiRXJyb3IiLCJiZWZvcmUiLCJiZWZvcmVOYW1lIiwicnVsZU5hbWUiLCJzcGxpY2UiLCJhZnRlck5hbWUiLCJlbmFibGUiLCJsaXN0IiwiaWdub3JlSW52YWxpZCIsImlzQXJyYXkiLCJyZXN1bHQiLCJpZHgiLCJlbmFibGVPbmx5IiwiZGlzYWJsZSIsImdldFJ1bGVzIiwiY2hhaW5OYW1lIiwibW9kdWxlIiwiVG9rZW4iLCJ0YWciLCJuZXN0aW5nIiwiYXR0cnMiLCJtYXAiLCJsZXZlbCIsImNvbnRlbnQiLCJtYXJrdXAiLCJpbmZvIiwibWV0YSIsImJsb2NrIiwiaGlkZGVuIiwiYXR0ckluZGV4IiwibGVuIiwiYXR0clB1c2giLCJhdHRyRGF0YSIsImF0dHJTZXQiLCJ2YWx1ZSIsImF0dHJHZXQiLCJhdHRySm9pbiIsIlN5bWJvbCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJ1bmRlZmluZWQiLCJiYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJpc09iamVjdExpa2UiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJhdHRyX25hbWUiLCJ1bnF1b3RlZCIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwiYXR0cl92YWx1ZSIsImF0dHJpYnV0ZSIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwiY29tbWVudCIsInByb2Nlc3NpbmciLCJkZWNsYXJhdGlvbiIsImNkYXRhIiwiSFRNTF9UQUdfUkUiLCJIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIiwidG9rZW5pemUiLCJlbXBoYXNpcyIsInN0YXRlIiwic2lsZW50Iiwic2Nhbm5lZCIsInRva2VuIiwic3RhcnQiLCJtYXJrZXIiLCJzY2FuRGVsaW1zIiwiZGVsaW1pdGVycyIsImp1bXAiLCJ0b2tlbnMiLCJlbmQiLCJvcGVuIiwiY2FuX29wZW4iLCJjbG9zZSIsImNhbl9jbG9zZSIsInBvc3RQcm9jZXNzIiwic3RhcnREZWxpbSIsImVuZERlbGltIiwiaXNTdHJvbmciLCJtYXgiLCJzdHJpa2V0aHJvdWdoIiwiaiIsImxvbmVNYXJrZXJzIiwicG9wIiwiZW5jb2RlIiwiZGVjb2RlIiwiZm9ybWF0IiwicGFyc2UiLCJnIiwiZSIsImdsb2JhbCIsImJhc2VSYW5kb20iLCJzaHVmZmxlU2VsZiIsImFycmF5Iiwic2l6ZSIsImxhc3RJbmRleCIsInJhbmQiLCJub3ciLCJ0b051bWJlciIsIkZVTkNfRVJST1JfVEVYVCIsIm5hdGl2ZU1heCIsIk1hdGgiLCJuYXRpdmVNaW4iLCJtaW4iLCJmdW5jIiwid2FpdCIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsInRyYWlsaW5nIiwiaW52b2tlRnVuYyIsInRpbWUiLCJhcmdzIiwidGhpc0FyZyIsImFwcGx5IiwibGVhZGluZ0VkZ2UiLCJzZXRUaW1lb3V0IiwidGltZXJFeHBpcmVkIiwicmVtYWluaW5nV2FpdCIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZVNpbmNlTGFzdEludm9rZSIsInRpbWVXYWl0aW5nIiwic2hvdWxkSW52b2tlIiwidHJhaWxpbmdFZGdlIiwiY2FuY2VsIiwiY2xlYXJUaW1lb3V0IiwiZmx1c2giLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoIiwiX1ZkdCIsImJsb2NrcyIsIiRjYWxsZWUiLCJoIiwibWlzcyIsImhjIiwiaHUiLCJ3aWRnZXRzIiwiX2Jsb2NrcyIsIl9fYmxvY2tzIiwiX191IiwidXRpbHMiLCJfZSIsImVycm9yIiwiX2NsYXNzTmFtZSIsImNsYXNzTmFtZSIsIl9fc2xpY2UiLCJfX25vb3AiLCJub29wIiwiX19tIiwiX19vIiwiT3B0aW9ucyIsIl9nZXRNb2RlbCIsImdldE1vZGVsIiwiX3NldE1vZGVsIiwic2V0TW9kZWwiLCJfc2V0Q2hlY2tib3hNb2RlbCIsInNldENoZWNrYm94TW9kZWwiLCJfZGV0ZWN0Q2hlY2tib3hDaGVja2VkIiwiZGV0ZWN0Q2hlY2tib3hDaGVja2VkIiwiX3NldFNlbGVjdE1vZGVsIiwic2V0U2VsZWN0TW9kZWwiLCJkYXRhIiwiJHRoaXMiLCJzY29wZSIsIkFuaW1hdGUiLCJfc3VwZXIiLCJuYXYiLCJocmVmIiwibmF2SW5kZXgiLCJmYWN0b3J5IiwiZ2xvYmFsT2JqZWN0IiwiaGxqcyIsImRlZmluZSIsImFtZCIsIkFycmF5UHJvdG8iLCJvYmplY3RLZXlzIiwibGFuZ3VhZ2VzIiwiYWxpYXNlcyIsIm5vSGlnaGxpZ2h0UmUiLCJsYW5ndWFnZVByZWZpeFJlIiwiZml4TWFya3VwUmUiLCJzcGFuRW5kVGFnIiwiY2xhc3NQcmVmaXgiLCJ0YWJSZXBsYWNlIiwidXNlQlIiLCJlc2NhcGUiLCJub2RlIiwibm9kZU5hbWUiLCJ0ZXN0UmUiLCJyZSIsImxleGVtZSIsImV4ZWMiLCJpc05vdEhpZ2hsaWdodGVkIiwibGFuZ3VhZ2UiLCJibG9ja0xhbmd1YWdlIiwiY2xhc3NlcyIsInBhcmVudE5vZGUiLCJnZXRMYW5ndWFnZSIsInNwbGl0IiwiaW5oZXJpdCIsIm9iamVjdHMiLCJub2RlU3RyZWFtIiwiX25vZGVTdHJlYW0iLCJvZmZzZXQiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJub2RlVHlwZSIsIm5vZGVWYWx1ZSIsImV2ZW50IiwibWVyZ2VTdHJlYW1zIiwib3JpZ2luYWwiLCJoaWdobGlnaHRlZCIsInByb2Nlc3NlZCIsIm5vZGVTdGFjayIsInNlbGVjdFN0cmVhbSIsImF0dHJfc3RyIiwiYSIsImF0dHJpYnV0ZXMiLCJqb2luIiwic3RyZWFtIiwic3Vic3RyaW5nIiwicmV2ZXJzZSIsInN1YnN0ciIsImV4cGFuZF9tb2RlIiwibW9kZSIsInZhcmlhbnRzIiwiY2FjaGVkX3ZhcmlhbnRzIiwidmFyaWFudCIsImVuZHNXaXRoUGFyZW50IiwiY29tcGlsZUxhbmd1YWdlIiwicmVTdHIiLCJsYW5nUmUiLCJjYXNlX2luc2Vuc2l0aXZlIiwiY29tcGlsZU1vZGUiLCJjb21waWxlZCIsImtleXdvcmRzIiwiYmVnaW5LZXl3b3JkcyIsImNvbXBpbGVkX2tleXdvcmRzIiwiZmxhdHRlbiIsImt3IiwicGFpciIsIk51bWJlciIsImxleGVtZXNSZSIsImxleGVtZXMiLCJiZWdpbiIsImJlZ2luUmUiLCJlbmRSZSIsInRlcm1pbmF0b3JfZW5kIiwiaWxsZWdhbCIsImlsbGVnYWxSZSIsInJlbGV2YW5jZSIsImNvbnRhaW5zIiwic3RhcnRzIiwidGVybWluYXRvcnMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaWdub3JlX2lsbGVnYWxzIiwiY29udGludWF0aW9uIiwic3ViTW9kZSIsImVuZE9mTW9kZSIsImVuZHNQYXJlbnQiLCJpc0lsbGVnYWwiLCJrZXl3b3JkTWF0Y2giLCJtYXRjaF9zdHIiLCJidWlsZFNwYW4iLCJjbGFzc25hbWUiLCJpbnNpZGVTcGFuIiwibGVhdmVPcGVuIiwibm9QcmVmaXgiLCJvcGVuU3BhbiIsImNsb3NlU3BhbiIsInByb2Nlc3NLZXl3b3JkcyIsImtleXdvcmRfbWF0Y2giLCJsYXN0X2luZGV4IiwibW9kZV9idWZmZXIiLCJwcm9jZXNzU3ViTGFuZ3VhZ2UiLCJleHBsaWNpdCIsInN1Ykxhbmd1YWdlIiwiY29udGludWF0aW9ucyIsImhpZ2hsaWdodEF1dG8iLCJwcm9jZXNzQnVmZmVyIiwic3RhcnROZXdNb2RlIiwiY3JlYXRlIiwicHJvY2Vzc0xleGVtZSIsImJ1ZmZlciIsIm5ld19tb2RlIiwic2tpcCIsImV4Y2x1ZGVCZWdpbiIsInJldHVybkJlZ2luIiwiZW5kX21vZGUiLCJvcmlnaW4iLCJyZXR1cm5FbmQiLCJleGNsdWRlRW5kIiwiY3VycmVudCIsImNvdW50IiwibWVzc2FnZSIsImxhbmd1YWdlU3Vic2V0Iiwic2Vjb25kX2Jlc3QiLCJmaXhNYXJrdXAiLCJwMSIsImJ1aWxkQ2xhc3NOYW1lIiwicHJldkNsYXNzTmFtZSIsImN1cnJlbnRMYW5nIiwicmVzdWx0TGFuZyIsIm9yaWdpbmFsU3RyZWFtIiwicmVzdWx0Tm9kZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJjb25maWd1cmUiLCJ1c2VyX29wdGlvbnMiLCJpbml0SGlnaGxpZ2h0aW5nIiwiY2FsbGVkIiwiaW5pdEhpZ2hsaWdodGluZ09uTG9hZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWdpc3Rlckxhbmd1YWdlIiwibGFuZyIsImFsaWFzIiwibGlzdExhbmd1YWdlcyIsIklERU5UX1JFIiwiVU5ERVJTQ09SRV9JREVOVF9SRSIsIk5VTUJFUl9SRSIsIkNfTlVNQkVSX1JFIiwiQklOQVJZX05VTUJFUl9SRSIsIlJFX1NUQVJURVJTX1JFIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkFQT1NfU1RSSU5HX01PREUiLCJRVU9URV9TVFJJTkdfTU9ERSIsIlBIUkFTQUxfV09SRFNfTU9ERSIsIkNPTU1FTlQiLCJpbmhlcml0cyIsIkNfTElORV9DT01NRU5UX01PREUiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIkhBU0hfQ09NTUVOVF9NT0RFIiwiTlVNQkVSX01PREUiLCJDX05VTUJFUl9NT0RFIiwiQklOQVJZX05VTUJFUl9NT0RFIiwiQ1NTX05VTUJFUl9NT0RFIiwiUkVHRVhQX01PREUiLCJUSVRMRV9NT0RFIiwiVU5ERVJTQ09SRV9USVRMRV9NT0RFIiwiTUVUSE9EX0dVQVJEIiwiVkFSIiwiUVVPVEVfU1RSSU5HIiwiQVBPU19TVFJJTkciLCJrZXl3b3JkIiwibGl0ZXJhbCIsImJ1aWx0X2luIiwiUlVMRSIsIktFWVdPUkRTIiwiRVhQUkVTU0lPTlMiLCJOVU1CRVIiLCJTVUJTVCIsIlRFTVBMQVRFX1NUUklORyIsIlBBUkFNU19DT05UQUlOUyIsIlhNTF9JREVOVF9SRSIsIlRBR19JTlRFUk5BTFMiLCJpc1JlZ0V4cCIsImlzRnVuY3Rpb24iLCJkZWZhdWx0T3B0aW9ucyIsImZ1enp5TGluayIsImZ1enp5RW1haWwiLCJmdXp6eUlQIiwiaXNPcHRpb25zT2JqIiwicmVkdWNlIiwiYWNjIiwiayIsImRlZmF1bHRTY2hlbWFzIiwidmFsaWRhdGUiLCJ0YWlsIiwiaHR0cCIsInNyY19hdXRoIiwic3JjX2hvc3RfcG9ydF9zdHJpY3QiLCJzcmNfcGF0aCIsIm5vX2h0dHAiLCJzcmNfZG9tYWluIiwic3JjX2RvbWFpbl9yb290Iiwic3JjX3BvcnQiLCJzcmNfaG9zdF90ZXJtaW5hdG9yIiwibWFpbHRvIiwic3JjX2VtYWlsX25hbWUiLCJzcmNfaG9zdF9zdHJpY3QiLCJ0bGRzXzJjaF9zcmNfcmUiLCJ0bGRzX2RlZmF1bHQiLCJyZXNldFNjYW5DYWNoZSIsIl9faW5kZXhfXyIsIl9fdGV4dF9jYWNoZV9fIiwiY3JlYXRlVmFsaWRhdG9yIiwiY3JlYXRlTm9ybWFsaXplciIsIm5vcm1hbGl6ZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiX19jb21waWxlZF9fIiwic2NoZW1hRXJyb3IiLCJ2YWwiLCJfX3NjaGVtYXNfXyIsImxpbmsiLCJzbGlzdCIsInNjaGVtYV90ZXN0Iiwic3JjX1pQQ2MiLCJzY2hlbWFfc2VhcmNoIiwicHJldGVzdCIsIk1hdGNoIiwic2hpZnQiLCJfX2xhc3RfaW5kZXhfXyIsInNjaGVtYSIsIl9fc2NoZW1hX18iLCJyYXciLCJ1cmwiLCJjcmVhdGVNYXRjaCIsIkxpbmtpZnlJdCIsInNjaGVtYXMiLCJhZGQiLCJkZWZpbml0aW9uIiwibSIsIm1sIiwibWUiLCJuZXh0IiwidGxkX3BvcyIsImF0X3BvcyIsInRlc3RTY2hlbWFBdCIsInNlYXJjaCIsImtlZXBPbGQiLCJzb3J0IiwiZWwiLCJhcnIiLCJvcHRzIiwic3JjX0FueSIsInNyY19DYyIsInNyY19aIiwic3JjX1AiLCJzcmNfWkNjIiwidGV4dF9zZXBhcmF0b3JzIiwic3JjX3BzZXVkb19sZXR0ZXIiLCJzcmNfaXA0Iiwic3JjX2hvc3QiLCJ0cGxfaG9zdF9mdXp6eSIsInRwbF9ob3N0X25vX2lwX2Z1enp5IiwidHBsX2hvc3RfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCIsInRhZ0V4cHIiLCJjb3JlIiwicnVsZXIiLCJjdXJseUF0dHJzIiwib3BlbmluZyIsImxpIiwidWwiLCJwIiwib2wiLCJibG9ja3F1b3RlIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2Iiwic2VsZkNsb3NpbmciLCJociIsImltYWdlIiwib21pc3Npb25zIiwic3RhY2siLCJjb250ZW50cyIsInR5cGVzIiwiaXNPcGVuZXIiLCJzcHVzaCIsImZpbmRQYXJlbnQiLCJhcHBseVRvVG9rZW4iLCJ1bnNoaWZ0IiwiY3VybHlJbmxpbmUiLCJsYXN0VGV4dCIsImRlcHRoIiwidHJpbVJpZ2h0IiwidGFyZ2V0cyIsInRhcmdldCIsImF0dHIiLCJ0b2RvIiwic2V0QXR0ciIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsImxpbmVzIiwib2siLCJkaXNhYmxlTmVzdGVkIiwiZm91bmQiLCJwcmV2UG9zIiwibGFiZWxFbmQiLCJwb3NNYXgiLCJvbGRQb3MiLCJpbmxpbmUiLCJza2lwVG9rZW4iLCJoZWxwZXJzIiwiUmVuZGVyZXIiLCJQYXJzZXJDb3JlIiwiUGFyc2VyQmxvY2siLCJQYXJzZXJJbmxpbmUiLCJwdW55Y29kZSIsImNvbmZpZyIsInplcm8iLCJjb21tb25tYXJrIiwiQkFEX1BST1RPX1JFIiwiR09PRF9EQVRBX1JFIiwidmFsaWRhdGVMaW5rIiwiUkVDT0RFX0hPU1ROQU1FX0ZPUiIsIm5vcm1hbGl6ZUxpbmsiLCJwYXJzZWQiLCJob3N0bmFtZSIsInByb3RvY29sIiwidG9BU0NJSSIsImVyIiwibm9ybWFsaXplTGlua1RleHQiLCJ0b1VuaWNvZGUiLCJNYXJrZG93bkl0IiwicHJlc2V0TmFtZSIsInJlbmRlcmVyIiwibGlua2lmeSIsInByZXNldHMiLCJjb21wb25lbnRzIiwicnVsZXMiLCJydWxlczIiLCJydWxlcjIiLCJtaXNzZWQiLCJ1c2UiLCJwbHVnaW4iLCJlbnYiLCJTdGF0ZSIsInByb2Nlc3MiLCJwYXJzZUlubGluZSIsImlubGluZU1vZGUiLCJyZW5kZXJJbmxpbmUiLCJfcnVsZXMiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZSIsImhhc0VtcHR5TGluZXMiLCJtYXhOZXN0aW5nIiwic2tpcEVtcHR5TGluZXMiLCJzQ291bnQiLCJibGtJbmRlbnQiLCJ0aWdodCIsImlzRW1wdHkiLCJvdXRUb2tlbnMiLCJsaW5lTWF4IiwiQ29yZSIsImwiLCJfcnVsZXMyIiwiY2FjaGUiLCJwZW5kaW5nIiwicHVzaFBlbmRpbmciLCJodG1sIiwieGh0bWxPdXQiLCJicmVha3MiLCJsYW5nUHJlZml4IiwidHlwb2dyYXBoZXIiLCJxdW90ZXMiLCJkZWZhdWx0X3J1bGVzIiwiY29kZV9pbmxpbmUiLCJzbGYiLCJyZW5kZXJBdHRycyIsImNvZGVfYmxvY2siLCJmZW5jZSIsImxhbmdOYW1lIiwidG1wQXR0cnMiLCJ0bXBUb2tlbiIsInJlbmRlcklubGluZUFzVGV4dCIsInJlbmRlclRva2VuIiwiaGFyZGJyZWFrIiwic29mdGJyZWFrIiwiaHRtbF9ibG9jayIsImh0bWxfaW5saW5lIiwibmV4dFRva2VuIiwibmVlZExmIiwiYWRqdXN0VGFiIiwiaW5pdGlhbCIsImxhc3RMaW5lRW1wdHkiLCJuZXh0TGluZSIsIm9sZEJNYXJrcyIsIm9sZEJTQ291bnQiLCJvbGRJbmRlbnQiLCJvbGRQYXJlbnRUeXBlIiwib2xkU0NvdW50Iiwib2xkVFNoaWZ0Iiwic3BhY2VBZnRlck1hcmtlciIsInRlcm1pbmF0ZSIsInRlcm1pbmF0b3JSdWxlcyIsIndhc091dGRlbnRlZCIsIm9sZExpbmVNYXgiLCJiTWFya3MiLCJ0U2hpZnQiLCJlTWFya3MiLCJic0NvdW50IiwicGFyZW50VHlwZSIsImdldExpbmVzIiwicGFyYW1zIiwibWVtIiwiaGF2ZUVuZE1hcmtlciIsInNraXBDaGFycyIsInNraXBTcGFjZXMiLCJoZWFkaW5nIiwidG1wIiwic2tpcFNwYWNlc0JhY2siLCJza2lwQ2hhcnNCYWNrIiwiY250IiwiYmxvY2tfbmFtZXMiLCJIVE1MX1NFUVVFTkNFUyIsImxpbmVUZXh0IiwibGhlYWRpbmciLCJza2lwQnVsbGV0TGlzdE1hcmtlciIsInNraXBPcmRlcmVkTGlzdE1hcmtlciIsIm1hcmtUaWdodFBhcmFncmFwaHMiLCJjb250ZW50U3RhcnQiLCJpbmRlbnQiLCJpbmRlbnRBZnRlck1hcmtlciIsImlzT3JkZXJlZCIsIml0ZW1MaW5lcyIsImxpc3RMaW5lcyIsImxpc3RUb2tJZHgiLCJtYXJrZXJDaGFyQ29kZSIsIm1hcmtlclZhbHVlIiwib2xkTEluZGVudCIsIm9sZFRpZ2h0IiwicG9zQWZ0ZXJNYXJrZXIiLCJwcmV2RW1wdHlFbmQiLCJpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwiX2VuZExpbmUiLCJkZXN0RW5kUG9zIiwiZGVzdEVuZExpbmVObyIsImxhYmVsIiwicmVzIiwicmVmZXJlbmNlcyIsIlN0YXRlQmxvY2siLCJzIiwiaW5kZW50X2ZvdW5kIiwiZGRJbmRlbnQiLCJmcm9tIiwia2VlcExhc3RMRiIsImxpbmVJbmRlbnQiLCJmaXJzdCIsInF1ZXVlIiwibGluZVN0YXJ0IiwiZ2V0TGluZSIsImVzY2FwZWRTcGxpdCIsImVzY2FwZXMiLCJsYXN0UG9zIiwiYmFja1RpY2tlZCIsImxhc3RCYWNrVGljayIsInRhYmxlIiwiY29sdW1ucyIsImNvbHVtbkNvdW50IiwiYWxpZ25zIiwidCIsInRhYmxlTGluZXMiLCJ0Ym9keUxpbmVzIiwidG9rIiwiaXNMaW5rT3BlbiIsImlzTGlua0Nsb3NlIiwiY3VycmVudFRva2VuIiwibm9kZXMiLCJsbiIsImh0bWxMaW5rTGV2ZWwiLCJmdWxsVXJsIiwidXJsVGV4dCIsImJsb2NrVG9rZW5zIiwibGlua3MiLCJORVdMSU5FU19SRSIsIk5VTExfUkUiLCJSQVJFX1JFIiwiU0NPUEVEX0FCQlJfVEVTVF9SRSIsIlNDT1BFRF9BQkJSX1JFIiwiU0NPUEVEX0FCQlIiLCJyIiwidG0iLCJyZXBsYWNlRm4iLCJyZXBsYWNlX3Njb3BlZCIsImlubGluZVRva2VucyIsImluc2lkZV9hdXRvbGluayIsInJlcGxhY2VfcmFyZSIsImJsa0lkeCIsIlFVT1RFX1RFU1RfUkUiLCJRVU9URV9SRSIsIkFQT1NUUk9QSEUiLCJyZXBsYWNlQXQiLCJwcm9jZXNzX2lubGluZXMiLCJ0aGlzTGV2ZWwiLCJsYXN0Q2hhciIsIm5leHRDaGFyIiwiaXNMYXN0UHVuY3RDaGFyIiwiaXNOZXh0UHVuY3RDaGFyIiwiaXNMYXN0V2hpdGVTcGFjZSIsImlzTmV4dFdoaXRlU3BhY2UiLCJjYW5PcGVuIiwiY2FuQ2xvc2UiLCJpc1NpbmdsZSIsIm9wZW5RdW90ZSIsImNsb3NlUXVvdGUiLCJPVVRFUiIsInNpbmdsZSIsInNtYXJ0cXVvdGVzIiwiU3RhdGVDb3JlIiwiRU1BSUxfUkUiLCJBVVRPTElOS19SRSIsImF1dG9saW5rIiwibGlua01hdGNoIiwiZW1haWxNYXRjaCIsImJhY2t0aWNrIiwibWF0Y2hTdGFydCIsIm1hdGNoRW5kIiwibGlua19wYWlycyIsImxhc3REZWxpbSIsImN1cnJEZWxpbSIsIm9kZF9tYXRjaCIsIkRJR0lUQUxfUkUiLCJOQU1FRF9SRSIsIkVTQ0FQRUQiLCJpc0xldHRlciIsImxjIiwibGFiZWxTdGFydCIsInJlZiIsInBhcnNlUmVmZXJlbmNlIiwibmV3bGluZSIsInBtYXgiLCJTdGF0ZUlubGluZSIsInBlbmRpbmdMZXZlbCIsImNhblNwbGl0V29yZCIsImxlZnRfZmxhbmtpbmciLCJyaWdodF9mbGFua2luZyIsImlzVGVybWluYXRvckNoYXIiLCJ0ZXh0X2NvbGxhcHNlIiwiY3VyciIsImRlY29kZUNhY2hlIiwiZ2V0RGVjb2RlQ2FjaGUiLCJleGNsdWRlIiwic3RyaW5nIiwiZGVmYXVsdENoYXJzIiwic2VxIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJjaHIiLCJjb21wb25lbnRDaGFycyIsImVuY29kZUNhY2hlIiwiZ2V0RW5jb2RlQ2FjaGUiLCJrZWVwRXNjYXBlZCIsIm5leHRDb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2xhc2hlcyIsImF1dGgiLCJwb3J0IiwicGF0aG5hbWUiLCJoYXNoIiwiVXJsIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJ1cmxQYXJzZSIsInNsYXNoZXNEZW5vdGVIb3N0IiwidSIsImxvd2VyUHJvdG8iLCJoZWMiLCJyZXN0Iiwic2ltcGxlUGF0aCIsInByb3RvIiwiaG9zdEVuZCIsImF0U2lnbiIsImxhc3RJbmRleE9mIiwiaG9zdCIsInBhcnNlSG9zdCIsImlwdjZIb3N0bmFtZSIsImhvc3RwYXJ0cyIsInBhcnQiLCJuZXdwYXJ0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJxbSIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiUmFuZ2VFcnJvciIsIm1hcERvbWFpbiIsInBhcnRzIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJvdXQiLCJuIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInciLCJiYXNlTWludXNUIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwiQW55IiwiQ2MiLCJDZiIsIlAiLCJaIiwibEJhc2giLCJsQ3NzIiwibEphdmFzY3JpcHQiLCJsWG1sIiwiTWFya2Rvd25JdERlY29yYXRlIiwiX3VwZGF0ZUJvcmRlciIsIiRuYXYiLCJ3aWR0aCIsImxlZnQiLCJvdXRlcldpZHRoIiwiYWRkQ2xhc3MiLCJzdWJDYXRhbG9ncyIsImN1cnJlbnROYXYiLCJTdWJzIiwiYmluZCIsIl9vYmoiLCJiYXNlVGltZXMiLCJpc0FyZ3VtZW50cyIsImlzQnVmZmVyIiwiaXNJbmRleCIsImlzVHlwZWRBcnJheSIsIm9iamVjdFByb3RvIiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImFycmF5TWFwIiwiaXRlcmF0ZWUiLCJjb3B5QXJyYXkiLCJhcnJheVNodWZmbGUiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJuYXRpdmVGbG9vciIsIm5hdGl2ZVJhbmRvbSIsInJhbmRvbSIsImxvd2VyIiwidXBwZXIiLCJ2YWx1ZXMiLCJiYXNlU2h1ZmZsZSIsImNvbGxlY3Rpb24iLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwicHJvcHMiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImlzT3duIiwidW5tYXNrZWQiLCJyZUlzVWludCIsIkN0b3IiLCJjb25zdHJ1Y3RvciIsIm92ZXJBcmciLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJub2RlVXRpbCIsImJpbmRpbmciLCJ0cmFuc2Zvcm0iLCJhcmciLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJyYXlMaWtlIiwic3R1YkZhbHNlIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJhc3luY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJub2RlSXNUeXBlZEFycmF5IiwiRGF0ZSIsIk5BTiIsInJlVHJpbSIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc09jdGFsIiwiZnJlZVBhcnNlSW50Iiwib3RoZXIiLCJ2YWx1ZU9mIiwiaXNCaW5hcnkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBQSxPQUFPQyxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBRCxPQUFPRSxDQUFQLEdBQVcsRUFBQ0MsK0JBQUQsRUFBV0MsNkJBQVgsRUFBb0JDLCtCQUFwQixFQUFYO0FBQ0FMLE9BQU9NLENBQVAsR0FBV0EsQ0FBWDs7dUJBR0tMLE9BQU9NLFFBQVAsRTs7Ozs7Ozs7O3VCQUdEQyxRLHVCQUFXO0FBQ1AsZUFBTztBQUNIQyxxQkFBUztBQUROLFNBQVA7QUFHSCxLOzt1QkFFREMsSyxvQkFBUTtBQUFBOztBQUNKLGVBQU9DLE1BQVMsS0FBS0MsR0FBTCxDQUFTLFNBQVQsQ0FBVCxTQUFnQyxLQUFLQSxHQUFMLENBQVMsT0FBVCxDQUFoQyxVQUF3REMsSUFBeEQsQ0FBNkQsb0JBQVk7QUFDNUUsbUJBQU9DLFNBQVNDLElBQVQsRUFBUDtBQUNILFNBRk0sRUFFSkYsSUFGSSxDQUVDLGNBQU07QUFDVixtQkFBS0csR0FBTCxDQUFTLFNBQVQsRUFBb0JDLGNBQU9DLE1BQVAsQ0FBY0MsRUFBZCxDQUFwQjtBQUNILFNBSk0sQ0FBUDtBQUtILEs7O3VCQUVEQyxNLHFCQUFTO0FBQ0wsMEJBQU1BLE1BQU47QUFDQSxZQUFNQyxRQUFRLEtBQUtDLE9BQUwsQ0FBYUMsZ0JBQWIsQ0FBOEIsVUFBOUIsQ0FBZDtBQUNBRixjQUFNRyxPQUFOLENBQWMsZ0JBQVE7QUFDbEJDLDZCQUFVQyxjQUFWLENBQXlCQyxJQUF6QjtBQUNILFNBRkQ7QUFHQSxZQUFNQyxXQUFXLEVBQWpCO0FBQ0FBLGlCQUFTQyxNQUFULEdBQWtC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Q0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0EsU0FBSyxJQUFMLENBQVMsT0FBVDtBQUNBLFNBQUssSUFBTCxDQUFTLE9BQVQ7QUFDQSxTQUFLLElBQUwsQ0FBUyxPQUFUO0FBQ0UsYUFBTyxJQUFQO0FBQ0Y7QUFDRSxhQUFPLEtBQVA7QUFuQ0o7QUFxQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQVNTLGtCQUFULENBQTRCbkIsR0FBNUIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBT0EsSUFBSW9CLElBQUosR0FBV2xCLE9BQVgsQ0FBbUIs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RSxvQ0FBb0MsdUJBQXVCLGFBQWEsV0FBVyxHQUFHLDJDQUEyQyxZQUFZLHVCQUF1QixtQkFBbUIsR0FBRyx3REFBd0Qsb0JBQW9CLHFCQUFxQixnQkFBZ0IsMEJBQTBCLEdBQUcsNERBQTRELDBCQUEwQixzQkFBc0IsZ0JBQWdCLHVCQUF1QixHQUFHLDhDQUE4QyxvQkFBb0Isa0NBQWtDLG1CQUFtQixHQUFHLDJGQUEyRixvQkFBb0IsbUJBQW1CLEdBQUcsNkNBQTZDLHNCQUFzQixHQUFHLG1EQUFtRCxrQkFBa0IsMkJBQTJCLG1CQUFtQixHQUFHOztBQUVqN0c7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEMiLCJmaWxlIjoic3RhdGljL2NodW5rLzEwN2ZkNmRmZjQ1ZTFlOWI0ZjljLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vZG9jdW1lbnQudmR0JztcbmltcG9ydCBjc3MgZnJvbSAnLi9kb2N1bWVudC5zdHlsJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IHNodWZmbGUgZnJvbSAnbG9kYXNoL3NodWZmbGUnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5pbXBvcnQge2hpZ2hsaWdodCwgbWFya2VkfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuXG4vLyBmb3IgZGVidWdcbndpbmRvdy5JbnRhY3QgPSBJbnRhY3Q7XG53aW5kb3cuXyA9IHt0aHJvdHRsZSwgc2h1ZmZsZSwgZGVib3VuY2V9O1xud2luZG93LiQgPSAkO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIExheW91dCB7XG4gICAgQEludGFjdC50ZW1wbGF0ZSgpXG4gICAgc3RhdGljIHRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICBkZWZhdWx0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvY1BhdGg6ICcuL2RvY3MnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmdldCgnZG9jUGF0aCcpfS8ke3RoaXMuZ2V0KCd0aXRsZScpfS5tZGApLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSkudGhlbihtZCA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldCgnY29udGVudCcsIG1hcmtlZC5yZW5kZXIobWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX21vdW50KCkge1xuICAgICAgICBzdXBlci5fbW91bnQoKTtcbiAgICAgICAgY29uc3QgY29kZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgY29kZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGhpZ2hsaWdodC5oaWdobGlnaHRCbG9jayhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhdGFsb2dzID0gW107XG4gICAgICAgIGNhdGFsb2dzLmFjdGl2ZSA9ICdhY3RpdmUxJztcbiAgICAgICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxJykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGFsb2cgPSB7dGl0bGU6IGl0ZW0uaW5uZXJUZXh0fTtcbiAgICAgICAgICAgIGxldCBuZXh0U2libGluZyA9IGl0ZW0ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gKG5leHRTaWJsaW5nLnRhZ05hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdoMScpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnaDInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2F0YWxvZy5zdWJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRhbG9nLnN1YnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGFsb2cuc3Vicy5hY3RpdmUgPSAnYWN0aXZlMic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0YWxvZy5zdWJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5leHRTaWJsaW5nLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGFsb2dzLnB1c2goY2F0YWxvZyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldCgnc3ViQ2F0YWxvZ3MnLCBjYXRhbG9ncyk7XG5cbiAgICAgICAgdGhpcy5ldmFsU2NyaXB0KCk7XG4gICAgICAgIHRoaXMub25TY3JvbGwoKTtcbiAgICB9XG5cbiAgICBldmFsU2NyaXB0KCkge1xuICAgICAgICBjb25zdCAkZXhhbXBsZXMgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmV4YW1wbGUnKTtcbiAgICAgICAgbGV0IHRlbXBsYXRlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRleGFtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0ICRleGFtcGxlID0gJGV4YW1wbGVzLmVxKGkpO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSAkZXhhbXBsZS50ZXh0KCk7XG4gICAgICAgICAgICBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2F1dG8nKSkge1xuICAgICAgICAgICAgICAgIGxldCBfQztcbiAgICAgICAgICAgICAgICBpZiAoJGV4YW1wbGUuaGFzQ2xhc3MoJ2xhbmd1YWdlLWh0bWwnKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IEludGFjdC5WZHQuY29tcGlsZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgX0MgPSBJbnRhY3QuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdqYXZhc2NyaXB0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgX0MgPSBldmFsKGNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgJGNvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJvdXRwdXRcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAkZXhhbXBsZS5wYXJlbnQoKS5hZnRlcigkY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBJbnRhY3QubW91bnQoX0MsICRjb250YWluZXJbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbWFudWFsJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgJGJ1dHRvbiA9ICQoJzxidXR0b24+54K55Ye76L+Q6KGMPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgbGV0ICRwID0gJCgnPHA+PC9wPicpLmFwcGVuZCgkYnV0dG9uKTtcbiAgICAgICAgICAgICAgICAkZXhhbXBsZS5wYXJlbnQoKS5hZnRlcigkcCk7XG4gICAgICAgICAgICAgICAgJGJ1dHRvbi5vbignY2xpY2snLCAoKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkoY29kZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbGFuZ3VhZ2UtaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBJbnRhY3QuVmR0LmNvbXBpbGUoY29kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRleGFtcGxlLmhhc0NsYXNzKCdqYXZhc2NyaXB0JykpIHtcbiAgICAgICAgICAgICAgICBldmFsKGNvZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZXhhbXBsZS5oYXNDbGFzcygnbGFuZ3VhZ2UtY3NzJykpIHtcbiAgICAgICAgICAgICAgICAkZXhhbXBsZS5wYXJlbnQoKS5hZnRlcihgPHN0eWxlPiR7Y29kZX08L3N0eWxlPmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5omn6KGMc2NyaXB05qCH562+XG4gICAgICAgIGNvbnN0ICRzY3JpcHRzID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJ3NjcmlwdCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgJHNjcmlwdCA9ICRzY3JpcHRzLmVxKGkpO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSAkc2NyaXB0LnRleHQoKTtcbiAgICAgICAgICAgIGV2YWwoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNjcm9sbCgpIHtcbiAgICAgICAgY29uc3QgJHdyYXBwZXIgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmNvbnRlbnQtd3JhcHBlcicpO1xuICAgICAgICBjb25zdCAkYXJ0aWNsZSA9ICQodGhpcy5lbGVtZW50KS5maW5kKCdhcnRpY2xlJyk7XG4gICAgICAgIGNvbnN0ICRoMXMgPSAkYXJ0aWNsZS5maW5kKCdoMScpO1xuICAgICAgICBjb25zdCAkaDJzID0gJGFydGljbGUuZmluZCgnaDInKTtcbiAgICAgICAgY29uc3QgJGFzaWRlID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQoJ2FzaWRlJyk7XG4gICAgICAgIGNvbnN0ICRib3JkZXIgPSAkYXNpZGUuZmluZCgnLmFzaWRlLWJvcmRlcicpO1xuICAgICAgICBjb25zdCAkd2luZG93ID0gJCh3aW5kb3cpO1xuICAgICAgICAkd2luZG93Lm9mZignc2Nyb2xsJyk7XG4gICAgICAgICR3aW5kb3cub24oJ3Njcm9sbC5maXgnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAkd3JhcHBlcltzY3JvbGxUb3AgPj0gMTUgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oJ2ZpeGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkd2luZG93Lm9uKCdzY3JvbGwuYWN0aXZlJywgdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQWN0aXZlKCRocywgbWluVG9wID0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAkaHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRoID0gJGhzLmVxKGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gJGgucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AgPiBtaW5Ub3AgJiYgc2Nyb2xsVG9wID49IHRvcCAtIDYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRoLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge3RleHQ6ICcnLCB0b3A6IDB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhY3RpdmUxID0gZmluZEFjdGl2ZSgkaDFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZTIgPSBmaW5kQWN0aXZlKCRoMnMsIGFjdGl2ZTEudG9wKTtcblxuICAgICAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZTI6IGFjdGl2ZTIudGV4dCxcbiAgICAgICAgICAgICAgICBhY3RpdmUxOiBhY3RpdmUxLnRleHQgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgJGFjdGl2ZUEgPSAkYXNpZGUuZmluZCgnLmFjdGl2ZScpLmxhc3QoKS5jaGlsZHJlbignYScpO1xuICAgICAgICAgICAgaWYgKCRhY3RpdmVBLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSAkYWN0aXZlQS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gJGFjdGl2ZUEucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgJGJvcmRlci5jc3Moe2hlaWdodDogaGVpZ2h0LCB0b3A6IHRvcH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCA1MCkpO1xuICAgICAgICAkd2luZG93LnRyaWdnZXIoJ3Njcm9sbCcpO1xuICAgIH1cblxuICAgIHNjcm9sbFRvKHRleHQsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgJGFydGljbGUgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnYXJ0aWNsZScpO1xuICAgICAgICBjb25zdCAkaHMgPSAkYXJ0aWNsZS5maW5kKHR5cGUgPT09ICdhY3RpdmUxJyA/ICdoMScgOiAnaDInKTtcbiAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCAkaCA9ICRocy5lcShpKTtcbiAgICAgICAgICAgIGlmICgkaC50ZXh0KCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gJGgucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiB0b3AgLSA2MFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rlc3Ryb3koKSB7XG4gICAgICAgICQod2luZG93KS5vZmYoJ3Njcm9sbCcpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvcGFnZXMvZG9jdW1lbnQvaW5kZXguanMiLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn0qL1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUFsbChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgIGlmIChlc2NhcGVkKSB7IHJldHVybiBlc2NhcGVkOyB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgJ1xcXFwkJicpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OlxuICAgIGNhc2UgMHgyMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICBpZiAoY29kZSA+PSAweDIwMDAgJiYgY29kZSA8PSAweDIwMEEpIHsgcmV0dXJuIHRydWU7IH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG52YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxuZnVuY3Rpb24gaXNQdW5jdENoYXIoY2gpIHtcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG59XG5cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDI3LyogJyAqLzpcbiAgICBjYXNlIDB4MjgvKiAoICovOlxuICAgIGNhc2UgMHgyOS8qICkgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyQy8qICwgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4MkUvKiAuICovOlxuICAgIGNhc2UgMHgyRi8qIC8gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHgzRi8qID8gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0MvKiB8ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVwbGVyIHRvIHVuaWZ5IFtyZWZlcmVuY2UgbGFiZWxzXS5cbi8vXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5leHBvcnRzLmxpYiAgICAgICAgICAgICAgICAgPSB7fTtcbmV4cG9ydHMubGliLm1kdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcbmV4cG9ydHMuaGFzICAgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcbmV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgICA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICAgID0gZnJvbUNvZGVQb2ludDtcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlSHRtbCAgICAgICAgICA9IGVzY2FwZUh0bWw7XG5leHBvcnRzLmFycmF5UmVwbGFjZUF0ICAgICAgPSBhcnJheVJlcGxhY2VBdDtcbmV4cG9ydHMuaXNTcGFjZSAgICAgICAgICAgICA9IGlzU3BhY2U7XG5leHBvcnRzLmlzV2hpdGVTcGFjZSAgICAgICAgPSBpc1doaXRlU3BhY2U7XG5leHBvcnRzLmlzTWRBc2NpaVB1bmN0ICAgICAgPSBpc01kQXNjaWlQdW5jdDtcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xuZXhwb3J0cy5lc2NhcGVSRSAgICAgICAgICAgID0gZXNjYXBlUkU7XG5leHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSAgPSBub3JtYWxpemVSZWZlcmVuY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanMiLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9ncmFwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwiLy8gVG9rZW4gY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogY2xhc3MgVG9rZW5cbiAqKi9cblxuLyoqXG4gKiBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICpcbiAqIENyZWF0ZSBuZXcgdG9rZW4gYW5kIGZpbGwgcGFzc2VkIHByb3BlcnRpZXMuXG4gKiovXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgLyoqXG4gICAqIFRva2VuI3R5cGUgLT4gU3RyaW5nXG4gICAqXG4gICAqIFR5cGUgb2YgdGhlIHRva2VuIChzdHJpbmcsIGUuZy4gXCJwYXJhZ3JhcGhfb3BlblwiKVxuICAgKiovXG4gIHRoaXMudHlwZSAgICAgPSB0eXBlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiN0YWcgLT4gU3RyaW5nXG4gICAqXG4gICAqIGh0bWwgdGFnIG5hbWUsIGUuZy4gXCJwXCJcbiAgICoqL1xuICB0aGlzLnRhZyAgICAgID0gdGFnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNhdHRycyAtPiBBcnJheVxuICAgKlxuICAgKiBIdG1sIGF0dHJpYnV0ZXMuIEZvcm1hdDogYFsgWyBuYW1lMSwgdmFsdWUxIF0sIFsgbmFtZTIsIHZhbHVlMiBdIF1gXG4gICAqKi9cbiAgdGhpcy5hdHRycyAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcCAtPiBBcnJheVxuICAgKlxuICAgKiBTb3VyY2UgbWFwIGluZm8uIEZvcm1hdDogYFsgbGluZV9iZWdpbiwgbGluZV9lbmQgXWBcbiAgICoqL1xuICB0aGlzLm1hcCAgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbmVzdGluZyAtPiBOdW1iZXJcbiAgICpcbiAgICogTGV2ZWwgY2hhbmdlIChudW1iZXIgaW4gey0xLCAwLCAxfSBzZXQpLCB3aGVyZTpcbiAgICpcbiAgICogLSAgYDFgIG1lYW5zIHRoZSB0YWcgaXMgb3BlbmluZ1xuICAgKiAtICBgMGAgbWVhbnMgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmdcbiAgICogLSBgLTFgIG1lYW5zIHRoZSB0YWcgaXMgY2xvc2luZ1xuICAgKiovXG4gIHRoaXMubmVzdGluZyAgPSBuZXN0aW5nO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcbiAgICpcbiAgICogbmVzdGluZyBsZXZlbCwgdGhlIHNhbWUgYXMgYHN0YXRlLmxldmVsYFxuICAgKiovXG4gIHRoaXMubGV2ZWwgICAgPSAwO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjaGlsZHJlbiAtPiBBcnJheVxuICAgKlxuICAgKiBBbiBhcnJheSBvZiBjaGlsZCBub2RlcyAoaW5saW5lIGFuZCBpbWcgdG9rZW5zKVxuICAgKiovXG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNjb250ZW50IC0+IFN0cmluZ1xuICAgKlxuICAgKiBJbiBhIGNhc2Ugb2Ygc2VsZi1jbG9zaW5nIHRhZyAoY29kZSwgaHRtbCwgZmVuY2UsIGV0Yy4pLFxuICAgKiBpdCBoYXMgY29udGVudHMgb2YgdGhpcyB0YWcuXG4gICAqKi9cbiAgdGhpcy5jb250ZW50ICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXJrdXAgLT4gU3RyaW5nXG4gICAqXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5tYXJrdXAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNpbmZvIC0+IFN0cmluZ1xuICAgKlxuICAgKiBmZW5jZSBpbmZvc3RyaW5nXG4gICAqKi9cbiAgdGhpcy5pbmZvICAgICA9ICcnO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxuICAgKlxuICAgKiBBIHBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBkYXRhXG4gICAqKi9cbiAgdGhpcy5tZXRhICAgICA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2Jsb2NrIC0+IEJvb2xlYW5cbiAgICpcbiAgICogVHJ1ZSBmb3IgYmxvY2stbGV2ZWwgdG9rZW5zLCBmYWxzZSBmb3IgaW5saW5lIHRva2Vucy5cbiAgICogVXNlZCBpbiByZW5kZXJlciB0byBjYWxjdWxhdGUgbGluZSBicmVha3NcbiAgICoqL1xuICB0aGlzLmJsb2NrICAgID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRva2VuI2hpZGRlbiAtPiBCb29sZWFuXG4gICAqXG4gICAqIElmIGl0J3MgdHJ1ZSwgaWdub3JlIHRoaXMgZWxlbWVudCB3aGVuIHJlbmRlcmluZy4gVXNlZCBmb3IgdGlnaHQgbGlzdHNcbiAgICogdG8gaGlkZSBwYXJhZ3JhcGhzLlxuICAgKiovXG4gIHRoaXMuaGlkZGVuICAgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFRva2VuLmF0dHJJbmRleChuYW1lKSAtPiBOdW1iZXJcbiAqXG4gKiBTZWFyY2ggYXR0cmlidXRlIGluZGV4IGJ5IG5hbWUuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckluZGV4ID0gZnVuY3Rpb24gYXR0ckluZGV4KG5hbWUpIHtcbiAgdmFyIGF0dHJzLCBpLCBsZW47XG5cbiAgaWYgKCF0aGlzLmF0dHJzKSB7IHJldHVybiAtMTsgfVxuXG4gIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSA9PT0gbmFtZSkgeyByZXR1cm4gaTsgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyUHVzaChhdHRyRGF0YSlcbiAqXG4gKiBBZGQgYFsgbmFtZSwgdmFsdWUgXWAgYXR0cmlidXRlIHRvIGxpc3QuIEluaXQgYXR0cnMgaWYgbmVjZXNzYXJ5XG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clB1c2ggPSBmdW5jdGlvbiBhdHRyUHVzaChhdHRyRGF0YSkge1xuICBpZiAodGhpcy5hdHRycykge1xuICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRycyA9IFsgYXR0ckRhdGEgXTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJTZXQobmFtZSwgdmFsdWUpXG4gKlxuICogU2V0IGBuYW1lYCBhdHRyaWJ1dGUgdG8gYHZhbHVlYC4gT3ZlcnJpZGUgb2xkIHZhbHVlIGlmIGV4aXN0cy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyU2V0ID0gZnVuY3Rpb24gYXR0clNldChuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksXG4gICAgICBhdHRyRGF0YSA9IFsgbmFtZSwgdmFsdWUgXTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJEYXRhO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckdldChuYW1lKVxuICpcbiAqIEdldCB0aGUgdmFsdWUgb2YgYXR0cmlidXRlIGBuYW1lYCwgb3IgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyR2V0ID0gZnVuY3Rpb24gYXR0ckdldChuYW1lKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgdmFsdWUgPSBudWxsO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0ckpvaW4obmFtZSwgdmFsdWUpXG4gKlxuICogSm9pbiB2YWx1ZSB0byBleGlzdGluZyBhdHRyaWJ1dGUgdmlhIHNwYWNlLiBPciBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBpZiBub3RcbiAqIGV4aXN0cy4gVXNlZnVsIHRvIG9wZXJhdGUgd2l0aCB0b2tlbiBjbGFzc2VzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJKb2luID0gZnVuY3Rpb24gYXR0ckpvaW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChbIG5hbWUsIHZhbHVlIF0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XVsxXSA9IHRoaXMuYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVG9rZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQ5XFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA2W1xcdURFM0YtXFx1REU0NlxcdURFOUEtXFx1REU5Q1xcdURFOUUtXFx1REVBMl18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc09iamVjdC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19yb290LmpzIiwiLy8gSFRNTDUgZW50aXRpZXMgbWFwOiB7IG5hbWUgLT4gdXRmMTZzdHJpbmcgfVxuLy9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgcXVvdGVzOjAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcblxudmFyIHVucXVvdGVkICAgICAgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG5cbnZhciBhdHRyX3ZhbHVlICA9ICcoPzonICsgdW5xdW90ZWQgKyAnfCcgKyBzaW5nbGVfcXVvdGVkICsgJ3wnICsgZG91YmxlX3F1b3RlZCArICcpJztcblxudmFyIGF0dHJpYnV0ZSAgID0gJyg/OlxcXFxzKycgKyBhdHRyX25hbWUgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyX3ZhbHVlICsgJyk/KSc7XG5cbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xuXG52YXIgY2xvc2VfdGFnICAgPSAnPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj4nO1xudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIHByb2Nlc3NpbmcgID0gJzxbP10uKj9bP10+JztcbnZhciBkZWNsYXJhdGlvbiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgY2RhdGEgICAgICAgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcblxudmFyIEhUTUxfVEFHX1JFID0gbmV3IFJlZ0V4cCgnXig/OicgKyBvcGVuX3RhZyArICd8JyArIGNsb3NlX3RhZyArICd8JyArIGNvbW1lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgcHJvY2Vzc2luZyArICd8JyArIGRlY2xhcmF0aW9uICsgJ3wnICsgY2RhdGEgKyAnKScpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJyknKTtcblxubW9kdWxlLmV4cG9ydHMuSFRNTF9UQUdfUkUgPSBIVE1MX1RBR19SRTtcbm1vZHVsZS5leHBvcnRzLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanMiLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEFuIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGJlZm9yZSB0aGlzIG9uZSB0aGF0J3MgZXF1aXZhbGVudCB0b1xuICAgICAgLy8gY3VycmVudCBvbmUuIEluIHBsYWluIEVuZ2xpc2g6IGlmIHRoaXMgZGVsaW1pdGVyIGRvZXMgbm90IG9wZW5cbiAgICAgIC8vIGFuIGVtcGhhc2lzLCBuZWl0aGVyIGRvIHByZXZpb3VzIGBqdW1wYCBjaGFyYWN0ZXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFVzZWQgdG8gc2tpcCBzZXF1ZW5jZXMgbGlrZSBcIioqKioqXCIgaW4gb25lIHN0ZXAsIGZvciAxc3QgYXN0ZXJpc2tcbiAgICAgIC8vIHZhbHVlIHdpbGwgYmUgMCwgZm9yIDJuZCBpdCdzIDEgYW5kIHNvIG9uLlxuICAgICAgLy9cbiAgICAgIGp1bXA6ICAgaSxcblxuICAgICAgLy8gQSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gdGhpcyBkZWxpbWl0ZXIgY29ycmVzcG9uZHMgdG8uXG4gICAgICAvL1xuICAgICAgdG9rZW46ICBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMSxcblxuICAgICAgLy8gVG9rZW4gbGV2ZWwuXG4gICAgICAvL1xuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcblxuICAgICAgLy8gSWYgdGhpcyBkZWxpbWl0ZXIgaXMgbWF0Y2hlZCBhcyBhIHZhbGlkIG9wZW5lciwgYGVuZGAgd2lsbCBiZVxuICAgICAgLy8gZXF1YWwgdG8gaXRzIHBvc2l0aW9uLCBvdGhlcndpc2UgaXQncyBgLTFgLlxuICAgICAgLy9cbiAgICAgIGVuZDogICAgLTEsXG5cbiAgICAgIC8vIEJvb2xlYW4gZmxhZ3MgdGhhdCBkZXRlcm1pbmUgaWYgdGhpcyBkZWxpbWl0ZXIgY291bGQgb3BlbiBvciBjbG9zZVxuICAgICAgLy8gYW4gZW1waGFzaXMuXG4gICAgICAvL1xuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xubW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSkge1xuICB2YXIgaSxcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgY2gsXG4gICAgICBpc1N0cm9uZyxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gbWF4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzdGFydERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4MkEvKiAqICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIC8vIElmIHRoZSBwcmV2aW91cyBkZWxpbWl0ZXIgaGFzIHRoZSBzYW1lIG1hcmtlciBhbmQgaXMgYWRqYWNlbnQgdG8gdGhpcyBvbmUsXG4gICAgLy8gbWVyZ2UgdGhvc2UgaW50byBvbmUgc3Ryb25nIGRlbGltaXRlci5cbiAgICAvL1xuICAgIC8vIGA8ZW0+PGVtPndoYXRldmVyPC9lbT48L2VtPmAgLT4gYDxzdHJvbmc+d2hhdGV2ZXI8L3N0cm9uZz5gXG4gICAgLy9cbiAgICBpc1N0cm9uZyA9IGkgPiAwICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgLSAxXS5lbmQgPT09IHN0YXJ0RGVsaW0uZW5kICsgMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW4gPT09IGVuZERlbGltLnRva2VuICsgMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlcjtcblxuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydERlbGltLm1hcmtlcik7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgIHRva2VuLnR5cGUgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmdfb3BlbicgOiAnZW1fb3Blbic7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgIHRva2VuLm1hcmt1cCAgPSBpc1N0cm9uZyA/IGNoICsgY2ggOiBjaDtcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX2Nsb3NlJyA6ICdlbV9jbG9zZSc7XG4gICAgdG9rZW4udGFnICAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZycgOiAnZW0nO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgaWYgKGlzU3Ryb25nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpIC0gMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW5dLmNvbnRlbnQgPSAnJztcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanMiLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBqdW1wOiAgIGksXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcbiAgICAgIGVuZDogICAgLTEsXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUpIHtcbiAgdmFyIGksIGosXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGxvbmVNYXJrZXJzID0gW10sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2guanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tZHVybC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qcyIsIm1vZHVsZS5leHBvcnRzPS9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXguanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanMiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TeW1ib2wuanMiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsInZhciBiYXNlUmFuZG9tID0gcmVxdWlyZSgnLi9fYmFzZVJhbmRvbScpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICB9XG4gIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaHVmZmxlU2VsZjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zaHVmZmxlU2VsZi5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuL25vdycpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9kZWJvdW5jZS5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0FycmF5LmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNMZW5ndGguanMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iaiwgX1ZkdCwgYmxvY2tzLCAkY2FsbGVlKSB7XG4gICAgX1ZkdCB8fCAoX1ZkdCA9IFZkdCk7XG4gICAgb2JqIHx8IChvYmogPSB7fSk7XG4gICAgYmxvY2tzIHx8IChibG9ja3MgPSB7fSk7XG4gICAgdmFyIGggPSBfVmR0Lm1pc3MuaCwgaGMgPSBfVmR0Lm1pc3MuaGMsIGh1ID0gX1ZkdC5taXNzLmh1LCB3aWRnZXRzID0gdGhpcyAmJiB0aGlzLndpZGdldHMgfHwge30sIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSB7fSxcbiAgICAgICAgX191ID0gX1ZkdC51dGlscywgZXh0ZW5kID0gX191LmV4dGVuZCwgX2UgPSBfX3UuZXJyb3IsIF9jbGFzc05hbWUgPSBfX3UuY2xhc3NOYW1lLCBfX3NsaWNlID0gX191LnNsaWNlLCBfX25vb3AgPSBfX3Uubm9vcCxcbiAgICAgICAgX19tID0gX191Lm1hcCwgX19vID0gX191Lk9wdGlvbnMsIF9nZXRNb2RlbCA9IF9fby5nZXRNb2RlbCwgX3NldE1vZGVsID0gX19vLnNldE1vZGVsLFxuICAgICAgICBfc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbiAgICAgICAgX3NldFNlbGVjdE1vZGVsID0gX191LnNldFNlbGVjdE1vZGVsLFxuICAgICAgICBzZWxmID0gdGhpcy5kYXRhLCAkdGhpcyA9IHRoaXMsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9ICgkY2FsbGVlIHx8IHt9KS5fc3VwZXI7XG5cbiAgICBjb25zdCBuYXYgPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogJ+aVmeeoiycsXG4gICAgICAgIGhyZWY6ICdkb2N1bWVudCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdBUEknLFxuICAgICAgICBocmVmOiAnYXBpJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0Jsb2cnLFxuICAgICAgICBocmVmOiAnYmxvZydcbiAgICB9XG5dXG4gICAgcmV0dXJuIGgoJ2RpdicsIG51bGwsIFtcbiAgICAgICAgaCgnZGl2JywgbnVsbCwgaCgnaGVhZGVyJywgbnVsbCwgKF9ibG9ja3NbJ2hlYWRlciddID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGgoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICdocmVmJzogJyMvJ1xuICAgICAgICAgICAgICAgIH0sICdJbnRhY3QnLCAnbG9nbycpLFxuICAgICAgICAgICAgICAgIGgoJ25hdicsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgX19tKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChuYXYpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiAoYCMvJHt2YWx1ZS5ocmVmfWApfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHZhbHVlLnRpdGxlKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcyksIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdmFsdWUuaHJlZiA9PT0gc2NvcGUubmF2SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sICR0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgbnVsbCwgJ2JvcmRlcicpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pICYmIChfX2Jsb2Nrc1snaGVhZGVyJ10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2Nrc1snaGVhZGVyJ10gPyBibG9ja3NbJ2hlYWRlciddLmFwcGx5KCR0aGlzLCBbZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ibG9ja3NbJ2hlYWRlciddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1dLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJncywgMSkpKSA6IF9ibG9ja3NbJ2hlYWRlciddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgfSkgJiYgX19ibG9ja3NbJ2hlYWRlciddLmFwcGx5KCR0aGlzLCBbX19ub29wXSkpLCAnaGVhZGVyLXdyYXBwZXInKSxcbiAgICAgICAgaCgnZGl2JywgbnVsbCwgKF9ibG9ja3NbJ2NvbnRlbnQnXSA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pICYmIChfX2Jsb2Nrc1snY29udGVudCddID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiBibG9ja3NbJ2NvbnRlbnQnXSA/IGJsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBbZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3MsIDEpKSkgOiBfYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KSAmJiBfX2Jsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBbX19ub29wXSksICdjb250ZW50LXdyYXBwZXInKVxuICAgIF0sIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKCdtYWluLXdyYXBwZXIgJyArIChzY29wZS5jbGFzc05hbWUgfHwgJycpKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpKVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUvcGFnZXMvbGF5b3V0LnZkdCIsIi8qXG5TeW50YXggaGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgYXV0b2RldGVjdGlvbi5cbmh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblxuICAvLyBGaW5kIHRoZSBnbG9iYWwgb2JqZWN0IGZvciBleHBvcnQgdG8gYm90aCB0aGUgYnJvd3NlciBhbmQgd2ViIHdvcmtlcnMuXG4gIHZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cgfHxcbiAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmO1xuXG4gIC8vIFNldHVwIGhpZ2hsaWdodC5qcyBmb3IgZGlmZmVyZW50IGVudmlyb25tZW50cy4gRmlyc3QgaXMgTm9kZS5qcyBvclxuICAvLyBDb21tb25KUy5cbiAgaWYodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTtcbiAgfSBlbHNlIGlmKGdsb2JhbE9iamVjdCkge1xuICAgIC8vIEV4cG9ydCBobGpzIGdsb2JhbGx5IGV2ZW4gd2hlbiB1c2luZyBBTUQgZm9yIGNhc2VzIHdoZW4gdGhpcyBzY3JpcHRcbiAgICAvLyBpcyBsb2FkZWQgd2l0aCBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIGhsanMuXG4gICAgZ2xvYmFsT2JqZWN0LmhsanMgPSBmYWN0b3J5KHt9KTtcblxuICAgIC8vIEZpbmFsbHkgcmVnaXN0ZXIgdGhlIGdsb2JhbCBobGpzIHdpdGggQU1ELlxuICAgIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbE9iamVjdC5obGpzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn0oZnVuY3Rpb24oaGxqcykge1xuICAvLyBDb252ZW5pZW5jZSB2YXJpYWJsZXMgZm9yIGJ1aWxkLWluIG9iamVjdHNcbiAgdmFyIEFycmF5UHJvdG8gPSBbXSxcbiAgICAgIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cztcblxuICAvLyBHbG9iYWwgaW50ZXJuYWwgdmFyaWFibGVzIHVzZWQgd2l0aGluIHRoZSBoaWdobGlnaHQuanMgbGlicmFyeS5cbiAgdmFyIGxhbmd1YWdlcyA9IHt9LFxuICAgICAgYWxpYXNlcyAgID0ge307XG5cbiAgLy8gUmVndWxhciBleHByZXNzaW9ucyB1c2VkIHRocm91Z2hvdXQgdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICB2YXIgbm9IaWdobGlnaHRSZSAgICA9IC9eKG5vLT9oaWdobGlnaHR8cGxhaW58dGV4dCkkL2ksXG4gICAgICBsYW5ndWFnZVByZWZpeFJlID0gL1xcYmxhbmcoPzp1YWdlKT8tKFtcXHctXSspXFxiL2ksXG4gICAgICBmaXhNYXJrdXBSZSAgICAgID0gLygoXig8W14+XSs+fFxcdHwpK3woPzpcXG4pKSkvZ207XG5cbiAgdmFyIHNwYW5FbmRUYWcgPSAnPC9zcGFuPic7XG5cbiAgLy8gR2xvYmFsIG9wdGlvbnMgdXNlZCB3aGVuIHdpdGhpbiBleHRlcm5hbCBBUElzLiBUaGlzIGlzIG1vZGlmaWVkIHdoZW5cbiAgLy8gY2FsbGluZyB0aGUgYGhsanMuY29uZmlndXJlYCBmdW5jdGlvbi5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgY2xhc3NQcmVmaXg6ICdobGpzLScsXG4gICAgdGFiUmVwbGFjZTogbnVsbCxcbiAgICB1c2VCUjogZmFsc2UsXG4gICAgbGFuZ3VhZ2VzOiB1bmRlZmluZWRcbiAgfTtcblxuXG4gIC8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbiAgZnVuY3Rpb24gZXNjYXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RSZShyZSwgbGV4ZW1lKSB7XG4gICAgdmFyIG1hdGNoID0gcmUgJiYgcmUuZXhlYyhsZXhlbWUpO1xuICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaC5pbmRleCA9PT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SGlnaGxpZ2h0ZWQobGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gbm9IaWdobGlnaHRSZS50ZXN0KGxhbmd1YWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJsb2NrTGFuZ3VhZ2UoYmxvY2spIHtcbiAgICB2YXIgaSwgbWF0Y2gsIGxlbmd0aCwgX2NsYXNzO1xuICAgIHZhciBjbGFzc2VzID0gYmxvY2suY2xhc3NOYW1lICsgJyAnO1xuXG4gICAgY2xhc3NlcyArPSBibG9jay5wYXJlbnROb2RlID8gYmxvY2sucGFyZW50Tm9kZS5jbGFzc05hbWUgOiAnJztcblxuICAgIC8vIGxhbmd1YWdlLSogdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5vbi1wcmVmaXhlZCBjbGFzcyBuYW1lcy5cbiAgICBtYXRjaCA9IGxhbmd1YWdlUHJlZml4UmUuZXhlYyhjbGFzc2VzKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBnZXRMYW5ndWFnZShtYXRjaFsxXSkgPyBtYXRjaFsxXSA6ICduby1oaWdobGlnaHQnO1xuICAgIH1cblxuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBfY2xhc3MgPSBjbGFzc2VzW2ldXG5cbiAgICAgIGlmIChpc05vdEhpZ2hsaWdodGVkKF9jbGFzcykgfHwgZ2V0TGFuZ3VhZ2UoX2NsYXNzKSkge1xuICAgICAgICByZXR1cm4gX2NsYXNzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaGVyaXQocGFyZW50KSB7ICAvLyBpbmhlcml0KHBhcmVudCwgb3ZlcnJpZGVfb2JqLCBvdmVycmlkZV9vYmosIC4uLilcbiAgICB2YXIga2V5O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpXG4gICAgICByZXN1bHRba2V5XSA9IHBhcmVudFtrZXldO1xuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGZvciAoa2V5IGluIG9iailcbiAgICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyogU3RyZWFtIG1lcmdpbmcgKi9cblxuICBmdW5jdGlvbiBub2RlU3RyZWFtKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgKGZ1bmN0aW9uIF9ub2RlU3RyZWFtKG5vZGUsIG9mZnNldCkge1xuICAgICAgZm9yICh2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMylcbiAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgbm9kZTogY2hpbGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZVN0cmVhbShjaGlsZCwgb2Zmc2V0KTtcbiAgICAgICAgICAvLyBQcmV2ZW50IHZvaWQgZWxlbWVudHMgZnJvbSBoYXZpbmcgYW4gZW5kIHRhZyB0aGF0IHdvdWxkIGFjdHVhbGx5XG4gICAgICAgICAgLy8gZG91YmxlIHRoZW0gaW4gdGhlIG91dHB1dC4gVGhlcmUgYXJlIG1vcmUgdm9pZCBlbGVtZW50cyBpbiBIVE1MXG4gICAgICAgICAgLy8gYnV0IHdlIGxpc3Qgb25seSB0aG9zZSByZWFsaXN0aWNhbGx5IGV4cGVjdGVkIGluIGNvZGUgZGlzcGxheS5cbiAgICAgICAgICBpZiAoIXRhZyhjaGlsZCkubWF0Y2goL2JyfGhyfGltZ3xpbnB1dC8pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIGV2ZW50OiAnc3RvcCcsXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0pKG5vZGUsIDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVN0cmVhbXMob3JpZ2luYWwsIGhpZ2hsaWdodGVkLCB2YWx1ZSkge1xuICAgIHZhciBwcm9jZXNzZWQgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbm9kZVN0YWNrID0gW107XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RTdHJlYW0oKSB7XG4gICAgICBpZiAoIW9yaWdpbmFsLmxlbmd0aCB8fCAhaGlnaGxpZ2h0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5sZW5ndGggPyBvcmlnaW5hbCA6IGhpZ2hsaWdodGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsWzBdLm9mZnNldCAhPT0gaGlnaGxpZ2h0ZWRbMF0ub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWxbMF0ub2Zmc2V0IDwgaGlnaGxpZ2h0ZWRbMF0ub2Zmc2V0KSA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBUbyBhdm9pZCBzdGFydGluZyB0aGUgc3RyZWFtIGp1c3QgYmVmb3JlIGl0IHNob3VsZCBzdG9wIHRoZSBvcmRlciBpc1xuICAgICAgZW5zdXJlZCB0aGF0IG9yaWdpbmFsIGFsd2F5cyBzdGFydHMgZmlyc3QgYW5kIGNsb3NlcyBsYXN0OlxuXG4gICAgICBpZiAoZXZlbnQxID09ICdzdGFydCcgJiYgZXZlbnQyID09ICdzdGFydCcpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgIGlmIChldmVudDEgPT0gJ3N0YXJ0JyAmJiBldmVudDIgPT0gJ3N0b3AnKVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQ7XG4gICAgICBpZiAoZXZlbnQxID09ICdzdG9wJyAmJiBldmVudDIgPT0gJ3N0YXJ0JylcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgaWYgKGV2ZW50MSA9PSAnc3RvcCcgJiYgZXZlbnQyID09ICdzdG9wJylcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkO1xuXG4gICAgICAuLi4gd2hpY2ggaXMgY29sbGFwc2VkIHRvOlxuICAgICAgKi9cbiAgICAgIHJldHVybiBoaWdobGlnaHRlZFswXS5ldmVudCA9PT0gJ3N0YXJ0JyA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3Blbihub2RlKSB7XG4gICAgICBmdW5jdGlvbiBhdHRyX3N0cihhKSB7cmV0dXJuICcgJyArIGEubm9kZU5hbWUgKyAnPVwiJyArIGVzY2FwZShhLnZhbHVlKS5yZXBsYWNlKCdcIicsICcmcXVvdDsnKSArICdcIic7fVxuICAgICAgcmVzdWx0ICs9ICc8JyArIHRhZyhub2RlKSArIEFycmF5UHJvdG8ubWFwLmNhbGwobm9kZS5hdHRyaWJ1dGVzLCBhdHRyX3N0cikuam9pbignJykgKyAnPic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2Uobm9kZSkge1xuICAgICAgcmVzdWx0ICs9ICc8LycgKyB0YWcobm9kZSkgKyAnPic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKGV2ZW50KSB7XG4gICAgICAoZXZlbnQuZXZlbnQgPT09ICdzdGFydCcgPyBvcGVuIDogY2xvc2UpKGV2ZW50Lm5vZGUpO1xuICAgIH1cblxuICAgIHdoaWxlIChvcmlnaW5hbC5sZW5ndGggfHwgaGlnaGxpZ2h0ZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgc3RyZWFtID0gc2VsZWN0U3RyZWFtKCk7XG4gICAgICByZXN1bHQgKz0gZXNjYXBlKHZhbHVlLnN1YnN0cmluZyhwcm9jZXNzZWQsIHN0cmVhbVswXS5vZmZzZXQpKTtcbiAgICAgIHByb2Nlc3NlZCA9IHN0cmVhbVswXS5vZmZzZXQ7XG4gICAgICBpZiAoc3RyZWFtID09PSBvcmlnaW5hbCkge1xuICAgICAgICAvKlxuICAgICAgICBPbiBhbnkgb3BlbmluZyBvciBjbG9zaW5nIHRhZyBvZiB0aGUgb3JpZ2luYWwgbWFya3VwIHdlIGZpcnN0IGNsb3NlXG4gICAgICAgIHRoZSBlbnRpcmUgaGlnaGxpZ2h0ZWQgbm9kZSBzdGFjaywgdGhlbiByZW5kZXIgdGhlIG9yaWdpbmFsIHRhZyBhbG9uZ1xuICAgICAgICB3aXRoIGFsbCB0aGUgZm9sbG93aW5nIG9yaWdpbmFsIHRhZ3MgYXQgdGhlIHNhbWUgb2Zmc2V0IGFuZCB0aGVuXG4gICAgICAgIHJlb3BlbiBhbGwgdGhlIHRhZ3Mgb24gdGhlIGhpZ2hsaWdodGVkIHN0YWNrLlxuICAgICAgICAqL1xuICAgICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2goY2xvc2UpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcmVuZGVyKHN0cmVhbS5zcGxpY2UoMCwgMSlbMF0pO1xuICAgICAgICAgIHN0cmVhbSA9IHNlbGVjdFN0cmVhbSgpO1xuICAgICAgICB9IHdoaWxlIChzdHJlYW0gPT09IG9yaWdpbmFsICYmIHN0cmVhbS5sZW5ndGggJiYgc3RyZWFtWzBdLm9mZnNldCA9PT0gcHJvY2Vzc2VkKTtcbiAgICAgICAgbm9kZVN0YWNrLnJldmVyc2UoKS5mb3JFYWNoKG9wZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0cmVhbVswXS5ldmVudCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIG5vZGVTdGFjay5wdXNoKHN0cmVhbVswXS5ub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKHN0cmVhbS5zcGxpY2UoMCwgMSlbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlKHZhbHVlLnN1YnN0cihwcm9jZXNzZWQpKTtcbiAgfVxuXG4gIC8qIEluaXRpYWxpemF0aW9uICovXG5cbiAgZnVuY3Rpb24gZXhwYW5kX21vZGUobW9kZSkge1xuICAgIGlmIChtb2RlLnZhcmlhbnRzICYmICFtb2RlLmNhY2hlZF92YXJpYW50cykge1xuICAgICAgbW9kZS5jYWNoZWRfdmFyaWFudHMgPSBtb2RlLnZhcmlhbnRzLm1hcChmdW5jdGlvbih2YXJpYW50KSB7XG4gICAgICAgIHJldHVybiBpbmhlcml0KG1vZGUsIHt2YXJpYW50czogbnVsbH0sIHZhcmlhbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlLmNhY2hlZF92YXJpYW50cyB8fCAobW9kZS5lbmRzV2l0aFBhcmVudCAmJiBbaW5oZXJpdChtb2RlKV0pIHx8IFttb2RlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGVMYW5ndWFnZShsYW5ndWFnZSkge1xuXG4gICAgZnVuY3Rpb24gcmVTdHIocmUpIHtcbiAgICAgICAgcmV0dXJuIChyZSAmJiByZS5zb3VyY2UpIHx8IHJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxhbmdSZSh2YWx1ZSwgZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgICAgcmVTdHIodmFsdWUpLFxuICAgICAgICAnbScgKyAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKSArIChnbG9iYWwgPyAnZycgOiAnJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGlsZU1vZGUobW9kZSwgcGFyZW50KSB7XG4gICAgICBpZiAobW9kZS5jb21waWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbW9kZS5jb21waWxlZCA9IHRydWU7XG5cbiAgICAgIG1vZGUua2V5d29yZHMgPSBtb2RlLmtleXdvcmRzIHx8IG1vZGUuYmVnaW5LZXl3b3JkcztcbiAgICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICAgIHZhciBjb21waWxlZF9rZXl3b3JkcyA9IHt9O1xuXG4gICAgICAgIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBzdHIpIHtcbiAgICAgICAgICBpZiAobGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ci5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oa3cpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0ga3cuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgIGNvbXBpbGVkX2tleXdvcmRzW3BhaXJbMF1dID0gW2NsYXNzTmFtZSwgcGFpclsxXSA/IE51bWJlcihwYWlyWzFdKSA6IDFdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kZS5rZXl3b3JkcyA9PT0gJ3N0cmluZycpIHsgLy8gc3RyaW5nXG4gICAgICAgICAgZmxhdHRlbigna2V5d29yZCcsIG1vZGUua2V5d29yZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdEtleXMobW9kZS5rZXl3b3JkcykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBmbGF0dGVuKGNsYXNzTmFtZSwgbW9kZS5rZXl3b3Jkc1tjbGFzc05hbWVdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZWRfa2V5d29yZHM7XG4gICAgICB9XG4gICAgICBtb2RlLmxleGVtZXNSZSA9IGxhbmdSZShtb2RlLmxleGVtZXMgfHwgL1xcdysvLCB0cnVlKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBpZiAobW9kZS5iZWdpbktleXdvcmRzKSB7XG4gICAgICAgICAgbW9kZS5iZWdpbiA9ICdcXFxcYignICsgbW9kZS5iZWdpbktleXdvcmRzLnNwbGl0KCcgJykuam9pbignfCcpICsgJylcXFxcYic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlLmJlZ2luKVxuICAgICAgICAgIG1vZGUuYmVnaW4gPSAvXFxCfFxcYi87XG4gICAgICAgIG1vZGUuYmVnaW5SZSA9IGxhbmdSZShtb2RlLmJlZ2luKTtcbiAgICAgICAgaWYgKCFtb2RlLmVuZCAmJiAhbW9kZS5lbmRzV2l0aFBhcmVudClcbiAgICAgICAgICBtb2RlLmVuZCA9IC9cXEJ8XFxiLztcbiAgICAgICAgaWYgKG1vZGUuZW5kKVxuICAgICAgICAgIG1vZGUuZW5kUmUgPSBsYW5nUmUobW9kZS5lbmQpO1xuICAgICAgICBtb2RlLnRlcm1pbmF0b3JfZW5kID0gcmVTdHIobW9kZS5lbmQpIHx8ICcnO1xuICAgICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCAmJiBwYXJlbnQudGVybWluYXRvcl9lbmQpXG4gICAgICAgICAgbW9kZS50ZXJtaW5hdG9yX2VuZCArPSAobW9kZS5lbmQgPyAnfCcgOiAnJykgKyBwYXJlbnQudGVybWluYXRvcl9lbmQ7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS5pbGxlZ2FsKVxuICAgICAgICBtb2RlLmlsbGVnYWxSZSA9IGxhbmdSZShtb2RlLmlsbGVnYWwpO1xuICAgICAgaWYgKG1vZGUucmVsZXZhbmNlID09IG51bGwpXG4gICAgICAgIG1vZGUucmVsZXZhbmNlID0gMTtcbiAgICAgIGlmICghbW9kZS5jb250YWlucykge1xuICAgICAgICBtb2RlLmNvbnRhaW5zID0gW107XG4gICAgICB9XG4gICAgICBtb2RlLmNvbnRhaW5zID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgbW9kZS5jb250YWlucy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gZXhwYW5kX21vZGUoYyA9PT0gJ3NlbGYnID8gbW9kZSA6IGMpXG4gICAgICB9KSk7XG4gICAgICBtb2RlLmNvbnRhaW5zLmZvckVhY2goZnVuY3Rpb24oYykge2NvbXBpbGVNb2RlKGMsIG1vZGUpO30pO1xuXG4gICAgICBpZiAobW9kZS5zdGFydHMpIHtcbiAgICAgICAgY29tcGlsZU1vZGUobW9kZS5zdGFydHMsIHBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXJtaW5hdG9ycyA9XG4gICAgICAgIG1vZGUuY29udGFpbnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5iZWdpbktleXdvcmRzID8gJ1xcXFwuPygnICsgYy5iZWdpbiArICcpXFxcXC4/JyA6IGMuYmVnaW47XG4gICAgICAgIH0pXG4gICAgICAgIC5jb25jYXQoW21vZGUudGVybWluYXRvcl9lbmQsIG1vZGUuaWxsZWdhbF0pXG4gICAgICAgIC5tYXAocmVTdHIpXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBtb2RlLnRlcm1pbmF0b3JzID0gdGVybWluYXRvcnMubGVuZ3RoID8gbGFuZ1JlKHRlcm1pbmF0b3JzLmpvaW4oJ3wnKSwgdHJ1ZSkgOiB7ZXhlYzogZnVuY3Rpb24oLypzKi8pIHtyZXR1cm4gbnVsbDt9fTtcbiAgICB9XG5cbiAgICBjb21waWxlTW9kZShsYW5ndWFnZSk7XG4gIH1cblxuICAvKlxuICBDb3JlIGhpZ2hsaWdodGluZyBmdW5jdGlvbi4gQWNjZXB0cyBhIGxhbmd1YWdlIG5hbWUsIG9yIGFuIGFsaWFzLCBhbmQgYVxuICBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICBwcm9wZXJ0aWVzOlxuXG4gIC0gcmVsZXZhbmNlIChpbnQpXG4gIC0gdmFsdWUgKGFuIEhUTUwgc3RyaW5nIHdpdGggaGlnaGxpZ2h0aW5nIG1hcmt1cClcblxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHQobmFtZSwgdmFsdWUsIGlnbm9yZV9pbGxlZ2FscywgY29udGludWF0aW9uKSB7XG5cbiAgICBmdW5jdGlvbiBzdWJNb2RlKGxleGVtZSwgbW9kZSkge1xuICAgICAgdmFyIGksIGxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbW9kZS5jb250YWlucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGVzdFJlKG1vZGUuY29udGFpbnNbaV0uYmVnaW5SZSwgbGV4ZW1lKSkge1xuICAgICAgICAgIHJldHVybiBtb2RlLmNvbnRhaW5zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIGxleGVtZSkge1xuICAgICAgaWYgKHRlc3RSZShtb2RlLmVuZFJlLCBsZXhlbWUpKSB7XG4gICAgICAgIHdoaWxlIChtb2RlLmVuZHNQYXJlbnQgJiYgbW9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBtb2RlID0gbW9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9XG4gICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCkge1xuICAgICAgICByZXR1cm4gZW5kT2ZNb2RlKG1vZGUucGFyZW50LCBsZXhlbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWxsZWdhbChsZXhlbWUsIG1vZGUpIHtcbiAgICAgIHJldHVybiAhaWdub3JlX2lsbGVnYWxzICYmIHRlc3RSZShtb2RlLmlsbGVnYWxSZSwgbGV4ZW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXl3b3JkTWF0Y2gobW9kZSwgbWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaF9zdHIgPSBsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSA6IG1hdGNoWzBdO1xuICAgICAgcmV0dXJuIG1vZGUua2V5d29yZHMuaGFzT3duUHJvcGVydHkobWF0Y2hfc3RyKSAmJiBtb2RlLmtleXdvcmRzW21hdGNoX3N0cl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRTcGFuKGNsYXNzbmFtZSwgaW5zaWRlU3BhbiwgbGVhdmVPcGVuLCBub1ByZWZpeCkge1xuICAgICAgdmFyIGNsYXNzUHJlZml4ID0gbm9QcmVmaXggPyAnJyA6IG9wdGlvbnMuY2xhc3NQcmVmaXgsXG4gICAgICAgICAgb3BlblNwYW4gICAgPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3NQcmVmaXgsXG4gICAgICAgICAgY2xvc2VTcGFuICAgPSBsZWF2ZU9wZW4gPyAnJyA6IHNwYW5FbmRUYWdcblxuICAgICAgb3BlblNwYW4gKz0gY2xhc3NuYW1lICsgJ1wiPic7XG5cbiAgICAgIHJldHVybiBvcGVuU3BhbiArIGluc2lkZVNwYW4gKyBjbG9zZVNwYW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXdvcmRzKCkge1xuICAgICAgdmFyIGtleXdvcmRfbWF0Y2gsIGxhc3RfaW5kZXgsIG1hdGNoLCByZXN1bHQ7XG5cbiAgICAgIGlmICghdG9wLmtleXdvcmRzKVxuICAgICAgICByZXR1cm4gZXNjYXBlKG1vZGVfYnVmZmVyKTtcblxuICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICBsYXN0X2luZGV4ID0gMDtcbiAgICAgIHRvcC5sZXhlbWVzUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIG1hdGNoID0gdG9wLmxleGVtZXNSZS5leGVjKG1vZGVfYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIHJlc3VsdCArPSBlc2NhcGUobW9kZV9idWZmZXIuc3Vic3RyaW5nKGxhc3RfaW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIGtleXdvcmRfbWF0Y2ggPSBrZXl3b3JkTWF0Y2godG9wLCBtYXRjaCk7XG4gICAgICAgIGlmIChrZXl3b3JkX21hdGNoKSB7XG4gICAgICAgICAgcmVsZXZhbmNlICs9IGtleXdvcmRfbWF0Y2hbMV07XG4gICAgICAgICAgcmVzdWx0ICs9IGJ1aWxkU3BhbihrZXl3b3JkX21hdGNoWzBdLCBlc2NhcGUobWF0Y2hbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2luZGV4ID0gdG9wLmxleGVtZXNSZS5sYXN0SW5kZXg7XG4gICAgICAgIG1hdGNoID0gdG9wLmxleGVtZXNSZS5leGVjKG1vZGVfYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGUobW9kZV9idWZmZXIuc3Vic3RyKGxhc3RfaW5kZXgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSB7XG4gICAgICB2YXIgZXhwbGljaXQgPSB0eXBlb2YgdG9wLnN1Ykxhbmd1YWdlID09PSAnc3RyaW5nJztcbiAgICAgIGlmIChleHBsaWNpdCAmJiAhbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZShtb2RlX2J1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBleHBsaWNpdCA/XG4gICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0KHRvcC5zdWJMYW5ndWFnZSwgbW9kZV9idWZmZXIsIHRydWUsIGNvbnRpbnVhdGlvbnNbdG9wLnN1Ykxhbmd1YWdlXSkgOlxuICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodEF1dG8obW9kZV9idWZmZXIsIHRvcC5zdWJMYW5ndWFnZS5sZW5ndGggPyB0b3Auc3ViTGFuZ3VhZ2UgOiB1bmRlZmluZWQpO1xuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2VjYXNlIGluIHBvaW50IGlzIE1hcmtkb3duIHRoYXRcbiAgICAgIC8vIGFsbG93cyBYTUwgZXZlcnl3aGVyZSBhbmQgbWFrZXMgZXZlcnkgWE1MIHNuaXBwZXQgdG8gaGF2ZSBhIG11Y2ggbGFyZ2VyIE1hcmtkb3duXG4gICAgICAvLyBzY29yZS5cbiAgICAgIGlmICh0b3AucmVsZXZhbmNlID4gMCkge1xuICAgICAgICByZWxldmFuY2UgKz0gcmVzdWx0LnJlbGV2YW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBsaWNpdCkge1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSByZXN1bHQudG9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkU3BhbihyZXN1bHQubGFuZ3VhZ2UsIHJlc3VsdC52YWx1ZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCdWZmZXIoKSB7XG4gICAgICByZXN1bHQgKz0gKHRvcC5zdWJMYW5ndWFnZSAhPSBudWxsID8gcHJvY2Vzc1N1Ykxhbmd1YWdlKCkgOiBwcm9jZXNzS2V5d29yZHMoKSk7XG4gICAgICBtb2RlX2J1ZmZlciA9ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlKSB7XG4gICAgICByZXN1bHQgKz0gbW9kZS5jbGFzc05hbWU/IGJ1aWxkU3Bhbihtb2RlLmNsYXNzTmFtZSwgJycsIHRydWUpOiAnJztcbiAgICAgIHRvcCA9IE9iamVjdC5jcmVhdGUobW9kZSwge3BhcmVudDoge3ZhbHVlOiB0b3B9fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xleGVtZShidWZmZXIsIGxleGVtZSkge1xuXG4gICAgICBtb2RlX2J1ZmZlciArPSBidWZmZXI7XG5cbiAgICAgIGlmIChsZXhlbWUgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3X21vZGUgPSBzdWJNb2RlKGxleGVtZSwgdG9wKTtcbiAgICAgIGlmIChuZXdfbW9kZSkge1xuICAgICAgICBpZiAobmV3X21vZGUuc2tpcCkge1xuICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3X21vZGUuZXhjbHVkZUJlZ2luKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgICBpZiAoIW5ld19tb2RlLnJldHVybkJlZ2luICYmICFuZXdfbW9kZS5leGNsdWRlQmVnaW4pIHtcbiAgICAgICAgICAgIG1vZGVfYnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydE5ld01vZGUobmV3X21vZGUsIGxleGVtZSk7XG4gICAgICAgIHJldHVybiBuZXdfbW9kZS5yZXR1cm5CZWdpbiA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kX21vZGUgPSBlbmRPZk1vZGUodG9wLCBsZXhlbWUpO1xuICAgICAgaWYgKGVuZF9tb2RlKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0b3A7XG4gICAgICAgIGlmIChvcmlnaW4uc2tpcCkge1xuICAgICAgICAgIG1vZGVfYnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIShvcmlnaW4ucmV0dXJuRW5kIHx8IG9yaWdpbi5leGNsdWRlRW5kKSkge1xuICAgICAgICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgICAgaWYgKG9yaWdpbi5leGNsdWRlRW5kKSB7XG4gICAgICAgICAgICBtb2RlX2J1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmICh0b3AuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3BhbkVuZFRhZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0b3Auc2tpcCkge1xuICAgICAgICAgICAgcmVsZXZhbmNlICs9IHRvcC5yZWxldmFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIH0gd2hpbGUgKHRvcCAhPT0gZW5kX21vZGUucGFyZW50KTtcbiAgICAgICAgaWYgKGVuZF9tb2RlLnN0YXJ0cykge1xuICAgICAgICAgIHN0YXJ0TmV3TW9kZShlbmRfbW9kZS5zdGFydHMsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luLnJldHVybkVuZCA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbGxlZ2FsKGxleGVtZSwgdG9wKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGxleGVtZSBcIicgKyBsZXhlbWUgKyAnXCIgZm9yIG1vZGUgXCInICsgKHRvcC5jbGFzc05hbWUgfHwgJzx1bm5hbWVkPicpICsgJ1wiJyk7XG5cbiAgICAgIC8qXG4gICAgICBQYXJzZXIgc2hvdWxkIG5vdCByZWFjaCB0aGlzIHBvaW50IGFzIGFsbCB0eXBlcyBvZiBsZXhlbWVzIHNob3VsZCBiZSBjYXVnaHRcbiAgICAgIGVhcmxpZXIsIGJ1dCBpZiBpdCBkb2VzIGR1ZSB0byBzb21lIGJ1ZyBtYWtlIHN1cmUgaXQgYWR2YW5jZXMgYXQgbGVhc3Qgb25lXG4gICAgICBjaGFyYWN0ZXIgZm9yd2FyZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BpbmcuXG4gICAgICAqL1xuICAgICAgbW9kZV9idWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgcmV0dXJuIGxleGVtZS5sZW5ndGggfHwgMTtcbiAgICB9XG5cbiAgICB2YXIgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShuYW1lKTtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICAgIHZhciB0b3AgPSBjb250aW51YXRpb24gfHwgbGFuZ3VhZ2U7XG4gICAgdmFyIGNvbnRpbnVhdGlvbnMgPSB7fTsgLy8ga2VlcCBjb250aW51YXRpb25zIGZvciBzdWItbGFuZ3VhZ2VzXG4gICAgdmFyIHJlc3VsdCA9ICcnLCBjdXJyZW50O1xuICAgIGZvcihjdXJyZW50ID0gdG9wOyBjdXJyZW50ICE9PSBsYW5ndWFnZTsgY3VycmVudCA9IGN1cnJlbnQucGFyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5jbGFzc05hbWUpIHtcbiAgICAgICAgcmVzdWx0ID0gYnVpbGRTcGFuKGN1cnJlbnQuY2xhc3NOYW1lLCAnJywgdHJ1ZSkgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtb2RlX2J1ZmZlciA9ICcnO1xuICAgIHZhciByZWxldmFuY2UgPSAwO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbWF0Y2gsIGNvdW50LCBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0b3AudGVybWluYXRvcnMubGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgIG1hdGNoID0gdG9wLnRlcm1pbmF0b3JzLmV4ZWModmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb3VudCA9IHByb2Nlc3NMZXhlbWUodmFsdWUuc3Vic3RyaW5nKGluZGV4LCBtYXRjaC5pbmRleCksIG1hdGNoWzBdKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIGNvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtZSh2YWx1ZS5zdWJzdHIoaW5kZXgpKTtcbiAgICAgIGZvcihjdXJyZW50ID0gdG9wOyBjdXJyZW50LnBhcmVudDsgY3VycmVudCA9IGN1cnJlbnQucGFyZW50KSB7IC8vIGNsb3NlIGRhbmdsaW5nIG1vZGVzXG4gICAgICAgIGlmIChjdXJyZW50LmNsYXNzTmFtZSkge1xuICAgICAgICAgIHJlc3VsdCArPSBzcGFuRW5kVGFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWxldmFuY2U6IHJlbGV2YW5jZSxcbiAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgbGFuZ3VhZ2U6IG5hbWUsXG4gICAgICAgIHRvcDogdG9wXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm1lc3NhZ2UgJiYgZS5tZXNzYWdlLmluZGV4T2YoJ0lsbGVnYWwnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZSh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgSGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgZGV0ZWN0aW9uLiBBY2NlcHRzIGEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG9cbiAgaGlnaGxpZ2h0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblxuICAtIGxhbmd1YWdlIChkZXRlY3RlZCBsYW5ndWFnZSlcbiAgLSByZWxldmFuY2UgKGludClcbiAgLSB2YWx1ZSAoYW4gSFRNTCBzdHJpbmcgd2l0aCBoaWdobGlnaHRpbmcgbWFya3VwKVxuICAtIHNlY29uZF9iZXN0IChvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgZm9yIHNlY29uZC1iZXN0IGhldXJpc3RpY2FsbHlcbiAgICBkZXRlY3RlZCBsYW5ndWFnZSwgbWF5IGJlIGFic2VudClcblxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBdXRvKHRleHQsIGxhbmd1YWdlU3Vic2V0KSB7XG4gICAgbGFuZ3VhZ2VTdWJzZXQgPSBsYW5ndWFnZVN1YnNldCB8fCBvcHRpb25zLmxhbmd1YWdlcyB8fCBvYmplY3RLZXlzKGxhbmd1YWdlcyk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIHZhbHVlOiBlc2NhcGUodGV4dClcbiAgICB9O1xuICAgIHZhciBzZWNvbmRfYmVzdCA9IHJlc3VsdDtcbiAgICBsYW5ndWFnZVN1YnNldC5maWx0ZXIoZ2V0TGFuZ3VhZ2UpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBoaWdobGlnaHQobmFtZSwgdGV4dCwgZmFsc2UpO1xuICAgICAgY3VycmVudC5sYW5ndWFnZSA9IG5hbWU7XG4gICAgICBpZiAoY3VycmVudC5yZWxldmFuY2UgPiBzZWNvbmRfYmVzdC5yZWxldmFuY2UpIHtcbiAgICAgICAgc2Vjb25kX2Jlc3QgPSBjdXJyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQucmVsZXZhbmNlID4gcmVzdWx0LnJlbGV2YW5jZSkge1xuICAgICAgICBzZWNvbmRfYmVzdCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc2Vjb25kX2Jlc3QubGFuZ3VhZ2UpIHtcbiAgICAgIHJlc3VsdC5zZWNvbmRfYmVzdCA9IHNlY29uZF9iZXN0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgUG9zdC1wcm9jZXNzaW5nIG9mIHRoZSBoaWdobGlnaHRlZCBtYXJrdXA6XG5cbiAgLSByZXBsYWNlIFRBQnMgd2l0aCBzb21ldGhpbmcgbW9yZSB1c2VmdWxcbiAgLSByZXBsYWNlIHJlYWwgbGluZS1icmVha3Mgd2l0aCAnPGJyPicgZm9yIG5vbi1wcmUgY29udGFpbmVyc1xuXG4gICovXG4gIGZ1bmN0aW9uIGZpeE1hcmt1cCh2YWx1ZSkge1xuICAgIHJldHVybiAhKG9wdGlvbnMudGFiUmVwbGFjZSB8fCBvcHRpb25zLnVzZUJSKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiB2YWx1ZS5yZXBsYWNlKGZpeE1hcmt1cFJlLCBmdW5jdGlvbihtYXRjaCwgcDEpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy51c2VCUiAmJiBtYXRjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGJyPic7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRhYlJlcGxhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwMS5yZXBsYWNlKC9cXHQvZywgb3B0aW9ucy50YWJSZXBsYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENsYXNzTmFtZShwcmV2Q2xhc3NOYW1lLCBjdXJyZW50TGFuZywgcmVzdWx0TGFuZykge1xuICAgIHZhciBsYW5ndWFnZSA9IGN1cnJlbnRMYW5nID8gYWxpYXNlc1tjdXJyZW50TGFuZ10gOiByZXN1bHRMYW5nLFxuICAgICAgICByZXN1bHQgICA9IFtwcmV2Q2xhc3NOYW1lLnRyaW0oKV07XG5cbiAgICBpZiAoIXByZXZDbGFzc05hbWUubWF0Y2goL1xcYmhsanNcXGIvKSkge1xuICAgICAgcmVzdWx0LnB1c2goJ2hsanMnKTtcbiAgICB9XG5cbiAgICBpZiAocHJldkNsYXNzTmFtZS5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvKlxuICBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhIERPTSBub2RlIGNvbnRhaW5pbmcgY29kZS4gQWNjZXB0cyBhIERPTSBub2RlIGFuZFxuICB0d28gb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgZml4TWFya3VwLlxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRCbG9jayhibG9jaykge1xuICAgIHZhciBub2RlLCBvcmlnaW5hbFN0cmVhbSwgcmVzdWx0LCByZXN1bHROb2RlLCB0ZXh0O1xuICAgIHZhciBsYW5ndWFnZSA9IGJsb2NrTGFuZ3VhZ2UoYmxvY2spO1xuXG4gICAgaWYgKGlzTm90SGlnaGxpZ2h0ZWQobGFuZ3VhZ2UpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAob3B0aW9ucy51c2VCUikge1xuICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdkaXYnKTtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gYmxvY2suaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9nLCAnJykucmVwbGFjZSgvPGJyWyBcXC9dKj4vZywgJ1xcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gYmxvY2s7XG4gICAgfVxuICAgIHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgIHJlc3VsdCA9IGxhbmd1YWdlID8gaGlnaGxpZ2h0KGxhbmd1YWdlLCB0ZXh0LCB0cnVlKSA6IGhpZ2hsaWdodEF1dG8odGV4dCk7XG5cbiAgICBvcmlnaW5hbFN0cmVhbSA9IG5vZGVTdHJlYW0obm9kZSk7XG4gICAgaWYgKG9yaWdpbmFsU3RyZWFtLmxlbmd0aCkge1xuICAgICAgcmVzdWx0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdkaXYnKTtcbiAgICAgIHJlc3VsdE5vZGUuaW5uZXJIVE1MID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmVzdWx0LnZhbHVlID0gbWVyZ2VTdHJlYW1zKG9yaWdpbmFsU3RyZWFtLCBub2RlU3RyZWFtKHJlc3VsdE5vZGUpLCB0ZXh0KTtcbiAgICB9XG4gICAgcmVzdWx0LnZhbHVlID0gZml4TWFya3VwKHJlc3VsdC52YWx1ZSk7XG5cbiAgICBibG9jay5pbm5lckhUTUwgPSByZXN1bHQudmFsdWU7XG4gICAgYmxvY2suY2xhc3NOYW1lID0gYnVpbGRDbGFzc05hbWUoYmxvY2suY2xhc3NOYW1lLCBsYW5ndWFnZSwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICBibG9jay5yZXN1bHQgPSB7XG4gICAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgICAgcmU6IHJlc3VsdC5yZWxldmFuY2VcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuc2Vjb25kX2Jlc3QpIHtcbiAgICAgIGJsb2NrLnNlY29uZF9iZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZF9iZXN0Lmxhbmd1YWdlLFxuICAgICAgICByZTogcmVzdWx0LnNlY29uZF9iZXN0LnJlbGV2YW5jZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKlxuICBVcGRhdGVzIGhpZ2hsaWdodC5qcyBnbG9iYWwgb3B0aW9ucyB3aXRoIHZhbHVlcyBwYXNzZWQgaW4gdGhlIGZvcm0gb2YgYW4gb2JqZWN0LlxuICAqL1xuICBmdW5jdGlvbiBjb25maWd1cmUodXNlcl9vcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGluaGVyaXQob3B0aW9ucywgdXNlcl9vcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGFsbCA8cHJlPjxjb2RlPi4uPC9jb2RlPjwvcHJlPiBibG9ja3Mgb24gYSBwYWdlLlxuICAqL1xuICBmdW5jdGlvbiBpbml0SGlnaGxpZ2h0aW5nKCkge1xuICAgIGlmIChpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICBpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZCA9IHRydWU7XG5cbiAgICB2YXIgYmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICBBcnJheVByb3RvLmZvckVhY2guY2FsbChibG9ja3MsIGhpZ2hsaWdodEJsb2NrKTtcbiAgfVxuXG4gIC8qXG4gIEF0dGFjaGVzIGhpZ2hsaWdodGluZyB0byB0aGUgcGFnZSBsb2FkIGV2ZW50LlxuICAqL1xuICBmdW5jdGlvbiBpbml0SGlnaGxpZ2h0aW5nT25Mb2FkKCkge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBpbml0SGlnaGxpZ2h0aW5nLCBmYWxzZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGluaXRIaWdobGlnaHRpbmcsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGFuZ3VhZ2UobmFtZSwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbGFuZyA9IGxhbmd1YWdlc1tuYW1lXSA9IGxhbmd1YWdlKGhsanMpO1xuICAgIGlmIChsYW5nLmFsaWFzZXMpIHtcbiAgICAgIGxhbmcuYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGFsaWFzKSB7YWxpYXNlc1thbGlhc10gPSBuYW1lO30pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIG9iamVjdEtleXMobGFuZ3VhZ2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhbmd1YWdlKG5hbWUpIHtcbiAgICBuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGxhbmd1YWdlc1tuYW1lXSB8fCBsYW5ndWFnZXNbYWxpYXNlc1tuYW1lXV07XG4gIH1cblxuICAvKiBJbnRlcmZhY2UgZGVmaW5pdGlvbiAqL1xuXG4gIGhsanMuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICBobGpzLmhpZ2hsaWdodEF1dG8gPSBoaWdobGlnaHRBdXRvO1xuICBobGpzLmZpeE1hcmt1cCA9IGZpeE1hcmt1cDtcbiAgaGxqcy5oaWdobGlnaHRCbG9jayA9IGhpZ2hsaWdodEJsb2NrO1xuICBobGpzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbiAgaGxqcy5pbml0SGlnaGxpZ2h0aW5nID0gaW5pdEhpZ2hsaWdodGluZztcbiAgaGxqcy5pbml0SGlnaGxpZ2h0aW5nT25Mb2FkID0gaW5pdEhpZ2hsaWdodGluZ09uTG9hZDtcbiAgaGxqcy5yZWdpc3Rlckxhbmd1YWdlID0gcmVnaXN0ZXJMYW5ndWFnZTtcbiAgaGxqcy5saXN0TGFuZ3VhZ2VzID0gbGlzdExhbmd1YWdlcztcbiAgaGxqcy5nZXRMYW5ndWFnZSA9IGdldExhbmd1YWdlO1xuICBobGpzLmluaGVyaXQgPSBpbmhlcml0O1xuXG4gIC8vIENvbW1vbiByZWdleHBzXG4gIGhsanMuSURFTlRfUkUgPSAnW2EtekEtWl1cXFxcdyonO1xuICBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgPSAnW2EtekEtWl9dXFxcXHcqJztcbiAgaGxqcy5OVU1CRVJfUkUgPSAnXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCspPyc7XG4gIGhsanMuQ19OVU1CRVJfUkUgPSAnKC0/KShcXFxcYjBbeFhdW2EtZkEtRjAtOV0rfChcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKik/fFxcXFwuXFxcXGQrKShbZUVdWy0rXT9cXFxcZCspPyknOyAvLyAweC4uLiwgMC4uLiwgZGVjaW1hbCwgZmxvYXRcbiAgaGxqcy5CSU5BUllfTlVNQkVSX1JFID0gJ1xcXFxiKDBiWzAxXSspJzsgLy8gMGIuLi5cbiAgaGxqcy5SRV9TVEFSVEVSU19SRSA9ICchfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH4nO1xuXG4gIC8vIENvbW1vbiBtb2Rlc1xuICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUgPSB7XG4gICAgYmVnaW46ICdcXFxcXFxcXFtcXFxcc1xcXFxTXScsIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLkFQT1NfU1RSSU5HX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ1xcJycsIGVuZDogJ1xcJycsXG4gICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgfTtcbiAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnXCInLCBlbmQ6ICdcIicsXG4gICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgfTtcbiAgaGxqcy5QSFJBU0FMX1dPUkRTX01PREUgPSB7XG4gICAgYmVnaW46IC9cXGIoYXxhbnx0aGV8YXJlfEknbXxpc24ndHxkb24ndHxkb2Vzbid0fHdvbid0fGJ1dHxqdXN0fHNob3VsZHxwcmV0dHl8c2ltcGx5fGVub3VnaHxnb25uYXxnb2luZ3x3dGZ8c298c3VjaHx3aWxsfHlvdXx5b3VyfHRoZXl8bGlrZXxtb3JlKVxcYi9cbiAgfTtcbiAgaGxqcy5DT01NRU5UID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQsIGluaGVyaXRzKSB7XG4gICAgdmFyIG1vZGUgPSBobGpzLmluaGVyaXQoXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2NvbW1lbnQnLFxuICAgICAgICBiZWdpbjogYmVnaW4sIGVuZDogZW5kLFxuICAgICAgICBjb250YWluczogW11cbiAgICAgIH0sXG4gICAgICBpbmhlcml0cyB8fCB7fVxuICAgICk7XG4gICAgbW9kZS5jb250YWlucy5wdXNoKGhsanMuUEhSQVNBTF9XT1JEU19NT0RFKTtcbiAgICBtb2RlLmNvbnRhaW5zLnB1c2goe1xuICAgICAgY2xhc3NOYW1lOiAnZG9jdGFnJyxcbiAgICAgIGJlZ2luOiAnKD86VE9ET3xGSVhNRXxOT1RFfEJVR3xYWFgpOicsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZTtcbiAgfTtcbiAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFID0gaGxqcy5DT01NRU5UKCcvLycsICckJyk7XG4gIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJy9cXFxcKicsICdcXFxcKi8nKTtcbiAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnIycsICckJyk7XG4gIGhsanMuTlVNQkVSX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICBiZWdpbjogaGxqcy5OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQ19OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLkNfTlVNQkVSX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLkJJTkFSWV9OVU1CRVJfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiBobGpzLkJJTkFSWV9OVU1CRVJfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuQ1NTX05VTUJFUl9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgYmVnaW46IGhsanMuTlVNQkVSX1JFICsgJygnICtcbiAgICAgICclfGVtfGV4fGNofHJlbScgICtcbiAgICAgICd8dnd8dmh8dm1pbnx2bWF4JyArXG4gICAgICAnfGNtfG1tfGlufHB0fHBjfHB4JyArXG4gICAgICAnfGRlZ3xncmFkfHJhZHx0dXJuJyArXG4gICAgICAnfHN8bXMnICtcbiAgICAgICd8SHp8a0h6JyArXG4gICAgICAnfGRwaXxkcGNtfGRwcHgnICtcbiAgICAgICcpPycsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGhsanMuUkVHRVhQX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAncmVnZXhwJyxcbiAgICBiZWdpbjogL1xcLy8sIGVuZDogL1xcL1tnaW11eV0qLyxcbiAgICBpbGxlZ2FsOiAvXFxuLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcWy8sIGVuZDogL1xcXS8sXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEVdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBobGpzLlRJVExFX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgIGJlZ2luOiBobGpzLklERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBobGpzLlVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgICBjbGFzc05hbWU6ICd0aXRsZScsXG4gICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgaGxqcy5NRVRIT0RfR1VBUkQgPSB7XG4gICAgLy8gZXhjbHVkZXMgbWV0aG9kIG5hbWVzIGZyb20ga2V5d29yZCBwcm9jZXNzaW5nXG4gICAgYmVnaW46ICdcXFxcLlxcXFxzKicgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgcmV0dXJuIGhsanM7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpZ2hsaWdodC5qcy9saWIvaGlnaGxpZ2h0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihobGpzKSB7XG4gIHZhciBWQVIgPSB7XG4gICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7YmVnaW46IC9cXCRbXFx3XFxkI0BdW1xcd1xcZF9dKi99LFxuICAgICAge2JlZ2luOiAvXFwkXFx7KC4qPyl9L31cbiAgICBdXG4gIH07XG4gIHZhciBRVU9URV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogL1wiLywgZW5kOiAvXCIvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBWQVIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICAgICAgYmVnaW46IC9cXCRcXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIHZhciBBUE9TX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvJy8sIGVuZDogLycvXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhbGlhc2VzOiBbJ3NoJywgJ3pzaCddLFxuICAgIGxleGVtZXM6IC9cXGItP1thLXpcXC5fXStcXGIvLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOlxuICAgICAgICAnaWYgdGhlbiBlbHNlIGVsaWYgZmkgZm9yIHdoaWxlIGluIGRvIGRvbmUgY2FzZSBlc2FjIGZ1bmN0aW9uJyxcbiAgICAgIGxpdGVyYWw6XG4gICAgICAgICd0cnVlIGZhbHNlJyxcbiAgICAgIGJ1aWx0X2luOlxuICAgICAgICAvLyBTaGVsbCBidWlsdC1pbnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcbiAgICAgICAgJ2JyZWFrIGNkIGNvbnRpbnVlIGV2YWwgZXhlYyBleGl0IGV4cG9ydCBnZXRvcHRzIGhhc2ggcHdkIHJlYWRvbmx5IHJldHVybiBzaGlmdCB0ZXN0IHRpbWVzICcgK1xuICAgICAgICAndHJhcCB1bWFzayB1bnNldCAnICtcbiAgICAgICAgLy8gQmFzaCBidWlsdC1pbnNcbiAgICAgICAgJ2FsaWFzIGJpbmQgYnVpbHRpbiBjYWxsZXIgY29tbWFuZCBkZWNsYXJlIGVjaG8gZW5hYmxlIGhlbHAgbGV0IGxvY2FsIGxvZ291dCBtYXBmaWxlIHByaW50ZiAnICtcbiAgICAgICAgJ3JlYWQgcmVhZGFycmF5IHNvdXJjZSB0eXBlIHR5cGVzZXQgdWxpbWl0IHVuYWxpYXMgJyArXG4gICAgICAgIC8vIFNoZWxsIG1vZGlmaWVyc1xuICAgICAgICAnc2V0IHNob3B0ICcgK1xuICAgICAgICAvLyBac2ggYnVpbHQtaW5zXG4gICAgICAgICdhdXRvbG9hZCBiZyBiaW5ka2V5IGJ5ZSBjYXAgY2hkaXIgY2xvbmUgY29tcGFyZ3VtZW50cyBjb21wY2FsbCBjb21wY3RsIGNvbXBkZXNjcmliZSBjb21wZmlsZXMgJyArXG4gICAgICAgICdjb21wZ3JvdXBzIGNvbXBxdW90ZSBjb21wdGFncyBjb21wdHJ5IGNvbXB2YWx1ZXMgZGlycyBkaXNhYmxlIGRpc293biBlY2hvdGMgZWNob3RpIGVtdWxhdGUgJyArXG4gICAgICAgICdmYyBmZyBmbG9hdCBmdW5jdGlvbnMgZ2V0Y2FwIGdldGxuIGhpc3RvcnkgaW50ZWdlciBqb2JzIGtpbGwgbGltaXQgbG9nIG5vZ2xvYiBwb3BkIHByaW50ICcgK1xuICAgICAgICAncHVzaGQgcHVzaGxuIHJlaGFzaCBzY2hlZCBzZXRjYXAgc2V0b3B0IHN0YXQgc3VzcGVuZCB0dHljdGwgdW5mdW5jdGlvbiB1bmhhc2ggdW5saW1pdCAnICtcbiAgICAgICAgJ3Vuc2V0b3B0IHZhcmVkIHdhaXQgd2hlbmNlIHdoZXJlIHdoaWNoIHpjb21waWxlIHpmb3JtYXQgemZ0cCB6bGUgem1vZGxvYWQgenBhcnNlb3B0cyB6cHJvZiAnICtcbiAgICAgICAgJ3pwdHkgenJlZ2V4cGFyc2UgenNvY2tldCB6c3R5bGUgenRjcCcsXG4gICAgICBfOlxuICAgICAgICAnLW5lIC1lcSAtbHQgLWd0IC1mIC1kIC1lIC1zIC1sIC1hJyAvLyByZWxldmFuY2UgYm9vc3RlclxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvXiMhW15cXG5dK3NoXFxzKiQvLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luOiAvXFx3W1xcd1xcZF9dKlxccypcXChcXHMqXFwpXFxzKlxcey8sXG4gICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICBjb250YWluczogW2hsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHtiZWdpbjogL1xcd1tcXHdcXGRfXSovfSldLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgICAgUVVPVEVfU1RSSU5HLFxuICAgICAgQVBPU19TVFJJTkcsXG4gICAgICBWQVJcbiAgICBdXG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvYmFzaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW2EtekEtWi1dW2EtekEtWjAtOV8tXSonO1xuICB2YXIgUlVMRSA9IHtcbiAgICBiZWdpbjogL1tBLVpcXF9cXC5cXC1dK1xccyo6LywgcmV0dXJuQmVnaW46IHRydWUsIGVuZDogJzsnLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICBiZWdpbjogL1xcUy8sIGVuZDogJzonLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWdpbjogL1tcXHctXStcXCgvLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdidWlsdF9pbicsXG4gICAgICAgICAgICAgICAgICBiZWdpbjogL1tcXHctXSsvXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBobGpzLkNTU19OVU1CRVJfTU9ERSxcbiAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdudW1iZXInLCBiZWdpbjogJyNbMC05QS1GYS1mXSsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtZXRhJywgYmVnaW46ICchaW1wb3J0YW50J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgaWxsZWdhbDogL1s9XFwvfCdcXCRdLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItaWQnLCBiZWdpbjogLyNbQS1aYS16MC05Xy1dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWNsYXNzJywgYmVnaW46IC9cXC5bQS1aYS16MC05Xy1dKy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWF0dHInLFxuICAgICAgICBiZWdpbjogL1xcWy8sIGVuZDogL1xcXS8sXG4gICAgICAgIGlsbGVnYWw6ICckJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItcHNldWRvJyxcbiAgICAgICAgYmVnaW46IC86KDopP1thLXpBLVowLTlcXF9cXC1cXCtcXChcXClcIicuXSsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ0AoZm9udC1mYWNlfHBhZ2UpJyxcbiAgICAgICAgbGV4ZW1lczogJ1thLXotXSsnLFxuICAgICAgICBrZXl3b3JkczogJ2ZvbnQtZmFjZSBwYWdlJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAJywgZW5kOiAnW3s7XScsIC8vIGF0X3J1bGUgZWF0aW5nIGZpcnN0IFwie1wiIGlzIGEgZ29vZCB0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBkb2VzbuKAmXQgbGV0IGl0IHRvIGJlIHBhcnNlZCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBydWxlIHNldCBidXQgaW5zdGVhZCBkcm9wcyBwYXJzZXIgaW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgbW9kZSB3aGljaCBpcyBob3cgaXQgc2hvdWxkIGJlLlxuICAgICAgICBpbGxlZ2FsOiAvOi8sIC8vIGJyZWFrIG9uIExlc3MgdmFyaWFibGVzIEB2YXI6IC4uLlxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2tleXdvcmQnLFxuICAgICAgICAgICAgYmVnaW46IC9cXHcrL1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXHMvLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSwgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSwgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXRhZycsIGJlZ2luOiBJREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ3snLCBlbmQ6ICd9JyxcbiAgICAgICAgaWxsZWdhbDogL1xcUy8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBSVUxFLFxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGxqcykge1xuICB2YXIgSURFTlRfUkUgPSAnW0EtWmEteiRfXVswLTlBLVphLXokX10qJztcbiAgdmFyIEtFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6XG4gICAgICAnaW4gb2YgaWYgZm9yIHdoaWxlIGZpbmFsbHkgdmFyIG5ldyBmdW5jdGlvbiBkbyByZXR1cm4gdm9pZCBlbHNlIGJyZWFrIGNhdGNoICcgK1xuICAgICAgJ2luc3RhbmNlb2Ygd2l0aCB0aHJvdyBjYXNlIGRlZmF1bHQgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHR5cGVvZiBkZWxldGUgJyArXG4gICAgICAnbGV0IHlpZWxkIGNvbnN0IGV4cG9ydCBzdXBlciBkZWJ1Z2dlciBhcyBhc3luYyBhd2FpdCBzdGF0aWMgJyArXG4gICAgICAvLyBFQ01BU2NyaXB0IDYgbW9kdWxlcyBpbXBvcnRcbiAgICAgICdpbXBvcnQgZnJvbSBhcydcbiAgICAsXG4gICAgbGl0ZXJhbDpcbiAgICAgICd0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkIE5hTiBJbmZpbml0eScsXG4gICAgYnVpbHRfaW46XG4gICAgICAnZXZhbCBpc0Zpbml0ZSBpc05hTiBwYXJzZUZsb2F0IHBhcnNlSW50IGRlY29kZVVSSSBkZWNvZGVVUklDb21wb25lbnQgJyArXG4gICAgICAnZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBlc2NhcGUgdW5lc2NhcGUgT2JqZWN0IEZ1bmN0aW9uIEJvb2xlYW4gRXJyb3IgJyArXG4gICAgICAnRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdG9wSXRlcmF0aW9uIFN5bnRheEVycm9yICcgK1xuICAgICAgJ1R5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgRmxvYXQzMkFycmF5ICcgK1xuICAgICAgJ0Zsb2F0NjRBcnJheSBJbnQxNkFycmF5IEludDMyQXJyYXkgSW50OEFycmF5IFVpbnQxNkFycmF5IFVpbnQzMkFycmF5ICcgK1xuICAgICAgJ1VpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBJbnRsIGFyZ3VtZW50cyByZXF1aXJlICcgK1xuICAgICAgJ21vZHVsZSBjb25zb2xlIHdpbmRvdyBkb2N1bWVudCBTeW1ib2wgU2V0IE1hcCBXZWFrU2V0IFdlYWtNYXAgUHJveHkgUmVmbGVjdCAnICtcbiAgICAgICdQcm9taXNlJ1xuICB9O1xuICB2YXIgRVhQUkVTU0lPTlM7XG4gIHZhciBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgeyBiZWdpbjogJ1xcXFxiKDBbYkJdWzAxXSspJyB9LFxuICAgICAgeyBiZWdpbjogJ1xcXFxiKDBbb09dWzAtN10rKScgfSxcbiAgICAgIHsgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUgfVxuICAgIF0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICdcXFxcJFxcXFx7JywgZW5kOiAnXFxcXH0nLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW10gIC8vIGRlZmluZWQgbGF0ZXJcbiAgfTtcbiAgdmFyIFRFTVBMQVRFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnYCcsIGVuZDogJ2AnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBTVUJTVFxuICAgIF1cbiAgfTtcbiAgU1VCU1QuY29udGFpbnMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIE5VTUJFUixcbiAgICBobGpzLlJFR0VYUF9NT0RFXG4gIF1cbiAgdmFyIFBBUkFNU19DT05UQUlOUyA9IFNVQlNULmNvbnRhaW5zLmNvbmNhdChbXG4gICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICBobGpzLkNfTElORV9DT01NRU5UX01PREVcbiAgXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCddLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvXiMhLywgZW5kOiAvJC9cbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgVEVNUExBVEVfU1RSSU5HLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIE5VTUJFUixcbiAgICAgIHsgLy8gb2JqZWN0IGF0dHIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAvW3ssXVxccyovLCByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IElERU5UX1JFICsgJ1xcXFxzKjonLCByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbe2NsYXNzTmFtZTogJ2F0dHInLCBiZWdpbjogSURFTlRfUkUsIHJlbGV2YW5jZTogMH1dXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLlJFR0VYUF9NT0RFLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgIGJlZ2luOiAnKFxcXFwoLio/XFxcXCl8JyArIElERU5UX1JFICsgJylcXFxccyo9PicsIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgZW5kOiAnXFxcXHMqPT4nLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IElERU5UX1JFXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKFxccypcXCkvLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBFNFggLyBKU1hcbiAgICAgICAgICAgIGJlZ2luOiAvPC8sIGVuZDogLyhcXC9cXHcrfFxcdytcXC8pPi8sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7YmVnaW46IC88XFx3K1xccypcXC8+Lywgc2tpcDogdHJ1ZX0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLzxcXHcrLywgZW5kOiAvKFxcL1xcdyt8XFx3K1xcLyk+Lywgc2tpcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAgICAge2JlZ2luOiAvPFxcdytcXHMqXFwvPi8sIHNraXA6IHRydWV9LFxuICAgICAgICAgICAgICAgICAgJ3NlbGYnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2Z1bmN0aW9uJywgZW5kOiAvXFx7LywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7YmVnaW46IElERU5UX1JFfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICBjb250YWluczogUEFSQU1TX0NPTlRBSU5TXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpbGxlZ2FsOiAvXFxbfCUvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9LFxuICAgICAgaGxqcy5NRVRIT0RfR1VBUkQsXG4gICAgICB7IC8vIEVTNiBjbGFzc1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdjbGFzcycsIGVuZDogL1t7Oz1dLywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgaWxsZWdhbDogL1s6XCJcXFtcXF1dLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7YmVnaW5LZXl3b3JkczogJ2V4dGVuZHMnfSxcbiAgICAgICAgICBobGpzLlVOREVSU0NPUkVfVElUTEVfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbktleXdvcmRzOiAnY29uc3RydWN0b3InLCBlbmQ6IC9cXHsvLCBleGNsdWRlRW5kOiB0cnVlXG4gICAgICB9XG4gICAgXSxcbiAgICBpbGxlZ2FsOiAvIyg/ISEpL1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhsanMpIHtcbiAgdmFyIFhNTF9JREVOVF9SRSA9ICdbQS1aYS16MC05XFxcXC5fOi1dKyc7XG4gIHZhciBUQUdfSU5URVJOQUxTID0ge1xuICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlLFxuICAgIGlsbGVnYWw6IC88LyxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cicsXG4gICAgICAgIGJlZ2luOiBYTUxfSURFTlRfUkUsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC89XFxzKi8sXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZW5kc1BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgIHtiZWdpbjogL1wiLywgZW5kOiAvXCIvfSxcbiAgICAgICAgICAgICAge2JlZ2luOiAvJy8sIGVuZDogLycvfSxcbiAgICAgICAgICAgICAge2JlZ2luOiAvW15cXHNcIic9PD5gXSsvfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhbGlhc2VzOiBbJ2h0bWwnLCAneGh0bWwnLCAncnNzJywgJ2F0b20nLCAneGpiJywgJ3hzZCcsICd4c2wnLCAncGxpc3QnXSxcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogJzwhRE9DVFlQRScsIGVuZDogJz4nLFxuICAgICAgICByZWxldmFuY2U6IDEwLFxuICAgICAgICBjb250YWluczogW3tiZWdpbjogJ1xcXFxbJywgZW5kOiAnXFxcXF0nfV1cbiAgICAgIH0sXG4gICAgICBobGpzLkNPTU1FTlQoXG4gICAgICAgICc8IS0tJyxcbiAgICAgICAgJy0tPicsXG4gICAgICAgIHtcbiAgICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnPFxcXFwhXFxcXFtDREFUQVxcXFxbJywgZW5kOiAnXFxcXF1cXFxcXT4nLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLzxcXD8ocGhwKT8vLCBlbmQ6IC9cXD8+LyxcbiAgICAgICAgc3ViTGFuZ3VhZ2U6ICdwaHAnLFxuICAgICAgICBjb250YWluczogW3tiZWdpbjogJy9cXFxcKicsIGVuZDogJ1xcXFwqLycsIHNraXA6IHRydWV9XVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLypcbiAgICAgICAgVGhlIGxvb2thaGVhZCBwYXR0ZXJuICg/PS4uLikgZW5zdXJlcyB0aGF0ICdiZWdpbicgb25seSBtYXRjaGVzXG4gICAgICAgICc8c3R5bGUnIGFzIGEgc2luZ2xlIHdvcmQsIGZvbGxvd2VkIGJ5IGEgd2hpdGVzcGFjZSBvciBhblxuICAgICAgICBlbmRpbmcgYnJha2V0LiBUaGUgJyQnIGlzIG5lZWRlZCBmb3IgdGhlIGxleGVtZSB0byBiZSByZWNvZ25pemVkXG4gICAgICAgIGJ5IGhsanMuc3ViTW9kZSgpIHRoYXQgdGVzdHMgbGV4ZW1lcyBvdXRzaWRlIHRoZSBzdHJlYW0uXG4gICAgICAgICovXG4gICAgICAgIGJlZ2luOiAnPHN0eWxlKD89XFxcXHN8PnwkKScsIGVuZDogJz4nLFxuICAgICAgICBrZXl3b3Jkczoge25hbWU6ICdzdHlsZSd9LFxuICAgICAgICBjb250YWluczogW1RBR19JTlRFUk5BTFNdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6ICc8L3N0eWxlPicsIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogWydjc3MnLCAneG1sJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSA8c3R5bGUgdGFnIGFib3V0IHRoZSBsb29rYWhlYWQgcGF0dGVyblxuICAgICAgICBiZWdpbjogJzxzY3JpcHQoPz1cXFxcc3w+fCQpJywgZW5kOiAnPicsXG4gICAgICAgIGtleXdvcmRzOiB7bmFtZTogJ3NjcmlwdCd9LFxuICAgICAgICBjb250YWluczogW1RBR19JTlRFUk5BTFNdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6ICdcXDxcXC9zY3JpcHRcXD4nLCByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFsnYWN0aW9uc2NyaXB0JywgJ2phdmFzY3JpcHQnLCAnaGFuZGxlYmFycycsICd4bWwnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICB7YmVnaW46IC88XFw/eG1sLywgZW5kOiAvXFw/Pi8sIHJlbGV2YW5jZTogMTB9LFxuICAgICAgICAgIHtiZWdpbjogLzxcXD9cXHcrLywgZW5kOiAvXFw/Pi99XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIGJlZ2luOiAnPC8/JywgZW5kOiAnLz8+JyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICduYW1lJywgYmVnaW46IC9bXlxcLz48XFxzXSsvLCByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFRBR19JTlRFUk5BTFNcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy94bWwuanMiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgICAgICAgPSBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xpbmtpZnktaXQvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgcmUgPSB7fTtcblxuICAvLyBVc2UgZGlyZWN0IGV4dHJhY3QgaW5zdGVhZCBvZiBgcmVnZW5lcmF0ZWAgdG8gcmVkdXNlIGJyb3dzZXJpZmllZCBzaXplXG4gIHJlLnNyY19BbnkgPSByZXF1aXJlKCd1Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX0NjICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19aICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19QICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgnKS5zb3VyY2U7XG5cbiAgLy8gXFxwe1xcWlxcUFxcQ2NcXENGfSAod2hpdGUgc3BhY2VzICsgY29udHJvbCArIGZvcm1hdCArIHB1bmN0dWF0aW9uKVxuICByZS5zcmNfWlBDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19QLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gXFxwe1xcWlxcQ2N9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sKVxuICByZS5zcmNfWkNjID0gWyByZS5zcmNfWiwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIEV4cGVyaW1lbnRhbC4gTGlzdCBvZiBjaGFycywgY29tcGxldGVseSBwcm9oaWJpdGVkIGluIGxpbmtzXG4gIC8vIGJlY2F1c2UgY2FuIHNlcGFyYXRlIGl0IGZyb20gb3RoZXIgcGFydCBvZiB0ZXh0XG4gIHZhciB0ZXh0X3NlcGFyYXRvcnMgPSAnWz48XFx1ZmY1Y10nO1xuXG4gIC8vIEFsbCBwb3NzaWJsZSB3b3JkIGNoYXJhY3RlcnMgKGV2ZXJ5dGhpbmcgd2l0aG91dCBwdW5jdHVhdGlvbiwgc3BhY2VzICYgY29udHJvbHMpXG4gIC8vIERlZmluZWQgdmlhIHB1bmN0dWF0aW9uICYgc3BhY2VzIHRvIHNhdmUgc3BhY2VcbiAgLy8gU2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlIFxccHtcXExcXE5cXFNcXE19IChcXHcgYnV0IHdpdGhvdXQgYF9gKVxuICByZS5zcmNfcHNldWRvX2xldHRlciAgICAgICA9ICcoPzooPyEnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKScgKyByZS5zcmNfQW55ICsgJyknO1xuICAvLyBUaGUgc2FtZSBhcyBhYm90aGUgYnV0IHdpdGhvdXQgWzAtOV1cbiAgLy8gdmFyIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kID0gJyg/Oig/IVswLTldfCcgKyBzcmNfWlBDYyArICcpJyArIHNyY19BbnkgKyAnKSc7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICByZS5zcmNfaXA0ID1cblxuICAgICcoPzooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJztcblxuICAvLyBQcm9oaWJpdCBhbnkgb2YgXCJAL1tdKClcIiBpbiB1c2VyL3Bhc3MgdG8gYXZvaWQgd3JvbmcgZG9tYWluIGZldGNoLlxuICByZS5zcmNfYXV0aCAgICA9ICcoPzooPzooPyEnICsgcmUuc3JjX1pDYyArICd8W0AvXFxcXFtcXFxcXSgpXSkuKStAKT8nO1xuXG4gIHJlLnNyY19wb3J0ID1cblxuICAgICcoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT8nO1xuXG4gIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgPVxuXG4gICAgJyg/PSR8JyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJykoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8JyArIHJlLnNyY19aUENjICsgJykpJztcblxuICByZS5zcmNfcGF0aCA9XG5cbiAgICAnKD86JyArXG4gICAgICAnWy8/I10nICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAgICcoPyEnICsgcmUuc3JjX1pDYyArICd8JyArIHRleHRfc2VwYXJhdG9ycyArICd8WygpW1xcXFxde30uLFwiXFwnPyFcXFxcLV0pLnwnICtcbiAgICAgICAgICAnXFxcXFsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8XFxcXF0pLikqXFxcXF18JyArXG4gICAgICAgICAgJ1xcXFwoKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFspXSkuKSpcXFxcKXwnICtcbiAgICAgICAgICAnXFxcXHsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W31dKS4pKlxcXFx9fCcgK1xuICAgICAgICAgICdcXFxcXCIoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W1wiXSkuKStcXFxcXCJ8JyArXG4gICAgICAgICAgXCJcXFxcJyg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFsnXSkuKStcXFxcJ3xcIiArXG4gICAgICAgICAgXCJcXFxcJyg/PVwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnfFstXSkufCcgKyAgLy8gYWxsb3cgYEknbV9raW5nYCBpZiBubyBwYWlyIGZvdW5kXG4gICAgICAgICAgJ1xcXFwuezIsM31bYS16QS1aMC05JS9dfCcgKyAvLyBnaXRodWIgaGFzIC4uLiBpbiBjb21taXQgcmFuZ2UgbGlua3MuIFJlc3RyaWN0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXSkufCcgK1xuICAgICAgICAgIChvcHRzICYmIG9wdHNbJy0tLSddID9cbiAgICAgICAgICAgICdcXFxcLSg/IS0tKD86W14tXXwkKSkoPzotKil8JyAvLyBgLS0tYCA9PiBsb25nIGRhc2gsIHRlcm1pbmF0ZVxuICAgICAgICAgIDpcbiAgICAgICAgICAgICdcXFxcLSt8J1xuICAgICAgICAgICkgK1xuICAgICAgICAgICdcXFxcLCg/IScgKyByZS5zcmNfWkNjICsgJykufCcgKyAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJ1xcXFwhKD8hJyArIHJlLnNyY19aQ2MgKyAnfFshXSkufCcgK1xuICAgICAgICAgICdcXFxcPyg/IScgKyByZS5zcmNfWkNjICsgJ3xbP10pLicgK1xuICAgICAgICAnKSsnICtcbiAgICAgICd8XFxcXC8nICtcbiAgICAnKT8nO1xuXG4gIHJlLnNyY19lbWFpbF9uYW1lID1cblxuICAgICdbXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKyc7XG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XG5cbiAgLy8gTW9yZSB0byByZWFkIGFib3V0IGRvbWFpbiBuYW1lc1xuICAvLyBodHRwOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy82MzgyNjAvXG5cbiAgcmUuc3JjX2RvbWFpbl9yb290ID1cblxuICAgIC8vIEFsbG93IGxldHRlcnMgJiBkaWdpdHMgKGh0dHA6Ly90ZXN0MSlcbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3sxLDYzfScgK1xuICAgICcpJztcblxuICByZS5zcmNfZG9tYWluID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgICAnfCcgK1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgYC0tYCBpbiBkb21haW4gbmFtZXMsIGJlY2F1c2U6XG4gICAgICAvLyAtIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggbWFya2Rvd24gJm1kYXNoOyAvICZuZGFzaDtcbiAgICAgIC8vIC0gbm9ib2R5IHVzZSB0aG9zZSBhbnl3YXlcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKD86LSg/IS0pfCcgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpezAsNjF9JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLypfcm9vdCovICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3RfZnV6enkgPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX2lwNCArXG4gICAgJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJztcblxuICByZS5zcmNfaG9zdF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJ1bGVzXG5cbiAgLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XG4gIHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QgPVxuXG4gICAgJ2xvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzonICsgcmUuc3JjX1pQQ2MgKyAnfD58JCkpJztcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKSgnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfbm9faXBfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmV0dXJuIHJlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbGlua2lmeS1pdC9saWIvcmUuanMiLCIndXNlIHN0cmljdCdcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cbnZhciB0YWdFeHByID0gL148IS0tID9cXHsoPzooW2EtejAtOV0rKShcXF5bMC05XSopPzogPyk/KC4qKVxcfSA/LS0+XFxuPyQvXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXR0cmlidXRlcyAobWQpIHtcbiAgbWQuY29yZS5ydWxlci5wdXNoKCdjdXJseV9hdHRyaWJ1dGVzJywgY3VybHlBdHRycylcbn1cblxuLypcbiAqIExpc3Qgb2YgdGFnIC0+IHRva2VuIHR5cGUgbWFwcGluZ3MuIEVnLCBgPGxpPmAgaXMgYGxpc3RfaXRlbV9vcGVuYC5cbiAqL1xuXG52YXIgb3BlbmluZyA9IHtcbiAgbGk6IFsnbGlzdF9pdGVtJ10sXG4gIHVsOiBbJ2J1bGxldF9saXN0J10sXG4gIHA6IFsncGFyYWdyYXBoJ10sXG4gIG9sOiBbJ29yZGVyZWRfbGlzdCddLFxuICBibG9ja3F1b3RlOiBbJ2Jsb2NrcXVvdGUnXSxcbiAgaDE6IFsnaGVhZGluZyddLFxuICBoMjogWydoZWFkaW5nJ10sXG4gIGgzOiBbJ2hlYWRpbmcnXSxcbiAgaDQ6IFsnaGVhZGluZyddLFxuICBoNTogWydoZWFkaW5nJ10sXG4gIGg2OiBbJ2hlYWRpbmcnXSxcbiAgYTogWydsaW5rJ10sXG4gIGNvZGU6IFsnY29kZV9pbmxpbmUnLCAnY29kZV9ibG9jaycsICdmZW5jZSddXG59XG5cbnZhciBzZWxmQ2xvc2luZyA9IHtcbiAgaHI6IHRydWUsXG4gIGltYWdlOiB0cnVlXG59XG5cbi8qKlxuICogLi4uXG4gKi9cblxuZnVuY3Rpb24gY3VybHlBdHRycyAoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2Vuc1xuICB2YXIgb21pc3Npb25zID0gW11cbiAgdmFyIHBhcmVudCwgbVxuICB2YXIgc3RhY2sgPSB7IGxlbjogMCwgY29udGVudHM6IFtdLCB0eXBlczoge30gfVxuXG4gIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbiwgaSkge1xuICAgIC8vIFNhdmUgYnJlYWRjcnVtYnMgc28gaHRtbF9ibG9jayB3aWxsIHBpY2sgaXQgdXBcbiAgICBpZiAoaXNPcGVuZXIodG9rZW4udHlwZSkgfHwgc2VsZkNsb3NpbmdbdG9rZW4udHlwZV0pIHtcbiAgICAgIHNwdXNoKHN0YWNrLCB0b2tlbilcbiAgICB9XG5cbiAgICAvLyBcIiMgSGVsbG9cXG48IS0tey5jbGFzc25hbWV9LS0+XCJcbiAgICAvLyAuLi5zZXF1ZW5jZSBvZiBbaGVhZGluZ19vcGVuLCBpbmxpbmUsIGhlYWRpbmdfY2xvc2UsIGh0bWxfYmxvY2tdXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdodG1sX2Jsb2NrJykge1xuICAgICAgbSA9IHRva2VuLmNvbnRlbnQubWF0Y2godGFnRXhwcilcbiAgICAgIGlmICghbSkgcmV0dXJuXG5cbiAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnQoc3RhY2ssIG1bMV0sIG1bMl0pXG4gICAgICBpZiAocGFyZW50ICYmIGFwcGx5VG9Ub2tlbihwYXJlbnQsIG1bM10pKSB7XG4gICAgICAgIG9taXNzaW9ucy51bnNoaWZ0KGkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gXCIjIEhlbGxvIDwhLS17LmNsYXNzbmFtZX0gLS0+XCJcbiAgICAvLyB7IHR5cGU6ICdpbmxpbmUnLCBjaGlsZHJlbjogeyAuLi4sICc8IS0tey4uLn0tLT4nIH0gfVxuICAgIGlmICh0b2tlbi50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgY3VybHlJbmxpbmUodG9rZW4uY2hpbGRyZW4sIHN0YWNrKVxuICAgIH1cbiAgfSlcblxuICAvLyBSZW1vdmUgPCEtLS4uLi0tPiBodG1sX2Jsb2NrIHRva2Vuc1xuICBvbWlzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiB0b2tlbnMuc3BsaWNlKGlkeCwgMSkgfSlcbn1cblxuLyoqXG4gKiBJbnRlcm5hbDogY2hlY2tzIGluIGEgdG9rZW4gdHlwZSBpcyBhIGJsb2NrIG9wZW5lclxuICovXG5cbmZ1bmN0aW9uIGlzT3BlbmVyICh0eXBlKSB7XG4gIHJldHVybiB0eXBlLm1hdGNoKC9fKG9wZW58c3RhcnQpJC8pIHx8XG4gICAgdHlwZSA9PT0gJ2ZlbmNlJyB8fCB0eXBlID09PSAnY29kZV9ibG9jaydcbn1cblxuLyoqXG4gKiBJbnRlcm5hbDogUnVuIHRocm91Z2ggaW5saW5lIGFuZCBzdHVmZlxuICovXG5cbmZ1bmN0aW9uIGN1cmx5SW5saW5lIChjaGlsZHJlbiwgc3RhY2spIHtcbiAgdmFyIGxhc3RUZXh0LCBtLCBwYXJlbnRcblxuICAvLyBLZWVwIGEgbGlzdCBvZiBzdWItdG9rZW5zIHRvIGJlIHJlbW92ZWRcbiAgdmFyIG9taXNzaW9ucyA9IFtdXG5cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICBpZiAoaXNPcGVuZXIoY2hpbGQudHlwZSkgfHxcbiAgICAgIHNlbGZDbG9zaW5nW2NoaWxkLnR5cGVdIHx8XG4gICAgICBjaGlsZC50eXBlID09PSAnY29kZV9pbmxpbmUnKSB7XG4gICAgICBzcHVzaChzdGFjaywgY2hpbGQpXG4gICAgfVxuXG4gICAgLy8gRGVjb3JhdGUgdGFncyBhcmUgZm91bmRcbiAgICBpZiAobSA9IGNoaWxkLmNvbnRlbnQubWF0Y2godGFnRXhwcikpIHtcbiAgICAgIHZhciB0YWcgPSBtWzFdXG4gICAgICB2YXIgZGVwdGggPSBtWzJdXG4gICAgICB2YXIgYXR0cnMgPSBtWzNdXG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgY29tbWVudCwgdGhlbiByZW1vdmUgdGhlIGV4dHJhIHNwYWNlXG4gICAgICBwYXJlbnQgPSBmaW5kUGFyZW50KHN0YWNrLCB0YWcsIGRlcHRoKVxuICAgICAgaWYgKHBhcmVudCAmJiBhcHBseVRvVG9rZW4ocGFyZW50LCBhdHRycykpIHtcbiAgICAgICAgb21pc3Npb25zLnVuc2hpZnQoaSlcbiAgICAgICAgaWYgKGxhc3RUZXh0KSB0cmltUmlnaHQobGFzdFRleHQsICdjb250ZW50JylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3RleHQnKSBsYXN0VGV4dCA9IGNoaWxkXG4gIH0pXG5cbiAgLy8gUmVtb3ZlIHRoZW0gaW4gYSBzZXBhcmF0ZSBzdGVwIHNvIHdlIGRvbid0XG4gIG9taXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKVxuICB9KVxufVxuXG4vKipcbiAqIFByaXZhdGU6IGdpdmVuIGEgbGlzdCBvZiB0b2tlbnMgYGxpc3RgIGFuZCBgbGFzdFBhcmVudGAsIGZpbmQgdGhlIG9uZSB0aGF0XG4gKiBtYXRjaGVzIGB0YWdgLlxuICovXG5cbmZ1bmN0aW9uIGZpbmRQYXJlbnQgKHN0YWNrLCB0YWcsIGRlcHRoKSB7XG4gIGlmICghdGFnKSByZXR1cm4gc3RhY2subGFzdFxuXG4gIGlmIChkZXB0aCA9PT0gJ14nKSB7XG4gICAgZGVwdGggPSAxXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlcHRoID09PSAnc3RyaW5nJykgeyAvKiAnXjInICovXG4gICAgZGVwdGggPSArZGVwdGguc3Vic3RyKDEpXG4gIH0gZWxzZSB7XG4gICAgZGVwdGggPSAwXG4gIH1cblxuICB2YXIgdGFyZ2V0cyA9IG9wZW5pbmdbdGFnLnRvTG93ZXJDYXNlKCldIHx8IFt0YWcudG9Mb3dlckNhc2UoKV1cblxuICB2YXIgdGFyZ2V0ID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiBzdGFjay50eXBlc1t0YXJnZXRdXG4gIH0pXG5cbiAgdmFyIGxpc3QgPSBzdGFjay50eXBlc1t0YXJnZXRdXG4gIGlmICghbGlzdCkgcmV0dXJuIC8vIENhbid0IGZpbmQgdGFnIGB0YWdgXG5cbiAgcmV0dXJuIGxpc3RbbGlzdC5sZW5ndGggLSAxIC0gZGVwdGhdXG59XG5cbi8qKlxuICogUHJpdmF0ZTogdHJpbSB0aGUgcmlnaHRcbiAqL1xuXG5mdW5jdGlvbiB0cmltUmlnaHQgKG9iaiwgYXR0cikge1xuICBvYmpbYXR0cl0gPSBvYmpbYXR0cl0ucmVwbGFjZSgvXFxzKiQvLCAnJylcbn1cblxuLyoqXG4gKiBQcml2YXRlOiBhcHBseSB0YWcgdG8gdG9rZW5cbiAqXG4gKiAgICAgYXBwbHlUb1Rva2VuKHRva2VuLCAnLmNsYXNzbmFtZScpXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUb1Rva2VuICh0b2tlbiwgYXR0cnMpIHtcbiAgdmFyIG1cbiAgdmFyIHRvZG8gPSBbXVxuXG4gIHdoaWxlIChhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccypcXC4oW2EtekEtWjAtOVxcLV9dKykvKSkge1xuICAgICAgdG9kby5wdXNoKFsgJ2NsYXNzJywgbVsxXSwgeyBhcHBlbmQ6IHRydWUgfSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKiMoW2EtekEtWjAtOVxcLV9dKykvKSkge1xuICAgICAgdG9kby5wdXNoKFsgJ2lkJywgbVsxXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKT1cIihbXlwiXSopXCIvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKT0nKFteJ10qKScvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgbVsyXSBdKVxuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSBpZiAobSA9IGF0dHJzLm1hdGNoKC9eXFxzKihbYS16QS1aMC05XFwtX10rKT0oW14gXSopLykpIHtcbiAgICAgIHRvZG8ucHVzaChbIG1bMV0sIG1bMl0gXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccyooW2EtekEtWjAtOVxcLV9dKykvKSkge1xuICAgICAgdG9kby5wdXNoKFsgbVsxXSwgJycgXSlcbiAgICAgIHNoaWZ0KClcbiAgICB9IGVsc2UgaWYgKG0gPSBhdHRycy5tYXRjaCgvXlxccysvKSkge1xuICAgICAgc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB0b2RvLmZvckVhY2goZnVuY3Rpb24gKGFyZ3MpIHsgc2V0QXR0ci5hcHBseSh0aGlzLCBbdG9rZW5dLmNvbmNhdChhcmdzKSkgfSlcbiAgcmV0dXJuIHRydWVcblxuICBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgYXR0cnMgPSBhdHRycy5zdWJzdHIobVswXS5sZW5ndGgpXG4gIH1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiBzZXRzIGFuIGF0dHJpYnV0ZSBgYXR0cmAgdG8gYHZhbHVlYCBpbiBhIHRva2VuLiBJZiBgb3B0aW9ucy5hcHBlbmRgXG4gKiBpcyB0cnVlLCBhcHBlbmQgdG8gdGhlIG9sZCB2YWx1ZSBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nIGl0LlxuICovXG5cbmZ1bmN0aW9uIHNldEF0dHIgKHRva2VuLCBhdHRyLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgaWR4ID0gdG9rZW4uYXR0ckluZGV4KGF0dHIpXG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICB0b2tlbi5hdHRyUHVzaChbIGF0dHIsIHZhbHVlIF0pXG4gIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFwcGVuZCkge1xuICAgIHRva2VuLmF0dHJzW2lkeF1bMV0gPVxuICAgICAgdG9rZW4uYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdG9rZW4uYXR0cnNbaWR4XVsxXSA9IHZhbHVlXG4gIH1cbn1cblxuLyoqXG4gKiBQcml2YXRlOiBwdXNoZXMgYSB0b2tlbiB0byB0aGUgc3RhY2tcbiAqL1xuXG5mdW5jdGlvbiBzcHVzaCAoc3RhY2ssIHRva2VuKSB7XG4gIHZhciB0eXBlID0gdG9rZW4udHlwZS5yZXBsYWNlKC9fKG9wZW58c3RhcnQpJC8sICcnKVxuICBpZiAoIXN0YWNrLnR5cGVzW3R5cGVdKSB7IHN0YWNrLnR5cGVzW3R5cGVdID0gW10gfVxuICBzdGFjay50eXBlc1t0eXBlXS5wdXNoKHRva2VuKVxuICBzdGFjay5sYXN0ID0gdG9rZW5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQtZGVjb3JhdGUvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvaW5kZXguanMiLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ21ldGEnLFxuICAnbmF2JyxcbiAgJ25vZnJhbWVzJyxcbiAgJ29sJyxcbiAgJ29wdGdyb3VwJyxcbiAgJ29wdGlvbicsXG4gICdwJyxcbiAgJ3BhcmFtJyxcbiAgJ3NlY3Rpb24nLFxuICAnc291cmNlJyxcbiAgJ3N1bW1hcnknLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGl0bGUnLFxuICAndHInLFxuICAndHJhY2snLFxuICAndWwnXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwiLy8gSnVzdCBhIHNob3J0Y3V0IGZvciBidWxrIGV4cG9ydFxuJ3VzZSBzdHJpY3QnO1xuXG5cbmV4cG9ydHMucGFyc2VMaW5rTGFiZWwgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfbGFiZWwnKTtcbmV4cG9ydHMucGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcbmV4cG9ydHMucGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfdGl0bGUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanMiLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1NwYWNlICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG52YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpIHtcbiAgdmFyIGNvZGUsIGxldmVsLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8gfHwgaXNTcGFjZShjb2RlKSkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xuICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBhc2NpaSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDB4MjAgfHwgY29kZSA9PT0gMHg3RikgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkgeyBicmVhazsgfVxuICAgICAgbGV2ZWwtLTtcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gcG9zKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgaWYgKGxldmVsICE9PSAwKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0LCBwb3MpKTtcbiAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gIHJlc3VsdC5wb3MgPSBwb3M7XG4gIHJlc3VsdC5vayA9IHRydWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwiLy8gUGFyc2UgbGluayBsYWJlbFxuLy9cbi8vIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGZpcnN0IGNoYXJhY3RlciAoXCJbXCIpIGFscmVhZHkgbWF0Y2hlcztcbi8vIHJldHVybnMgdGhlIGVuZCBvZiB0aGUgbGFiZWxcbi8vXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0LCBkaXNhYmxlTmVzdGVkKSB7XG4gIHZhciBsZXZlbCwgZm91bmQsIG1hcmtlciwgcHJldlBvcyxcbiAgICAgIGxhYmVsRW5kID0gLTEsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3M7XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuICBsZXZlbCA9IDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldlBvcyA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcbiAgICBpZiAobWFya2VyID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIGlmIChwcmV2UG9zID09PSBzdGF0ZS5wb3MgLSAxKSB7XG4gICAgICAgIC8vIGluY3JlYXNlIGxldmVsIGlmIHdlIGZpbmQgdGV4dCBgW2AsIHdoaWNoIGlzIG5vdCBhIHBhcnQgb2YgYW55IHRva2VuXG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKGRpc2FibGVOZXN0ZWQpIHtcbiAgICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3M7XG4gIH1cblxuICAvLyByZXN0b3JlIG9sZCBzdGF0ZVxuICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG5cbiAgcmV0dXJuIGxhYmVsRW5kO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIi8vIFBhcnNlIGxpbmsgdGl0bGVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLFxuICAgICAgbWFya2VyLFxuICAgICAgbGluZXMgPSAwLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiAnJ1xuICAgICAgfTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgbWFya2VyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDIyIC8qIFwiICovICYmIG1hcmtlciAhPT0gMHgyNyAvKiAnICovICYmIG1hcmtlciAhPT0gMHgyOCAvKiAoICovKSB7IHJldHVybiByZXN1bHQ7IH1cblxuICBwb3MrKztcblxuICAvLyBpZiBvcGVuaW5nIG1hcmtlciBpcyBcIihcIiwgc3dpdGNoIGl0IHRvIGNsb3NpbmcgbWFya2VyIFwiKVwiXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZS5qcyIsIi8vIE1haW4gcGFyc2VyIGNsYXNzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKTtcbnZhciBoZWxwZXJzICAgICAgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBSZW5kZXJlciAgICAgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG52YXIgUGFyc2VyQ29yZSAgID0gcmVxdWlyZSgnLi9wYXJzZXJfY29yZScpO1xudmFyIFBhcnNlckJsb2NrICA9IHJlcXVpcmUoJy4vcGFyc2VyX2Jsb2NrJyk7XG52YXIgUGFyc2VySW5saW5lID0gcmVxdWlyZSgnLi9wYXJzZXJfaW5saW5lJyk7XG52YXIgTGlua2lmeUl0ICAgID0gcmVxdWlyZSgnbGlua2lmeS1pdCcpO1xudmFyIG1kdXJsICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG52YXIgcHVueWNvZGUgICAgID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuXG52YXIgY29uZmlnID0ge1xuICAnZGVmYXVsdCc6IHJlcXVpcmUoJy4vcHJlc2V0cy9kZWZhdWx0JyksXG4gIHplcm86IHJlcXVpcmUoJy4vcHJlc2V0cy96ZXJvJyksXG4gIGNvbW1vbm1hcms6IHJlcXVpcmUoJy4vcHJlc2V0cy9jb21tb25tYXJrJylcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gVGhpcyB2YWxpZGF0b3IgY2FuIHByb2hpYml0IG1vcmUgdGhhbiByZWFsbHkgbmVlZGVkIHRvIHByZXZlbnQgWFNTLiBJdCdzIGFcbi8vIHRyYWRlb2ZmIHRvIGtlZXAgY29kZSBzaW1wbGUgYW5kIHRvIGJlIHNlY3VyZSBieSBkZWZhdWx0LlxuLy9cbi8vIElmIHlvdSBuZWVkIGRpZmZlcmVudCBzZXR1cCAtIG92ZXJyaWRlIHZhbGlkYXRvciBtZXRob2QgYXMgeW91IHdpc2guIE9yXG4vLyByZXBsYWNlIGl0IHdpdGggZHVtbXkgZnVuY3Rpb24gYW5kIHVzZSBleHRlcm5hbCBzYW5pdGl6ZXIuXG4vL1xuXG52YXIgQkFEX1BST1RPX1JFID0gL14odmJzY3JpcHR8amF2YXNjcmlwdHxmaWxlfGRhdGEpOi87XG52YXIgR09PRF9EQVRBX1JFID0gL15kYXRhOmltYWdlXFwvKGdpZnxwbmd8anBlZ3x3ZWJwKTsvO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmsodXJsKSB7XG4gIC8vIHVybCBzaG91bGQgYmUgbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50LCBhbmQgZXhpc3RpbmcgZW50aXRpZXMgYXJlIGRlY29kZWRcbiAgdmFyIHN0ciA9IHVybC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gQkFEX1BST1RPX1JFLnRlc3Qoc3RyKSA/IChHT09EX0RBVEFfUkUudGVzdChzdHIpID8gdHJ1ZSA6IGZhbHNlKSA6IHRydWU7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbICdodHRwOicsICdodHRwczonLCAnbWFpbHRvOicgXTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTGluayh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICB9IGNhdGNoIChlcikgeyAvKiovIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWR1cmwuZW5jb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTGlua1RleHQodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9Vbmljb2RlKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICB9IGNhdGNoIChlcikgeyAvKiovIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWR1cmwuZGVjb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpKTtcbn1cblxuXG4vKipcbiAqIGNsYXNzIE1hcmtkb3duSXRcbiAqXG4gKiBNYWluIHBhcnNlci9yZW5kZXJlciBjbGFzcy5cbiAqXG4gKiAjIyMjIyBVc2FnZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIG5vZGUuanMsIFwiY2xhc3NpY1wiIHdheTpcbiAqIHZhciBNYXJrZG93bkl0ID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSxcbiAqICAgICBtZCA9IG5ldyBNYXJrZG93bkl0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBub2RlLmpzLCB0aGUgc2FtZSwgYnV0IHdpdGggc3VnYXI6XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBicm93c2VyIHdpdGhvdXQgQU1ELCBhZGRlZCB0byBcIndpbmRvd1wiIG9uIHNjcmlwdCBsb2FkXG4gKiAvLyBOb3RlLCB0aGVyZSBhcmUgbm8gZGFzaC5cbiAqIHZhciBtZCA9IHdpbmRvdy5tYXJrZG93bml0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqIGBgYFxuICpcbiAqIFNpbmdsZSBsaW5lIHJlbmRlcmluZywgd2l0aG91dCBwYXJhZ3JhcGggd3JhcDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKCdfX21hcmtkb3duLWl0X18gcnVsZXp6IScpO1xuICogYGBgXG4gKiovXG5cbi8qKlxuICogbmV3IE1hcmtkb3duSXQoW3ByZXNldE5hbWUsIG9wdGlvbnNdKVxuICogLSBwcmVzZXROYW1lIChTdHJpbmcpOiBvcHRpb25hbCwgYGNvbW1vbm1hcmtgIC8gYHplcm9gXG4gKiAtIG9wdGlvbnMgKE9iamVjdClcbiAqXG4gKiBDcmVhdGVzIHBhcnNlciBpbnN0YW5zZSB3aXRoIGdpdmVuIGNvbmZpZy4gQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgLlxuICpcbiAqICMjIyMjIHByZXNldE5hbWVcbiAqXG4gKiBNYXJrZG93bkl0IHByb3ZpZGVzIG5hbWVkIHByZXNldHMgYXMgYSBjb252ZW5pZW5jZSB0byBxdWlja2x5XG4gKiBlbmFibGUvZGlzYWJsZSBhY3RpdmUgc3ludGF4IHJ1bGVzIGFuZCBvcHRpb25zIGZvciBjb21tb24gdXNlIGNhc2VzLlxuICpcbiAqIC0gW1wiY29tbW9ubWFya1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvY29tbW9ubWFyay5qcykgLVxuICogICBjb25maWd1cmVzIHBhcnNlciB0byBzdHJpY3QgW0NvbW1vbk1hcmtdKGh0dHA6Ly9jb21tb25tYXJrLm9yZy8pIG1vZGUuXG4gKiAtIFtkZWZhdWx0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvZGVmYXVsdC5qcykgLVxuICogICBzaW1pbGFyIHRvIEdGTSwgdXNlZCB3aGVuIG5vIHByZXNldCBuYW1lIGdpdmVuLiBFbmFibGVzIGFsbCBhdmFpbGFibGUgcnVsZXMsXG4gKiAgIGJ1dCBzdGlsbCB3aXRob3V0IGh0bWwsIHR5cG9ncmFwaGVyICYgYXV0b2xpbmtlci5cbiAqIC0gW1wiemVyb1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvemVyby5qcykgLVxuICogICBhbGwgcnVsZXMgZGlzYWJsZWQuIFVzZWZ1bCB0byBxdWlja2x5IHNldHVwIHlvdXIgY29uZmlnIHZpYSBgLmVuYWJsZSgpYC5cbiAqICAgRm9yIGV4YW1wbGUsIHdoZW4geW91IG5lZWQgb25seSBgYm9sZGAgYW5kIGBpdGFsaWNgIG1hcmt1cCBhbmQgbm90aGluZyBlbHNlLlxuICpcbiAqICMjIyMjIG9wdGlvbnM6XG4gKlxuICogLSBfX2h0bWxfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2UuIEJlIGNhcmVmdWwhXG4gKiAgIFRoYXQncyBub3Qgc2FmZSEgWW91IG1heSBuZWVkIGV4dGVybmFsIHNhbml0aXplciB0byBwcm90ZWN0IG91dHB1dCBmcm9tIFhTUy5cbiAqICAgSXQncyBiZXR0ZXIgdG8gZXh0ZW5kIGZlYXR1cmVzIHZpYSBwbHVnaW5zLCBpbnN0ZWFkIG9mIGVuYWJsaW5nIEhUTUwuXG4gKiAtIF9feGh0bWxPdXRfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYWRkICcvJyB3aGVuIGNsb3Npbmcgc2luZ2xlIHRhZ3NcbiAqICAgKGA8YnIgLz5gKS4gVGhpcyBpcyBuZWVkZWQgb25seSBmb3IgZnVsbCBDb21tb25NYXJrIGNvbXBhdGliaWxpdHkuIEluIHJlYWxcbiAqICAgd29ybGQgeW91IHdpbGwgbmVlZCBIVE1MIG91dHB1dC5cbiAqIC0gX19icmVha3NfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gY29udmVydCBgXFxuYCBpbiBwYXJhZ3JhcGhzIGludG8gYDxicj5gLlxuICogLSBfX2xhbmdQcmVmaXhfXyAtIGBsYW5ndWFnZS1gLiBDU1MgbGFuZ3VhZ2UgY2xhc3MgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzLlxuICogICBDYW4gYmUgdXNlZnVsIGZvciBleHRlcm5hbCBoaWdobGlnaHRlcnMuXG4gKiAtIF9fbGlua2lmeV9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0IHRvIGxpbmtzLlxuICogLSBfX3R5cG9ncmFwaGVyX18gIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgW3NvbWUgbGFuZ3VhZ2UtbmV1dHJhbFxuICogICByZXBsYWNlbWVudF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5qcykgK1xuICogICBxdW90ZXMgYmVhdXRpZmljYXRpb24gKHNtYXJ0cXVvdGVzKS5cbiAqIC0gX19xdW90ZXNfXyAtIGDigJzigJ3igJjigJlgLCBTdHJpbmcgb3IgQXJyYXkuIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnRcbiAqICAgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCBhbmQgc21hcnRxdW90ZXMgb24uIEZvciBleGFtcGxlLCB5b3UgY2FuXG4gKiAgIHVzZSBgJ8KrwrvigJ7igJwnYCBmb3IgUnVzc2lhbiwgYCfigJ7igJzigJrigJgnYCBmb3IgR2VybWFuLCBhbmRcbiAqICAgYFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J11gIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAqIC0gX19oaWdobGlnaHRfXyAtIGBudWxsYC4gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24gZm9yIGZlbmNlZCBjb2RlIGJsb2Nrcy5cbiAqICAgSGlnaGxpZ2h0ZXIgYGZ1bmN0aW9uIChzdHIsIGxhbmcpYCBzaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTC4gSXQgY2FuIGFsc29cbiAqICAgcmV0dXJuIGVtcHR5IHN0cmluZyBpZiB0aGUgc291cmNlIHdhcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWRcbiAqICAgZXh0ZXJuYWx5LiBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIGNvbW1vbm1hcmsgbW9kZVxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgnY29tbW9ubWFyaycpO1xuICpcbiAqIC8vIGRlZmF1bHQgbW9kZVxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICpcbiAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaHRtbDogdHJ1ZSxcbiAqICAgbGlua2lmeTogdHJ1ZSxcbiAqICAgdHlwb2dyYXBoZXI6IHRydWVcbiAqIH0pO1xuICogYGBgXG4gKlxuICogIyMjIyMgU3ludGF4IGhpZ2hsaWdodGluZ1xuICpcbiAqIGBgYGpzXG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuICpcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcbiAqICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XG4gKiAgICAgICB0cnkge1xuICogICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZTtcbiAqICAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuICcnOyAvLyB1c2UgZXh0ZXJuYWwgZGVmYXVsdCBlc2NhcGluZ1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE9yIHdpdGggZnVsbCB3cmFwcGVyIG92ZXJyaWRlIChpZiB5b3UgbmVlZCBhc3NpZ24gY2xhc3MgdG8gYDxwcmU+YCk6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiAvLyBBY3R1YWwgZGVmYXVsdCB2YWx1ZXNcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0Jykoe1xuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcbiAqICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XG4gKiAgICAgICB0cnkge1xuICogICAgICAgICByZXR1cm4gJzxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+JyArXG4gKiAgICAgICAgICAgICAgICBobGpzLmhpZ2hsaWdodChsYW5nLCBzdHIsIHRydWUpLnZhbHVlICtcbiAqICAgICAgICAgICAgICAgICc8L2NvZGU+PC9wcmU+JztcbiAqICAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICogICAgIH1cbiAqXG4gKiAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgKyBtZC51dGlscy5lc2NhcGVIdG1sKHN0cikgKyAnPC9jb2RlPjwvcHJlPic7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICoqL1xuZnVuY3Rpb24gTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXJrZG93bkl0KSkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICghdXRpbHMuaXNTdHJpbmcocHJlc2V0TmFtZSkpIHtcbiAgICAgIG9wdGlvbnMgPSBwcmVzZXROYW1lIHx8IHt9O1xuICAgICAgcHJlc2V0TmFtZSA9ICdkZWZhdWx0JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya2Rvd25JdCNpbmxpbmUgLT4gUGFyc2VySW5saW5lXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VySW5saW5lXV0uIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmlubGluZSA9IG5ldyBQYXJzZXJJbmxpbmUoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNibG9jayAtPiBQYXJzZXJCbG9ja1xuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlckJsb2NrXV0uIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cbiAgICogd3JpdGluZyBwbHVnaW5zLiBGb3Igc2ltcGxlIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0gYW5kXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cbiAgICoqL1xuICB0aGlzLmJsb2NrID0gbmV3IFBhcnNlckJsb2NrKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjY29yZSAtPiBDb3JlXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbQ29yZV1dIGNoYWluIGV4ZWN1dG9yLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5jb3JlID0gbmV3IFBhcnNlckNvcmUoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNyZW5kZXJlciAtPiBSZW5kZXJlclxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1JlbmRlcmVyXV0uIFVzZSBpdCB0byBtb2RpZnkgb3V0cHV0IGxvb2suIE9yIHRvIGFkZCByZW5kZXJpbmdcbiAgICogcnVsZXMgZm9yIG5ldyB0b2tlbiB0eXBlcywgZ2VuZXJhdGVkIGJ5IHBsdWdpbnMuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIGZ1bmN0aW9uIG15VG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2VsZikge1xuICAgKiAgIC8vLi4uXG4gICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICogfTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXNbJ215X3Rva2VuJ10gPSBteVRva2VuXG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW1tSZW5kZXJlcl1dIGRvY3MgYW5kIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcykuXG4gICAqKi9cbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2xpbmtpZnkgLT4gTGlua2lmeUl0XG4gICAqXG4gICAqIFtsaW5raWZ5LWl0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCkgaW5zdGFuY2UuXG4gICAqIFVzZWQgYnkgW2xpbmtpZnldKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzKVxuICAgKiBydWxlLlxuICAgKiovXG4gIHRoaXMubGlua2lmeSA9IG5ldyBMaW5raWZ5SXQoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCN2YWxpZGF0ZUxpbmsodXJsKSAtPiBCb29sZWFuXG4gICAqXG4gICAqIExpbmsgdmFsaWRhdGlvbiBmdW5jdGlvbi4gQ29tbW9uTWFyayBhbGxvd3MgdG9vIG11Y2ggaW4gbGlua3MuIEJ5IGRlZmF1bHRcbiAgICogd2UgZGlzYWJsZSBgamF2YXNjcmlwdDpgLCBgdmJzY3JpcHQ6YCwgYGZpbGU6YCBzY2hlbWFzLCBhbmQgYWxtb3N0IGFsbCBgZGF0YTouLi5gIHNjaGVtYXNcbiAgICogZXhjZXB0IHNvbWUgZW1iZWRkZWQgaW1hZ2UgdHlwZXMuXG4gICAqXG4gICAqIFlvdSBjYW4gY2hhbmdlIHRoaXMgYmVoYXZpb3VyOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcbiAgICogbWQudmFsaWRhdGVMaW5rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgKiBgYGBcbiAgICoqL1xuICB0aGlzLnZhbGlkYXRlTGluayA9IHZhbGlkYXRlTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rKHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZW5jb2RlIGxpbmsgdXJsIHRvIGEgbWFjaGluZS1yZWFkYWJsZSBmb3JtYXQsXG4gICAqIHdoaWNoIGluY2x1ZGVzIHVybC1lbmNvZGluZywgcHVueWNvZGUsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmsgPSBub3JtYWxpemVMaW5rO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmtUZXh0KHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGVjb2RlIGxpbmsgdXJsIHRvIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0YFxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGlua1RleHQgPSBub3JtYWxpemVMaW5rVGV4dDtcblxuXG4gIC8vIEV4cG9zZSB1dGlscyAmIGhlbHBlcnMgZm9yIGVhc3kgYWNjZXMgZnJvbSBwbHVnaW5zXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdXRpbHMgLT4gdXRpbHNcbiAgICpcbiAgICogQXNzb3J0ZWQgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9jb21tb24vdXRpbHMuanMpLlxuICAgKiovXG4gIHRoaXMudXRpbHMgPSB1dGlscztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNoZWxwZXJzIC0+IGhlbHBlcnNcbiAgICpcbiAgICogTGluayBjb21wb25lbnRzIHBhcnNlciBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9oZWxwZXJzKS5cbiAgICoqL1xuICB0aGlzLmhlbHBlcnMgPSB1dGlscy5hc3NpZ24oe30sIGhlbHBlcnMpO1xuXG5cbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMuY29uZmlndXJlKHByZXNldE5hbWUpO1xuXG4gIGlmIChvcHRpb25zKSB7IHRoaXMuc2V0KG9wdGlvbnMpOyB9XG59XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5zZXQob3B0aW9ucylcbiAqXG4gKiBTZXQgcGFyc2VyIG9wdGlvbnMgKGluIHRoZSBzYW1lIGZvcm1hdCBhcyBpbiBjb25zdHJ1Y3RvcikuIFByb2JhYmx5LCB5b3VcbiAqIHdpbGwgbmV2ZXIgbmVlZCBpdCwgYnV0IHlvdSBjYW4gY2hhbmdlIG9wdGlvbnMgYWZ0ZXIgY29uc3RydWN0b3IgY2FsbC5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuc2V0KHsgaHRtbDogdHJ1ZSwgYnJlYWtzOiB0cnVlIH0pXG4gKiAgICAgICAgICAgICAuc2V0KHsgdHlwb2dyYXBoZXIsIHRydWUgfSk7XG4gKiBgYGBcbiAqXG4gKiBfX05vdGU6X18gVG8gYWNoaWV2ZSB0aGUgYmVzdCBwb3NzaWJsZSBwZXJmb3JtYW5jZSwgZG9uJ3QgbW9kaWZ5IGFcbiAqIGBtYXJrZG93bi1pdGAgaW5zdGFuY2Ugb3B0aW9ucyBvbiB0aGUgZmx5LiBJZiB5b3UgbmVlZCBtdWx0aXBsZSBjb25maWd1cmF0aW9uc1xuICogaXQncyBiZXN0IHRvIGNyZWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMgYW5kIGluaXRpYWxpemUgZWFjaCB3aXRoIHNlcGFyYXRlXG4gKiBjb25maWcuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB1dGlscy5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGUsIGludGVybmFsXG4gKiBNYXJrZG93bkl0LmNvbmZpZ3VyZShwcmVzZXRzKVxuICpcbiAqIEJhdGNoIGxvYWQgb2YgYWxsIG9wdGlvbnMgYW5kIGNvbXBlbmVudCBzZXR0aW5ncy4gVGhpcyBpcyBpbnRlcm5hbCBtZXRob2QsXG4gKiBhbmQgeW91IHByb2JhYmx5IHdpbGwgbm90IG5lZWQgaXQuIEJ1dCBpZiB5b3Ugd2l0aCAtIHNlZSBhdmFpbGFibGUgcHJlc2V0c1xuICogYW5kIGRhdGEgc3RydWN0dXJlIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvdHJlZS9tYXN0ZXIvbGliL3ByZXNldHMpXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBwcmVzZXRzIGluc3RlYWQgb2YgZGlyZWN0IGNvbmZpZyBsb2Fkcy4gVGhhdFxuICogd2lsbCBnaXZlIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggbmV4dCB2ZXJzaW9ucy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChwcmVzZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcywgcHJlc2V0TmFtZTtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcocHJlc2V0cykpIHtcbiAgICBwcmVzZXROYW1lID0gcHJlc2V0cztcbiAgICBwcmVzZXRzID0gY29uZmlnW3ByZXNldE5hbWVdO1xuICAgIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0IFwiJyArIHByZXNldE5hbWUgKyAnXCIsIGNoZWNrIG5hbWUnKTsgfVxuICB9XG5cbiAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQsIGNhblxcJ3QgYmUgZW1wdHknKTsgfVxuXG4gIGlmIChwcmVzZXRzLm9wdGlvbnMpIHsgc2VsZi5zZXQocHJlc2V0cy5vcHRpb25zKTsgfVxuXG4gIGlmIChwcmVzZXRzLmNvbXBvbmVudHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcmVzZXRzLmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlci5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcyk7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMikge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyMi5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZVxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIGxpc3Qgb3IgcnVsZXMuIEl0IHdpbGwgYXV0b21hdGljYWxseSBmaW5kIGFwcHJvcHJpYXRlIGNvbXBvbmVudHMsXG4gKiBjb250YWluaW5nIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIHJ1bGUgbm90IGZvdW5kLCBhbmQgYGlnbm9yZUludmFsaWRgXG4gKiBub3Qgc2V0IC0gdGhyb3dzIGV4Y2VwdGlvbi5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuZW5hYmxlKFsnc3ViJywgJ3N1cCddKVxuICogICAgICAgICAgICAgLmRpc2FibGUoJ3NtYXJ0cXVvdGVzJyk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XG5cbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmVuYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmVuYWJsZShsaXN0LCB0cnVlKSk7XG5cbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZW5hYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5kaXNhYmxlKGxpc3QsIGlnbm9yZUludmFsaWQpXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5lbmFibGVdXSwgYnV0IHR1cm4gc3BlY2lmaWVkIHJ1bGVzIG9mZi5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5kaXNhYmxlKGxpc3QsIHRydWUpKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG5cbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZGlzYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LnVzZShwbHVnaW4sIHBhcmFtcylcbiAqXG4gKiBMb2FkIHNwZWNpZmllZCBwbHVnaW4gd2l0aCBnaXZlbiBwYXJhbXMgaW50byBjdXJyZW50IHBhcnNlciBpbnN0YW5jZS5cbiAqIEl0J3MganVzdCBhIHN1Z2FyIHRvIGNhbGwgYHBsdWdpbihtZCwgcGFyYW1zKWAgd2l0aCBjdXJyaW5nLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgaXRlcmF0b3IgPSByZXF1aXJlKCdtYXJrZG93bi1pdC1mb3ItaW5saW5lJyk7XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcbiAqICAgICAgICAgICAgIC51c2UoaXRlcmF0b3IsICdmb29fcmVwbGFjZScsICd0ZXh0JywgZnVuY3Rpb24gKHRva2VucywgaWR4KSB7XG4gKiAgICAgICAgICAgICAgIHRva2Vuc1tpZHhdLmNvbnRlbnQgPSB0b2tlbnNbaWR4XS5jb250ZW50LnJlcGxhY2UoL2Zvby9nLCAnYmFyJyk7XG4gKiAgICAgICAgICAgICB9KTtcbiAqIGBgYFxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKHBsdWdpbiAvKiwgcGFyYW1zLCAuLi4gKi8pIHtcbiAgdmFyIGFyZ3MgPSBbIHRoaXMgXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIHBsdWdpbi5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUGFyc2UgaW5wdXQgc3RyaW5nIGFuZCByZXR1cm5zIGxpc3Qgb2YgYmxvY2sgdG9rZW5zIChzcGVjaWFsIHRva2VuIHR5cGVcbiAqIFwiaW5saW5lXCIgd2lsbCBjb250YWluIGxpc3Qgb2YgaW5saW5lIHRva2VucykuIFlvdSBzaG91bGQgbm90IGNhbGwgdGhpc1xuICogbWV0aG9kIGRpcmVjdGx5LCB1bnRpbCB5b3Ugd3JpdGUgY3VzdG9tIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgdG8gcHJvZHVjZVxuICogQVNUKS5cbiAqXG4gKiBgZW52YCBpcyB1c2VkIHRvIHBhc3MgZGF0YSBiZXR3ZWVuIFwiZGlzdHJpYnV0ZWRcIiBydWxlcyBhbmQgcmV0dXJuIGFkZGl0aW9uYWxcbiAqIG1ldGFkYXRhIGxpa2UgcmVmZXJlbmNlIGluZm8sIG5lZWRlZCBmb3IgdGhlIHJlbmRlcmVyLiBJdCBhbHNvIGNhbiBiZSB1c2VkIHRvXG4gKiBpbmplY3QgZGF0YSBpbiBzcGVjaWZpYyBjYXNlcy4gVXN1YWxseSwgeW91IHdpbGwgYmUgb2sgdG8gcGFzcyBge31gLFxuICogYW5kIHRoZW4gcGFzcyB1cGRhdGVkIG9iamVjdCB0byByZW5kZXJlci5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBzaG91bGQgYmUgYSBTdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVyKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFJlbmRlciBtYXJrZG93biBzdHJpbmcgaW50byBodG1sLiBJdCBkb2VzIGFsbCBtYWdpYyBmb3IgeW91IDopLlxuICpcbiAqIGBlbnZgIGNhbiBiZSB1c2VkIHRvIGluamVjdCBhZGRpdGlvbmFsIG1ldGFkYXRhIChge31gIGJ5IGRlZmF1bHQpLlxuICogQnV0IHlvdSB3aWxsIG5vdCBuZWVkIGl0IHdpdGggaGlnaCBwcm9iYWJpbGl0eS4gU2VlIGFsc28gY29tbWVudFxuICogaW4gW1tNYXJrZG93bkl0LnBhcnNlXV0uXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2VJbmxpbmUoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXG4gKiBibG9jayB0b2tlbnMgbGlzdCB3aXRoIHRoZSBzaW5nbGUgYGlubGluZWAgZWxlbWVudCwgY29udGFpbmluZyBwYXJzZWQgaW5saW5lXG4gKiB0b2tlbnMgaW4gYGNoaWxkcmVuYCBwcm9wZXJ0eS4gQWxzbyB1cGRhdGVzIGBlbnZgIG9iamVjdC5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcklubGluZShzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBTaW1pbGFyIHRvIFtbTWFya2Rvd25JdC5yZW5kZXJdXSBidXQgZm9yIHNpbmdsZSBwYXJhZ3JhcGggY29udGVudC4gUmVzdWx0XG4gKiB3aWxsIE5PVCBiZSB3cmFwcGVkIGludG8gYDxwPmAgdGFncy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2Rvd25JdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJCbG9ja1xuICpcbiAqIEJsb2NrLWxldmVsIHRva2VuaXplci5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIC8vIEZpcnN0IDIgcGFyYW1zIC0gcnVsZSBuYW1lICYgc291cmNlLiBTZWNvbmRhcnkgYXJyYXkgLSBsaXN0IG9mIHJ1bGVzLFxuICAvLyB3aGljaCBjYW4gYmUgdGVybWluYXRlZCBieSB0aGlzIG9uZS5cbiAgWyAndGFibGUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svdGFibGUnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJyBdIF0sXG4gIFsgJ2NvZGUnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2NvZGUnKSBdLFxuICBbICdmZW5jZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9mZW5jZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2Jsb2NrcXVvdGUnLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUnKSwgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnaHInLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHInKSwgICAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdsaXN0JywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saXN0JyksICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdyZWZlcmVuY2UnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9yZWZlcmVuY2UnKSBdLFxuICBbICdoZWFkaW5nJywgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9oZWFkaW5nJyksICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdsaGVhZGluZycsICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saGVhZGluZycpIF0sXG4gIFsgJ2h0bWxfYmxvY2snLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2snKSwgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3BhcmFncmFwaCcsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3BhcmFncmFwaCcpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VyQmxvY2soKVxuICoqL1xuZnVuY3Rpb24gUGFyc2VyQmxvY2soKSB7XG4gIC8qKlxuICAgKiBQYXJzZXJCbG9jayNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBibG9jayBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0sIHsgYWx0OiAoX3J1bGVzW2ldWzJdIHx8IFtdKS5zbGljZSgpIH0pO1xuICB9XG59XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlckJsb2NrLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBsaW5lID0gc3RhcnRMaW5lLFxuICAgICAgaGFzRW1wdHlMaW5lcyA9IGZhbHNlLFxuICAgICAgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcblxuICB3aGlsZSAobGluZSA8IGVuZExpbmUpIHtcbiAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpO1xuICAgIGlmIChsaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIC8vIFRlcm1pbmF0aW9uIGNvbmRpdGlvbiBmb3IgbmVzdGVkIGNhbGxzLlxuICAgIC8vIE5lc3RlZCBjYWxscyBjdXJyZW50bHkgdXNlZCBmb3IgYmxvY2txdW90ZXMgJiBsaXN0c1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIElmIG5lc3RpbmcgbGV2ZWwgZXhjZWVkZWQgLSBza2lwIHRhaWwgdG8gdGhlIGVuZC4gVGhhdCdzIG5vdCBvcmRpbmFyeVxuICAgIC8vIHNpdHVhdGlvbiBhbmQgd2Ugc2hvdWxkIG5vdCBjYXJlIGFib3V0IGNvbnRlbnQuXG4gICAgaWYgKHN0YXRlLmxldmVsID49IG1heE5lc3RpbmcpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBlbmRMaW5lO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5saW5lYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBsaW5lLCBlbmRMaW5lLCBmYWxzZSk7XG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBzZXQgc3RhdGUudGlnaHQgaWYgd2UgaGFkIGFuIGVtcHR5IGxpbmUgYmVmb3JlIGN1cnJlbnQgdGFnXG4gICAgLy8gaS5lLiBsYXRlc3QgZW1wdHkgbGluZSBzaG91bGQgbm90IGNvdW50XG4gICAgc3RhdGUudGlnaHQgPSAhaGFzRW1wdHlMaW5lcztcblxuICAgIC8vIHBhcmFncmFwaCBtaWdodCBcImVhdFwiIG9uZSBuZXdsaW5lIGFmdGVyIGl0IGluIG5lc3RlZCBsaXN0c1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgbGluZSA9IHN0YXRlLmxpbmU7XG5cbiAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgICBsaW5lKys7XG4gICAgICBzdGF0ZS5saW5lID0gbGluZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXJzZXJCbG9jay5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBibG9jayB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXNyYykgeyByZXR1cm47IH1cblxuICBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlLCBzdGF0ZS5saW5lLCBzdGF0ZS5saW5lTWF4KTtcbn07XG5cblxuUGFyc2VyQmxvY2sucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jaycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyQmxvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanMiLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIENvcmVcbiAqXG4gKiBUb3AtbGV2ZWwgcnVsZXMgZXhlY3V0b3IuIEdsdWVzIGJsb2NrL2lubGluZSBwYXJzZXJzIGFuZCBkb2VzIGludGVybWVkaWF0ZVxuICogdHJhbnNmb3JtYXRpb25zLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnbm9ybWFsaXplJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbm9ybWFsaXplJykgICAgICBdLFxuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXG4gIFsgJ2lubGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2lubGluZScpICAgICAgICAgXSxcbiAgWyAnbGlua2lmeScsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbGlua2lmeScpICAgICAgICBdLFxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXG4gIFsgJ3NtYXJ0cXVvdGVzJywgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzJykgICAgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBDb3JlKClcbiAqKi9cbmZ1bmN0aW9uIENvcmUoKSB7XG4gIC8qKlxuICAgKiBDb3JlI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGNvcmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ29yZS5wcm9jZXNzKHN0YXRlKVxuICpcbiAqIEV4ZWN1dGVzIGNvcmUgY2hhaW4gcnVsZXMuXG4gKiovXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBydWxlcztcblxuICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cbkNvcmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19jb3JlL3N0YXRlX2NvcmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VySW5saW5lXG4gKlxuICogVG9rZW5pemVzIHBhcmFncmFwaCBjb250ZW50LlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFBhcnNlciBydWxlc1xuXG52YXIgX3J1bGVzID0gW1xuICBbICd0ZXh0JywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0JykgXSxcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXG4gIFsgJ2VzY2FwZScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VzY2FwZScpIF0sXG4gIFsgJ2JhY2t0aWNrcycsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhY2t0aWNrcycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS50b2tlbml6ZSBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnRva2VuaXplIF0sXG4gIFsgJ2xpbmsnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2xpbmsnKSBdLFxuICBbICdpbWFnZScsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbWFnZScpIF0sXG4gIFsgJ2F1dG9saW5rJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2F1dG9saW5rJykgXSxcbiAgWyAnaHRtbF9pbmxpbmUnLCAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUnKSBdLFxuICBbICdlbnRpdHknLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbnRpdHknKSBdXG5dO1xuXG52YXIgX3J1bGVzMiA9IFtcbiAgWyAnYmFsYW5jZV9wYWlycycsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS5wb3N0UHJvY2VzcyBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ3RleHRfY29sbGFwc2UnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlcklubGluZSgpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUoKSB7XG4gIHZhciBpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgaW5saW5lIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gU2Vjb25kIHJ1bGVyIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZ1xuICAgKiAoZS5nLiBpbiBlbXBoYXNpcy1saWtlIHJ1bGVzKS5cbiAgICoqL1xuICB0aGlzLnJ1bGVyMiA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlcjIucHVzaChfcnVsZXMyW2ldWzBdLCBfcnVsZXMyW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8vIFNraXAgc2luZ2xlIHRva2VuIGJ5IHJ1bm5pbmcgYWxsIHJ1bGVzIGluIHZhbGlkYXRpb24gbW9kZTtcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3Ncbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nLFxuICAgICAgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcblxuXG4gIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEluY3JlbWVudCBzdGF0ZS5sZXZlbCBhbmQgZGVjcmVtZW50IGl0IGxhdGVyIHRvIGxpbWl0IHJlY3Vyc2lvbi5cbiAgICAgIC8vIEl0J3MgaGFybWxlc3MgdG8gZG8gaGVyZSwgYmVjYXVzZSBubyB0b2tlbnMgYXJlIGNyZWF0ZWQuIEJ1dCBpZGVhbGx5LFxuICAgICAgLy8gd2UnZCBuZWVkIGEgc2VwYXJhdGUgcHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgLy9cbiAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCB0cnVlKTtcbiAgICAgIHN0YXRlLmxldmVsLS07XG5cbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUb28gbXVjaCBuZXN0aW5nLCBqdXN0IHNraXAgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLlxuICAgIC8vXG4gICAgLy8gTk9URTogdGhpcyB3aWxsIGNhdXNlIGxpbmtzIHRvIGJlaGF2ZSBpbmNvcnJlY3RseSBpbiB0aGUgZm9sbG93aW5nIGNhc2UsXG4gICAgLy8gICAgICAgd2hlbiBhbiBhbW91bnQgb2YgYFtgIGlzIGV4YWN0bHkgZXF1YWwgdG8gYG1heE5lc3RpbmcgKyAxYDpcbiAgICAvL1xuICAgIC8vICAgICAgIFtbW1tbW1tbW1tbW1tbW1tbW1tbW2Zvb10oKVxuICAgIC8vXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIENNIHN0YW5kYXJkIHdpbGwgYWxsb3cgbmVzdGVkIGxpbmtzXG4gICAgLy8gICAgICAgKHdlIGNhbiByZXBsYWNlIGl0IGJ5IHByZXZlbnRpbmcgbGlua3MgZnJvbSBiZWluZyBwYXJzZWQgaW5cbiAgICAvLyAgICAgICB2YWxpZGF0aW9uIG1vZGUpXG4gICAgLy9cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXg7XG4gIH1cblxuICBpZiAoIW9rKSB7IHN0YXRlLnBvcysrOyB9XG4gIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBlbmQgPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvaykge1xuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgc3RhdGUucHVzaFBlbmRpbmcoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlcklubGluZS5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBpbmxpbmUgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIGksIHJ1bGVzLCBsZW47XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlKTtcblxuICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKCcnKTtcbiAgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwiLy8gQ29tbW9ubWFyayBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICB0cnVlLCAgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICB0cnVlLCAgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnZmVuY2UnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdocicsXG4gICAgICAgICdodG1sX2Jsb2NrJyxcbiAgICAgICAgJ2xoZWFkaW5nJyxcbiAgICAgICAgJ2xpc3QnLFxuICAgICAgICAncmVmZXJlbmNlJyxcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYXV0b2xpbmsnLFxuICAgICAgICAnYmFja3RpY2tzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2VudGl0eScsXG4gICAgICAgICdlc2NhcGUnLFxuICAgICAgICAnaHRtbF9pbmxpbmUnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAnbGluaycsXG4gICAgICAgICduZXdsaW5lJyxcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzIiwiLy8gbWFya2Rvd24taXQgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDEwMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHt9LFxuICAgIGJsb2NrOiB7fSxcbiAgICBpbmxpbmU6IHt9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCIvLyBcIlplcm9cIiBwcmVzZXQsIHdpdGggbm90aGluZyBlbmFibGVkLiBVc2VmdWwgZm9yIG1hbnVhbCBjb25maWd1cmluZyBvZiBzaW1wbGVcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnbm9ybWFsaXplJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZSdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3RleHQnXG4gICAgICBdLFxuICAgICAgcnVsZXMyOiBbXG4gICAgICAgICdiYWxhbmNlX3BhaXJzJyxcbiAgICAgICAgJ3RleHRfY29sbGFwc2UnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwiLyoqXG4gKiBjbGFzcyBSZW5kZXJlclxuICpcbiAqIEdlbmVyYXRlcyBIVE1MIGZyb20gcGFyc2VkIHRva2VuIHN0cmVhbS4gRWFjaCBpbnN0YW5jZSBoYXMgaW5kZXBlbmRlbnRcbiAqIGNvcHkgb2YgcnVsZXMuIFRob3NlIGNhbiBiZSByZXdyaXR0ZW4gd2l0aCBlYXNlLiBBbHNvLCB5b3UgY2FuIGFkZCBuZXdcbiAqIHJ1bGVzIGlmIHlvdSBjcmVhdGUgcGx1Z2luIGFuZCBhZGRzIG5ldyB0b2tlbiB0eXBlcy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXNzaWduICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5hc3NpZ247XG52YXIgdW5lc2NhcGVBbGwgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZUFsbDtcbnZhciBlc2NhcGVIdG1sICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmVzY2FwZUh0bWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmF1bHRfcnVsZXMgPSB7fTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9ibG9jayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPHByZScgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz48Y29kZT4nICtcbiAgICAgICAgICBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICtcbiAgICAgICAgICAnPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuZmVuY2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdLFxuICAgICAgaW5mbyA9IHRva2VuLmluZm8gPyB1bmVzY2FwZUFsbCh0b2tlbi5pbmZvKS50cmltKCkgOiAnJyxcbiAgICAgIGxhbmdOYW1lID0gJycsXG4gICAgICBoaWdobGlnaHRlZCwgaSwgdG1wQXR0cnMsIHRtcFRva2VuO1xuXG4gIGlmIChpbmZvKSB7XG4gICAgbGFuZ05hbWUgPSBpbmZvLnNwbGl0KC9cXHMrL2cpWzBdO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi5jb250ZW50LCBsYW5nTmFtZSkgfHwgZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH1cblxuICBpZiAoaGlnaGxpZ2h0ZWQuaW5kZXhPZignPHByZScpID09PSAwKSB7XG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkICsgJ1xcbic7XG4gIH1cblxuICAvLyBJZiBsYW5ndWFnZSBleGlzdHMsIGluamVjdCBjbGFzcyBnZW50bHksIHdpdGhvdXQgbW9kaWZ5aW5nIG9yaWdpbmFsIHRva2VuLlxuICAvLyBNYXkgYmUsIG9uZSBkYXkgd2Ugd2lsbCBhZGQgLmNsb25lKCkgZm9yIHRva2VuIGFuZCBzaW1wbGlmeSB0aGlzIHBhcnQsIGJ1dFxuICAvLyBub3cgd2UgcHJlZmVyIHRvIGtlZXAgdGhpbmdzIGxvY2FsLlxuICBpZiAoaW5mbykge1xuICAgIGkgICAgICAgID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpO1xuICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRtcEF0dHJzLnB1c2goWyAnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZSBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgfVxuXG4gICAgLy8gRmFrZSB0b2tlbiBqdXN0IHRvIHJlbmRlciBhdHRyaWJ1dGVzXG4gICAgdG1wVG9rZW4gPSB7XG4gICAgICBhdHRyczogdG1wQXR0cnNcbiAgICB9O1xuXG4gICAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG1wVG9rZW4pICsgJz4nXG4gICAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cblxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPidcbiAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gXCJhbHRcIiBhdHRyIE1VU1QgYmUgc2V0LCBldmVuIGlmIGVtcHR5LiBCZWNhdXNlIGl0J3MgbWFuZGF0b3J5IGFuZFxuICAvLyBzaG91bGQgYmUgcGxhY2VkIG9uIHByb3BlciBwb3NpdGlvbiBmb3IgdGVzdHMuXG4gIC8vXG4gIC8vIFJlcGxhY2UgY29udGVudCB3aXRoIGFjdHVhbCB2YWx1ZVxuXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cbiAgICBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuXG4gIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XG59O1xuZGVmYXVsdF9ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcblxuXG4vKipcbiAqIG5ldyBSZW5kZXJlcigpXG4gKlxuICogQ3JlYXRlcyBuZXcgW1tSZW5kZXJlcl1dIGluc3RhbmNlIGFuZCBmaWxsIFtbUmVuZGVyZXIjcnVsZXNdXSB3aXRoIGRlZmF1bHRzLlxuICoqL1xuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcmVyI3J1bGVzIC0+IE9iamVjdFxuICAgKlxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfb3BlbiAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPGI+JzsgfTtcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzwvYj4nOyB9O1xuICAgKlxuICAgKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKC4uLik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFYWNoIHJ1bGUgaXMgY2FsbGVkIGFzIGluZGVwZW5kZW50IHN0YXRpYyBmdW5jdGlvbiB3aXRoIGZpeGVkIHNpZ25hdHVyZTpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBmdW5jdGlvbiBteV90b2tlbl9yZW5kZXIodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgcmVuZGVyZXIpIHtcbiAgICogICAvLyAuLi5cbiAgICogICByZXR1cm4gcmVuZGVyZWRIVE1MO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVzID0gYXNzaWduKHt9LCBkZWZhdWx0X3J1bGVzKTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlckF0dHJzKHRva2VuKSAtPiBTdHJpbmdcbiAqXG4gKiBSZW5kZXIgdG9rZW4gYXR0cmlidXRlcyB0byBzdHJpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQXR0cnMgPSBmdW5jdGlvbiByZW5kZXJBdHRycyh0b2tlbikge1xuICB2YXIgaSwgbCwgcmVzdWx0O1xuXG4gIGlmICghdG9rZW4uYXR0cnMpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmVzdWx0ID0gJyc7XG5cbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICcgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzBdKSArICc9XCInICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9mIHRva2Vuc1xuICogLSBpZHggKE51bWJlZCk6IHRva2VuIGluZGV4IHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogRGVmYXVsdCB0b2tlbiByZW5kZXJlci4gQ2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gZnVuY3Rpb25cbiAqIGluIFtbUmVuZGVyZXIjcnVsZXNdXS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbiA9IGZ1bmN0aW9uIHJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gIHZhciBuZXh0VG9rZW4sXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIG5lZWRMZiA9IGZhbHNlLFxuICAgICAgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBUaWdodCBsaXN0IHBhcmFncmFwaHNcbiAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEluc2VydCBhIG5ld2xpbmUgYmV0d2VlbiBoaWRkZW4gcGFyYWdyYXBoIGFuZCBzdWJzZXF1ZW50IG9wZW5pbmdcbiAgLy8gYmxvY2stbGV2ZWwgdGFnLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaGVyZSB3ZSBzaG91bGQgaW5zZXJ0IGEgbmV3bGluZSBiZWZvcmUgYmxvY2txdW90ZTpcbiAgLy8gIC0gYVxuICAvLyAgICA+XG4gIC8vXG4gIGlmICh0b2tlbi5ibG9jayAmJiB0b2tlbi5uZXN0aW5nICE9PSAtMSAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLmhpZGRlbikge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIEFkZCB0b2tlbiBuYW1lLCBlLmcuIGA8aW1nYFxuICByZXN1bHQgKz0gKHRva2VuLm5lc3RpbmcgPT09IC0xID8gJzwvJyA6ICc8JykgKyB0b2tlbi50YWc7XG5cbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXG4gIHJlc3VsdCArPSB0aGlzLnJlbmRlckF0dHJzKHRva2VuKTtcblxuICAvLyBBZGQgYSBzbGFzaCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCIgL2BcbiAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDAgJiYgb3B0aW9ucy54aHRtbE91dCkge1xuICAgIHJlc3VsdCArPSAnIC8nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXdsaW5lIGFmdGVyIHRoaXMgdGFnXG4gIGlmICh0b2tlbi5ibG9jaykge1xuICAgIG5lZWRMZiA9IHRydWU7XG5cbiAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMSkge1xuICAgICAgaWYgKGlkeCArIDEgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tpZHggKyAxXTtcblxuICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICdpbmxpbmUnIHx8IG5leHRUb2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBCbG9jay1sZXZlbCB0YWcgY29udGFpbmluZyBhbiBpbmxpbmUgdGFnLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyB0YWcgKyBjbG9zaW5nIHRhZyBvZiB0aGUgc2FtZSB0eXBlLiBFLmcuIGA8bGk+PC9saT5gLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bHQgKz0gbmVlZExmID8gJz5cXG4nIDogJz4nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVySW5saW5lKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3R5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogU3BlY2lhbCBrbHVkZ2UgZm9yIGltYWdlIGBhbHRgIGF0dHJpYnV0ZXMgdG8gY29uZm9ybSBDb21tb25NYXJrIHNwZWMuXG4gKiBEb24ndCB0cnkgdG8gdXNlIGl0ISBTcGVjIHJlcXVpcmVzIHRvIHNob3cgYGFsdGAgY29udGVudCB3aXRoIHN0cmlwcGVkIG1hcmt1cCxcbiAqIGluc3RlYWQgb2Ygc2ltcGxlIGVzY2FwaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZUFzVGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlcih0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogVGFrZXMgdG9rZW4gc3RyZWFtIGFuZCBnZW5lcmF0ZXMgSFRNTC4gUHJvYmFibHksIHlvdSB3aWxsIG5ldmVyIG5lZWQgdG8gY2FsbFxuICogdGhpcyBtZXRob2QgZGlyZWN0bHkuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciBpLCBsZW4sIHR5cGUsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcblxuICBmb3IgKGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZSh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdG9rZW5zW2ldLnR5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanMiLCIvLyBCbG9jayBxdW90ZXNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgYWRqdXN0VGFiLFxuICAgICAgY2gsXG4gICAgICBpLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGwsXG4gICAgICBsYXN0TGluZUVtcHR5LFxuICAgICAgbGluZXMsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEJNYXJrcyxcbiAgICAgIG9sZEJTQ291bnQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkU0NvdW50LFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgc3BhY2VBZnRlck1hcmtlcixcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgd2FzT3V0ZGVudGVkLFxuICAgICAgb2xkTGluZU1heCA9IHN0YXRlLmxpbmVNYXgsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2hlY2sgdGhlIGJsb2NrIHF1b3RlIG1hcmtlclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspICE9PSAweDNFLyogPiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSBrbm93IHRoYXQgaXQncyBnb2luZyB0byBiZSBhIHZhbGlkIGJsb2NrcXVvdGUsXG4gIC8vIHNvIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBlbmQgb2YgaXQgaW4gc2lsZW50IG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgcG9zKys7XG4gICAgaW5pdGlhbCsrO1xuICAgIG9mZnNldCsrO1xuICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICBpZiAoKHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgIHBvcysrO1xuICAgICAgaW5pdGlhbCsrO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICB9XG5cbiAgb2xkQk1hcmtzID0gWyBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IHBvcztcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgb2xkQlNDb3VudCA9IFsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdIF07XG4gIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gIG9sZFNDb3VudCA9IFsgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gIG9sZFRTaGlmdCA9IFsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2Jsb2NrcXVvdGUnO1xuICB3YXNPdXRkZW50ZWQgPSBmYWxzZTtcblxuICAvLyBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgYmxvY2tcbiAgLy9cbiAgLy8gQmxvY2sgZW5kcyB3aXRoIGVpdGhlcjpcbiAgLy8gIDEuIGFuIGVtcHR5IGxpbmUgb3V0c2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vXG4gIC8vICAgICBgYGBcbiAgLy8gIDIuIGFuIGVtcHR5IGxpbmUgaW5zaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+XG4gIC8vICAgICB0ZXN0XG4gIC8vICAgICBgYGBcbiAgLy8gIDMuIGFub3RoZXIgdGFnOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy8gICAgICAtIC0gLVxuICAvLyAgICAgYGBgXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAxOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAvLyBjaGVjayBpZiBpdCdzIG91dGRlbnRlZCwgaS5lLiBpdCdzIGluc2lkZSBsaXN0IGl0ZW0gYW5kIGluZGVudGVkXG4gICAgLy8gbGVzcyB0aGFuIHNhaWQgbGlzdCBpdGVtOlxuICAgIC8vXG4gICAgLy8gYGBgXG4gICAgLy8gMS4gYW55dGhpbmdcbiAgICAvLyAgICA+IGN1cnJlbnQgYmxvY2txdW90ZVxuICAgIC8vIDIuIGNoZWNraW5nIHRoaXMgbGluZVxuICAgIC8vIGBgYFxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB3YXNPdXRkZW50ZWQgPSB0cnVlO1xuXG4gICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAvLyBDYXNlIDE6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoaXMgbGluZSBpcyBlbXB0eS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgPT09IDB4M0UvKiA+ICovICYmICF3YXNPdXRkZW50ZWQpIHtcbiAgICAgIC8vIFRoaXMgbGluZSBpcyBpbnNpZGUgdGhlIGJsb2NrcXVvdGUuXG5cbiAgICAgIC8vIHNraXAgc3BhY2VzIGFmdGVyIFwiPlwiIGFuZCByZS1jYWxjdWxhdGUgb2Zmc2V0XG4gICAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvcyAtIChzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG5cbiAgICAgIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAgLyogc3BhY2UgKi8pIHtcbiAgICAgICAgLy8gJyA+ICAgdGVzdCAnXG4gICAgICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG5cbiAgICAgICAgaWYgKChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIG9mZnNldCkgJSA0ID09PSAzKSB7XG4gICAgICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuYk1hcmtzW25leHRMaW5lXSA9IHBvcztcblxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuXG4gICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuXG4gICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2FzZSAyOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGUgbGFzdCBsaW5lIHdhcyBlbXB0eS5cbiAgICBpZiAobGFzdExpbmVFbXB0eSkgeyBicmVhazsgfVxuXG4gICAgLy8gQ2FzZSAzOiBhbm90aGVyIHRhZyBmb3VuZC5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIC8vIFF1aXJrIHRvIGVuZm9yY2UgXCJoYXJkIHRlcm1pbmF0aW9uIG1vZGVcIiBmb3IgcGFyYWdyYXBocztcbiAgICAgIC8vIG5vcm1hbGx5IGlmIHlvdSBjYWxsIGB0b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSlgLFxuICAgICAgLy8gcGFyYWdyYXBocyB3aWxsIGxvb2sgYmVsb3cgbmV4dExpbmUgZm9yIHBhcmFncmFwaCBjb250aW51YXRpb24sXG4gICAgICAvLyBidXQgaWYgYmxvY2txdW90ZSBpcyB0ZXJtaW5hdGVkIGJ5IGFub3RoZXIgdGFnLCB0aGV5IHNob3VsZG4ndFxuICAgICAgc3RhdGUubGluZU1heCA9IG5leHRMaW5lO1xuXG4gICAgICBpZiAoc3RhdGUuYmxrSW5kZW50ICE9PSAwKSB7XG4gICAgICAgIC8vIHN0YXRlLmJsa0luZGVudCB3YXMgbm9uLXplcm8sIHdlIG5vdyBzZXQgaXQgdG8gemVybyxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgYWxsIG9mZnNldHMgdG8gYXBwZWFyIGFzXG4gICAgICAgIC8vIGlmIGluZGVudCB3YXNuJ3QgY2hhbmdlZFxuICAgICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC09IHN0YXRlLmJsa0luZGVudDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcblxuICAgIC8vIEEgbmVnYXRpdmUgaW5kZW50YXRpb24gbWVhbnMgdGhhdCB0aGlzIGlzIGEgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICAgIC8vXG4gICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IC0xO1xuICB9XG5cbiAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICBzdGF0ZS5ibGtJbmRlbnQgPSAwO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfb3BlbicsICdibG9ja3F1b3RlJywgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcbiAgdG9rZW4ubWFwICAgID0gbGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX2Nsb3NlJywgJ2Jsb2NrcXVvdGUnLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICc+JztcblxuICBzdGF0ZS5saW5lTWF4ID0gb2xkTGluZU1heDtcbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gIGxpbmVzWzFdID0gc3RhdGUubGluZTtcblxuICAvLyBSZXN0b3JlIG9yaWdpbmFsIHRTaGlmdDsgdGhpcyBtaWdodCBub3QgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBwYXJzZXJcbiAgLy8gaGFzIGFscmVhZHkgYmVlbiBoZXJlLCBidXQganVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIGRvIHRoYXQuXG4gIGZvciAoaSA9IDA7IGkgPCBvbGRUU2hpZnQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGF0ZS5iTWFya3NbaSArIHN0YXJ0TGluZV0gPSBvbGRCTWFya3NbaV07XG4gICAgc3RhdGUudFNoaWZ0W2kgKyBzdGFydExpbmVdID0gb2xkVFNoaWZ0W2ldO1xuICAgIHN0YXRlLnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZFNDb3VudFtpXTtcbiAgICBzdGF0ZS5ic0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkQlNDb3VudFtpXTtcbiAgfVxuICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3Q7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfYmxvY2snLCAnY29kZScsIDApO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qcyIsIi8vIGZlbmNlcyAoYGBgIGxhbmcsIH5+fiBsYW5nKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgbGVuLCBwYXJhbXMsIG5leHRMaW5lLCBtZW0sIHRva2VuLCBtYXJrdXAsXG4gICAgICBoYXZlRW5kTWFya2VyID0gZmFsc2UsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDMgPiBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4NjAgLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICBtZW0gPSBwb3M7XG4gIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgbGVuID0gcG9zIC0gbWVtO1xuXG4gIGlmIChsZW4gPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcyk7XG4gIHBhcmFtcyA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgaWYgKHBhcmFtcy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSkgPj0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW5jZSBzdGFydCBpcyBmb3VuZCwgd2UgY2FuIHJlcG9ydCBzdWNjZXNzIGhlcmUgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZWFyY2ggZW5kIG9mIGJsb2NrXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuXG4gIGZvciAoOzspIHtcbiAgICBuZXh0TGluZSsrO1xuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAvLyB1bmNsb3NlZCBibG9jayBzaG91bGQgYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgZG9jdW1lbnQuXG4gICAgICAvLyBhbHNvIGJsb2NrIHNlZW1zIHRvIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIHBhcmVudFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zID0gbWVtID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgLy8gbm9uLWVtcHR5IGxpbmUgd2l0aCBuZWdhdGl2ZSBpbmRlbnQgc2hvdWxkIHN0b3AgdGhlIGxpc3Q6XG4gICAgICAvLyAtIGBgYFxuICAgICAgLy8gIHRlc3RcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBtYXJrZXIpIHsgY29udGludWU7IH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIC8vIGNsb3NpbmcgZmVuY2Ugc2hvdWxkIGJlIGluZGVudGVkIGxlc3MgdGhhbiA0IHNwYWNlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICAgIC8vIGNsb3NpbmcgY29kZSBmZW5jZSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxvbmcgYXMgdGhlIG9wZW5pbmcgb25lXG4gICAgaWYgKHBvcyAtIG1lbSA8IGxlbikgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRhaWwgaGFzIHNwYWNlcyBvbmx5XG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgaWYgKHBvcyA8IG1heCkgeyBjb250aW51ZTsgfVxuXG4gICAgaGF2ZUVuZE1hcmtlciA9IHRydWU7XG4gICAgLy8gZm91bmQhXG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBJZiBhIGZlbmNlIGhhcyBoZWFkaW5nIHNwYWNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGl0cyBpbm5lciBibG9ja1xuICBsZW4gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnZmVuY2UnLCAnY29kZScsIDApO1xuICB0b2tlbi5pbmZvICAgID0gcGFyYW1zO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lICsgMSwgbmV4dExpbmUsIGxlbiwgdHJ1ZSk7XG4gIHRva2VuLm1hcmt1cCAgPSBtYXJrdXA7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzIiwiLy8gaGVhZGluZyAoIywgIyMsIC4uLilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxldmVsLCB0bXAsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoICA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKGNoICE9PSAweDIzLyogIyAqLyB8fCBwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNvdW50IGhlYWRpbmcgbGV2ZWxcbiAgbGV2ZWwgPSAxO1xuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgd2hpbGUgKGNoID09PSAweDIzLyogIyAqLyAmJiBwb3MgPCBtYXggJiYgbGV2ZWwgPD0gNikge1xuICAgIGxldmVsKys7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIH1cblxuICBpZiAobGV2ZWwgPiA2IHx8IChwb3MgPCBtYXggJiYgIWlzU3BhY2UoY2gpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xuXG4gIG1heCA9IHN0YXRlLnNraXBTcGFjZXNCYWNrKG1heCwgcG9zKTtcbiAgdG1wID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgsIDB4MjMsIHBvcyk7IC8vICNcbiAgaWYgKHRtcCA+IHBvcyAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHRtcCAtIDEpKSkge1xuICAgIG1heCA9IHRtcDtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKTtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCIvLyBIb3Jpem9udGFsIHJ1bGVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBocihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgY250LCBjaCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIC8vIENoZWNrIGhyIG1hcmtlclxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDVGLyogXyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb2YgdGhlbVxuXG4gIGNudCA9IDE7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGNoID09PSBtYXJrZXIpIHsgY250Kys7IH1cbiAgfVxuXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5tYXJrdXAgPSBBcnJheShjbnQgKyAxKS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanMiLCIvLyBIVE1MIGJsb2NrXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYmxvY2tfbmFtZXMgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9ibG9ja3MnKTtcbnZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuXG4vLyBBbiBhcnJheSBvZiBvcGVuaW5nIGFuZCBjb3JyZXNwb25kaW5nIGNsb3Npbmcgc2VxdWVuY2VzIGZvciBodG1sIHRhZ3MsXG4vLyBsYXN0IGFyZ3VtZW50IGRlZmluZXMgd2hldGhlciBpdCBjYW4gdGVybWluYXRlIGEgcGFyYWdyYXBoIG9yIG5vdFxuLy9cbnZhciBIVE1MX1NFUVVFTkNFUyA9IFtcbiAgWyAvXjwoc2NyaXB0fHByZXxzdHlsZSkoPz0oXFxzfD58JCkpL2ksIC88XFwvKHNjcmlwdHxwcmV8c3R5bGUpPi9pLCB0cnVlIF0sXG4gIFsgL148IS0tLywgICAgICAgIC8tLT4vLCAgIHRydWUgXSxcbiAgWyAvXjxcXD8vLCAgICAgICAgIC9cXD8+LywgICB0cnVlIF0sXG4gIFsgL148IVtBLVpdLywgICAgIC8+LywgICAgIHRydWUgXSxcbiAgWyAvXjwhXFxbQ0RBVEFcXFsvLCAvXFxdXFxdPi8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKCdePC8/KCcgKyBibG9ja19uYW1lcy5qb2luKCd8JykgKyAnKSg/PShcXFxcc3wvPz58JCkpJywgJ2knKSwgL14kLywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoSFRNTF9PUEVOX0NMT1NFX1RBR19SRS5zb3VyY2UgKyAnXFxcXHMqJCcpLCAgL14kLywgZmFsc2UgXVxuXTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfYmxvY2soc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBpLCBuZXh0TGluZSwgdG9rZW4sIGxpbmVUZXh0LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzBdLnRlc3QobGluZVRleHQpKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoaSA9PT0gSFRNTF9TRVFVRU5DRVMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHtcbiAgICAvLyB0cnVlIGlmIHRoaXMgc2VxdWVuY2UgY2FuIGJlIGEgdGVybWluYXRvciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgcmV0dXJuIEhUTUxfU0VRVUVOQ0VTW2ldWzJdO1xuICB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIC8vIElmIHdlIGFyZSBoZXJlIC0gd2UgZGV0ZWN0ZWQgSFRNTCBibG9jay5cbiAgLy8gTGV0J3Mgcm9sbCBkb3duIHRpbGwgYmxvY2sgZW5kLlxuICBpZiAoIUhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gICAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICAgICAgaWYgKGxpbmVUZXh0Lmxlbmd0aCAhPT0gMCkgeyBuZXh0TGluZSsrOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9ibG9jaycsICcnLCAwKTtcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBuZXh0TGluZSBdO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBwb3MsIG1heCwgbGV2ZWwsIG1hcmtlcixcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgb2xkUGFyZW50VHlwZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnOyAvLyB1c2UgcGFyYWdyYXBoIHRvIG1hdGNoIHRlcm1pbmF0b3JSdWxlc1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAobWFya2VyID09PSAweDJELyogLSAqLyB8fCBtYXJrZXIgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICAgICAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCIvLyBMaXN0c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG4vLyBTZWFyY2ggYFstKypdW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhZnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIG1hcmtlciwgcG9zLCBtYXgsIGNoO1xuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgLy8gQ2hlY2sgYnVsbGV0XG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkIvKiArICovKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIC10ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxuLy8gU2VhcmNoIGBcXGQrWy4pXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgY2gsXG4gICAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBwb3MgPSBzdGFydCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIExpc3QgbWFya2VyIHNob3VsZCBoYXZlIGF0IGxlYXN0IDIgY2hhcnMgKGRpZ2l0ICsgZG90KVxuICBpZiAocG9zICsgMSA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgaWYgKGNoIDwgMHgzMC8qIDAgKi8gfHwgY2ggPiAweDM5LyogOSAqLykgeyByZXR1cm4gLTE7IH1cblxuICBmb3IgKDs7KSB7XG4gICAgLy8gRU9MIC0+IGZhaWxcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gICAgaWYgKGNoID49IDB4MzAvKiAwICovICYmIGNoIDw9IDB4MzkvKiA5ICovKSB7XG5cbiAgICAgIC8vIExpc3QgbWFya2VyIHNob3VsZCBoYXZlIG5vIG1vcmUgdGhhbiA5IGRpZ2l0c1xuICAgICAgLy8gKHByZXZlbnRzIGludGVnZXIgb3ZlcmZsb3cgaW4gYnJvd3NlcnMpXG4gICAgICBpZiAocG9zIC0gc3RhcnQgPj0gMTApIHsgcmV0dXJuIC0xOyB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZvdW5kIHZhbGlkIG1hcmtlclxuICAgIGlmIChjaCA9PT0gMHgyOS8qICkgKi8gfHwgY2ggPT09IDB4MmUvKiAuICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAxLnRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgaWR4KSB7XG4gIHZhciBpLCBsLFxuICAgICAgbGV2ZWwgPSBzdGF0ZS5sZXZlbCArIDI7XG5cbiAgZm9yIChpID0gaWR4ICsgMiwgbCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgaSArPSAyO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY29udGVudFN0YXJ0LFxuICAgICAgaSxcbiAgICAgIGluZGVudCxcbiAgICAgIGluZGVudEFmdGVyTWFya2VyLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGlzT3JkZXJlZCxcbiAgICAgIGl0ZW1MaW5lcyxcbiAgICAgIGwsXG4gICAgICBsaXN0TGluZXMsXG4gICAgICBsaXN0VG9rSWR4LFxuICAgICAgbWFya2VyQ2hhckNvZGUsXG4gICAgICBtYXJrZXJWYWx1ZSxcbiAgICAgIG1heCxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkTEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBvbGRUaWdodCxcbiAgICAgIHBvcyxcbiAgICAgIHBvc0FmdGVyTWFya2VyLFxuICAgICAgcHJldkVtcHR5RW5kLFxuICAgICAgc3RhcnQsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0b2tlbixcbiAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSBmYWxzZSxcbiAgICAgIHRpZ2h0ID0gdHJ1ZTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBsaW1pdCBjb25kaXRpb25zIHdoZW4gbGlzdCBjYW4gaW50ZXJydXB0XG4gIC8vIGEgcGFyYWdyYXBoICh2YWxpZGF0aW9uIG1vZGUgb25seSlcbiAgaWYgKHNpbGVudCAmJiBzdGF0ZS5wYXJlbnRUeXBlID09PSAncGFyYWdyYXBoJykge1xuICAgIC8vIE5leHQgbGlzdCBpdGVtIHNob3VsZCBzdGlsbCB0ZXJtaW5hdGUgcHJldmlvdXMgbGlzdCBpdGVtO1xuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGNhbiBmYWlsIGlmIHBsdWdpbnMgdXNlIGJsa0luZGVudCBhcyB3ZWxsIGFzIGxpc3RzLFxuICAgIC8vIGJ1dCBJIGhvcGUgdGhlIHNwZWMgZ2V0cyBmaXhlZCBsb25nIGJlZm9yZSB0aGF0IGhhcHBlbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBEZXRlY3QgbGlzdCB0eXBlIGFuZCBwb3NpdGlvbiBhZnRlciBtYXJrZXJcbiAgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IHRydWU7XG4gICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG1hcmtlclZhbHVlID0gTnVtYmVyKHN0YXRlLnNyYy5zdWJzdHIoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gc3RhcnQgLSAxKSk7XG5cbiAgICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyBvcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgICAvLyBhIHBhcmFncmFwaCwgaXQgc2hvdWxkIHN0YXJ0IHdpdGggMS5cbiAgICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCAmJiBtYXJrZXJWYWx1ZSAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gIH0gZWxzZSBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIHN0YXJ0aW5nIGEgbmV3IHVub3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gIC8vIGEgcGFyYWdyYXBoLCBmaXJzdCBsaW5lIHNob3VsZCBub3QgYmUgZW1wdHkuXG4gIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoKSB7XG4gICAgaWYgKHN0YXRlLnNraXBTcGFjZXMocG9zQWZ0ZXJNYXJrZXIpID49IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBzaG91bGQgdGVybWluYXRlIGxpc3Qgb24gc3R5bGUgY2hhbmdlLiBSZW1lbWJlciBmaXJzdCBvbmUgdG8gY29tcGFyZS5cbiAgbWFya2VyQ2hhckNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpO1xuXG4gIC8vIEZvciB2YWxpZGF0aW9uIG1vZGUgd2UgY2FuIHRlcm1pbmF0ZSBpbW1lZGlhdGVseVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gU3RhcnQgbGlzdFxuICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gICAgICAgPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3Rfb3BlbicsICdvbCcsIDEpO1xuICAgIGlmIChtYXJrZXJWYWx1ZSAhPT0gMSkge1xuICAgICAgdG9rZW4uYXR0cnMgPSBbIFsgJ3N0YXJ0JywgbWFya2VyVmFsdWUgXSBdO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3Rfb3BlbicsICd1bCcsIDEpO1xuICB9XG5cbiAgdG9rZW4ubWFwICAgID0gbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgLy9cbiAgLy8gSXRlcmF0ZSBsaXN0IGl0ZW1zXG4gIC8vXG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG4gIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnbGlzdCcpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2xpc3QnO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBwb3MgPSBwb3NBZnRlck1hcmtlcjtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3NBZnRlck1hcmtlciAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcblxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKSAlIDQ7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAweDIwKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIGNvbnRlbnRTdGFydCA9IHBvcztcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4KSB7XG4gICAgICAvLyB0cmltbWluZyBzcGFjZSBpbiBcIi0gICAgXFxuICAzXCIgY2FzZSwgaW5kZW50IGlzIDEgaGVyZVxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IG9mZnNldCAtIGluaXRpYWw7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gNCBzcGFjZXMsIHRoZSBpbmRlbnQgaXMgMVxuICAgIC8vICh0aGUgcmVzdCBpcyBqdXN0IGluZGVudGVkIGNvZGUgYmxvY2spXG4gICAgaWYgKGluZGVudEFmdGVyTWFya2VyID4gNCkgeyBpbmRlbnRBZnRlck1hcmtlciA9IDE7IH1cblxuICAgIC8vIFwiICAtICB0ZXN0XCJcbiAgICAvLyAgXl5eXl4gLSBjYWxjdWxhdGluZyB0b3RhbCBsZW5ndGggb2YgdGhpcyB0aGluZ1xuICAgIGluZGVudCA9IGluaXRpYWwgKyBpbmRlbnRBZnRlck1hcmtlcjtcblxuICAgIC8vIFJ1biBzdWJwYXJzZXIgJiB3cml0ZSB0b2tlbnNcbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fb3BlbicsICdsaScsIDEpO1xuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuICAgIHRva2VuLm1hcCAgICA9IGl0ZW1MaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgb2xkVGlnaHQgPSBzdGF0ZS50aWdodDtcbiAgICBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBvbGRMSW5kZW50ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG4gICAgc3RhdGUuYmxrSW5kZW50ID0gaW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gdHJ1ZTtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IGNvbnRlbnRTdGFydCAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0O1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXggJiYgc3RhdGUuaXNFbXB0eShzdGFydExpbmUgKyAxKSkge1xuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgdGhpcyBjYXNlXG4gICAgICAvLyAobGlzdCBpdGVtIGlzIGVtcHR5LCBsaXN0IHRlcm1pbmF0ZXMgYmVmb3JlIFwiZm9vXCIpOlxuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIC8vICAgLVxuICAgICAgLy9cbiAgICAgIC8vICAgICBmb29cbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICBzdGF0ZS5saW5lID0gTWF0aC5taW4oc3RhdGUubGluZSArIDIsIGVuZExpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgb2YgbGlzdCBpdGVtIGlzIHRpZ2h0LCBtYXJrIGxpc3QgYXMgdGlnaHRcbiAgICBpZiAoIXN0YXRlLnRpZ2h0IHx8IHByZXZFbXB0eUVuZCkge1xuICAgICAgdGlnaHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gSXRlbSBiZWNvbWUgbG9vc2UgaWYgZmluaXNoIHdpdGggZW1wdHkgbGluZSxcbiAgICAvLyBidXQgd2Ugc2hvdWxkIGZpbHRlciBsYXN0IGVsZW1lbnQsIGJlY2F1c2UgaXQgbWVhbnMgbGlzdCBmaW5pc2hcbiAgICBwcmV2RW1wdHlFbmQgPSAoc3RhdGUubGluZSAtIHN0YXJ0TGluZSkgPiAxICYmIHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpO1xuXG4gICAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gb2xkVFNoaWZ0O1xuICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2xkTEluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IG9sZFRpZ2h0O1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX2Nsb3NlJywgJ2xpJywgLTEpO1xuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gICAgbmV4dExpbmUgPSBzdGFydExpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGl0ZW1MaW5lc1sxXSA9IG5leHRMaW5lO1xuICAgIGNvbnRlbnRTdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIC8vXG4gICAgLy8gVHJ5IHRvIGNoZWNrIGlmIGxpc3QgaXMgdGVybWluYXRlZCBvciBjb250aW51ZWQuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiB0ZXJtaW5hdGluZyBibG9jayBmb3VuZFxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgbGlzdCBoYXMgYW5vdGhlciB0eXBlXG4gICAgaWYgKGlzT3JkZXJlZCkge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkgeyBicmVhazsgfVxuICB9XG5cbiAgLy8gRmluYWxpemUgbGlzdFxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3RfY2xvc2UnLCAnb2wnLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9jbG9zZScsICd1bCcsIC0xKTtcbiAgfVxuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIC8vIG1hcmsgcGFyYWdyYXBocyB0aWdodCBpZiBuZWVkZWRcbiAgaWYgKHRpZ2h0KSB7XG4gICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwiLy8gUGFyYWdyYXBoXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgc3RhcnRMaW5lLyosIGVuZExpbmUqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgb2xkUGFyZW50VHlwZSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKSxcbiAgICAgIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX29wZW4nLCAncCcsIDEpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX2Nsb3NlJywgJ3AnLCAtMSk7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWZlcmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBkZXN0RW5kUG9zLFxuICAgICAgZGVzdEVuZExpbmVObyxcbiAgICAgIGVuZExpbmUsXG4gICAgICBocmVmLFxuICAgICAgaSxcbiAgICAgIGwsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIHJlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdGl0bGUsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbXBsZSBjaGVjayB0byBxdWlja2x5IGludGVycnVwdCBzY2FuIG9uIFtsaW5rXSh1cmwpIGF0IHRoZSBzdGFydCBvZiBsaW5lLlxuICAvLyBDYW4gYmUgdXNlZnVsIG9uIHByYWN0aWNlOiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzU0XG4gIHdoaWxlICgrK3BvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVEIC8qIF0gKi8gJiZcbiAgICAgICAgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgaWYgKHBvcyArIDEgPT09IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdyZWZlcmVuY2UnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdyZWZlcmVuY2UnO1xuXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgc3RyID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuICBtYXggPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAocG9zID0gMTsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGFiZWxFbmQgPSBwb3M7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBBIC8qIFxcbiAqLykge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDIC8qIFxcICovKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcbiAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgIF5eXl5eXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KTtcbiAgaWYgKCFyZXMub2spIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHJlcy5wb3M7XG4gIGxpbmVzICs9IHJlcy5saW5lcztcblxuICAvLyBzYXZlIGN1cnNvciBzdGF0ZSwgd2UgY291bGQgcmVxdWlyZSB0byByb2xsYmFjayBsYXRlclxuICBkZXN0RW5kUG9zID0gcG9zO1xuICBkZXN0RW5kTGluZU5vID0gbGluZXM7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgc3RhcnQgPSBwb3M7XG4gIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgdGl0bGUgPSByZXMuc3RyO1xuICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgbGluZXMgKz0gcmVzLmxpbmVzO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gJyc7XG4gICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gIH1cblxuICAvLyBza2lwIHRyYWlsaW5nIHNwYWNlcyB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRpdGxlLFxuICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgdmFsaWQgcmVmZXJlbmNlIGlmIHdlIHJvbGwgYmFja1xuICAgICAgdGl0bGUgPSAnJztcbiAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIuc2xpY2UoMSwgbGFiZWxFbmQpKTtcbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIENvbW1vbk1hcmsgMC4yMCBkaXNhbGxvd3MgZW1wdHkgbGFiZWxzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUmVmZXJlbmNlIGNhbiBub3QgdGVybWluYXRlIGFueXRoaW5nLiBUaGlzIGNoZWNrIGlzIGZvciBzYWZldHkgb25seS5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgaWYqL1xuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGU6IHRpdGxlLCBocmVmOiBocmVmIH07XG4gIH1cblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgbGluZXMgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanMiLCIvLyBQYXJzZXIgc3RhdGUgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBtZCwgZW52LCB0b2tlbnMpIHtcbiAgdmFyIGNoLCBzLCBzdGFydCwgcG9zLCBsZW4sIGluZGVudCwgb2Zmc2V0LCBpbmRlbnRfZm91bmQ7XG5cbiAgdGhpcy5zcmMgPSBzcmM7XG5cbiAgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2VcbiAgdGhpcy5tZCAgICAgPSBtZDtcblxuICB0aGlzLmVudiA9IGVudjtcblxuICAvL1xuICAvLyBJbnRlcm5hbCBzdGF0ZSB2YXJ0aWFibGVzXG4gIC8vXG5cbiAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cbiAgdGhpcy5iTWFya3MgPSBbXTsgIC8vIGxpbmUgYmVnaW4gb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLmVNYXJrcyA9IFtdOyAgLy8gbGluZSBlbmQgb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLnRTaGlmdCA9IFtdOyAgLy8gb2Zmc2V0cyBvZiB0aGUgZmlyc3Qgbm9uLXNwYWNlIGNoYXJhY3RlcnMgKHRhYnMgbm90IGV4cGFuZGVkKVxuICB0aGlzLnNDb3VudCA9IFtdOyAgLy8gaW5kZW50cyBmb3IgZWFjaCBsaW5lICh0YWJzIGV4cGFuZGVkKVxuXG4gIC8vIEFuIGFtb3VudCBvZiB2aXJ0dWFsIHNwYWNlcyAodGFicyBleHBhbmRlZCkgYmV0d2VlbiBiZWdpbm5pbmdcbiAgLy8gb2YgZWFjaCBsaW5lIChiTWFya3MpIGFuZCByZWFsIGJlZ2lubmluZyBvZiB0aGF0IGxpbmUuXG4gIC8vXG4gIC8vIEl0IGV4aXN0cyBvbmx5IGFzIGEgaGFjayBiZWNhdXNlIGJsb2NrcXVvdGVzIG92ZXJyaWRlIGJNYXJrc1xuICAvLyBsb3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIHByb2Nlc3MuXG4gIC8vXG4gIC8vIEl0J3MgdXNlZCBvbmx5IHdoZW4gZXhwYW5kaW5nIHRhYnMsIHlvdSBjYW4gdGhpbmsgYWJvdXQgaXQgYXNcbiAgLy8gYW4gaW5pdGlhbCB0YWIgbGVuZ3RoLCBlLmcuIGJzQ291bnQ9MjEgYXBwbGllZCB0byBzdHJpbmcgYFxcdDEyM2BcbiAgLy8gbWVhbnMgZmlyc3QgdGFiIHNob3VsZCBiZSBleHBhbmRlZCB0byA0LTIxJTQgPT09IDMgc3BhY2VzLlxuICAvL1xuICB0aGlzLmJzQ291bnQgPSBbXTtcblxuICAvLyBibG9jayBwYXJzZXIgdmFyaWFibGVzXG4gIHRoaXMuYmxrSW5kZW50ICA9IDA7IC8vIHJlcXVpcmVkIGJsb2NrIGNvbnRlbnQgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgaWYgd2UgYXJlIGluIGxpc3QpXG4gIHRoaXMubGluZSAgICAgICA9IDA7IC8vIGxpbmUgaW5kZXggaW4gc3JjXG4gIHRoaXMubGluZU1heCAgICA9IDA7IC8vIGxpbmVzIGNvdW50XG4gIHRoaXMudGlnaHQgICAgICA9IGZhbHNlOyAgLy8gbG9vc2UvdGlnaHQgbW9kZSBmb3IgbGlzdHNcbiAgdGhpcy5kZEluZGVudCAgID0gLTE7IC8vIGluZGVudCBvZiB0aGUgY3VycmVudCBkZCBibG9jayAoLTEgaWYgdGhlcmUgaXNuJ3QgYW55KVxuXG4gIC8vIGNhbiBiZSAnYmxvY2txdW90ZScsICdsaXN0JywgJ3Jvb3QnLCAncGFyYWdyYXBoJyBvciAncmVmZXJlbmNlJ1xuICAvLyB1c2VkIGluIGxpc3RzIHRvIGRldGVybWluZSBpZiB0aGV5IGludGVycnVwdCBhIHBhcmFncmFwaFxuICB0aGlzLnBhcmVudFR5cGUgPSAncm9vdCc7XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG5cbiAgLy8gcmVuZGVyZXJcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICAvLyBDcmVhdGUgY2FjaGVzXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXG4gIHMgPSB0aGlzLnNyYztcbiAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgY2ggPSBzLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaW5kZW50X2ZvdW5kKSB7XG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaW5kZW50Kys7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQgLSBvZmZzZXQgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50X2ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKys7IH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpO1xuICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcbiAgdGhpcy5iTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMuZU1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xuICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxufVxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy9cblN0YXRlQmxvY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICB0b2tlbi5ibG9jayA9IHRydWU7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkobGluZSkge1xuICByZXR1cm4gdGhpcy5iTWFya3NbbGluZV0gKyB0aGlzLnRTaGlmdFtsaW5lXSA+PSB0aGlzLmVNYXJrc1tsaW5lXTtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBFbXB0eUxpbmVzID0gZnVuY3Rpb24gc2tpcEVtcHR5TGluZXMoZnJvbSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLmxpbmVNYXg7IGZyb20gPCBtYXg7IGZyb20rKykge1xuICAgIGlmICh0aGlzLmJNYXJrc1tmcm9tXSArIHRoaXMudFNoaWZ0W2Zyb21dIDwgdGhpcy5lTWFya3NbZnJvbV0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbTtcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzID0gZnVuY3Rpb24gc2tpcFNwYWNlcyhwb3MpIHtcbiAgdmFyIGNoO1xuXG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbiBpbiByZXZlcnNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlc0JhY2sgPSBmdW5jdGlvbiBza2lwU3BhY2VzQmFjayhwb3MsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmICghaXNTcGFjZSh0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIGZyb20gZ2l2ZW4gcG9zaXRpb25cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFycyA9IGZ1bmN0aW9uIHNraXBDaGFycyhwb3MsIGNvZGUpIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgcmV2ZXJzZSBmcm9tIGdpdmVuIHBvc2l0aW9uIC0gMVxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzQmFjayA9IGZ1bmN0aW9uIHNraXBDaGFyc0JhY2socG9zLCBjb2RlLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoY29kZSAhPT0gdGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gY3V0IGxpbmVzIHJhbmdlIGZyb20gc291cmNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhiZWdpbiwgZW5kLCBpbmRlbnQsIGtlZXBMYXN0TEYpIHtcbiAgdmFyIGksIGxpbmVJbmRlbnQsIGNoLCBmaXJzdCwgbGFzdCwgcXVldWUsIGxpbmVTdGFydCxcbiAgICAgIGxpbmUgPSBiZWdpbjtcblxuICBpZiAoYmVnaW4gPj0gZW5kKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcXVldWUgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pO1xuXG4gIGZvciAoaSA9IDA7IGxpbmUgPCBlbmQ7IGxpbmUrKywgaSsrKSB7XG4gICAgbGluZUluZGVudCA9IDA7XG4gICAgbGluZVN0YXJ0ID0gZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXTtcblxuICAgIGlmIChsaW5lICsgMSA8IGVuZCB8fCBrZWVwTGFzdExGKSB7XG4gICAgICAvLyBObyBuZWVkIGZvciBib3VuZHMgY2hlY2sgYmVjYXVzZSB3ZSBoYXZlIGZha2UgZW50cnkgb24gdGFpbC5cbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoZmlyc3QgPCBsYXN0ICYmIGxpbmVJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChmaXJzdCk7XG5cbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBsaW5lSW5kZW50ICs9IDQgLSAobGluZUluZGVudCArIHRoaXMuYnNDb3VudFtsaW5lXSkgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVJbmRlbnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCAtIGxpbmVTdGFydCA8IHRoaXMudFNoaWZ0W2xpbmVdKSB7XG4gICAgICAgIC8vIHBhdGNoZWQgdFNoaWZ0IG1hc2tlZCBjaGFyYWN0ZXJzIHRvIGxvb2sgbGlrZSBzcGFjZXMgKGJsb2NrcXVvdGVzLCBsaXN0IG1hcmtlcnMpXG4gICAgICAgIGxpbmVJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmaXJzdCsrO1xuICAgIH1cblxuICAgIGlmIChsaW5lSW5kZW50ID4gaW5kZW50KSB7XG4gICAgICAvLyBwYXJ0aWFsbHkgZXhwYW5kaW5nIHRhYnMgaW4gY29kZSBibG9ja3MsIGUuZyAnXFx0XFx0Zm9vYmFyJ1xuICAgICAgLy8gd2l0aCBpbmRlbnQ9MiBiZWNvbWVzICcgIFxcdGZvb2JhcidcbiAgICAgIHF1ZXVlW2ldID0gbmV3IEFycmF5KGxpbmVJbmRlbnQgLSBpbmRlbnQgKyAxKS5qb2luKCcgJykgKyB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlW2ldID0gdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWV1ZS5qb2luKCcnKTtcbn07XG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlQmxvY2sucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUJsb2NrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCIvLyBHRk0gdGFibGUsIG5vbi1zdGFuZGFyZFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5ibGtJbmRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgcmV0dXJuIHN0YXRlLnNyYy5zdWJzdHIocG9zLCBtYXggLSBwb3MpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkU3BsaXQoc3RyKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBtYXggPSBzdHIubGVuZ3RoLFxuICAgICAgY2gsXG4gICAgICBlc2NhcGVzID0gMCxcbiAgICAgIGxhc3RQb3MgPSAwLFxuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlLFxuICAgICAgbGFzdEJhY2tUaWNrID0gMDtcblxuICBjaCAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBpZiAoY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgICBpZiAoYmFja1RpY2tlZCkge1xuICAgICAgICAvLyBtYWtlIFxcYCBjbG9zZSBjb2RlIHNlcXVlbmNlLCBidXQgbm90IG9wZW4gaXQ7XG4gICAgICAgIC8vIHRoZSByZWFzb24gaXM6IGBcXGAgaXMgY29ycmVjdCBjb2RlIGJsb2NrXG4gICAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVzICUgMiA9PT0gMCkge1xuICAgICAgICBiYWNrVGlja2VkID0gdHJ1ZTtcbiAgICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N2MvKiB8ICovICYmIChlc2NhcGVzICUgMiA9PT0gMCkgJiYgIWJhY2tUaWNrZWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICBsYXN0UG9zID0gcG9zICsgMTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4NWMvKiBcXCAqLykge1xuICAgICAgZXNjYXBlcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlc2NhcGVzID0gMDtcbiAgICB9XG5cbiAgICBwb3MrKztcblxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiB1bi1jbG9zZWQgYmFja3RpY2ssIGdvIGJhY2sgdG8ganVzdCBhZnRlclxuICAgIC8vIHRoZSBsYXN0IGJhY2t0aWNrLCBidXQgYXMgaWYgaXQgd2FzIGEgbm9ybWFsIGNoYXJhY3RlclxuICAgIGlmIChwb3MgPT09IG1heCAmJiBiYWNrVGlja2VkKSB7XG4gICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICBwb3MgPSBsYXN0QmFja1RpY2sgKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgfVxuXG4gIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsaW5lVGV4dCwgcG9zLCBpLCBuZXh0TGluZSwgY29sdW1ucywgY29sdW1uQ291bnQsIHRva2VuLFxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xuXG4gIC8vIHNob3VsZCBoYXZlIGF0IGxlYXN0IHR3byBsaW5lc1xuICBpZiAoc3RhcnRMaW5lICsgMiA+IGVuZExpbmUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnLCAnLScsICc6JyxcbiAgLy8gYW5kIG5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgYnV0IHNwYWNlcztcbiAgLy8gYmFzaWNhbGx5LCB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC9eWy06fF1bLTp8XFxzXSokLyByZWdleHBcblxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgaWYgKHBvcyA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkbid0IGJlIHNtYWxsZXIgdGhhbiB0aGF0ICh0aGUgcmVzdCBvZiB0aGUgcm93cyBjYW4pXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA+IGFsaWducy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcbiAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICB0b2tlbi5hdHRycyAgPSBbIFsgJ3N0eWxlJywgJ3RleHQtYWxpZ246JyArIGFsaWduc1tpXSBdIF07XG4gICAgfVxuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfY2xvc2UnLCAndGgnLCAtMSk7XG4gIH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfY2xvc2UnLCAndGhlYWQnLCAtMSk7XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGJvZHlfb3BlbicsICd0Ym9keScsIDEpO1xuICB0b2tlbi5tYXAgPSB0Ym9keUxpbmVzID0gWyBzdGFydExpbmUgKyAyLCAwIF07XG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKCk7XG4gICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpKTtcblxuICAgIHRva2VuID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKTtcbiAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgICAgfVxuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogJyc7XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX2Nsb3NlJywgJ3RkJywgLTEpO1xuICAgIH1cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xuICB9XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGJvZHlfY2xvc2UnLCAndGJvZHknLCAtMSk7XG4gIHRva2VuID0gc3RhdGUucHVzaCgndGFibGVfY2xvc2UnLCAndGFibGUnLCAtMSk7XG5cbiAgdGFibGVMaW5lc1sxXSA9IHRib2R5TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrKHN0YXRlKSB7XG4gIHZhciB0b2tlbjtcblxuICBpZiAoc3RhdGUuaW5saW5lTW9kZSkge1xuICAgIHRva2VuICAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmM7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIDAsIDEgXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5tZC5ibG9jay5wYXJzZShzdGF0ZS5zcmMsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHN0YXRlLnRva2Vucyk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XG5cbiAgLy8gUGFyc2UgaW5saW5lc1xuICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRvayA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UodG9rLmNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRvay5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanMiLCIvLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXG4vL1xuLy8gQ3VycmVudGx5IHJlc3RyaWN0ZWQgYnkgYG1kLnZhbGlkYXRlTGluaygpYCB0byBodHRwL2h0dHBzL2Z0cFxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXJyYXlSZXBsYWNlQXQgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5hcnJheVJlcGxhY2VBdDtcblxuXG5mdW5jdGlvbiBpc0xpbmtPcGVuKHN0cikge1xuICByZXR1cm4gL148YVs+XFxzXS9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzTGlua0Nsb3NlKHN0cikge1xuICByZXR1cm4gL148XFwvYVxccyo+L2kudGVzdChzdHIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua2lmeShzdGF0ZSkge1xuICB2YXIgaSwgaiwgbCwgdG9rZW5zLCB0b2tlbiwgY3VycmVudFRva2VuLCBub2RlcywgbG4sIHRleHQsIHBvcywgbGFzdFBvcyxcbiAgICAgIGxldmVsLCBodG1sTGlua0xldmVsLCB1cmwsIGZ1bGxVcmwsIHVybFRleHQsXG4gICAgICBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIGxpbmtzO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybjsgfVxuXG4gIGZvciAoaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIXN0YXRlLm1kLmxpbmtpZnkucHJldGVzdChibG9ja1Rva2Vuc1tqXS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdG9rZW5zID0gYmxvY2tUb2tlbnNbal0uY2hpbGRyZW47XG5cbiAgICBodG1sTGlua0xldmVsID0gMDtcblxuICAgIC8vIFdlIHNjYW4gZnJvbSB0aGUgZW5kLCB0byBrZWVwIHBvc2l0aW9uIHdoZW4gbmV3IHRhZ3MgYWRkZWQuXG4gICAgLy8gVXNlIHJldmVyc2VkIGxvZ2ljIGluIGxpbmtzIHN0YXJ0L2VuZCBtYXRjaFxuICAgIGZvciAoaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgbWFya2Rvd24gbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgd2hpbGUgKHRva2Vuc1tpXS5sZXZlbCAhPT0gY3VycmVudFRva2VuLmxldmVsICYmIHRva2Vuc1tpXS50eXBlICE9PSAnbGlua19vcGVuJykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIGh0bWwgdGFnIGxpbmtzXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdodG1sX2lubGluZScpIHtcbiAgICAgICAgaWYgKGlzTGlua09wZW4oY3VycmVudFRva2VuLmNvbnRlbnQpICYmIGh0bWxMaW5rTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbmtDbG9zZShjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBzdGF0ZS5tZC5saW5raWZ5LnRlc3QoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG5cbiAgICAgICAgdGV4dCA9IGN1cnJlbnRUb2tlbi5jb250ZW50O1xuICAgICAgICBsaW5rcyA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2godGV4dCk7XG5cbiAgICAgICAgLy8gTm93IHNwbGl0IHN0cmluZyB0byBub2Rlc1xuICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICBsZXZlbCA9IGN1cnJlbnRUb2tlbi5sZXZlbDtcbiAgICAgICAgbGFzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsbiA9IDA7IGxuIDwgbGlua3MubGVuZ3RoOyBsbisrKSB7XG5cbiAgICAgICAgICB1cmwgPSBsaW5rc1tsbl0udXJsO1xuICAgICAgICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIHVybFRleHQgPSBsaW5rc1tsbl0udGV4dDtcblxuICAgICAgICAgIC8vIExpbmtpZmllciBtaWdodCBzZW5kIHJhdyBob3N0bmFtZXMgbGlrZSBcImV4YW1wbGUuY29tXCIsIHdoZXJlIHVybFxuICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoIGRvbWFpbiBuYW1lLiBTbyB3ZSBwcmVwZW5kIGh0dHA6Ly8gaW4gdGhvc2UgY2FzZXMsXG4gICAgICAgICAgLy8gYW5kIHJlbW92ZSBpdCBhZnRlcndhcmRzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKCFsaW5rc1tsbl0uc2NoZW1hKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ2h0dHA6Ly8nICsgdXJsVGV4dCkucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgJycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlua3NbbG5dLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KHVybFRleHQpKSB7XG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ21haWx0bzonICsgdXJsVGV4dCkucmVwbGFjZSgvXm1haWx0bzovLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmxUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3MgPSBsaW5rc1tsbl0uaW5kZXg7XG5cbiAgICAgICAgICBpZiAocG9zID4gbGFzdFBvcykge1xuICAgICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MsIHBvcyk7XG4gICAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgICAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWwrKztcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB1cmxUZXh0O1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gLS1sZXZlbDtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xuICAgICAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICBsYXN0UG9zID0gbGlua3NbbG5dLmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvcyA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIGN1cnJlbnQgbm9kZVxuICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IGFycmF5UmVwbGFjZUF0KHRva2VucywgaSwgbm9kZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIi8vIE5vcm1hbGl6ZSBpbnB1dCBzdHJpbmdcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBORVdMSU5FU19SRSAgPSAvXFxyW1xcblxcdTAwODVdP3xbXFx1MjQyNFxcdTIwMjhcXHUwMDg1XS9nO1xudmFyIE5VTExfUkUgICAgICA9IC9cXHUwMDAwL2c7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHN0cjtcblxuICAvLyBOb3JtYWxpemUgbmV3bGluZXNcbiAgc3RyID0gc3RhdGUuc3JjLnJlcGxhY2UoTkVXTElORVNfUkUsICdcXG4nKTtcblxuICAvLyBSZXBsYWNlIE5VTEwgY2hhcmFjdGVyc1xuICBzdHIgPSBzdHIucmVwbGFjZShOVUxMX1JFLCAnXFx1RkZGRCcpO1xuXG4gIHN0YXRlLnNyYyA9IHN0cjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL25vcm1hbGl6ZS5qcyIsIi8vIFNpbXBsZSB0eXBvZ3JhcGh5YyByZXBsYWNlbWVudHNcbi8vXG4vLyAoYykgKEMpIOKGkiDCqVxuLy8gKHRtKSAoVE0pIOKGkiDihKJcbi8vIChyKSAoUikg4oaSIMKuXG4vLyArLSDihpIgwrFcbi8vIChwKSAoUCkgLT4gwqdcbi8vIC4uLiDihpIg4oCmIChhbHNvID8uLi4uIOKGkiA/Li4sICEuLi4uIOKGkiAhLi4pXG4vLyA/Pz8/Pz8/PyDihpIgPz8/LCAhISEhISDihpIgISEhLCBgLCxgIOKGkiBgLGBcbi8vIC0tIOKGkiAmbmRhc2g7LCAtLS0g4oaSICZtZGFzaDtcbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86XG4vLyAtIGZyYWN0aW9uYWxzIDEvMiwgMS80LCAzLzQgLT4gwr0sIMK8LCDCvlxuLy8gLSBtaWx0aXBsaWNhdGlvbiAyIHggNCAtPiAyIMOXIDRcblxudmFyIFJBUkVfUkUgPSAvXFwrLXxcXC5cXC58XFw/XFw/XFw/XFw/fCEhISF8LCx8LS0vO1xuXG4vLyBXb3JrYXJvdW5kIGZvciBwaGFudG9tanMgLSBuZWVkIHJlZ2V4IHdpdGhvdXQgL2cgZmxhZyxcbi8vIG9yIHJvb3QgY2hlY2sgd2lsbCBmYWlsIGV2ZXJ5IHNlY29uZCB0aW1lXG52YXIgU0NPUEVEX0FCQlJfVEVTVF9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2k7XG5cbnZhciBTQ09QRURfQUJCUl9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2lnO1xudmFyIFNDT1BFRF9BQkJSID0ge1xuICBjOiAnwqknLFxuICByOiAnwq4nLFxuICBwOiAnwqcnLFxuICB0bTogJ+KEoidcbn07XG5cbmZ1bmN0aW9uIHJlcGxhY2VGbihtYXRjaCwgbmFtZSkge1xuICByZXR1cm4gU0NPUEVEX0FCQlJbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9zY29wZWQoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQucmVwbGFjZShTQ09QRURfQUJCUl9SRSwgcmVwbGFjZUZuKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfb3BlbicgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKys7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VfcmFyZShpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICBpZiAoUkFSRV9SRS50ZXN0KHRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCstL2csICfCsScpXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCA/Li4uLi4gJiAhLi4uLi4gLT4gPy4uICYgIS4uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC57Mix9L2csICfigKYnKS5yZXBsYWNlKC8oWz8hXSnigKYvZywgJyQxLi4nKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxuICAgICAgICAgICAgICAgICAgICAvLyBlbS1kYXNoXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1dKS0tLShbXi1dfCQpL21nLCAnJDFcXHUyMDE0JDInKVxuICAgICAgICAgICAgICAgICAgICAvLyBlbi1kYXNoXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxcXHMpLS0oXFxzfCQpL21nLCAnJDFcXHUyMDEzJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXFxzXSktLShbXi1cXHNdfCQpL21nLCAnJDFcXHUyMDEzJDInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfb3BlbicgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKys7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoU0NPUEVEX0FCQlJfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3Njb3BlZChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgaWYgKFJBUkVfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9yYXJlKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzIiwiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xuXG52YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG52YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbnZhciBBUE9TVFJPUEhFID0gJ1xcdTIwMTknOyAvKiDigJkgKi9cblxuXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfaW5saW5lcyh0b2tlbnMsIHN0YXRlKSB7XG4gIHZhciBpLCB0b2tlbiwgdGV4dCwgdCwgcG9zLCBtYXgsIHRoaXNMZXZlbCwgaXRlbSwgbGFzdENoYXIsIG5leHRDaGFyLFxuICAgICAgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsXG4gICAgICBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIHN0YWNrLCBvcGVuUXVvdGUsIGNsb3NlUXVvdGU7XG5cbiAgc3RhY2sgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICB0aGlzTGV2ZWwgPSB0b2tlbnNbaV0ubGV2ZWw7XG5cbiAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgIHBvcyA9IDA7XG4gICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgIE9VVEVSOlxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIHQgPSBRVU9URV9SRS5leGVjKHRleHQpO1xuICAgICAgaWYgKCF0KSB7IGJyZWFrOyB9XG5cbiAgICAgIGNhbk9wZW4gPSBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBwb3MgPSB0LmluZGV4ICsgMTtcbiAgICAgIGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKTtcblxuICAgICAgLy8gRmluZCBwcmV2aW91cyBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIGxhc3RDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHQuaW5kZXggLSAxID49IDApIHtcbiAgICAgICAgbGFzdENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQodC5pbmRleCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSAnc29mdGJyZWFrJyB8fCB0b2tlbnNbal0udHlwZSA9PT0gJ2hhcmRicmVhaycpIGJyZWFrOyAvLyBsYXN0Q2hhciBkZWZhdWx0cyB0byAweDIwXG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgbGFzdENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KHRva2Vuc1tqXS5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBjaGFyYWN0ZXIsXG4gICAgICAvLyBkZWZhdWx0IHRvIHNwYWNlIGlmIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgLy9cbiAgICAgIG5leHRDaGFyID0gMHgyMDtcblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBuZXh0Q2hhciA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgPT09ICdzb2Z0YnJlYWsnIHx8IHRva2Vuc1tqXS50eXBlID09PSAnaGFyZGJyZWFrJykgYnJlYWs7IC8vIG5leHRDaGFyIGRlZmF1bHRzIHRvIDB4MjBcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgIT09ICd0ZXh0JykgY29udGludWU7XG5cbiAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdHJlYXQgdGhpcyBhcyB0aGUgbWlkZGxlIG9mIHRoZSB3b3JkXG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgY2FuQ2xvc2UgPSBpc05leHRQdW5jdENoYXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuT3BlbiAmJiAhY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gbWlkZGxlIG9mIHdvcmRcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjbG9zaW5nIHF1b3RlLCByZXdpbmQgdGhlIHN0YWNrIHRvIGdldCBhIG1hdGNoXG4gICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgICAgICAgIGlmIChpdGVtLnNpbmdsZSA9PT0gaXNTaW5nbGUgJiYgc3RhY2tbal0ubGV2ZWwgPT09IHRoaXNMZXZlbCkge1xuICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMl07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1szXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdG9rZW4uY29udGVudCAqYmVmb3JlKiB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UsIGlmIHRoZXkgYXJlIHBvaW50aW5nIGF0IHRoZSBzYW1lIHRva2VuLCByZXBsYWNlQXRcbiAgICAgICAgICAgIC8vIGNvdWxkIG1lc3MgdXAgaW5kaWNlcyB3aGVuIHF1b3RlIGxlbmd0aCAhPSAxXG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIGNsb3NlUXVvdGUpO1xuICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQoXG4gICAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LCBpdGVtLnBvcywgb3BlblF1b3RlKTtcblxuICAgICAgICAgICAgcG9zICs9IGNsb3NlUXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChpdGVtLnRva2VuID09PSBpKSB7IHBvcyArPSBvcGVuUXVvdGUubGVuZ3RoIC0gMTsgfVxuXG4gICAgICAgICAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICAgICAgICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBqO1xuICAgICAgICAgICAgY29udGludWUgT1VURVI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuKSB7XG4gICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgIHRva2VuOiBpLFxuICAgICAgICAgIHBvczogdC5pbmRleCxcbiAgICAgICAgICBzaW5nbGU6IGlzU2luZ2xlLFxuICAgICAgICAgIGxldmVsOiB0aGlzTGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbkNsb3NlICYmIGlzU2luZ2xlKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzbWFydHF1b3RlcyhzdGF0ZSkge1xuICAvKmVzbGludCBtYXgtZGVwdGg6MCovXG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnIHx8XG4gICAgICAgICFRVU9URV9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb2Nlc3NfaW5saW5lcyhzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbiwgc3RhdGUpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIi8vIENvcmUgc3RhdGUgb2JqZWN0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZTtcbiAgdGhpcy5tZCA9IG1kOyAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxufVxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGNvcmUgcnVsZXNcblN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKEFVVE9MSU5LX1JFLnRlc3QodGFpbCkpIHtcbiAgICBsaW5rTWF0Y2ggPSB0YWlsLm1hdGNoKEFVVE9MSU5LX1JFKTtcblxuICAgIHVybCA9IGxpbmtNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFTUFJTF9SRS50ZXN0KHRhaWwpKSB7XG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hcmtlcjtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjsgfVxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIi8vIEZvciBlYWNoIG9wZW5pbmcgZW1waGFzaXMtbGlrZSBtYXJrZXIgZmluZCBhIG1hdGNoaW5nIGNsb3Npbmcgb25lXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICB2YXIgaSwgaiwgbGFzdERlbGltLCBjdXJyRGVsaW0sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGxhc3REZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoIWxhc3REZWxpbS5jbG9zZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaiA9IGkgLSBsYXN0RGVsaW0uanVtcCAtIDE7XG5cbiAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICBjdXJyRGVsaW0gPSBkZWxpbWl0ZXJzW2pdO1xuXG4gICAgICBpZiAoY3VyckRlbGltLm9wZW4gJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubWFya2VyID09PSBsYXN0RGVsaW0ubWFya2VyICYmXG4gICAgICAgICAgY3VyckRlbGltLmVuZCA8IDAgJiZcbiAgICAgICAgICBjdXJyRGVsaW0ubGV2ZWwgPT09IGxhc3REZWxpbS5sZXZlbCkge1xuXG4gICAgICAgIC8vIHR5cGVvZnMgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggcGx1Z2luc1xuICAgICAgICB2YXIgb2RkX21hdGNoID0gKGN1cnJEZWxpbS5jbG9zZSB8fCBsYXN0RGVsaW0ub3BlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyRGVsaW0ubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3REZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VyckRlbGltLmxlbmd0aCArIGxhc3REZWxpbS5sZW5ndGgpICUgMyA9PT0gMDtcblxuICAgICAgICBpZiAoIW9kZF9tYXRjaCkge1xuICAgICAgICAgIGxhc3REZWxpbS5qdW1wID0gaSAtIGo7XG4gICAgICAgICAgbGFzdERlbGltLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kICA9IGk7XG4gICAgICAgICAgY3VyckRlbGltLmp1bXAgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGogLT0gY3VyckRlbGltLmp1bXAgKyAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdGllcyAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lbnRpdGllcycpO1xudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIGlzVmFsaWRFbnRpdHlDb2RlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNWYWxpZEVudGl0eUNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5mcm9tQ29kZVBvaW50O1xuXG5cbnZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSk7L2k7XG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgY29kZSwgbWF0Y2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMSA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMgLyogIyAqLykge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpID8gZnJvbUNvZGVQb2ludChjb2RlKSA6IGZyb21Db2RlUG9pbnQoMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07IH1cbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanMiLCIvLyBQcm9jZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cbnZhciBFU0NBUEVEID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApOyB9XG5cbidcXFxcIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LSdcbiAgLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA8IDI1NiAmJiBFU0NBUEVEW2NoXSAhPT0gMCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbcG9zXTsgfVxuICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvcyA9IHBvcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzIiwiLy8gUHJvY2VzcyBodG1sIHRhZ3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBIVE1MX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9UQUdfUkU7XG5cblxuZnVuY3Rpb24gaXNMZXR0ZXIoY2gpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgdmFyIGxjID0gY2ggfCAweDIwOyAvLyB0byBsb3dlciBjYXNlXG4gIHJldHVybiAobGMgPj0gMHg2MS8qIGEgKi8pICYmIChsYyA8PSAweDdhLyogeiAqLyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2lubGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbWF0Y2gsIG1heCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gQ2hlY2sgc3RhcnRcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8gfHxcbiAgICAgIHBvcyArIDIgPj0gbWF4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUXVpY2sgZmFpbCBvbiBzZWNvbmQgY2hhclxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICBpZiAoY2ggIT09IDB4MjEvKiAhICovICYmXG4gICAgICBjaCAhPT0gMHgzRi8qID8gKi8gJiZcbiAgICAgIGNoICE9PSAweDJGLyogLyAqLyAmJlxuICAgICAgIWlzTGV0dGVyKGNoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goSFRNTF9UQUdfUkUpO1xuICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBtYXRjaFswXS5sZW5ndGgpO1xuICB9XG4gIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5qcyIsIi8vIFByb2Nlc3MgIVtpbWFnZV0oPHNyYz4gXCJ0aXRsZVwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbWFnZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBhdHRycyxcbiAgICAgIGNvZGUsXG4gICAgICBjb250ZW50LFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZWYsXG4gICAgICByZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIHRva2VuLFxuICAgICAgdG9rZW5zLFxuICAgICAgc3RhcnQsXG4gICAgICBocmVmID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDB4MjEvKiAhICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMSkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAyO1xuICBsYWJlbEVuZCA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcyArIDEsIGZhbHNlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgICBwb3MgPSByZXMucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfSBlbHNlIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkgeyBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7IH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTtcblxuICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZShcbiAgICAgIGNvbnRlbnQsXG4gICAgICBzdGF0ZS5tZCxcbiAgICAgIHN0YXRlLmVudixcbiAgICAgIHRva2VucyA9IFtdXG4gICAgKTtcblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW1hZ2UnLCAnaW1nJywgMCk7XG4gICAgdG9rZW4uYXR0cnMgICAgPSBhdHRycyA9IFsgWyAnc3JjJywgaHJlZiBdLCBbICdhbHQnLCAnJyBdIF07XG4gICAgdG9rZW4uY2hpbGRyZW4gPSB0b2tlbnM7XG4gICAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIi8vIFByb2Nlc3MgW2xpbmtdKDx0bz4gXCJzdHVmZlwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVzLFxuICAgICAgcmVmLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMTtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gbWlnaHQgaGF2ZSBmb3VuZCBhIHZhbGlkIHNob3J0Y3V0IGxpbmssIGRpc2FibGUgcmVmZXJlbmNlIHBhcnNpbmdcbiAgICBwYXJzZVJlZmVyZW5jZSA9IGZhbHNlO1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICAvLyBwYXJzaW5nIGEgdmFsaWQgc2hvcnRjdXQgbGluayBmYWlsZWQsIGZhbGxiYWNrIHRvIHJlZmVyZW5jZVxuICAgICAgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgc3RhdGUucG9zTWF4ID0gbGFiZWxFbmQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xuICAgIHRva2VuLmF0dHJzICA9IGF0dHJzID0gWyBbICdocmVmJywgaHJlZiBdIF07XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XG4gICAgfVxuXG4gICAgc3RhdGUubWQuaW5saW5lLnRva2VuaXplKHN0YXRlKTtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIi8vIFByb2NlZXNzICdcXG4nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwbWF4LCBtYXgsIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQS8qIFxcbiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgLy8gJyAgXFxuJyAtPiBoYXJkYnJlYWtcbiAgLy8gTG9va3VwIGluIHBlbmRpbmcgY2hhcnMgaXMgYmFkIHByYWN0aWNlISBEb24ndCBjb3B5IHRvIG90aGVyIHJ1bGVzIVxuICAvLyBQZW5kaW5nIHN0cmluZyBpcyBzdG9yZWQgaW4gY29uY2F0IG1vZGUsIGluZGV4ZWQgbG9va3VwcyB3aWxsIGNhdXNlXG4gIC8vIGNvbnZlcnRpb24gdG8gZmxhdCBtb2RlLlxuICBpZiAoIXNpbGVudCkge1xuICAgIGlmIChwbWF4ID49IDAgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXgpID09PSAweDIwKSB7XG4gICAgICBpZiAocG1heCA+PSAxICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4IC0gMSkgPT09IDB4MjApIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcucmVwbGFjZSgvICskLywgJycpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgc3RhdGUucHVzaCgnc29mdGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaCgnc29mdGJyZWFrJywgJ2JyJywgMCk7XG4gICAgfVxuICB9XG5cbiAgcG9zKys7XG5cbiAgLy8gc2tpcCBoZWFkaW5nIHNwYWNlcyBmb3IgbmV4dCBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkgeyBwb3MrKzsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanMiLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG5cbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG5cbiAgdGhpcy5jYWNoZSA9IHt9OyAgICAgICAgLy8gU3RvcmVzIHsgc3RhcnQ6IGVuZCB9IHBhaXJzLiBVc2VmdWwgZm9yIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cblxuICB0aGlzLmRlbGltaXRlcnMgPSBbXTsgICAvLyBFbXBoYXNpcy1saWtlIGRlbGltaXRlcnNcbn1cblxuXG4vLyBGbHVzaCBwZW5kaW5nIHRleHRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbigndGV4dCcsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHRoaXMucGVuZGluZztcbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vLyBJZiBwZW5kaW5nIHRleHQgZXhpc3RzIC0gZmx1c2ggaXQgYXMgdGV4dCB0b2tlblxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xuICB9XG5cbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5qcyIsIi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgaW50byBvbmUsIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRfY29sbGFwc2Uoc3RhdGUpIHtcbiAgdmFyIGN1cnIsIGxhc3QsXG4gICAgICBsZXZlbCA9IDAsXG4gICAgICB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsXG4gICAgICBtYXggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGZvciAoY3VyciA9IGxhc3QgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICAvLyByZS1jYWxjdWxhdGUgbGV2ZWxzXG4gICAgbGV2ZWwgKz0gdG9rZW5zW2N1cnJdLm5lc3Rpbmc7XG4gICAgdG9rZW5zW2N1cnJdLmxldmVsID0gbGV2ZWw7XG5cbiAgICBpZiAodG9rZW5zW2N1cnJdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBjdXJyICsgMSA8IG1heCAmJlxuICAgICAgICB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuXG4gICAgICAvLyBjb2xsYXBzZSB0d28gYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyICE9PSBsYXN0KSB7IHRva2Vuc1tsYXN0XSA9IHRva2Vuc1tjdXJyXTsgfVxuXG4gICAgICBsYXN0Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICB0b2tlbnMubGVuZ3RoID0gbGFzdDtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzIiwiXG4ndXNlIHN0cmljdCc7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG52YXIgZGVjb2RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGNhY2hlLnB1c2goY2gpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcbiAgICBjYWNoZVtjaF0gPSAnJScgKyAoJzAnICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBEZWNvZGUgcGVyY2VudC1lbmNvZGVkIHN0cmluZy5cbi8vXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBleGNsdWRlKSB7XG4gIHZhciBjYWNoZTtcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXhjbHVkZSA9IGRlY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICB2YXIgaSwgbCwgYjEsIGIyLCBiMywgYjQsIGNocixcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuXG4gICAgICBpZiAoYjEgPCAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgNikgJiAweDdDMCkgfCAoYjIgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTIpICYgMHhGMDAwKSB8ICgoYjIgPDwgNikgJiAweEZDMCkgfCAoYjMgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGOCkgPT09IDB4RjAgJiYgKGkgKyA5IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjQgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDEwMDAwIHx8IGNociA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuXG5kZWNvZGUuZGVmYXVsdENoYXJzICAgPSAnOy8/OkAmPSskLCMnO1xuZGVjb2RlLmNvbXBvbmVudENoYXJzID0gJyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21kdXJsL2RlY29kZS5qcyIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xuXG5cbi8vIENyZWF0ZSBhIGxvb2t1cCBhcnJheSB3aGVyZSBhbnl0aGluZyBidXQgY2hhcmFjdGVycyBpbiBgY2hhcnNgIHN0cmluZ1xuLy8gYW5kIGFscGhhbnVtZXJpYyBjaGFycyBpcyBwZXJjZW50LWVuY29kZWQuXG4vL1xuZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuXG4gICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcbiAgICAgIC8vIGFsd2F5cyBhbGxvdyB1bmVuY29kZWQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgIGNhY2hlLnB1c2goY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKCclJyArICgnMCcgKyBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRW5jb2RlIHVuc2FmZSBjaGFyYWN0ZXJzIHdpdGggcGVyY2VudC1lbmNvZGluZywgc2tpcHBpbmcgYWxyZWFkeVxuLy8gZW5jb2RlZCBzZXF1ZW5jZXMuXG4vL1xuLy8gIC0gc3RyaW5nICAgICAgIC0gc3RyaW5nIHRvIGVuY29kZVxuLy8gIC0gZXhjbHVkZSAgICAgIC0gbGlzdCBvZiBjaGFyYWN0ZXJzIHRvIGlnbm9yZSAoaW4gYWRkaXRpb24gdG8gYS16QS1aMC05KVxuLy8gIC0ga2VlcEVzY2FwZWQgIC0gZG9uJ3QgZW5jb2RlICclJyBpbiBhIGNvcnJlY3QgZXNjYXBlIHNlcXVlbmNlIChkZWZhdWx0OiB0cnVlKVxuLy9cbmZ1bmN0aW9uIGVuY29kZShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsXG4gICAgICByZXN1bHQgPSAnJztcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAga2VlcEVzY2FwZWQgID0gZXhjbHVkZTtcbiAgICBleGNsdWRlID0gZW5jb2RlLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2VlcEVzY2FwZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICB9XG5cbiAgY2FjaGUgPSBnZXRFbmNvZGVDYWNoZShleGNsdWRlKTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlID09PSAweDI1IC8qICUgKi8gJiYgaSArIDIgPCBsKSB7XG4gICAgICBpZiAoL15bMC05YS1mXXsyfSQvaS50ZXN0KHN0cmluZy5zbGljZShpICsgMSwgaSArIDMpKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5nLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA8IDEyOCkge1xuICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhERkZGKSB7XG4gICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERCRkYgJiYgaSArIDEgPCBsKSB7XG4gICAgICAgIG5leHRDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldICsgc3RyaW5nW2kgKyAxXSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJyVFRiVCRiVCRCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5lbmNvZGUuZGVmYXVsdENoYXJzICAgPSBcIjsvPzpAJj0rJCwtXy4hfionKCkjXCI7XG5lbmNvZGUuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9tZHVybC9lbmNvZGUuanMiLCJcbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdCh1cmwpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHJlc3VsdCArPSB1cmwucHJvdG9jb2wgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2xhc2hlcyA/ICcvLycgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyAnQCcgOiAnJztcblxuICBpZiAodXJsLmhvc3RuYW1lICYmIHVybC5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgLy8gaXB2NiBhZGRyZXNzXG4gICAgcmVzdWx0ICs9ICdbJyArIHVybC5ob3N0bmFtZSArICddJztcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5wYXRobmFtZSB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zZWFyY2ggfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuaGFzaCB8fCAnJztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbWR1cmwvZm9ybWF0LmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIENoYW5nZXMgZnJvbSBqb3llbnQvbm9kZTpcbi8vXG4vLyAxLiBObyBsZWFkaW5nIHNsYXNoIGluIHBhdGhzLFxuLy8gICAgZS5nLiBpbiBgdXJsLnBhcnNlKCdodHRwOi8vZm9vP2JhcicpYCBwYXRobmFtZSBpcyBgYCwgbm90IGAvYFxuLy9cbi8vIDIuIEJhY2tzbGFzaGVzIGFyZSBub3QgcmVwbGFjZWQgd2l0aCBzbGFzaGVzLFxuLy8gICAgc28gYGh0dHA6XFxcXGV4YW1wbGUub3JnXFxgIGlzIHRyZWF0ZWQgbGlrZSBhIHJlbGF0aXZlIHBhdGhcbi8vXG4vLyAzLiBUcmFpbGluZyBjb2xvbiBpcyB0cmVhdGVkIGxpa2UgYSBwYXJ0IG9mIHRoZSBwYXRoLFxuLy8gICAgaS5lLiBpbiBgaHR0cDovL2V4YW1wbGUub3JnOmZvb2AgcGF0aG5hbWUgaXMgYDpmb29gXG4vL1xuLy8gNC4gTm90aGluZyBpcyBVUkwtZW5jb2RlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCxcbi8vICAgIChpbiBqb3llbnQvbm9kZSBzb21lIGNoYXJzIGluIGF1dGggYW5kIHBhdGhzIGFyZSBlbmNvZGVkKVxuLy9cbi8vIDUuIGB1cmwucGFyc2UoKWAgZG9lcyBub3QgaGF2ZSBgcGFyc2VRdWVyeVN0cmluZ2AgYXJndW1lbnRcbi8vXG4vLyA2LiBSZW1vdmVkIGV4dHJhbmVvdXMgcmVzdWx0IHByb3BlcnRpZXM6IGBob3N0YCwgYHBhdGhgLCBgcXVlcnlgLCBldGMuLFxuLy8gICAgd2hpY2ggY2FuIGJlIGNvbnN0cnVjdGVkIHVzaW5nIG90aGVyIHBhcnRzIG9mIHRoZSB1cmwuXG4vL1xuXG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbICc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0JyBdLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbICd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCcgXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWyAnXFwnJyBdLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyAnJScsICcvJywgJz8nLCAnOycsICcjJyBdLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbICcvJywgJz8nLCAnIycgXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNjcmlwdC11cmwgKi9cbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1zY3JpcHQtdXJsICovXG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIHZhciB1ID0gbmV3IFVybCgpO1xuICB1LnBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgdmFyIGksIGwsIGxvd2VyUHJvdG8sIGhlYywgc2xhc2hlcyxcbiAgICAgIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHJlc3RbaG9zdEVuZCAtIDFdID09PSAnOicpIHsgaG9zdEVuZC0tOyB9XG4gICAgdmFyIGhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdChob3N0KTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfVxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKGhvc3QpIHtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXJsUGFyc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21kdXJsL3BhcnNlLmpzIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCJtb2R1bGUuZXhwb3J0cz0vW1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MDhFMlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0XFx1RENCRHxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl0vXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFueSA9IHJlcXVpcmUoJy4vcHJvcGVydGllcy9BbnkvcmVnZXgnKTtcbmV4cG9ydHMuQ2MgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NjL3JlZ2V4Jyk7XG5leHBvcnRzLkNmICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DZi9yZWdleCcpO1xuZXhwb3J0cy5QICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuZXhwb3J0cy5aICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvWi9yZWdleCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91Yy5taWNyby9pbmRleC5qcyIsImltcG9ydCBNYXJrZG93bkl0IGZyb20gJ21hcmtkb3duLWl0JztcbmltcG9ydCBNYXJrZG93bkl0RGVjb3JhdGUgZnJvbSAnbWFya2Rvd24taXQtZGVjb3JhdGUnO1xuaW1wb3J0IGhpZ2hsaWdodCBmcm9tICdoaWdobGlnaHQuanMvbGliL2hpZ2hsaWdodCc7XG5pbXBvcnQgbEphdmFzY3JpcHQgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvamF2YXNjcmlwdCc7XG5pbXBvcnQgbENzcyBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9jc3MnO1xuaW1wb3J0IGxYbWwgZnJvbSAnaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMveG1sJztcbmltcG9ydCBsQmFzaCBmcm9tICdoaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9iYXNoJztcblxuaGlnaGxpZ2h0LnJlZ2lzdGVyTGFuZ3VhZ2UoJ2Jhc2gnLCBsQmFzaCk7XG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgnY3NzJywgbENzcyk7XG5oaWdobGlnaHQucmVnaXN0ZXJMYW5ndWFnZSgnamF2YXNjcmlwdCcsIGxKYXZhc2NyaXB0KTtcbmhpZ2hsaWdodC5yZWdpc3Rlckxhbmd1YWdlKCd4bWwnLCBsWG1sKTtcblxud2luZG93LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuY29uc3QgbWFya2VkID0gTWFya2Rvd25JdCh7XG4gICAgaHRtbDogdHJ1ZSxcbiAgICBicmVha3M6IGZhbHNlIFxufSkudXNlKE1hcmtkb3duSXREZWNvcmF0ZSk7XG4vLyDljrvmjonmrrXokL1zb2Z0YnJlYWtcbm1hcmtlZC5yZW5kZXJlci5ydWxlcy5zb2Z0YnJlYWsgPSAoKSA9PiAnJztcblxuZXhwb3J0IHtoaWdobGlnaHQsIG1hcmtlZH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaXRlL2xpYi91dGlscy5qcyIsImltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL2xheW91dC52ZHQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIEludGFjdCB7XG4gICAgQEludGFjdC50ZW1wbGF0ZSgpXG4gICAgc3RhdGljIHRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICBfbW91bnQoKSB7XG4gICAgICAgIHRoaXMuJGJvcmRlciA9ICQodGhpcy5lbGVtZW50KS5maW5kKCcuYm9yZGVyJyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvcmRlcigpO1xuICAgIH1cblxuICAgIF91cGRhdGVCb3JkZXIoKSB7XG4gICAgICAgIGNvbnN0ICRuYXYgPSAkKHRoaXMuZWxlbWVudCkuZmluZCgnLmFjdGl2ZScpO1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIGlmICgkbmF2Lmxlbmd0aCkge1xuICAgICAgICAgICAgbGVmdCA9ICRuYXYucG9zaXRpb24oKS5sZWZ0O1xuICAgICAgICAgICAgd2lkdGggPSAkbmF2Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRib3JkZXIuYWRkQ2xhc3MoJ3RyYW5zaXRpb24nKTtcbiAgICAgICAgdGhpcy4kYm9yZGVyLmNzcyh7d2lkdGg6IHdpZHRoLCBsZWZ0OiBsZWZ0fSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS9wYWdlcy9sYXlvdXQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIkFhY3V0ZVwiOlwiw4FcIixcImFhY3V0ZVwiOlwiw6FcIixcIkFicmV2ZVwiOlwixIJcIixcImFicmV2ZVwiOlwixINcIixcImFjXCI6XCLiiL5cIixcImFjZFwiOlwi4oi/XCIsXCJhY0VcIjpcIuKIvsyzXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBY3lcIjpcItCQXCIsXCJhY3lcIjpcItCwXCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiYWZcIjpcIuKBoVwiLFwiQWZyXCI6XCLwnZSEXCIsXCJhZnJcIjpcIvCdlJ5cIixcIkFncmF2ZVwiOlwiw4BcIixcImFncmF2ZVwiOlwiw6BcIixcImFsZWZzeW1cIjpcIuKEtVwiLFwiYWxlcGhcIjpcIuKEtVwiLFwiQWxwaGFcIjpcIs6RXCIsXCJhbHBoYVwiOlwizrFcIixcIkFtYWNyXCI6XCLEgFwiLFwiYW1hY3JcIjpcIsSBXCIsXCJhbWFsZ1wiOlwi4qi/XCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCLiqZVcIixcIkFuZFwiOlwi4qmTXCIsXCJhbmRcIjpcIuKIp1wiLFwiYW5kZFwiOlwi4qmcXCIsXCJhbmRzbG9wZVwiOlwi4qmYXCIsXCJhbmR2XCI6XCLiqZpcIixcImFuZ1wiOlwi4oigXCIsXCJhbmdlXCI6XCLipqRcIixcImFuZ2xlXCI6XCLiiKBcIixcImFuZ21zZGFhXCI6XCLipqhcIixcImFuZ21zZGFiXCI6XCLipqlcIixcImFuZ21zZGFjXCI6XCLipqpcIixcImFuZ21zZGFkXCI6XCLipqtcIixcImFuZ21zZGFlXCI6XCLipqxcIixcImFuZ21zZGFmXCI6XCLipq1cIixcImFuZ21zZGFnXCI6XCLipq5cIixcImFuZ21zZGFoXCI6XCLipq9cIixcImFuZ21zZFwiOlwi4oihXCIsXCJhbmdydFwiOlwi4oifXCIsXCJhbmdydHZiXCI6XCLiir5cIixcImFuZ3J0dmJkXCI6XCLipp1cIixcImFuZ3NwaFwiOlwi4oiiXCIsXCJhbmdzdFwiOlwiw4VcIixcImFuZ3phcnJcIjpcIuKNvFwiLFwiQW9nb25cIjpcIsSEXCIsXCJhb2dvblwiOlwixIVcIixcIkFvcGZcIjpcIvCdlLhcIixcImFvcGZcIjpcIvCdlZJcIixcImFwYWNpclwiOlwi4qmvXCIsXCJhcFwiOlwi4omIXCIsXCJhcEVcIjpcIuKpsFwiLFwiYXBlXCI6XCLiiYpcIixcImFwaWRcIjpcIuKJi1wiLFwiYXBvc1wiOlwiJ1wiLFwiQXBwbHlGdW5jdGlvblwiOlwi4oGhXCIsXCJhcHByb3hcIjpcIuKJiFwiLFwiYXBwcm94ZXFcIjpcIuKJilwiLFwiQXJpbmdcIjpcIsOFXCIsXCJhcmluZ1wiOlwiw6VcIixcIkFzY3JcIjpcIvCdkpxcIixcImFzY3JcIjpcIvCdkrZcIixcIkFzc2lnblwiOlwi4omUXCIsXCJhc3RcIjpcIipcIixcImFzeW1wXCI6XCLiiYhcIixcImFzeW1wZXFcIjpcIuKJjVwiLFwiQXRpbGRlXCI6XCLDg1wiLFwiYXRpbGRlXCI6XCLDo1wiLFwiQXVtbFwiOlwiw4RcIixcImF1bWxcIjpcIsOkXCIsXCJhd2NvbmludFwiOlwi4oizXCIsXCJhd2ludFwiOlwi4qiRXCIsXCJiYWNrY29uZ1wiOlwi4omMXCIsXCJiYWNrZXBzaWxvblwiOlwiz7ZcIixcImJhY2twcmltZVwiOlwi4oC1XCIsXCJiYWNrc2ltXCI6XCLiiL1cIixcImJhY2tzaW1lcVwiOlwi4ouNXCIsXCJCYWNrc2xhc2hcIjpcIuKIllwiLFwiQmFydlwiOlwi4qunXCIsXCJiYXJ2ZWVcIjpcIuKKvVwiLFwiYmFyd2VkXCI6XCLijIVcIixcIkJhcndlZFwiOlwi4oyGXCIsXCJiYXJ3ZWRnZVwiOlwi4oyFXCIsXCJiYnJrXCI6XCLijrVcIixcImJicmt0YnJrXCI6XCLijrZcIixcImJjb25nXCI6XCLiiYxcIixcIkJjeVwiOlwi0JFcIixcImJjeVwiOlwi0LFcIixcImJkcXVvXCI6XCLigJ5cIixcImJlY2F1c1wiOlwi4oi1XCIsXCJiZWNhdXNlXCI6XCLiiLVcIixcIkJlY2F1c2VcIjpcIuKItVwiLFwiYmVtcHR5dlwiOlwi4qawXCIsXCJiZXBzaVwiOlwiz7ZcIixcImJlcm5vdVwiOlwi4oSsXCIsXCJCZXJub3VsbGlzXCI6XCLihKxcIixcIkJldGFcIjpcIs6SXCIsXCJiZXRhXCI6XCLOslwiLFwiYmV0aFwiOlwi4oS2XCIsXCJiZXR3ZWVuXCI6XCLiiaxcIixcIkJmclwiOlwi8J2UhVwiLFwiYmZyXCI6XCLwnZSfXCIsXCJiaWdjYXBcIjpcIuKLglwiLFwiYmlnY2lyY1wiOlwi4pevXCIsXCJiaWdjdXBcIjpcIuKLg1wiLFwiYmlnb2RvdFwiOlwi4qiAXCIsXCJiaWdvcGx1c1wiOlwi4qiBXCIsXCJiaWdvdGltZXNcIjpcIuKoglwiLFwiYmlnc3FjdXBcIjpcIuKohlwiLFwiYmlnc3RhclwiOlwi4piFXCIsXCJiaWd0cmlhbmdsZWRvd25cIjpcIuKWvVwiLFwiYmlndHJpYW5nbGV1cFwiOlwi4pazXCIsXCJiaWd1cGx1c1wiOlwi4qiEXCIsXCJiaWd2ZWVcIjpcIuKLgVwiLFwiYmlnd2VkZ2VcIjpcIuKLgFwiLFwiYmthcm93XCI6XCLipI1cIixcImJsYWNrbG96ZW5nZVwiOlwi4qerXCIsXCJibGFja3NxdWFyZVwiOlwi4paqXCIsXCJibGFja3RyaWFuZ2xlXCI6XCLilrRcIixcImJsYWNrdHJpYW5nbGVkb3duXCI6XCLilr5cIixcImJsYWNrdHJpYW5nbGVsZWZ0XCI6XCLil4JcIixcImJsYWNrdHJpYW5nbGVyaWdodFwiOlwi4pa4XCIsXCJibGFua1wiOlwi4pCjXCIsXCJibGsxMlwiOlwi4paSXCIsXCJibGsxNFwiOlwi4paRXCIsXCJibGszNFwiOlwi4paTXCIsXCJibG9ja1wiOlwi4paIXCIsXCJibmVcIjpcIj3ig6VcIixcImJuZXF1aXZcIjpcIuKJoeKDpVwiLFwiYk5vdFwiOlwi4qutXCIsXCJibm90XCI6XCLijJBcIixcIkJvcGZcIjpcIvCdlLlcIixcImJvcGZcIjpcIvCdlZNcIixcImJvdFwiOlwi4oqlXCIsXCJib3R0b21cIjpcIuKKpVwiLFwiYm93dGllXCI6XCLii4hcIixcImJveGJveFwiOlwi4qeJXCIsXCJib3hkbFwiOlwi4pSQXCIsXCJib3hkTFwiOlwi4pWVXCIsXCJib3hEbFwiOlwi4pWWXCIsXCJib3hETFwiOlwi4pWXXCIsXCJib3hkclwiOlwi4pSMXCIsXCJib3hkUlwiOlwi4pWSXCIsXCJib3hEclwiOlwi4pWTXCIsXCJib3hEUlwiOlwi4pWUXCIsXCJib3hoXCI6XCLilIBcIixcImJveEhcIjpcIuKVkFwiLFwiYm94aGRcIjpcIuKUrFwiLFwiYm94SGRcIjpcIuKVpFwiLFwiYm94aERcIjpcIuKVpVwiLFwiYm94SERcIjpcIuKVplwiLFwiYm94aHVcIjpcIuKUtFwiLFwiYm94SHVcIjpcIuKVp1wiLFwiYm94aFVcIjpcIuKVqFwiLFwiYm94SFVcIjpcIuKVqVwiLFwiYm94bWludXNcIjpcIuKKn1wiLFwiYm94cGx1c1wiOlwi4oqeXCIsXCJib3h0aW1lc1wiOlwi4oqgXCIsXCJib3h1bFwiOlwi4pSYXCIsXCJib3h1TFwiOlwi4pWbXCIsXCJib3hVbFwiOlwi4pWcXCIsXCJib3hVTFwiOlwi4pWdXCIsXCJib3h1clwiOlwi4pSUXCIsXCJib3h1UlwiOlwi4pWYXCIsXCJib3hVclwiOlwi4pWZXCIsXCJib3hVUlwiOlwi4pWaXCIsXCJib3h2XCI6XCLilIJcIixcImJveFZcIjpcIuKVkVwiLFwiYm94dmhcIjpcIuKUvFwiLFwiYm94dkhcIjpcIuKVqlwiLFwiYm94VmhcIjpcIuKVq1wiLFwiYm94VkhcIjpcIuKVrFwiLFwiYm94dmxcIjpcIuKUpFwiLFwiYm94dkxcIjpcIuKVoVwiLFwiYm94VmxcIjpcIuKVolwiLFwiYm94VkxcIjpcIuKVo1wiLFwiYm94dnJcIjpcIuKUnFwiLFwiYm94dlJcIjpcIuKVnlwiLFwiYm94VnJcIjpcIuKVn1wiLFwiYm94VlJcIjpcIuKVoFwiLFwiYnByaW1lXCI6XCLigLVcIixcImJyZXZlXCI6XCLLmFwiLFwiQnJldmVcIjpcIsuYXCIsXCJicnZiYXJcIjpcIsKmXCIsXCJic2NyXCI6XCLwnZK3XCIsXCJCc2NyXCI6XCLihKxcIixcImJzZW1pXCI6XCLigY9cIixcImJzaW1cIjpcIuKIvVwiLFwiYnNpbWVcIjpcIuKLjVwiLFwiYnNvbGJcIjpcIuKnhVwiLFwiYnNvbFwiOlwiXFxcXFwiLFwiYnNvbGhzdWJcIjpcIuKfiFwiLFwiYnVsbFwiOlwi4oCiXCIsXCJidWxsZXRcIjpcIuKAolwiLFwiYnVtcFwiOlwi4omOXCIsXCJidW1wRVwiOlwi4qquXCIsXCJidW1wZVwiOlwi4omPXCIsXCJCdW1wZXFcIjpcIuKJjlwiLFwiYnVtcGVxXCI6XCLiiY9cIixcIkNhY3V0ZVwiOlwixIZcIixcImNhY3V0ZVwiOlwixIdcIixcImNhcGFuZFwiOlwi4qmEXCIsXCJjYXBicmN1cFwiOlwi4qmJXCIsXCJjYXBjYXBcIjpcIuKpi1wiLFwiY2FwXCI6XCLiiKlcIixcIkNhcFwiOlwi4ouSXCIsXCJjYXBjdXBcIjpcIuKph1wiLFwiY2FwZG90XCI6XCLiqYBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCLihYVcIixcImNhcHNcIjpcIuKIqe+4gFwiLFwiY2FyZXRcIjpcIuKBgVwiLFwiY2Fyb25cIjpcIsuHXCIsXCJDYXlsZXlzXCI6XCLihK1cIixcImNjYXBzXCI6XCLiqY1cIixcIkNjYXJvblwiOlwixIxcIixcImNjYXJvblwiOlwixI1cIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcIkNjaXJjXCI6XCLEiFwiLFwiY2NpcmNcIjpcIsSJXCIsXCJDY29uaW50XCI6XCLiiLBcIixcImNjdXBzXCI6XCLiqYxcIixcImNjdXBzc21cIjpcIuKpkFwiLFwiQ2RvdFwiOlwixIpcIixcImNkb3RcIjpcIsSLXCIsXCJjZWRpbFwiOlwiwrhcIixcIkNlZGlsbGFcIjpcIsK4XCIsXCJjZW1wdHl2XCI6XCLiprJcIixcImNlbnRcIjpcIsKiXCIsXCJjZW50ZXJkb3RcIjpcIsK3XCIsXCJDZW50ZXJEb3RcIjpcIsK3XCIsXCJjZnJcIjpcIvCdlKBcIixcIkNmclwiOlwi4oStXCIsXCJDSGN5XCI6XCLQp1wiLFwiY2hjeVwiOlwi0YdcIixcImNoZWNrXCI6XCLinJNcIixcImNoZWNrbWFya1wiOlwi4pyTXCIsXCJDaGlcIjpcIs6nXCIsXCJjaGlcIjpcIs+HXCIsXCJjaXJjXCI6XCLLhlwiLFwiY2lyY2VxXCI6XCLiiZdcIixcImNpcmNsZWFycm93bGVmdFwiOlwi4oa6XCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCLihrtcIixcImNpcmNsZWRhc3RcIjpcIuKKm1wiLFwiY2lyY2xlZGNpcmNcIjpcIuKKmlwiLFwiY2lyY2xlZGRhc2hcIjpcIuKKnVwiLFwiQ2lyY2xlRG90XCI6XCLiiplcIixcImNpcmNsZWRSXCI6XCLCrlwiLFwiY2lyY2xlZFNcIjpcIuKTiFwiLFwiQ2lyY2xlTWludXNcIjpcIuKKllwiLFwiQ2lyY2xlUGx1c1wiOlwi4oqVXCIsXCJDaXJjbGVUaW1lc1wiOlwi4oqXXCIsXCJjaXJcIjpcIuKXi1wiLFwiY2lyRVwiOlwi4qeDXCIsXCJjaXJlXCI6XCLiiZdcIixcImNpcmZuaW50XCI6XCLiqJBcIixcImNpcm1pZFwiOlwi4quvXCIsXCJjaXJzY2lyXCI6XCLip4JcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiyXCIsXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnVwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCLigJlcIixcImNsdWJzXCI6XCLimaNcIixcImNsdWJzdWl0XCI6XCLimaNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwi4oi3XCIsXCJDb2xvbmVcIjpcIuKptFwiLFwiY29sb25lXCI6XCLiiZRcIixcImNvbG9uZXFcIjpcIuKJlFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwi4oiBXCIsXCJjb21wZm5cIjpcIuKImFwiLFwiY29tcGxlbWVudFwiOlwi4oiBXCIsXCJjb21wbGV4ZXNcIjpcIuKEglwiLFwiY29uZ1wiOlwi4omFXCIsXCJjb25nZG90XCI6XCLiqa1cIixcIkNvbmdydWVudFwiOlwi4omhXCIsXCJjb25pbnRcIjpcIuKIrlwiLFwiQ29uaW50XCI6XCLiiK9cIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiuXCIsXCJjb3BmXCI6XCLwnZWUXCIsXCJDb3BmXCI6XCLihIJcIixcImNvcHJvZFwiOlwi4oiQXCIsXCJDb3Byb2R1Y3RcIjpcIuKIkFwiLFwiY29weVwiOlwiwqlcIixcIkNPUFlcIjpcIsKpXCIsXCJjb3B5c3JcIjpcIuKEl1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oizXCIsXCJjcmFyclwiOlwi4oa1XCIsXCJjcm9zc1wiOlwi4pyXXCIsXCJDcm9zc1wiOlwi4qivXCIsXCJDc2NyXCI6XCLwnZKeXCIsXCJjc2NyXCI6XCLwnZK4XCIsXCJjc3ViXCI6XCLiq49cIixcImNzdWJlXCI6XCLiq5FcIixcImNzdXBcIjpcIuKrkFwiLFwiY3N1cGVcIjpcIuKrklwiLFwiY3Rkb3RcIjpcIuKLr1wiLFwiY3VkYXJybFwiOlwi4qS4XCIsXCJjdWRhcnJyXCI6XCLipLVcIixcImN1ZXByXCI6XCLii55cIixcImN1ZXNjXCI6XCLii59cIixcImN1bGFyclwiOlwi4oa2XCIsXCJjdWxhcnJwXCI6XCLipL1cIixcImN1cGJyY2FwXCI6XCLiqYhcIixcImN1cGNhcFwiOlwi4qmGXCIsXCJDdXBDYXBcIjpcIuKJjVwiLFwiY3VwXCI6XCLiiKpcIixcIkN1cFwiOlwi4ouTXCIsXCJjdXBjdXBcIjpcIuKpilwiLFwiY3VwZG90XCI6XCLiio1cIixcImN1cG9yXCI6XCLiqYVcIixcImN1cHNcIjpcIuKIqu+4gFwiLFwiY3VyYXJyXCI6XCLihrdcIixcImN1cmFycm1cIjpcIuKkvFwiLFwiY3VybHllcXByZWNcIjpcIuKLnlwiLFwiY3VybHllcXN1Y2NcIjpcIuKLn1wiLFwiY3VybHl2ZWVcIjpcIuKLjlwiLFwiY3VybHl3ZWRnZVwiOlwi4ouPXCIsXCJjdXJyZW5cIjpcIsKkXCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwi4oa2XCIsXCJjdXJ2ZWFycm93cmlnaHRcIjpcIuKGt1wiLFwiY3V2ZWVcIjpcIuKLjlwiLFwiY3V3ZWRcIjpcIuKLj1wiLFwiY3djb25pbnRcIjpcIuKIslwiLFwiY3dpbnRcIjpcIuKIsVwiLFwiY3lsY3R5XCI6XCLijK1cIixcImRhZ2dlclwiOlwi4oCgXCIsXCJEYWdnZXJcIjpcIuKAoVwiLFwiZGFsZXRoXCI6XCLihLhcIixcImRhcnJcIjpcIuKGk1wiLFwiRGFyclwiOlwi4oahXCIsXCJkQXJyXCI6XCLih5NcIixcImRhc2hcIjpcIuKAkFwiLFwiRGFzaHZcIjpcIuKrpFwiLFwiZGFzaHZcIjpcIuKKo1wiLFwiZGJrYXJvd1wiOlwi4qSPXCIsXCJkYmxhY1wiOlwiy51cIixcIkRjYXJvblwiOlwixI5cIixcImRjYXJvblwiOlwixI9cIixcIkRjeVwiOlwi0JRcIixcImRjeVwiOlwi0LRcIixcImRkYWdnZXJcIjpcIuKAoVwiLFwiZGRhcnJcIjpcIuKHilwiLFwiRERcIjpcIuKFhVwiLFwiZGRcIjpcIuKFhlwiLFwiRERvdHJhaGRcIjpcIuKkkVwiLFwiZGRvdHNlcVwiOlwi4qm3XCIsXCJkZWdcIjpcIsKwXCIsXCJEZWxcIjpcIuKIh1wiLFwiRGVsdGFcIjpcIs6UXCIsXCJkZWx0YVwiOlwizrRcIixcImRlbXB0eXZcIjpcIuKmsVwiLFwiZGZpc2h0XCI6XCLipb9cIixcIkRmclwiOlwi8J2Uh1wiLFwiZGZyXCI6XCLwnZShXCIsXCJkSGFyXCI6XCLipaVcIixcImRoYXJsXCI6XCLih4NcIixcImRoYXJyXCI6XCLih4JcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIsK0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiy5lcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIsudXCIsXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJgXCIsXCJEaWFjcml0aWNhbFRpbGRlXCI6XCLLnFwiLFwiZGlhbVwiOlwi4ouEXCIsXCJkaWFtb25kXCI6XCLii4RcIixcIkRpYW1vbmRcIjpcIuKLhFwiLFwiZGlhbW9uZHN1aXRcIjpcIuKZplwiLFwiZGlhbXNcIjpcIuKZplwiLFwiZGllXCI6XCLCqFwiLFwiRGlmZmVyZW50aWFsRFwiOlwi4oWGXCIsXCJkaWdhbW1hXCI6XCLPnVwiLFwiZGlzaW5cIjpcIuKLslwiLFwiZGl2XCI6XCLDt1wiLFwiZGl2aWRlXCI6XCLDt1wiLFwiZGl2aWRlb250aW1lc1wiOlwi4ouHXCIsXCJkaXZvbnhcIjpcIuKLh1wiLFwiREpjeVwiOlwi0IJcIixcImRqY3lcIjpcItGSXCIsXCJkbGNvcm5cIjpcIuKMnlwiLFwiZGxjcm9wXCI6XCLijI1cIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwi8J2Uu1wiLFwiZG9wZlwiOlwi8J2VlVwiLFwiRG90XCI6XCLCqFwiLFwiZG90XCI6XCLLmVwiLFwiRG90RG90XCI6XCLig5xcIixcImRvdGVxXCI6XCLiiZBcIixcImRvdGVxZG90XCI6XCLiiZFcIixcIkRvdEVxdWFsXCI6XCLiiZBcIixcImRvdG1pbnVzXCI6XCLiiLhcIixcImRvdHBsdXNcIjpcIuKIlFwiLFwiZG90c3F1YXJlXCI6XCLiiqFcIixcImRvdWJsZWJhcndlZGdlXCI6XCLijIZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oivXCIsXCJEb3VibGVEb3RcIjpcIsKoXCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIuKHk1wiLFwiRG91YmxlTGVmdEFycm93XCI6XCLih5BcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCLih5RcIixcIkRvdWJsZUxlZnRUZWVcIjpcIuKrpFwiLFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwi4p+4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKfulwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIuKfuVwiLFwiRG91YmxlUmlnaHRBcnJvd1wiOlwi4oeSXCIsXCJEb3VibGVSaWdodFRlZVwiOlwi4oqoXCIsXCJEb3VibGVVcEFycm93XCI6XCLih5FcIixcIkRvdWJsZVVwRG93bkFycm93XCI6XCLih5VcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKVcIixcIkRvd25BcnJvd0JhclwiOlwi4qSTXCIsXCJkb3duYXJyb3dcIjpcIuKGk1wiLFwiRG93bkFycm93XCI6XCLihpNcIixcIkRvd25hcnJvd1wiOlwi4oeTXCIsXCJEb3duQXJyb3dVcEFycm93XCI6XCLih7VcIixcIkRvd25CcmV2ZVwiOlwizJFcIixcImRvd25kb3duYXJyb3dzXCI6XCLih4pcIixcImRvd25oYXJwb29ubGVmdFwiOlwi4oeDXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCLih4JcIixcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjpcIuKlkFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIuKlnlwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIuKlllwiLFwiRG93bkxlZnRWZWN0b3JcIjpcIuKGvVwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCLipZ9cIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwi4qWXXCIsXCJEb3duUmlnaHRWZWN0b3JcIjpcIuKHgVwiLFwiRG93blRlZUFycm93XCI6XCLihqdcIixcIkRvd25UZWVcIjpcIuKKpFwiLFwiZHJia2Fyb3dcIjpcIuKkkFwiLFwiZHJjb3JuXCI6XCLijJ9cIixcImRyY3JvcFwiOlwi4oyMXCIsXCJEc2NyXCI6XCLwnZKfXCIsXCJkc2NyXCI6XCLwnZK5XCIsXCJEU2N5XCI6XCLQhVwiLFwiZHNjeVwiOlwi0ZVcIixcImRzb2xcIjpcIuKntlwiLFwiRHN0cm9rXCI6XCLEkFwiLFwiZHN0cm9rXCI6XCLEkVwiLFwiZHRkb3RcIjpcIuKLsVwiLFwiZHRyaVwiOlwi4pa/XCIsXCJkdHJpZlwiOlwi4pa+XCIsXCJkdWFyclwiOlwi4oe1XCIsXCJkdWhhclwiOlwi4qWvXCIsXCJkd2FuZ2xlXCI6XCLipqZcIixcIkRaY3lcIjpcItCPXCIsXCJkemN5XCI6XCLRn1wiLFwiZHppZ3JhcnJcIjpcIuKfv1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiZWFzdGVyXCI6XCLiqa5cIixcIkVjYXJvblwiOlwixJpcIixcImVjYXJvblwiOlwixJtcIixcIkVjaXJjXCI6XCLDilwiLFwiZWNpcmNcIjpcIsOqXCIsXCJlY2lyXCI6XCLiiZZcIixcImVjb2xvblwiOlwi4omVXCIsXCJFY3lcIjpcItCtXCIsXCJlY3lcIjpcItGNXCIsXCJlRERvdFwiOlwi4qm3XCIsXCJFZG90XCI6XCLEllwiLFwiZWRvdFwiOlwixJdcIixcImVEb3RcIjpcIuKJkVwiLFwiZWVcIjpcIuKFh1wiLFwiZWZEb3RcIjpcIuKJklwiLFwiRWZyXCI6XCLwnZSIXCIsXCJlZnJcIjpcIvCdlKJcIixcImVnXCI6XCLiqppcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcImVnc1wiOlwi4qqWXCIsXCJlZ3Nkb3RcIjpcIuKqmFwiLFwiZWxcIjpcIuKqmVwiLFwiRWxlbWVudFwiOlwi4oiIXCIsXCJlbGludGVyc1wiOlwi4o+nXCIsXCJlbGxcIjpcIuKEk1wiLFwiZWxzXCI6XCLiqpVcIixcImVsc2RvdFwiOlwi4qqXXCIsXCJFbWFjclwiOlwixJJcIixcImVtYWNyXCI6XCLEk1wiLFwiZW1wdHlcIjpcIuKIhVwiLFwiZW1wdHlzZXRcIjpcIuKIhVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwi4pe7XCIsXCJlbXB0eXZcIjpcIuKIhVwiLFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIuKWq1wiLFwiZW1zcDEzXCI6XCLigIRcIixcImVtc3AxNFwiOlwi4oCFXCIsXCJlbXNwXCI6XCLigINcIixcIkVOR1wiOlwixYpcIixcImVuZ1wiOlwixYtcIixcImVuc3BcIjpcIuKAglwiLFwiRW9nb25cIjpcIsSYXCIsXCJlb2dvblwiOlwixJlcIixcIkVvcGZcIjpcIvCdlLxcIixcImVvcGZcIjpcIvCdlZZcIixcImVwYXJcIjpcIuKLlVwiLFwiZXBhcnNsXCI6XCLip6NcIixcImVwbHVzXCI6XCLiqbFcIixcImVwc2lcIjpcIs61XCIsXCJFcHNpbG9uXCI6XCLOlVwiLFwiZXBzaWxvblwiOlwizrVcIixcImVwc2l2XCI6XCLPtVwiLFwiZXFjaXJjXCI6XCLiiZZcIixcImVxY29sb25cIjpcIuKJlVwiLFwiZXFzaW1cIjpcIuKJglwiLFwiZXFzbGFudGd0clwiOlwi4qqWXCIsXCJlcXNsYW50bGVzc1wiOlwi4qqVXCIsXCJFcXVhbFwiOlwi4qm1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIuKJglwiLFwiZXF1ZXN0XCI6XCLiiZ9cIixcIkVxdWlsaWJyaXVtXCI6XCLih4xcIixcImVxdWl2XCI6XCLiiaFcIixcImVxdWl2RERcIjpcIuKpuFwiLFwiZXF2cGFyc2xcIjpcIuKnpVwiLFwiZXJhcnJcIjpcIuKlsVwiLFwiZXJEb3RcIjpcIuKJk1wiLFwiZXNjclwiOlwi4oSvXCIsXCJFc2NyXCI6XCLihLBcIixcImVzZG90XCI6XCLiiZBcIixcIkVzaW1cIjpcIuKps1wiLFwiZXNpbVwiOlwi4omCXCIsXCJFdGFcIjpcIs6XXCIsXCJldGFcIjpcIs63XCIsXCJFVEhcIjpcIsOQXCIsXCJldGhcIjpcIsOwXCIsXCJFdW1sXCI6XCLDi1wiLFwiZXVtbFwiOlwiw6tcIixcImV1cm9cIjpcIuKCrFwiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIuKIg1wiLFwiRXhpc3RzXCI6XCLiiINcIixcImV4cGVjdGF0aW9uXCI6XCLihLBcIixcImV4cG9uZW50aWFsZVwiOlwi4oWHXCIsXCJFeHBvbmVudGlhbEVcIjpcIuKFh1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwi4omSXCIsXCJGY3lcIjpcItCkXCIsXCJmY3lcIjpcItGEXCIsXCJmZW1hbGVcIjpcIuKZgFwiLFwiZmZpbGlnXCI6XCLvrINcIixcImZmbGlnXCI6XCLvrIBcIixcImZmbGxpZ1wiOlwi76yEXCIsXCJGZnJcIjpcIvCdlIlcIixcImZmclwiOlwi8J2Uo1wiLFwiZmlsaWdcIjpcIu+sgVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIuKXvFwiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCLilqpcIixcImZqbGlnXCI6XCJmalwiLFwiZmxhdFwiOlwi4pmtXCIsXCJmbGxpZ1wiOlwi76yCXCIsXCJmbHRuc1wiOlwi4paxXCIsXCJmbm9mXCI6XCLGklwiLFwiRm9wZlwiOlwi8J2UvVwiLFwiZm9wZlwiOlwi8J2Vl1wiLFwiZm9yYWxsXCI6XCLiiIBcIixcIkZvckFsbFwiOlwi4oiAXCIsXCJmb3JrXCI6XCLii5RcIixcImZvcmt2XCI6XCLiq5lcIixcIkZvdXJpZXJ0cmZcIjpcIuKEsVwiLFwiZnBhcnRpbnRcIjpcIuKojVwiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzEzXCI6XCLihZNcIixcImZyYWMxNFwiOlwiwrxcIixcImZyYWMxNVwiOlwi4oWVXCIsXCJmcmFjMTZcIjpcIuKFmVwiLFwiZnJhYzE4XCI6XCLihZtcIixcImZyYWMyM1wiOlwi4oWUXCIsXCJmcmFjMjVcIjpcIuKFllwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZnJhYzM1XCI6XCLihZdcIixcImZyYWMzOFwiOlwi4oWcXCIsXCJmcmFjNDVcIjpcIuKFmFwiLFwiZnJhYzU2XCI6XCLihZpcIixcImZyYWM1OFwiOlwi4oWdXCIsXCJmcmFjNzhcIjpcIuKFnlwiLFwiZnJhc2xcIjpcIuKBhFwiLFwiZnJvd25cIjpcIuKMolwiLFwiZnNjclwiOlwi8J2Su1wiLFwiRnNjclwiOlwi4oSxXCIsXCJnYWN1dGVcIjpcIse1XCIsXCJHYW1tYVwiOlwizpNcIixcImdhbW1hXCI6XCLOs1wiLFwiR2FtbWFkXCI6XCLPnFwiLFwiZ2FtbWFkXCI6XCLPnVwiLFwiZ2FwXCI6XCLiqoZcIixcIkdicmV2ZVwiOlwixJ5cIixcImdicmV2ZVwiOlwixJ9cIixcIkdjZWRpbFwiOlwixKJcIixcIkdjaXJjXCI6XCLEnFwiLFwiZ2NpcmNcIjpcIsSdXCIsXCJHY3lcIjpcItCTXCIsXCJnY3lcIjpcItCzXCIsXCJHZG90XCI6XCLEoFwiLFwiZ2RvdFwiOlwixKFcIixcImdlXCI6XCLiiaVcIixcImdFXCI6XCLiiadcIixcImdFbFwiOlwi4qqMXCIsXCJnZWxcIjpcIuKLm1wiLFwiZ2VxXCI6XCLiiaVcIixcImdlcXFcIjpcIuKJp1wiLFwiZ2Vxc2xhbnRcIjpcIuKpvlwiLFwiZ2VzY2NcIjpcIuKqqVwiLFwiZ2VzXCI6XCLiqb5cIixcImdlc2RvdFwiOlwi4qqAXCIsXCJnZXNkb3RvXCI6XCLiqoJcIixcImdlc2RvdG9sXCI6XCLiqoRcIixcImdlc2xcIjpcIuKLm++4gFwiLFwiZ2VzbGVzXCI6XCLiqpRcIixcIkdmclwiOlwi8J2UilwiLFwiZ2ZyXCI6XCLwnZSkXCIsXCJnZ1wiOlwi4omrXCIsXCJHZ1wiOlwi4ouZXCIsXCJnZ2dcIjpcIuKLmVwiLFwiZ2ltZWxcIjpcIuKEt1wiLFwiR0pjeVwiOlwi0INcIixcImdqY3lcIjpcItGTXCIsXCJnbGFcIjpcIuKqpVwiLFwiZ2xcIjpcIuKJt1wiLFwiZ2xFXCI6XCLiqpJcIixcImdsalwiOlwi4qqkXCIsXCJnbmFwXCI6XCLiqopcIixcImduYXBwcm94XCI6XCLiqopcIixcImduZVwiOlwi4qqIXCIsXCJnbkVcIjpcIuKJqVwiLFwiZ25lcVwiOlwi4qqIXCIsXCJnbmVxcVwiOlwi4ompXCIsXCJnbnNpbVwiOlwi4ounXCIsXCJHb3BmXCI6XCLwnZS+XCIsXCJnb3BmXCI6XCLwnZWYXCIsXCJncmF2ZVwiOlwiYFwiLFwiR3JlYXRlckVxdWFsXCI6XCLiiaVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIuKLm1wiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnXCIsXCJHcmVhdGVyR3JlYXRlclwiOlwi4qqiXCIsXCJHcmVhdGVyTGVzc1wiOlwi4om3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+XCIsXCJHcmVhdGVyVGlsZGVcIjpcIuKJs1wiLFwiR3NjclwiOlwi8J2SolwiLFwiZ3NjclwiOlwi4oSKXCIsXCJnc2ltXCI6XCLiibNcIixcImdzaW1lXCI6XCLiqo5cIixcImdzaW1sXCI6XCLiqpBcIixcImd0Y2NcIjpcIuKqp1wiLFwiZ3RjaXJcIjpcIuKpulwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwi4omrXCIsXCJndGRvdFwiOlwi4ouXXCIsXCJndGxQYXJcIjpcIuKmlVwiLFwiZ3RxdWVzdFwiOlwi4qm8XCIsXCJndHJhcHByb3hcIjpcIuKqhlwiLFwiZ3RyYXJyXCI6XCLipbhcIixcImd0cmRvdFwiOlwi4ouXXCIsXCJndHJlcWxlc3NcIjpcIuKLm1wiLFwiZ3RyZXFxbGVzc1wiOlwi4qqMXCIsXCJndHJsZXNzXCI6XCLiibdcIixcImd0cnNpbVwiOlwi4omzXCIsXCJndmVydG5lcXFcIjpcIuKJqe+4gFwiLFwiZ3ZuRVwiOlwi4omp77iAXCIsXCJIYWNla1wiOlwiy4dcIixcImhhaXJzcFwiOlwi4oCKXCIsXCJoYWxmXCI6XCLCvVwiLFwiaGFtaWx0XCI6XCLihItcIixcIkhBUkRjeVwiOlwi0KpcIixcImhhcmRjeVwiOlwi0YpcIixcImhhcnJjaXJcIjpcIuKliFwiLFwiaGFyclwiOlwi4oaUXCIsXCJoQXJyXCI6XCLih5RcIixcImhhcnJ3XCI6XCLihq1cIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwi4oSPXCIsXCJIY2lyY1wiOlwixKRcIixcImhjaXJjXCI6XCLEpVwiLFwiaGVhcnRzXCI6XCLimaVcIixcImhlYXJ0c3VpdFwiOlwi4pmlXCIsXCJoZWxsaXBcIjpcIuKAplwiLFwiaGVyY29uXCI6XCLiirlcIixcImhmclwiOlwi8J2UpVwiLFwiSGZyXCI6XCLihIxcIixcIkhpbGJlcnRTcGFjZVwiOlwi4oSLXCIsXCJoa3NlYXJvd1wiOlwi4qSlXCIsXCJoa3N3YXJvd1wiOlwi4qSmXCIsXCJob2FyclwiOlwi4oe/XCIsXCJob210aHRcIjpcIuKIu1wiLFwiaG9va2xlZnRhcnJvd1wiOlwi4oapXCIsXCJob29rcmlnaHRhcnJvd1wiOlwi4oaqXCIsXCJob3BmXCI6XCLwnZWZXCIsXCJIb3BmXCI6XCLihI1cIixcImhvcmJhclwiOlwi4oCVXCIsXCJIb3Jpem9udGFsTGluZVwiOlwi4pSAXCIsXCJoc2NyXCI6XCLwnZK9XCIsXCJIc2NyXCI6XCLihItcIixcImhzbGFzaFwiOlwi4oSPXCIsXCJIc3Ryb2tcIjpcIsSmXCIsXCJoc3Ryb2tcIjpcIsSnXCIsXCJIdW1wRG93bkh1bXBcIjpcIuKJjlwiLFwiSHVtcEVxdWFsXCI6XCLiiY9cIixcImh5YnVsbFwiOlwi4oGDXCIsXCJoeXBoZW5cIjpcIuKAkFwiLFwiSWFjdXRlXCI6XCLDjVwiLFwiaWFjdXRlXCI6XCLDrVwiLFwiaWNcIjpcIuKBo1wiLFwiSWNpcmNcIjpcIsOOXCIsXCJpY2lyY1wiOlwiw65cIixcIkljeVwiOlwi0JhcIixcImljeVwiOlwi0LhcIixcIklkb3RcIjpcIsSwXCIsXCJJRWN5XCI6XCLQlVwiLFwiaWVjeVwiOlwi0LVcIixcImlleGNsXCI6XCLCoVwiLFwiaWZmXCI6XCLih5RcIixcImlmclwiOlwi8J2UplwiLFwiSWZyXCI6XCLihJFcIixcIklncmF2ZVwiOlwiw4xcIixcImlncmF2ZVwiOlwiw6xcIixcImlpXCI6XCLihYhcIixcImlpaWludFwiOlwi4qiMXCIsXCJpaWludFwiOlwi4oitXCIsXCJpaW5maW5cIjpcIuKnnFwiLFwiaWlvdGFcIjpcIuKEqVwiLFwiSUpsaWdcIjpcIsSyXCIsXCJpamxpZ1wiOlwixLNcIixcIkltYWNyXCI6XCLEqlwiLFwiaW1hY3JcIjpcIsSrXCIsXCJpbWFnZVwiOlwi4oSRXCIsXCJJbWFnaW5hcnlJXCI6XCLihYhcIixcImltYWdsaW5lXCI6XCLihJBcIixcImltYWdwYXJ0XCI6XCLihJFcIixcImltYXRoXCI6XCLEsVwiLFwiSW1cIjpcIuKEkVwiLFwiaW1vZlwiOlwi4oq3XCIsXCJpbXBlZFwiOlwixrVcIixcIkltcGxpZXNcIjpcIuKHklwiLFwiaW5jYXJlXCI6XCLihIVcIixcImluXCI6XCLiiIhcIixcImluZmluXCI6XCLiiJ5cIixcImluZmludGllXCI6XCLip51cIixcImlub2RvdFwiOlwixLFcIixcImludGNhbFwiOlwi4oq6XCIsXCJpbnRcIjpcIuKIq1wiLFwiSW50XCI6XCLiiKxcIixcImludGVnZXJzXCI6XCLihKRcIixcIkludGVncmFsXCI6XCLiiKtcIixcImludGVyY2FsXCI6XCLiirpcIixcIkludGVyc2VjdGlvblwiOlwi4ouCXCIsXCJpbnRsYXJoa1wiOlwi4qiXXCIsXCJpbnRwcm9kXCI6XCLiqLxcIixcIkludmlzaWJsZUNvbW1hXCI6XCLigaNcIixcIkludmlzaWJsZVRpbWVzXCI6XCLigaJcIixcIklPY3lcIjpcItCBXCIsXCJpb2N5XCI6XCLRkVwiLFwiSW9nb25cIjpcIsSuXCIsXCJpb2dvblwiOlwixK9cIixcIklvcGZcIjpcIvCdlYBcIixcImlvcGZcIjpcIvCdlZpcIixcIklvdGFcIjpcIs6ZXCIsXCJpb3RhXCI6XCLOuVwiLFwiaXByb2RcIjpcIuKovFwiLFwiaXF1ZXN0XCI6XCLCv1wiLFwiaXNjclwiOlwi8J2SvlwiLFwiSXNjclwiOlwi4oSQXCIsXCJpc2luXCI6XCLiiIhcIixcImlzaW5kb3RcIjpcIuKLtVwiLFwiaXNpbkVcIjpcIuKLuVwiLFwiaXNpbnNcIjpcIuKLtFwiLFwiaXNpbnN2XCI6XCLii7NcIixcImlzaW52XCI6XCLiiIhcIixcIml0XCI6XCLigaJcIixcIkl0aWxkZVwiOlwixKhcIixcIml0aWxkZVwiOlwixKlcIixcIkl1a2N5XCI6XCLQhlwiLFwiaXVrY3lcIjpcItGWXCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcIkpjaXJjXCI6XCLEtFwiLFwiamNpcmNcIjpcIsS1XCIsXCJKY3lcIjpcItCZXCIsXCJqY3lcIjpcItC5XCIsXCJKZnJcIjpcIvCdlI1cIixcImpmclwiOlwi8J2Up1wiLFwiam1hdGhcIjpcIsi3XCIsXCJKb3BmXCI6XCLwnZWBXCIsXCJqb3BmXCI6XCLwnZWbXCIsXCJKc2NyXCI6XCLwnZKlXCIsXCJqc2NyXCI6XCLwnZK/XCIsXCJKc2VyY3lcIjpcItCIXCIsXCJqc2VyY3lcIjpcItGYXCIsXCJKdWtjeVwiOlwi0IRcIixcImp1a2N5XCI6XCLRlFwiLFwiS2FwcGFcIjpcIs6aXCIsXCJrYXBwYVwiOlwizrpcIixcImthcHBhdlwiOlwiz7BcIixcIktjZWRpbFwiOlwixLZcIixcImtjZWRpbFwiOlwixLdcIixcIktjeVwiOlwi0JpcIixcImtjeVwiOlwi0LpcIixcIktmclwiOlwi8J2UjlwiLFwia2ZyXCI6XCLwnZSoXCIsXCJrZ3JlZW5cIjpcIsS4XCIsXCJLSGN5XCI6XCLQpVwiLFwia2hjeVwiOlwi0YVcIixcIktKY3lcIjpcItCMXCIsXCJramN5XCI6XCLRnFwiLFwiS29wZlwiOlwi8J2VglwiLFwia29wZlwiOlwi8J2VnFwiLFwiS3NjclwiOlwi8J2SplwiLFwia3NjclwiOlwi8J2TgFwiLFwibEFhcnJcIjpcIuKHmlwiLFwiTGFjdXRlXCI6XCLEuVwiLFwibGFjdXRlXCI6XCLEulwiLFwibGFlbXB0eXZcIjpcIuKmtFwiLFwibGFncmFuXCI6XCLihJJcIixcIkxhbWJkYVwiOlwizptcIixcImxhbWJkYVwiOlwizrtcIixcImxhbmdcIjpcIuKfqFwiLFwiTGFuZ1wiOlwi4p+qXCIsXCJsYW5nZFwiOlwi4qaRXCIsXCJsYW5nbGVcIjpcIuKfqFwiLFwibGFwXCI6XCLiqoVcIixcIkxhcGxhY2V0cmZcIjpcIuKEklwiLFwibGFxdW9cIjpcIsKrXCIsXCJsYXJyYlwiOlwi4oekXCIsXCJsYXJyYmZzXCI6XCLipJ9cIixcImxhcnJcIjpcIuKGkFwiLFwiTGFyclwiOlwi4oaeXCIsXCJsQXJyXCI6XCLih5BcIixcImxhcnJmc1wiOlwi4qSdXCIsXCJsYXJyaGtcIjpcIuKGqVwiLFwibGFycmxwXCI6XCLihqtcIixcImxhcnJwbFwiOlwi4qS5XCIsXCJsYXJyc2ltXCI6XCLipbNcIixcImxhcnJ0bFwiOlwi4oaiXCIsXCJsYXRhaWxcIjpcIuKkmVwiLFwibEF0YWlsXCI6XCLipJtcIixcImxhdFwiOlwi4qqrXCIsXCJsYXRlXCI6XCLiqq1cIixcImxhdGVzXCI6XCLiqq3vuIBcIixcImxiYXJyXCI6XCLipIxcIixcImxCYXJyXCI6XCLipI5cIixcImxiYnJrXCI6XCLinbJcIixcImxicmFjZVwiOlwie1wiLFwibGJyYWNrXCI6XCJbXCIsXCJsYnJrZVwiOlwi4qaLXCIsXCJsYnJrc2xkXCI6XCLipo9cIixcImxicmtzbHVcIjpcIuKmjVwiLFwiTGNhcm9uXCI6XCLEvVwiLFwibGNhcm9uXCI6XCLEvlwiLFwiTGNlZGlsXCI6XCLEu1wiLFwibGNlZGlsXCI6XCLEvFwiLFwibGNlaWxcIjpcIuKMiFwiLFwibGN1YlwiOlwie1wiLFwiTGN5XCI6XCLQm1wiLFwibGN5XCI6XCLQu1wiLFwibGRjYVwiOlwi4qS2XCIsXCJsZHF1b1wiOlwi4oCcXCIsXCJsZHF1b3JcIjpcIuKAnlwiLFwibGRyZGhhclwiOlwi4qWnXCIsXCJsZHJ1c2hhclwiOlwi4qWLXCIsXCJsZHNoXCI6XCLihrJcIixcImxlXCI6XCLiiaRcIixcImxFXCI6XCLiiaZcIixcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIuKfqFwiLFwiTGVmdEFycm93QmFyXCI6XCLih6RcIixcImxlZnRhcnJvd1wiOlwi4oaQXCIsXCJMZWZ0QXJyb3dcIjpcIuKGkFwiLFwiTGVmdGFycm93XCI6XCLih5BcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIuKHhlwiLFwibGVmdGFycm93dGFpbFwiOlwi4oaiXCIsXCJMZWZ0Q2VpbGluZ1wiOlwi4oyIXCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwi4p+mXCIsXCJMZWZ0RG93blRlZVZlY3RvclwiOlwi4qWhXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwi4qWZXCIsXCJMZWZ0RG93blZlY3RvclwiOlwi4oeDXCIsXCJMZWZ0Rmxvb3JcIjpcIuKMilwiLFwibGVmdGhhcnBvb25kb3duXCI6XCLihr1cIixcImxlZnRoYXJwb29udXBcIjpcIuKGvFwiLFwibGVmdGxlZnRhcnJvd3NcIjpcIuKHh1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIuKGlFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIuKGlFwiLFwiTGVmdHJpZ2h0YXJyb3dcIjpcIuKHlFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCLih4ZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCLih4tcIixcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIuKGrVwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCLipY5cIixcIkxlZnRUZWVBcnJvd1wiOlwi4oakXCIsXCJMZWZ0VGVlXCI6XCLiiqNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIuKlmlwiLFwibGVmdHRocmVldGltZXNcIjpcIuKLi1wiLFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCLip49cIixcIkxlZnRUcmlhbmdsZVwiOlwi4oqyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4oq0XCIsXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCLipZFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwi4qWgXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIuKlmFwiLFwiTGVmdFVwVmVjdG9yXCI6XCLihr9cIixcIkxlZnRWZWN0b3JCYXJcIjpcIuKlklwiLFwiTGVmdFZlY3RvclwiOlwi4oa8XCIsXCJsRWdcIjpcIuKqi1wiLFwibGVnXCI6XCLii5pcIixcImxlcVwiOlwi4omkXCIsXCJsZXFxXCI6XCLiiaZcIixcImxlcXNsYW50XCI6XCLiqb1cIixcImxlc2NjXCI6XCLiqqhcIixcImxlc1wiOlwi4qm9XCIsXCJsZXNkb3RcIjpcIuKpv1wiLFwibGVzZG90b1wiOlwi4qqBXCIsXCJsZXNkb3RvclwiOlwi4qqDXCIsXCJsZXNnXCI6XCLii5rvuIBcIixcImxlc2dlc1wiOlwi4qqTXCIsXCJsZXNzYXBwcm94XCI6XCLiqoVcIixcImxlc3Nkb3RcIjpcIuKLllwiLFwibGVzc2VxZ3RyXCI6XCLii5pcIixcImxlc3NlcXFndHJcIjpcIuKqi1wiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwi4ouaXCIsXCJMZXNzRnVsbEVxdWFsXCI6XCLiiaZcIixcIkxlc3NHcmVhdGVyXCI6XCLiibZcIixcImxlc3NndHJcIjpcIuKJtlwiLFwiTGVzc0xlc3NcIjpcIuKqoVwiLFwibGVzc3NpbVwiOlwi4omyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwi4qm9XCIsXCJMZXNzVGlsZGVcIjpcIuKJslwiLFwibGZpc2h0XCI6XCLipbxcIixcImxmbG9vclwiOlwi4oyKXCIsXCJMZnJcIjpcIvCdlI9cIixcImxmclwiOlwi8J2UqVwiLFwibGdcIjpcIuKJtlwiLFwibGdFXCI6XCLiqpFcIixcImxIYXJcIjpcIuKlolwiLFwibGhhcmRcIjpcIuKGvVwiLFwibGhhcnVcIjpcIuKGvFwiLFwibGhhcnVsXCI6XCLipapcIixcImxoYmxrXCI6XCLiloRcIixcIkxKY3lcIjpcItCJXCIsXCJsamN5XCI6XCLRmVwiLFwibGxhcnJcIjpcIuKHh1wiLFwibGxcIjpcIuKJqlwiLFwiTGxcIjpcIuKLmFwiLFwibGxjb3JuZXJcIjpcIuKMnlwiLFwiTGxlZnRhcnJvd1wiOlwi4oeaXCIsXCJsbGhhcmRcIjpcIuKlq1wiLFwibGx0cmlcIjpcIuKXulwiLFwiTG1pZG90XCI6XCLEv1wiLFwibG1pZG90XCI6XCLFgFwiLFwibG1vdXN0YWNoZVwiOlwi4o6wXCIsXCJsbW91c3RcIjpcIuKOsFwiLFwibG5hcFwiOlwi4qqJXCIsXCJsbmFwcHJveFwiOlwi4qqJXCIsXCJsbmVcIjpcIuKqh1wiLFwibG5FXCI6XCLiiahcIixcImxuZXFcIjpcIuKqh1wiLFwibG5lcXFcIjpcIuKJqFwiLFwibG5zaW1cIjpcIuKLplwiLFwibG9hbmdcIjpcIuKfrFwiLFwibG9hcnJcIjpcIuKHvVwiLFwibG9icmtcIjpcIuKfplwiLFwibG9uZ2xlZnRhcnJvd1wiOlwi4p+1XCIsXCJMb25nTGVmdEFycm93XCI6XCLin7VcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIuKfuFwiLFwibG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7dcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKfulwiLFwibG9uZ21hcHN0b1wiOlwi4p+8XCIsXCJsb25ncmlnaHRhcnJvd1wiOlwi4p+2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwi4p+2XCIsXCJMb25ncmlnaHRhcnJvd1wiOlwi4p+5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCLihqtcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCLihqxcIixcImxvcGFyXCI6XCLipoVcIixcIkxvcGZcIjpcIvCdlYNcIixcImxvcGZcIjpcIvCdlZ1cIixcImxvcGx1c1wiOlwi4qitXCIsXCJsb3RpbWVzXCI6XCLiqLRcIixcImxvd2FzdFwiOlwi4oiXXCIsXCJsb3diYXJcIjpcIl9cIixcIkxvd2VyTGVmdEFycm93XCI6XCLihplcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwi4oaYXCIsXCJsb3pcIjpcIuKXilwiLFwibG96ZW5nZVwiOlwi4peKXCIsXCJsb3pmXCI6XCLip6tcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwi4qaTXCIsXCJscmFyclwiOlwi4oeGXCIsXCJscmNvcm5lclwiOlwi4oyfXCIsXCJscmhhclwiOlwi4oeLXCIsXCJscmhhcmRcIjpcIuKlrVwiLFwibHJtXCI6XCLigI5cIixcImxydHJpXCI6XCLiir9cIixcImxzYXF1b1wiOlwi4oC5XCIsXCJsc2NyXCI6XCLwnZOBXCIsXCJMc2NyXCI6XCLihJJcIixcImxzaFwiOlwi4oawXCIsXCJMc2hcIjpcIuKGsFwiLFwibHNpbVwiOlwi4omyXCIsXCJsc2ltZVwiOlwi4qqNXCIsXCJsc2ltZ1wiOlwi4qqPXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwi4oCYXCIsXCJsc3F1b3JcIjpcIuKAmlwiLFwiTHN0cm9rXCI6XCLFgVwiLFwibHN0cm9rXCI6XCLFglwiLFwibHRjY1wiOlwi4qqmXCIsXCJsdGNpclwiOlwi4qm5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCLiiapcIixcImx0ZG90XCI6XCLii5ZcIixcImx0aHJlZVwiOlwi4ouLXCIsXCJsdGltZXNcIjpcIuKLiVwiLFwibHRsYXJyXCI6XCLipbZcIixcImx0cXVlc3RcIjpcIuKpu1wiLFwibHRyaVwiOlwi4peDXCIsXCJsdHJpZVwiOlwi4oq0XCIsXCJsdHJpZlwiOlwi4peCXCIsXCJsdHJQYXJcIjpcIuKmllwiLFwibHVyZHNoYXJcIjpcIuKlilwiLFwibHVydWhhclwiOlwi4qWmXCIsXCJsdmVydG5lcXFcIjpcIuKJqO+4gFwiLFwibHZuRVwiOlwi4omo77iAXCIsXCJtYWNyXCI6XCLCr1wiLFwibWFsZVwiOlwi4pmCXCIsXCJtYWx0XCI6XCLinKBcIixcIm1hbHRlc2VcIjpcIuKcoFwiLFwiTWFwXCI6XCLipIVcIixcIm1hcFwiOlwi4oamXCIsXCJtYXBzdG9cIjpcIuKGplwiLFwibWFwc3RvZG93blwiOlwi4oanXCIsXCJtYXBzdG9sZWZ0XCI6XCLihqRcIixcIm1hcHN0b3VwXCI6XCLihqVcIixcIm1hcmtlclwiOlwi4pauXCIsXCJtY29tbWFcIjpcIuKoqVwiLFwiTWN5XCI6XCLQnFwiLFwibWN5XCI6XCLQvFwiLFwibWRhc2hcIjpcIuKAlFwiLFwibUREb3RcIjpcIuKIulwiLFwibWVhc3VyZWRhbmdsZVwiOlwi4oihXCIsXCJNZWRpdW1TcGFjZVwiOlwi4oGfXCIsXCJNZWxsaW50cmZcIjpcIuKEs1wiLFwiTWZyXCI6XCLwnZSQXCIsXCJtZnJcIjpcIvCdlKpcIixcIm1ob1wiOlwi4oSnXCIsXCJtaWNyb1wiOlwiwrVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCLiq7BcIixcIm1pZFwiOlwi4oijXCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJtaW51c2JcIjpcIuKKn1wiLFwibWludXNcIjpcIuKIklwiLFwibWludXNkXCI6XCLiiLhcIixcIm1pbnVzZHVcIjpcIuKoqlwiLFwiTWludXNQbHVzXCI6XCLiiJNcIixcIm1sY3BcIjpcIuKrm1wiLFwibWxkclwiOlwi4oCmXCIsXCJtbnBsdXNcIjpcIuKIk1wiLFwibW9kZWxzXCI6XCLiiqdcIixcIk1vcGZcIjpcIvCdlYRcIixcIm1vcGZcIjpcIvCdlZ5cIixcIm1wXCI6XCLiiJNcIixcIm1zY3JcIjpcIvCdk4JcIixcIk1zY3JcIjpcIuKEs1wiLFwibXN0cG9zXCI6XCLiiL5cIixcIk11XCI6XCLOnFwiLFwibXVcIjpcIs68XCIsXCJtdWx0aW1hcFwiOlwi4oq4XCIsXCJtdW1hcFwiOlwi4oq4XCIsXCJuYWJsYVwiOlwi4oiHXCIsXCJOYWN1dGVcIjpcIsWDXCIsXCJuYWN1dGVcIjpcIsWEXCIsXCJuYW5nXCI6XCLiiKDig5JcIixcIm5hcFwiOlwi4omJXCIsXCJuYXBFXCI6XCLiqbDMuFwiLFwibmFwaWRcIjpcIuKJi8y4XCIsXCJuYXBvc1wiOlwixYlcIixcIm5hcHByb3hcIjpcIuKJiVwiLFwibmF0dXJhbFwiOlwi4pmuXCIsXCJuYXR1cmFsc1wiOlwi4oSVXCIsXCJuYXR1clwiOlwi4pmuXCIsXCJuYnNwXCI6XCLCoFwiLFwibmJ1bXBcIjpcIuKJjsy4XCIsXCJuYnVtcGVcIjpcIuKJj8y4XCIsXCJuY2FwXCI6XCLiqYNcIixcIk5jYXJvblwiOlwixYdcIixcIm5jYXJvblwiOlwixYhcIixcIk5jZWRpbFwiOlwixYVcIixcIm5jZWRpbFwiOlwixYZcIixcIm5jb25nXCI6XCLiiYdcIixcIm5jb25nZG90XCI6XCLiqa3MuFwiLFwibmN1cFwiOlwi4qmCXCIsXCJOY3lcIjpcItCdXCIsXCJuY3lcIjpcItC9XCIsXCJuZGFzaFwiOlwi4oCTXCIsXCJuZWFyaGtcIjpcIuKkpFwiLFwibmVhcnJcIjpcIuKGl1wiLFwibmVBcnJcIjpcIuKHl1wiLFwibmVhcnJvd1wiOlwi4oaXXCIsXCJuZVwiOlwi4omgXCIsXCJuZWRvdFwiOlwi4omQzLhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJuZXF1aXZcIjpcIuKJolwiLFwibmVzZWFyXCI6XCLipKhcIixcIm5lc2ltXCI6XCLiiYLMuFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKJq1wiLFwiTmVzdGVkTGVzc0xlc3NcIjpcIuKJqlwiLFwiTmV3TGluZVwiOlwiXFxuXCIsXCJuZXhpc3RcIjpcIuKIhFwiLFwibmV4aXN0c1wiOlwi4oiEXCIsXCJOZnJcIjpcIvCdlJFcIixcIm5mclwiOlwi8J2Uq1wiLFwibmdFXCI6XCLiiafMuFwiLFwibmdlXCI6XCLiibFcIixcIm5nZXFcIjpcIuKJsVwiLFwibmdlcXFcIjpcIuKJp8y4XCIsXCJuZ2Vxc2xhbnRcIjpcIuKpvsy4XCIsXCJuZ2VzXCI6XCLiqb7MuFwiLFwibkdnXCI6XCLii5nMuFwiLFwibmdzaW1cIjpcIuKJtVwiLFwibkd0XCI6XCLiiavig5JcIixcIm5ndFwiOlwi4omvXCIsXCJuZ3RyXCI6XCLiia9cIixcIm5HdHZcIjpcIuKJq8y4XCIsXCJuaGFyclwiOlwi4oauXCIsXCJuaEFyclwiOlwi4oeOXCIsXCJuaHBhclwiOlwi4quyXCIsXCJuaVwiOlwi4oiLXCIsXCJuaXNcIjpcIuKLvFwiLFwibmlzZFwiOlwi4ou6XCIsXCJuaXZcIjpcIuKIi1wiLFwiTkpjeVwiOlwi0IpcIixcIm5qY3lcIjpcItGaXCIsXCJubGFyclwiOlwi4oaaXCIsXCJubEFyclwiOlwi4oeNXCIsXCJubGRyXCI6XCLigKVcIixcIm5sRVwiOlwi4ommzLhcIixcIm5sZVwiOlwi4omwXCIsXCJubGVmdGFycm93XCI6XCLihppcIixcIm5MZWZ0YXJyb3dcIjpcIuKHjVwiLFwibmxlZnRyaWdodGFycm93XCI6XCLihq5cIixcIm5MZWZ0cmlnaHRhcnJvd1wiOlwi4oeOXCIsXCJubGVxXCI6XCLiibBcIixcIm5sZXFxXCI6XCLiiabMuFwiLFwibmxlcXNsYW50XCI6XCLiqb3MuFwiLFwibmxlc1wiOlwi4qm9zLhcIixcIm5sZXNzXCI6XCLiia5cIixcIm5MbFwiOlwi4ouYzLhcIixcIm5sc2ltXCI6XCLiibRcIixcIm5MdFwiOlwi4omq4oOSXCIsXCJubHRcIjpcIuKJrlwiLFwibmx0cmlcIjpcIuKLqlwiLFwibmx0cmllXCI6XCLii6xcIixcIm5MdHZcIjpcIuKJqsy4XCIsXCJubWlkXCI6XCLiiKRcIixcIk5vQnJlYWtcIjpcIuKBoFwiLFwiTm9uQnJlYWtpbmdTcGFjZVwiOlwiwqBcIixcIm5vcGZcIjpcIvCdlZ9cIixcIk5vcGZcIjpcIuKElVwiLFwiTm90XCI6XCLiq6xcIixcIm5vdFwiOlwiwqxcIixcIk5vdENvbmdydWVudFwiOlwi4omiXCIsXCJOb3RDdXBDYXBcIjpcIuKJrVwiLFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIuKIplwiLFwiTm90RWxlbWVudFwiOlwi4oiJXCIsXCJOb3RFcXVhbFwiOlwi4omgXCIsXCJOb3RFcXVhbFRpbGRlXCI6XCLiiYLMuFwiLFwiTm90RXhpc3RzXCI6XCLiiIRcIixcIk5vdEdyZWF0ZXJcIjpcIuKJr1wiLFwiTm90R3JlYXRlckVxdWFsXCI6XCLiibFcIixcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp8y4XCIsXCJOb3RHcmVhdGVyR3JlYXRlclwiOlwi4omrzLhcIixcIk5vdEdyZWF0ZXJMZXNzXCI6XCLiiblcIixcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb7MuFwiLFwiTm90R3JlYXRlclRpbGRlXCI6XCLiibVcIixcIk5vdEh1bXBEb3duSHVtcFwiOlwi4omOzLhcIixcIk5vdEh1bXBFcXVhbFwiOlwi4omPzLhcIixcIm5vdGluXCI6XCLiiIlcIixcIm5vdGluZG90XCI6XCLii7XMuFwiLFwibm90aW5FXCI6XCLii7nMuFwiLFwibm90aW52YVwiOlwi4oiJXCIsXCJub3RpbnZiXCI6XCLii7dcIixcIm5vdGludmNcIjpcIuKLtlwiLFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6XCLip4/MuFwiLFwiTm90TGVmdFRyaWFuZ2xlXCI6XCLii6pcIixcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6XCLii6xcIixcIk5vdExlc3NcIjpcIuKJrlwiLFwiTm90TGVzc0VxdWFsXCI6XCLiibBcIixcIk5vdExlc3NHcmVhdGVyXCI6XCLiibhcIixcIk5vdExlc3NMZXNzXCI6XCLiiarMuFwiLFwiTm90TGVzc1NsYW50RXF1YWxcIjpcIuKpvcy4XCIsXCJOb3RMZXNzVGlsZGVcIjpcIuKJtFwiLFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKqosy4XCIsXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwi4qqhzLhcIixcIm5vdG5pXCI6XCLiiIxcIixcIm5vdG5pdmFcIjpcIuKIjFwiLFwibm90bml2YlwiOlwi4ou+XCIsXCJub3RuaXZjXCI6XCLii71cIixcIk5vdFByZWNlZGVzXCI6XCLiioBcIixcIk5vdFByZWNlZGVzRXF1YWxcIjpcIuKqr8y4XCIsXCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKLoFwiLFwiTm90UmV2ZXJzZUVsZW1lbnRcIjpcIuKIjFwiLFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQzLhcIixcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIuKLq1wiLFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLii61cIixcIk5vdFNxdWFyZVN1YnNldFwiOlwi4oqPzLhcIixcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCLii6JcIixcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCLiipDMuFwiLFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oujXCIsXCJOb3RTdWJzZXRcIjpcIuKKguKDklwiLFwiTm90U3Vic2V0RXF1YWxcIjpcIuKKiFwiLFwiTm90U3VjY2VlZHNcIjpcIuKKgVwiLFwiTm90U3VjY2VlZHNFcXVhbFwiOlwi4qqwzLhcIixcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4ouhXCIsXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCLiib/MuFwiLFwiTm90U3VwZXJzZXRcIjpcIuKKg+KDklwiLFwiTm90U3VwZXJzZXRFcXVhbFwiOlwi4oqJXCIsXCJOb3RUaWxkZVwiOlwi4omBXCIsXCJOb3RUaWxkZUVxdWFsXCI6XCLiiYRcIixcIk5vdFRpbGRlRnVsbEVxdWFsXCI6XCLiiYdcIixcIk5vdFRpbGRlVGlsZGVcIjpcIuKJiVwiLFwiTm90VmVydGljYWxCYXJcIjpcIuKIpFwiLFwibnBhcmFsbGVsXCI6XCLiiKZcIixcIm5wYXJcIjpcIuKIplwiLFwibnBhcnNsXCI6XCLiq73ig6VcIixcIm5wYXJ0XCI6XCLiiILMuFwiLFwibnBvbGludFwiOlwi4qiUXCIsXCJucHJcIjpcIuKKgFwiLFwibnByY3VlXCI6XCLii6BcIixcIm5wcmVjXCI6XCLiioBcIixcIm5wcmVjZXFcIjpcIuKqr8y4XCIsXCJucHJlXCI6XCLiqq/MuFwiLFwibnJhcnJjXCI6XCLipLPMuFwiLFwibnJhcnJcIjpcIuKGm1wiLFwibnJBcnJcIjpcIuKHj1wiLFwibnJhcnJ3XCI6XCLihp3MuFwiLFwibnJpZ2h0YXJyb3dcIjpcIuKGm1wiLFwiblJpZ2h0YXJyb3dcIjpcIuKHj1wiLFwibnJ0cmlcIjpcIuKLq1wiLFwibnJ0cmllXCI6XCLii61cIixcIm5zY1wiOlwi4oqBXCIsXCJuc2NjdWVcIjpcIuKLoVwiLFwibnNjZVwiOlwi4qqwzLhcIixcIk5zY3JcIjpcIvCdkqlcIixcIm5zY3JcIjpcIvCdk4NcIixcIm5zaG9ydG1pZFwiOlwi4oikXCIsXCJuc2hvcnRwYXJhbGxlbFwiOlwi4oimXCIsXCJuc2ltXCI6XCLiiYFcIixcIm5zaW1lXCI6XCLiiYRcIixcIm5zaW1lcVwiOlwi4omEXCIsXCJuc21pZFwiOlwi4oikXCIsXCJuc3BhclwiOlwi4oimXCIsXCJuc3FzdWJlXCI6XCLii6JcIixcIm5zcXN1cGVcIjpcIuKLo1wiLFwibnN1YlwiOlwi4oqEXCIsXCJuc3ViRVwiOlwi4quFzLhcIixcIm5zdWJlXCI6XCLiiohcIixcIm5zdWJzZXRcIjpcIuKKguKDklwiLFwibnN1YnNldGVxXCI6XCLiiohcIixcIm5zdWJzZXRlcXFcIjpcIuKrhcy4XCIsXCJuc3VjY1wiOlwi4oqBXCIsXCJuc3VjY2VxXCI6XCLiqrDMuFwiLFwibnN1cFwiOlwi4oqFXCIsXCJuc3VwRVwiOlwi4quGzLhcIixcIm5zdXBlXCI6XCLiiolcIixcIm5zdXBzZXRcIjpcIuKKg+KDklwiLFwibnN1cHNldGVxXCI6XCLiiolcIixcIm5zdXBzZXRlcXFcIjpcIuKrhsy4XCIsXCJudGdsXCI6XCLiiblcIixcIk50aWxkZVwiOlwiw5FcIixcIm50aWxkZVwiOlwiw7FcIixcIm50bGdcIjpcIuKJuFwiLFwibnRyaWFuZ2xlbGVmdFwiOlwi4ouqXCIsXCJudHJpYW5nbGVsZWZ0ZXFcIjpcIuKLrFwiLFwibnRyaWFuZ2xlcmlnaHRcIjpcIuKLq1wiLFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwi4outXCIsXCJOdVwiOlwizp1cIixcIm51XCI6XCLOvVwiLFwibnVtXCI6XCIjXCIsXCJudW1lcm9cIjpcIuKEllwiLFwibnVtc3BcIjpcIuKAh1wiLFwibnZhcFwiOlwi4omN4oOSXCIsXCJudmRhc2hcIjpcIuKKrFwiLFwibnZEYXNoXCI6XCLiiq1cIixcIm5WZGFzaFwiOlwi4oquXCIsXCJuVkRhc2hcIjpcIuKKr1wiLFwibnZnZVwiOlwi4oml4oOSXCIsXCJudmd0XCI6XCI+4oOSXCIsXCJudkhhcnJcIjpcIuKkhFwiLFwibnZpbmZpblwiOlwi4qeeXCIsXCJudmxBcnJcIjpcIuKkglwiLFwibnZsZVwiOlwi4omk4oOSXCIsXCJudmx0XCI6XCI84oOSXCIsXCJudmx0cmllXCI6XCLiirTig5JcIixcIm52ckFyclwiOlwi4qSDXCIsXCJudnJ0cmllXCI6XCLiirXig5JcIixcIm52c2ltXCI6XCLiiLzig5JcIixcIm53YXJoa1wiOlwi4qSjXCIsXCJud2FyclwiOlwi4oaWXCIsXCJud0FyclwiOlwi4oeWXCIsXCJud2Fycm93XCI6XCLihpZcIixcIm53bmVhclwiOlwi4qSnXCIsXCJPYWN1dGVcIjpcIsOTXCIsXCJvYWN1dGVcIjpcIsOzXCIsXCJvYXN0XCI6XCLiiptcIixcIk9jaXJjXCI6XCLDlFwiLFwib2NpcmNcIjpcIsO0XCIsXCJvY2lyXCI6XCLiippcIixcIk9jeVwiOlwi0J5cIixcIm9jeVwiOlwi0L5cIixcIm9kYXNoXCI6XCLiip1cIixcIk9kYmxhY1wiOlwixZBcIixcIm9kYmxhY1wiOlwixZFcIixcIm9kaXZcIjpcIuKouFwiLFwib2RvdFwiOlwi4oqZXCIsXCJvZHNvbGRcIjpcIuKmvFwiLFwiT0VsaWdcIjpcIsWSXCIsXCJvZWxpZ1wiOlwixZNcIixcIm9mY2lyXCI6XCLipr9cIixcIk9mclwiOlwi8J2UklwiLFwib2ZyXCI6XCLwnZSsXCIsXCJvZ29uXCI6XCLLm1wiLFwiT2dyYXZlXCI6XCLDklwiLFwib2dyYXZlXCI6XCLDslwiLFwib2d0XCI6XCLip4FcIixcIm9oYmFyXCI6XCLiprVcIixcIm9obVwiOlwizqlcIixcIm9pbnRcIjpcIuKIrlwiLFwib2xhcnJcIjpcIuKGulwiLFwib2xjaXJcIjpcIuKmvlwiLFwib2xjcm9zc1wiOlwi4qa7XCIsXCJvbGluZVwiOlwi4oC+XCIsXCJvbHRcIjpcIuKngFwiLFwiT21hY3JcIjpcIsWMXCIsXCJvbWFjclwiOlwixY1cIixcIk9tZWdhXCI6XCLOqVwiLFwib21lZ2FcIjpcIs+JXCIsXCJPbWljcm9uXCI6XCLOn1wiLFwib21pY3JvblwiOlwizr9cIixcIm9taWRcIjpcIuKmtlwiLFwib21pbnVzXCI6XCLiipZcIixcIk9vcGZcIjpcIvCdlYZcIixcIm9vcGZcIjpcIvCdlaBcIixcIm9wYXJcIjpcIuKmt1wiLFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnFwiLFwiT3BlbkN1cmx5UXVvdGVcIjpcIuKAmFwiLFwib3BlcnBcIjpcIuKmuVwiLFwib3BsdXNcIjpcIuKKlVwiLFwib3JhcnJcIjpcIuKGu1wiLFwiT3JcIjpcIuKplFwiLFwib3JcIjpcIuKIqFwiLFwib3JkXCI6XCLiqZ1cIixcIm9yZGVyXCI6XCLihLRcIixcIm9yZGVyb2ZcIjpcIuKEtFwiLFwib3JkZlwiOlwiwqpcIixcIm9yZG1cIjpcIsK6XCIsXCJvcmlnb2ZcIjpcIuKKtlwiLFwib3JvclwiOlwi4qmWXCIsXCJvcnNsb3BlXCI6XCLiqZdcIixcIm9ydlwiOlwi4qmbXCIsXCJvU1wiOlwi4pOIXCIsXCJPc2NyXCI6XCLwnZKqXCIsXCJvc2NyXCI6XCLihLRcIixcIk9zbGFzaFwiOlwiw5hcIixcIm9zbGFzaFwiOlwiw7hcIixcIm9zb2xcIjpcIuKKmFwiLFwiT3RpbGRlXCI6XCLDlVwiLFwib3RpbGRlXCI6XCLDtVwiLFwib3RpbWVzYXNcIjpcIuKotlwiLFwiT3RpbWVzXCI6XCLiqLdcIixcIm90aW1lc1wiOlwi4oqXXCIsXCJPdW1sXCI6XCLDllwiLFwib3VtbFwiOlwiw7ZcIixcIm92YmFyXCI6XCLijL1cIixcIk92ZXJCYXJcIjpcIuKAvlwiLFwiT3ZlckJyYWNlXCI6XCLij55cIixcIk92ZXJCcmFja2V0XCI6XCLijrRcIixcIk92ZXJQYXJlbnRoZXNpc1wiOlwi4o+cXCIsXCJwYXJhXCI6XCLCtlwiLFwicGFyYWxsZWxcIjpcIuKIpVwiLFwicGFyXCI6XCLiiKVcIixcInBhcnNpbVwiOlwi4quzXCIsXCJwYXJzbFwiOlwi4qu9XCIsXCJwYXJ0XCI6XCLiiIJcIixcIlBhcnRpYWxEXCI6XCLiiIJcIixcIlBjeVwiOlwi0J9cIixcInBjeVwiOlwi0L9cIixcInBlcmNudFwiOlwiJVwiLFwicGVyaW9kXCI6XCIuXCIsXCJwZXJtaWxcIjpcIuKAsFwiLFwicGVycFwiOlwi4oqlXCIsXCJwZXJ0ZW5rXCI6XCLigLFcIixcIlBmclwiOlwi8J2Uk1wiLFwicGZyXCI6XCLwnZStXCIsXCJQaGlcIjpcIs6mXCIsXCJwaGlcIjpcIs+GXCIsXCJwaGl2XCI6XCLPlVwiLFwicGhtbWF0XCI6XCLihLNcIixcInBob25lXCI6XCLimI5cIixcIlBpXCI6XCLOoFwiLFwicGlcIjpcIs+AXCIsXCJwaXRjaGZvcmtcIjpcIuKLlFwiLFwicGl2XCI6XCLPllwiLFwicGxhbmNrXCI6XCLihI9cIixcInBsYW5ja2hcIjpcIuKEjlwiLFwicGxhbmt2XCI6XCLihI9cIixcInBsdXNhY2lyXCI6XCLiqKNcIixcInBsdXNiXCI6XCLiip5cIixcInBsdXNjaXJcIjpcIuKoolwiLFwicGx1c1wiOlwiK1wiLFwicGx1c2RvXCI6XCLiiJRcIixcInBsdXNkdVwiOlwi4qilXCIsXCJwbHVzZVwiOlwi4qmyXCIsXCJQbHVzTWludXNcIjpcIsKxXCIsXCJwbHVzbW5cIjpcIsKxXCIsXCJwbHVzc2ltXCI6XCLiqKZcIixcInBsdXN0d29cIjpcIuKop1wiLFwicG1cIjpcIsKxXCIsXCJQb2luY2FyZXBsYW5lXCI6XCLihIxcIixcInBvaW50aW50XCI6XCLiqJVcIixcInBvcGZcIjpcIvCdlaFcIixcIlBvcGZcIjpcIuKEmVwiLFwicG91bmRcIjpcIsKjXCIsXCJwcmFwXCI6XCLiqrdcIixcIlByXCI6XCLiqrtcIixcInByXCI6XCLiibpcIixcInByY3VlXCI6XCLiibxcIixcInByZWNhcHByb3hcIjpcIuKqt1wiLFwicHJlY1wiOlwi4om6XCIsXCJwcmVjY3VybHllcVwiOlwi4om8XCIsXCJQcmVjZWRlc1wiOlwi4om6XCIsXCJQcmVjZWRlc0VxdWFsXCI6XCLiqq9cIixcIlByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4om8XCIsXCJQcmVjZWRlc1RpbGRlXCI6XCLiib5cIixcInByZWNlcVwiOlwi4qqvXCIsXCJwcmVjbmFwcHJveFwiOlwi4qq5XCIsXCJwcmVjbmVxcVwiOlwi4qq1XCIsXCJwcmVjbnNpbVwiOlwi4ouoXCIsXCJwcmVcIjpcIuKqr1wiLFwicHJFXCI6XCLiqrNcIixcInByZWNzaW1cIjpcIuKJvlwiLFwicHJpbWVcIjpcIuKAslwiLFwiUHJpbWVcIjpcIuKAs1wiLFwicHJpbWVzXCI6XCLihJlcIixcInBybmFwXCI6XCLiqrlcIixcInBybkVcIjpcIuKqtVwiLFwicHJuc2ltXCI6XCLii6hcIixcInByb2RcIjpcIuKIj1wiLFwiUHJvZHVjdFwiOlwi4oiPXCIsXCJwcm9mYWxhclwiOlwi4oyuXCIsXCJwcm9mbGluZVwiOlwi4oySXCIsXCJwcm9mc3VyZlwiOlwi4oyTXCIsXCJwcm9wXCI6XCLiiJ1cIixcIlByb3BvcnRpb25hbFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uXCI6XCLiiLdcIixcInByb3B0b1wiOlwi4oidXCIsXCJwcnNpbVwiOlwi4om+XCIsXCJwcnVyZWxcIjpcIuKKsFwiLFwiUHNjclwiOlwi8J2Sq1wiLFwicHNjclwiOlwi8J2ThVwiLFwiUHNpXCI6XCLOqFwiLFwicHNpXCI6XCLPiFwiLFwicHVuY3NwXCI6XCLigIhcIixcIlFmclwiOlwi8J2UlFwiLFwicWZyXCI6XCLwnZSuXCIsXCJxaW50XCI6XCLiqIxcIixcInFvcGZcIjpcIvCdlaJcIixcIlFvcGZcIjpcIuKEmlwiLFwicXByaW1lXCI6XCLigZdcIixcIlFzY3JcIjpcIvCdkqxcIixcInFzY3JcIjpcIvCdk4ZcIixcInF1YXRlcm5pb25zXCI6XCLihI1cIixcInF1YXRpbnRcIjpcIuKollwiLFwicXVlc3RcIjpcIj9cIixcInF1ZXN0ZXFcIjpcIuKJn1wiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwickFhcnJcIjpcIuKHm1wiLFwicmFjZVwiOlwi4oi9zLFcIixcIlJhY3V0ZVwiOlwixZRcIixcInJhY3V0ZVwiOlwixZVcIixcInJhZGljXCI6XCLiiJpcIixcInJhZW1wdHl2XCI6XCLiprNcIixcInJhbmdcIjpcIuKfqVwiLFwiUmFuZ1wiOlwi4p+rXCIsXCJyYW5nZFwiOlwi4qaSXCIsXCJyYW5nZVwiOlwi4qalXCIsXCJyYW5nbGVcIjpcIuKfqVwiLFwicmFxdW9cIjpcIsK7XCIsXCJyYXJyYXBcIjpcIuKltVwiLFwicmFycmJcIjpcIuKHpVwiLFwicmFycmJmc1wiOlwi4qSgXCIsXCJyYXJyY1wiOlwi4qSzXCIsXCJyYXJyXCI6XCLihpJcIixcIlJhcnJcIjpcIuKGoFwiLFwickFyclwiOlwi4oeSXCIsXCJyYXJyZnNcIjpcIuKknlwiLFwicmFycmhrXCI6XCLihqpcIixcInJhcnJscFwiOlwi4oasXCIsXCJyYXJycGxcIjpcIuKlhVwiLFwicmFycnNpbVwiOlwi4qW0XCIsXCJSYXJydGxcIjpcIuKkllwiLFwicmFycnRsXCI6XCLihqNcIixcInJhcnJ3XCI6XCLihp1cIixcInJhdGFpbFwiOlwi4qSaXCIsXCJyQXRhaWxcIjpcIuKknFwiLFwicmF0aW9cIjpcIuKItlwiLFwicmF0aW9uYWxzXCI6XCLihJpcIixcInJiYXJyXCI6XCLipI1cIixcInJCYXJyXCI6XCLipI9cIixcIlJCYXJyXCI6XCLipJBcIixcInJiYnJrXCI6XCLinbNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwi4qaMXCIsXCJyYnJrc2xkXCI6XCLipo5cIixcInJicmtzbHVcIjpcIuKmkFwiLFwiUmNhcm9uXCI6XCLFmFwiLFwicmNhcm9uXCI6XCLFmVwiLFwiUmNlZGlsXCI6XCLFllwiLFwicmNlZGlsXCI6XCLFl1wiLFwicmNlaWxcIjpcIuKMiVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCLQoFwiLFwicmN5XCI6XCLRgFwiLFwicmRjYVwiOlwi4qS3XCIsXCJyZGxkaGFyXCI6XCLipalcIixcInJkcXVvXCI6XCLigJ1cIixcInJkcXVvclwiOlwi4oCdXCIsXCJyZHNoXCI6XCLihrNcIixcInJlYWxcIjpcIuKEnFwiLFwicmVhbGluZVwiOlwi4oSbXCIsXCJyZWFscGFydFwiOlwi4oScXCIsXCJyZWFsc1wiOlwi4oSdXCIsXCJSZVwiOlwi4oScXCIsXCJyZWN0XCI6XCLilq1cIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcIlJldmVyc2VFbGVtZW50XCI6XCLiiItcIixcIlJldmVyc2VFcXVpbGlicml1bVwiOlwi4oeLXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwi4qWvXCIsXCJyZmlzaHRcIjpcIuKlvVwiLFwicmZsb29yXCI6XCLijItcIixcInJmclwiOlwi8J2Ur1wiLFwiUmZyXCI6XCLihJxcIixcInJIYXJcIjpcIuKlpFwiLFwicmhhcmRcIjpcIuKHgVwiLFwicmhhcnVcIjpcIuKHgFwiLFwicmhhcnVsXCI6XCLipaxcIixcIlJob1wiOlwizqFcIixcInJob1wiOlwiz4FcIixcInJob3ZcIjpcIs+xXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwi4p+pXCIsXCJSaWdodEFycm93QmFyXCI6XCLih6VcIixcInJpZ2h0YXJyb3dcIjpcIuKGklwiLFwiUmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJSaWdodGFycm93XCI6XCLih5JcIixcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIuKHhFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIuKGo1wiLFwiUmlnaHRDZWlsaW5nXCI6XCLijIlcIixcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwi4p+nXCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIuKlnVwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCLipZVcIixcIlJpZ2h0RG93blZlY3RvclwiOlwi4oeCXCIsXCJSaWdodEZsb29yXCI6XCLijItcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIuKHgVwiLFwicmlnaHRoYXJwb29udXBcIjpcIuKHgFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCLih4RcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCLih4xcIixcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIuKHiVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCLihp1cIixcIlJpZ2h0VGVlQXJyb3dcIjpcIuKGplwiLFwiUmlnaHRUZWVcIjpcIuKKolwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIuKlm1wiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCLii4xcIixcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwi4oqzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKKtVwiLFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIuKlj1wiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwi4qWcXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCLipZRcIixcIlJpZ2h0VXBWZWN0b3JcIjpcIuKGvlwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIuKlk1wiLFwiUmlnaHRWZWN0b3JcIjpcIuKHgFwiLFwicmluZ1wiOlwiy5pcIixcInJpc2luZ2RvdHNlcVwiOlwi4omTXCIsXCJybGFyclwiOlwi4oeEXCIsXCJybGhhclwiOlwi4oeMXCIsXCJybG1cIjpcIuKAj1wiLFwicm1vdXN0YWNoZVwiOlwi4o6xXCIsXCJybW91c3RcIjpcIuKOsVwiLFwicm5taWRcIjpcIuKrrlwiLFwicm9hbmdcIjpcIuKfrVwiLFwicm9hcnJcIjpcIuKHvlwiLFwicm9icmtcIjpcIuKfp1wiLFwicm9wYXJcIjpcIuKmhlwiLFwicm9wZlwiOlwi8J2Vo1wiLFwiUm9wZlwiOlwi4oSdXCIsXCJyb3BsdXNcIjpcIuKorlwiLFwicm90aW1lc1wiOlwi4qi1XCIsXCJSb3VuZEltcGxpZXNcIjpcIuKlsFwiLFwicnBhclwiOlwiKVwiLFwicnBhcmd0XCI6XCLippRcIixcInJwcG9saW50XCI6XCLiqJJcIixcInJyYXJyXCI6XCLih4lcIixcIlJyaWdodGFycm93XCI6XCLih5tcIixcInJzYXF1b1wiOlwi4oC6XCIsXCJyc2NyXCI6XCLwnZOHXCIsXCJSc2NyXCI6XCLihJtcIixcInJzaFwiOlwi4oaxXCIsXCJSc2hcIjpcIuKGsVwiLFwicnNxYlwiOlwiXVwiLFwicnNxdW9cIjpcIuKAmVwiLFwicnNxdW9yXCI6XCLigJlcIixcInJ0aHJlZVwiOlwi4ouMXCIsXCJydGltZXNcIjpcIuKLilwiLFwicnRyaVwiOlwi4pa5XCIsXCJydHJpZVwiOlwi4oq1XCIsXCJydHJpZlwiOlwi4pa4XCIsXCJydHJpbHRyaVwiOlwi4qeOXCIsXCJSdWxlRGVsYXllZFwiOlwi4qe0XCIsXCJydWx1aGFyXCI6XCLipahcIixcInJ4XCI6XCLihJ5cIixcIlNhY3V0ZVwiOlwixZpcIixcInNhY3V0ZVwiOlwixZtcIixcInNicXVvXCI6XCLigJpcIixcInNjYXBcIjpcIuKquFwiLFwiU2Nhcm9uXCI6XCLFoFwiLFwic2Nhcm9uXCI6XCLFoVwiLFwiU2NcIjpcIuKqvFwiLFwic2NcIjpcIuKJu1wiLFwic2NjdWVcIjpcIuKJvVwiLFwic2NlXCI6XCLiqrBcIixcInNjRVwiOlwi4qq0XCIsXCJTY2VkaWxcIjpcIsWeXCIsXCJzY2VkaWxcIjpcIsWfXCIsXCJTY2lyY1wiOlwixZxcIixcInNjaXJjXCI6XCLFnVwiLFwic2NuYXBcIjpcIuKqulwiLFwic2NuRVwiOlwi4qq2XCIsXCJzY25zaW1cIjpcIuKLqVwiLFwic2Nwb2xpbnRcIjpcIuKok1wiLFwic2NzaW1cIjpcIuKJv1wiLFwiU2N5XCI6XCLQoVwiLFwic2N5XCI6XCLRgVwiLFwic2RvdGJcIjpcIuKKoVwiLFwic2RvdFwiOlwi4ouFXCIsXCJzZG90ZVwiOlwi4qmmXCIsXCJzZWFyaGtcIjpcIuKkpVwiLFwic2VhcnJcIjpcIuKGmFwiLFwic2VBcnJcIjpcIuKHmFwiLFwic2VhcnJvd1wiOlwi4oaYXCIsXCJzZWN0XCI6XCLCp1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCLipKlcIixcInNldG1pbnVzXCI6XCLiiJZcIixcInNldG1uXCI6XCLiiJZcIixcInNleHRcIjpcIuKctlwiLFwiU2ZyXCI6XCLwnZSWXCIsXCJzZnJcIjpcIvCdlLBcIixcInNmcm93blwiOlwi4oyiXCIsXCJzaGFycFwiOlwi4pmvXCIsXCJTSENIY3lcIjpcItCpXCIsXCJzaGNoY3lcIjpcItGJXCIsXCJTSGN5XCI6XCLQqFwiLFwic2hjeVwiOlwi0YhcIixcIlNob3J0RG93bkFycm93XCI6XCLihpNcIixcIlNob3J0TGVmdEFycm93XCI6XCLihpBcIixcInNob3J0bWlkXCI6XCLiiKNcIixcInNob3J0cGFyYWxsZWxcIjpcIuKIpVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCLihpJcIixcIlNob3J0VXBBcnJvd1wiOlwi4oaRXCIsXCJzaHlcIjpcIsKtXCIsXCJTaWdtYVwiOlwizqNcIixcInNpZ21hXCI6XCLPg1wiLFwic2lnbWFmXCI6XCLPglwiLFwic2lnbWF2XCI6XCLPglwiLFwic2ltXCI6XCLiiLxcIixcInNpbWRvdFwiOlwi4qmqXCIsXCJzaW1lXCI6XCLiiYNcIixcInNpbWVxXCI6XCLiiYNcIixcInNpbWdcIjpcIuKqnlwiLFwic2ltZ0VcIjpcIuKqoFwiLFwic2ltbFwiOlwi4qqdXCIsXCJzaW1sRVwiOlwi4qqfXCIsXCJzaW1uZVwiOlwi4omGXCIsXCJzaW1wbHVzXCI6XCLiqKRcIixcInNpbXJhcnJcIjpcIuKlslwiLFwic2xhcnJcIjpcIuKGkFwiLFwiU21hbGxDaXJjbGVcIjpcIuKImFwiLFwic21hbGxzZXRtaW51c1wiOlwi4oiWXCIsXCJzbWFzaHBcIjpcIuKos1wiLFwic21lcGFyc2xcIjpcIuKnpFwiLFwic21pZFwiOlwi4oijXCIsXCJzbWlsZVwiOlwi4oyjXCIsXCJzbXRcIjpcIuKqqlwiLFwic210ZVwiOlwi4qqsXCIsXCJzbXRlc1wiOlwi4qqs77iAXCIsXCJTT0ZUY3lcIjpcItCsXCIsXCJzb2Z0Y3lcIjpcItGMXCIsXCJzb2xiYXJcIjpcIuKMv1wiLFwic29sYlwiOlwi4qeEXCIsXCJzb2xcIjpcIi9cIixcIlNvcGZcIjpcIvCdlYpcIixcInNvcGZcIjpcIvCdlaRcIixcInNwYWRlc1wiOlwi4pmgXCIsXCJzcGFkZXN1aXRcIjpcIuKZoFwiLFwic3BhclwiOlwi4oilXCIsXCJzcWNhcFwiOlwi4oqTXCIsXCJzcWNhcHNcIjpcIuKKk++4gFwiLFwic3FjdXBcIjpcIuKKlFwiLFwic3FjdXBzXCI6XCLiipTvuIBcIixcIlNxcnRcIjpcIuKImlwiLFwic3FzdWJcIjpcIuKKj1wiLFwic3FzdWJlXCI6XCLiipFcIixcInNxc3Vic2V0XCI6XCLiio9cIixcInNxc3Vic2V0ZXFcIjpcIuKKkVwiLFwic3FzdXBcIjpcIuKKkFwiLFwic3FzdXBlXCI6XCLiipJcIixcInNxc3Vwc2V0XCI6XCLiipBcIixcInNxc3Vwc2V0ZXFcIjpcIuKKklwiLFwic3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIuKKk1wiLFwiU3F1YXJlU3Vic2V0XCI6XCLiio9cIixcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCLiipFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCLiipBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKKklwiLFwiU3F1YXJlVW5pb25cIjpcIuKKlFwiLFwic3F1YXJmXCI6XCLilqpcIixcInNxdVwiOlwi4pahXCIsXCJzcXVmXCI6XCLilqpcIixcInNyYXJyXCI6XCLihpJcIixcIlNzY3JcIjpcIvCdkq5cIixcInNzY3JcIjpcIvCdk4hcIixcInNzZXRtblwiOlwi4oiWXCIsXCJzc21pbGVcIjpcIuKMo1wiLFwic3N0YXJmXCI6XCLii4ZcIixcIlN0YXJcIjpcIuKLhlwiLFwic3RhclwiOlwi4piGXCIsXCJzdGFyZlwiOlwi4piFXCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIs+1XCIsXCJzdHJhaWdodHBoaVwiOlwiz5VcIixcInN0cm5zXCI6XCLCr1wiLFwic3ViXCI6XCLiioJcIixcIlN1YlwiOlwi4ouQXCIsXCJzdWJkb3RcIjpcIuKqvVwiLFwic3ViRVwiOlwi4quFXCIsXCJzdWJlXCI6XCLiioZcIixcInN1YmVkb3RcIjpcIuKrg1wiLFwic3VibXVsdFwiOlwi4quBXCIsXCJzdWJuRVwiOlwi4quLXCIsXCJzdWJuZVwiOlwi4oqKXCIsXCJzdWJwbHVzXCI6XCLiqr9cIixcInN1YnJhcnJcIjpcIuKluVwiLFwic3Vic2V0XCI6XCLiioJcIixcIlN1YnNldFwiOlwi4ouQXCIsXCJzdWJzZXRlcVwiOlwi4oqGXCIsXCJzdWJzZXRlcXFcIjpcIuKrhVwiLFwiU3Vic2V0RXF1YWxcIjpcIuKKhlwiLFwic3Vic2V0bmVxXCI6XCLiiopcIixcInN1YnNldG5lcXFcIjpcIuKri1wiLFwic3Vic2ltXCI6XCLiq4dcIixcInN1YnN1YlwiOlwi4quVXCIsXCJzdWJzdXBcIjpcIuKrk1wiLFwic3VjY2FwcHJveFwiOlwi4qq4XCIsXCJzdWNjXCI6XCLiibtcIixcInN1Y2NjdXJseWVxXCI6XCLiib1cIixcIlN1Y2NlZWRzXCI6XCLiibtcIixcIlN1Y2NlZWRzRXF1YWxcIjpcIuKqsFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCLiib1cIixcIlN1Y2NlZWRzVGlsZGVcIjpcIuKJv1wiLFwic3VjY2VxXCI6XCLiqrBcIixcInN1Y2NuYXBwcm94XCI6XCLiqrpcIixcInN1Y2NuZXFxXCI6XCLiqrZcIixcInN1Y2Nuc2ltXCI6XCLii6lcIixcInN1Y2NzaW1cIjpcIuKJv1wiLFwiU3VjaFRoYXRcIjpcIuKIi1wiLFwic3VtXCI6XCLiiJFcIixcIlN1bVwiOlwi4oiRXCIsXCJzdW5nXCI6XCLimapcIixcInN1cDFcIjpcIsK5XCIsXCJzdXAyXCI6XCLCslwiLFwic3VwM1wiOlwiwrNcIixcInN1cFwiOlwi4oqDXCIsXCJTdXBcIjpcIuKLkVwiLFwic3VwZG90XCI6XCLiqr5cIixcInN1cGRzdWJcIjpcIuKrmFwiLFwic3VwRVwiOlwi4quGXCIsXCJzdXBlXCI6XCLiiodcIixcInN1cGVkb3RcIjpcIuKrhFwiLFwiU3VwZXJzZXRcIjpcIuKKg1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwi4oqHXCIsXCJzdXBoc29sXCI6XCLin4lcIixcInN1cGhzdWJcIjpcIuKrl1wiLFwic3VwbGFyclwiOlwi4qW7XCIsXCJzdXBtdWx0XCI6XCLiq4JcIixcInN1cG5FXCI6XCLiq4xcIixcInN1cG5lXCI6XCLiiotcIixcInN1cHBsdXNcIjpcIuKrgFwiLFwic3Vwc2V0XCI6XCLiioNcIixcIlN1cHNldFwiOlwi4ouRXCIsXCJzdXBzZXRlcVwiOlwi4oqHXCIsXCJzdXBzZXRlcXFcIjpcIuKrhlwiLFwic3Vwc2V0bmVxXCI6XCLiiotcIixcInN1cHNldG5lcXFcIjpcIuKrjFwiLFwic3Vwc2ltXCI6XCLiq4hcIixcInN1cHN1YlwiOlwi4quUXCIsXCJzdXBzdXBcIjpcIuKrllwiLFwic3dhcmhrXCI6XCLipKZcIixcInN3YXJyXCI6XCLihplcIixcInN3QXJyXCI6XCLih5lcIixcInN3YXJyb3dcIjpcIuKGmVwiLFwic3dud2FyXCI6XCLipKpcIixcInN6bGlnXCI6XCLDn1wiLFwiVGFiXCI6XCJcXHRcIixcInRhcmdldFwiOlwi4oyWXCIsXCJUYXVcIjpcIs6kXCIsXCJ0YXVcIjpcIs+EXCIsXCJ0YnJrXCI6XCLijrRcIixcIlRjYXJvblwiOlwixaRcIixcInRjYXJvblwiOlwixaVcIixcIlRjZWRpbFwiOlwixaJcIixcInRjZWRpbFwiOlwixaNcIixcIlRjeVwiOlwi0KJcIixcInRjeVwiOlwi0YJcIixcInRkb3RcIjpcIuKDm1wiLFwidGVscmVjXCI6XCLijJVcIixcIlRmclwiOlwi8J2Ul1wiLFwidGZyXCI6XCLwnZSxXCIsXCJ0aGVyZTRcIjpcIuKItFwiLFwidGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGV0YVwiOlwizphcIixcInRoZXRhXCI6XCLOuFwiLFwidGhldGFzeW1cIjpcIs+RXCIsXCJ0aGV0YXZcIjpcIs+RXCIsXCJ0aGlja2FwcHJveFwiOlwi4omIXCIsXCJ0aGlja3NpbVwiOlwi4oi8XCIsXCJUaGlja1NwYWNlXCI6XCLigZ/igIpcIixcIlRoaW5TcGFjZVwiOlwi4oCJXCIsXCJ0aGluc3BcIjpcIuKAiVwiLFwidGhrYXBcIjpcIuKJiFwiLFwidGhrc2ltXCI6XCLiiLxcIixcIlRIT1JOXCI6XCLDnlwiLFwidGhvcm5cIjpcIsO+XCIsXCJ0aWxkZVwiOlwiy5xcIixcIlRpbGRlXCI6XCLiiLxcIixcIlRpbGRlRXF1YWxcIjpcIuKJg1wiLFwiVGlsZGVGdWxsRXF1YWxcIjpcIuKJhVwiLFwiVGlsZGVUaWxkZVwiOlwi4omIXCIsXCJ0aW1lc2JhclwiOlwi4qixXCIsXCJ0aW1lc2JcIjpcIuKKoFwiLFwidGltZXNcIjpcIsOXXCIsXCJ0aW1lc2RcIjpcIuKosFwiLFwidGludFwiOlwi4oitXCIsXCJ0b2VhXCI6XCLipKhcIixcInRvcGJvdFwiOlwi4oy2XCIsXCJ0b3BjaXJcIjpcIuKrsVwiLFwidG9wXCI6XCLiiqRcIixcIlRvcGZcIjpcIvCdlYtcIixcInRvcGZcIjpcIvCdlaVcIixcInRvcGZvcmtcIjpcIuKrmlwiLFwidG9zYVwiOlwi4qSpXCIsXCJ0cHJpbWVcIjpcIuKAtFwiLFwidHJhZGVcIjpcIuKEolwiLFwiVFJBREVcIjpcIuKEolwiLFwidHJpYW5nbGVcIjpcIuKWtVwiLFwidHJpYW5nbGVkb3duXCI6XCLilr9cIixcInRyaWFuZ2xlbGVmdFwiOlwi4peDXCIsXCJ0cmlhbmdsZWxlZnRlcVwiOlwi4oq0XCIsXCJ0cmlhbmdsZXFcIjpcIuKJnFwiLFwidHJpYW5nbGVyaWdodFwiOlwi4pa5XCIsXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIuKKtVwiLFwidHJpZG90XCI6XCLil6xcIixcInRyaWVcIjpcIuKJnFwiLFwidHJpbWludXNcIjpcIuKoulwiLFwiVHJpcGxlRG90XCI6XCLig5tcIixcInRyaXBsdXNcIjpcIuKouVwiLFwidHJpc2JcIjpcIuKnjVwiLFwidHJpdGltZVwiOlwi4qi7XCIsXCJ0cnBleml1bVwiOlwi4o+iXCIsXCJUc2NyXCI6XCLwnZKvXCIsXCJ0c2NyXCI6XCLwnZOJXCIsXCJUU2N5XCI6XCLQplwiLFwidHNjeVwiOlwi0YZcIixcIlRTSGN5XCI6XCLQi1wiLFwidHNoY3lcIjpcItGbXCIsXCJUc3Ryb2tcIjpcIsWmXCIsXCJ0c3Ryb2tcIjpcIsWnXCIsXCJ0d2l4dFwiOlwi4omsXCIsXCJ0d29oZWFkbGVmdGFycm93XCI6XCLihp5cIixcInR3b2hlYWRyaWdodGFycm93XCI6XCLihqBcIixcIlVhY3V0ZVwiOlwiw5pcIixcInVhY3V0ZVwiOlwiw7pcIixcInVhcnJcIjpcIuKGkVwiLFwiVWFyclwiOlwi4oafXCIsXCJ1QXJyXCI6XCLih5FcIixcIlVhcnJvY2lyXCI6XCLipYlcIixcIlVicmN5XCI6XCLQjlwiLFwidWJyY3lcIjpcItGeXCIsXCJVYnJldmVcIjpcIsWsXCIsXCJ1YnJldmVcIjpcIsWtXCIsXCJVY2lyY1wiOlwiw5tcIixcInVjaXJjXCI6XCLDu1wiLFwiVWN5XCI6XCLQo1wiLFwidWN5XCI6XCLRg1wiLFwidWRhcnJcIjpcIuKHhVwiLFwiVWRibGFjXCI6XCLFsFwiLFwidWRibGFjXCI6XCLFsVwiLFwidWRoYXJcIjpcIuKlrlwiLFwidWZpc2h0XCI6XCLipb5cIixcIlVmclwiOlwi8J2UmFwiLFwidWZyXCI6XCLwnZSyXCIsXCJVZ3JhdmVcIjpcIsOZXCIsXCJ1Z3JhdmVcIjpcIsO5XCIsXCJ1SGFyXCI6XCLipaNcIixcInVoYXJsXCI6XCLihr9cIixcInVoYXJyXCI6XCLihr5cIixcInVoYmxrXCI6XCLiloBcIixcInVsY29yblwiOlwi4oycXCIsXCJ1bGNvcm5lclwiOlwi4oycXCIsXCJ1bGNyb3BcIjpcIuKMj1wiLFwidWx0cmlcIjpcIuKXuFwiLFwiVW1hY3JcIjpcIsWqXCIsXCJ1bWFjclwiOlwixatcIixcInVtbFwiOlwiwqhcIixcIlVuZGVyQmFyXCI6XCJfXCIsXCJVbmRlckJyYWNlXCI6XCLij59cIixcIlVuZGVyQnJhY2tldFwiOlwi4o61XCIsXCJVbmRlclBhcmVudGhlc2lzXCI6XCLij51cIixcIlVuaW9uXCI6XCLii4NcIixcIlVuaW9uUGx1c1wiOlwi4oqOXCIsXCJVb2dvblwiOlwixbJcIixcInVvZ29uXCI6XCLFs1wiLFwiVW9wZlwiOlwi8J2VjFwiLFwidW9wZlwiOlwi8J2VplwiLFwiVXBBcnJvd0JhclwiOlwi4qSSXCIsXCJ1cGFycm93XCI6XCLihpFcIixcIlVwQXJyb3dcIjpcIuKGkVwiLFwiVXBhcnJvd1wiOlwi4oeRXCIsXCJVcEFycm93RG93bkFycm93XCI6XCLih4VcIixcInVwZG93bmFycm93XCI6XCLihpVcIixcIlVwRG93bkFycm93XCI6XCLihpVcIixcIlVwZG93bmFycm93XCI6XCLih5VcIixcIlVwRXF1aWxpYnJpdW1cIjpcIuKlrlwiLFwidXBoYXJwb29ubGVmdFwiOlwi4oa/XCIsXCJ1cGhhcnBvb25yaWdodFwiOlwi4oa+XCIsXCJ1cGx1c1wiOlwi4oqOXCIsXCJVcHBlckxlZnRBcnJvd1wiOlwi4oaWXCIsXCJVcHBlclJpZ2h0QXJyb3dcIjpcIuKGl1wiLFwidXBzaVwiOlwiz4VcIixcIlVwc2lcIjpcIs+SXCIsXCJ1cHNpaFwiOlwiz5JcIixcIlVwc2lsb25cIjpcIs6lXCIsXCJ1cHNpbG9uXCI6XCLPhVwiLFwiVXBUZWVBcnJvd1wiOlwi4oalXCIsXCJVcFRlZVwiOlwi4oqlXCIsXCJ1cHVwYXJyb3dzXCI6XCLih4hcIixcInVyY29yblwiOlwi4oydXCIsXCJ1cmNvcm5lclwiOlwi4oydXCIsXCJ1cmNyb3BcIjpcIuKMjlwiLFwiVXJpbmdcIjpcIsWuXCIsXCJ1cmluZ1wiOlwixa9cIixcInVydHJpXCI6XCLil7lcIixcIlVzY3JcIjpcIvCdkrBcIixcInVzY3JcIjpcIvCdk4pcIixcInV0ZG90XCI6XCLii7BcIixcIlV0aWxkZVwiOlwixahcIixcInV0aWxkZVwiOlwixalcIixcInV0cmlcIjpcIuKWtVwiLFwidXRyaWZcIjpcIuKWtFwiLFwidXVhcnJcIjpcIuKHiFwiLFwiVXVtbFwiOlwiw5xcIixcInV1bWxcIjpcIsO8XCIsXCJ1d2FuZ2xlXCI6XCLipqdcIixcInZhbmdydFwiOlwi4qacXCIsXCJ2YXJlcHNpbG9uXCI6XCLPtVwiLFwidmFya2FwcGFcIjpcIs+wXCIsXCJ2YXJub3RoaW5nXCI6XCLiiIVcIixcInZhcnBoaVwiOlwiz5VcIixcInZhcnBpXCI6XCLPllwiLFwidmFycHJvcHRvXCI6XCLiiJ1cIixcInZhcnJcIjpcIuKGlVwiLFwidkFyclwiOlwi4oeVXCIsXCJ2YXJyaG9cIjpcIs+xXCIsXCJ2YXJzaWdtYVwiOlwiz4JcIixcInZhcnN1YnNldG5lcVwiOlwi4oqK77iAXCIsXCJ2YXJzdWJzZXRuZXFxXCI6XCLiq4vvuIBcIixcInZhcnN1cHNldG5lcVwiOlwi4oqL77iAXCIsXCJ2YXJzdXBzZXRuZXFxXCI6XCLiq4zvuIBcIixcInZhcnRoZXRhXCI6XCLPkVwiLFwidmFydHJpYW5nbGVsZWZ0XCI6XCLiirJcIixcInZhcnRyaWFuZ2xlcmlnaHRcIjpcIuKKs1wiLFwidkJhclwiOlwi4quoXCIsXCJWYmFyXCI6XCLiq6tcIixcInZCYXJ2XCI6XCLiq6lcIixcIlZjeVwiOlwi0JJcIixcInZjeVwiOlwi0LJcIixcInZkYXNoXCI6XCLiiqJcIixcInZEYXNoXCI6XCLiiqhcIixcIlZkYXNoXCI6XCLiiqlcIixcIlZEYXNoXCI6XCLiiqtcIixcIlZkYXNobFwiOlwi4qumXCIsXCJ2ZWViYXJcIjpcIuKKu1wiLFwidmVlXCI6XCLiiKhcIixcIlZlZVwiOlwi4ouBXCIsXCJ2ZWVlcVwiOlwi4omaXCIsXCJ2ZWxsaXBcIjpcIuKLrlwiLFwidmVyYmFyXCI6XCJ8XCIsXCJWZXJiYXJcIjpcIuKAllwiLFwidmVydFwiOlwifFwiLFwiVmVydFwiOlwi4oCWXCIsXCJWZXJ0aWNhbEJhclwiOlwi4oijXCIsXCJWZXJ0aWNhbExpbmVcIjpcInxcIixcIlZlcnRpY2FsU2VwYXJhdG9yXCI6XCLinZhcIixcIlZlcnRpY2FsVGlsZGVcIjpcIuKJgFwiLFwiVmVyeVRoaW5TcGFjZVwiOlwi4oCKXCIsXCJWZnJcIjpcIvCdlJlcIixcInZmclwiOlwi8J2Us1wiLFwidmx0cmlcIjpcIuKKslwiLFwidm5zdWJcIjpcIuKKguKDklwiLFwidm5zdXBcIjpcIuKKg+KDklwiLFwiVm9wZlwiOlwi8J2VjVwiLFwidm9wZlwiOlwi8J2Vp1wiLFwidnByb3BcIjpcIuKInVwiLFwidnJ0cmlcIjpcIuKKs1wiLFwiVnNjclwiOlwi8J2SsVwiLFwidnNjclwiOlwi8J2Ti1wiLFwidnN1Ym5FXCI6XCLiq4vvuIBcIixcInZzdWJuZVwiOlwi4oqK77iAXCIsXCJ2c3VwbkVcIjpcIuKrjO+4gFwiLFwidnN1cG5lXCI6XCLiiovvuIBcIixcIlZ2ZGFzaFwiOlwi4oqqXCIsXCJ2emlnemFnXCI6XCLipppcIixcIldjaXJjXCI6XCLFtFwiLFwid2NpcmNcIjpcIsW1XCIsXCJ3ZWRiYXJcIjpcIuKpn1wiLFwid2VkZ2VcIjpcIuKIp1wiLFwiV2VkZ2VcIjpcIuKLgFwiLFwid2VkZ2VxXCI6XCLiiZlcIixcIndlaWVycFwiOlwi4oSYXCIsXCJXZnJcIjpcIvCdlJpcIixcIndmclwiOlwi8J2UtFwiLFwiV29wZlwiOlwi8J2VjlwiLFwid29wZlwiOlwi8J2VqFwiLFwid3BcIjpcIuKEmFwiLFwid3JcIjpcIuKJgFwiLFwid3JlYXRoXCI6XCLiiYBcIixcIldzY3JcIjpcIvCdkrJcIixcIndzY3JcIjpcIvCdk4xcIixcInhjYXBcIjpcIuKLglwiLFwieGNpcmNcIjpcIuKXr1wiLFwieGN1cFwiOlwi4ouDXCIsXCJ4ZHRyaVwiOlwi4pa9XCIsXCJYZnJcIjpcIvCdlJtcIixcInhmclwiOlwi8J2UtVwiLFwieGhhcnJcIjpcIuKft1wiLFwieGhBcnJcIjpcIuKfulwiLFwiWGlcIjpcIs6eXCIsXCJ4aVwiOlwizr5cIixcInhsYXJyXCI6XCLin7VcIixcInhsQXJyXCI6XCLin7hcIixcInhtYXBcIjpcIuKfvFwiLFwieG5pc1wiOlwi4ou7XCIsXCJ4b2RvdFwiOlwi4qiAXCIsXCJYb3BmXCI6XCLwnZWPXCIsXCJ4b3BmXCI6XCLwnZWpXCIsXCJ4b3BsdXNcIjpcIuKogVwiLFwieG90aW1lXCI6XCLiqIJcIixcInhyYXJyXCI6XCLin7ZcIixcInhyQXJyXCI6XCLin7lcIixcIlhzY3JcIjpcIvCdkrNcIixcInhzY3JcIjpcIvCdk41cIixcInhzcWN1cFwiOlwi4qiGXCIsXCJ4dXBsdXNcIjpcIuKohFwiLFwieHV0cmlcIjpcIuKWs1wiLFwieHZlZVwiOlwi4ouBXCIsXCJ4d2VkZ2VcIjpcIuKLgFwiLFwiWWFjdXRlXCI6XCLDnVwiLFwieWFjdXRlXCI6XCLDvVwiLFwiWUFjeVwiOlwi0K9cIixcInlhY3lcIjpcItGPXCIsXCJZY2lyY1wiOlwixbZcIixcInljaXJjXCI6XCLFt1wiLFwiWWN5XCI6XCLQq1wiLFwieWN5XCI6XCLRi1wiLFwieWVuXCI6XCLCpVwiLFwiWWZyXCI6XCLwnZScXCIsXCJ5ZnJcIjpcIvCdlLZcIixcIllJY3lcIjpcItCHXCIsXCJ5aWN5XCI6XCLRl1wiLFwiWW9wZlwiOlwi8J2VkFwiLFwieW9wZlwiOlwi8J2VqlwiLFwiWXNjclwiOlwi8J2StFwiLFwieXNjclwiOlwi8J2TjlwiLFwiWVVjeVwiOlwi0K5cIixcInl1Y3lcIjpcItGOXCIsXCJ5dW1sXCI6XCLDv1wiLFwiWXVtbFwiOlwixbhcIixcIlphY3V0ZVwiOlwixblcIixcInphY3V0ZVwiOlwixbpcIixcIlpjYXJvblwiOlwixb1cIixcInpjYXJvblwiOlwixb5cIixcIlpjeVwiOlwi0JdcIixcInpjeVwiOlwi0LdcIixcIlpkb3RcIjpcIsW7XCIsXCJ6ZG90XCI6XCLFvFwiLFwiemVldHJmXCI6XCLihKhcIixcIlplcm9XaWR0aFNwYWNlXCI6XCLigItcIixcIlpldGFcIjpcIs6WXCIsXCJ6ZXRhXCI6XCLOtlwiLFwiemZyXCI6XCLwnZS3XCIsXCJaZnJcIjpcIuKEqFwiLFwiWkhjeVwiOlwi0JZcIixcInpoY3lcIjpcItC2XCIsXCJ6aWdyYXJyXCI6XCLih51cIixcInpvcGZcIjpcIvCdlatcIixcIlpvcGZcIjpcIuKEpFwiLFwiWnNjclwiOlwi8J2StVwiLFwienNjclwiOlwi8J2Tj1wiLFwiendqXCI6XCLigI1cIixcInp3bmpcIjpcIuKAjFwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iaiwgX1ZkdCwgYmxvY2tzLCAkY2FsbGVlKSB7XG4gICAgX1ZkdCB8fCAoX1ZkdCA9IFZkdCk7XG4gICAgb2JqIHx8IChvYmogPSB7fSk7XG4gICAgYmxvY2tzIHx8IChibG9ja3MgPSB7fSk7XG4gICAgdmFyIGggPSBfVmR0Lm1pc3MuaCwgaGMgPSBfVmR0Lm1pc3MuaGMsIGh1ID0gX1ZkdC5taXNzLmh1LCB3aWRnZXRzID0gdGhpcyAmJiB0aGlzLndpZGdldHMgfHwge30sIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSB7fSxcbiAgICAgICAgX191ID0gX1ZkdC51dGlscywgZXh0ZW5kID0gX191LmV4dGVuZCwgX2UgPSBfX3UuZXJyb3IsIF9jbGFzc05hbWUgPSBfX3UuY2xhc3NOYW1lLCBfX3NsaWNlID0gX191LnNsaWNlLCBfX25vb3AgPSBfX3Uubm9vcCxcbiAgICAgICAgX19tID0gX191Lm1hcCwgX19vID0gX191Lk9wdGlvbnMsIF9nZXRNb2RlbCA9IF9fby5nZXRNb2RlbCwgX3NldE1vZGVsID0gX19vLnNldE1vZGVsLFxuICAgICAgICBfc2V0Q2hlY2tib3hNb2RlbCA9IF9fdS5zZXRDaGVja2JveE1vZGVsLCBfZGV0ZWN0Q2hlY2tib3hDaGVja2VkID0gX191LmRldGVjdENoZWNrYm94Q2hlY2tlZCxcbiAgICAgICAgX3NldFNlbGVjdE1vZGVsID0gX191LnNldFNlbGVjdE1vZGVsLFxuICAgICAgICBzZWxmID0gdGhpcy5kYXRhLCAkdGhpcyA9IHRoaXMsIHNjb3BlID0gb2JqLCBBbmltYXRlID0gc2VsZiAmJiBzZWxmLkFuaW1hdGUsIHBhcmVudCA9ICgkY2FsbGVlIHx8IHt9KS5fc3VwZXI7XG5cbiAgICBjb25zdCBjYXRhbG9ncyA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAn5Z+656GAJyxcbiAgICAgICAgc3ViQ2F0YWxvZ3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+W8gOWniycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3N0YXJ0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0ludGFjdOWunuS+iycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2luc3RhbmNlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+e7hOS7tueUn+WRveWRqOacnycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2xpZmVjeWNsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfmqKHmnb/or63ms5UnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdzeW50YXgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5LqL5Lu25aSE55CGJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnZXZlbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn6KGo5Y2V5aSE55CGJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnZm9ybSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfnu4Tku7YnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdjb21wb25lbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn57uE5Lu257un5om/JyxcbiAgICAgICAgICAgICAgICBocmVmOiAnZXh0ZW5kJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAn6L+b6Zi2JyxcbiAgICAgICAgc3ViQ2F0YWxvZ3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+WKqOeUuycsXG4gICAgICAgICAgICAgICAgaHJlZjogJ2FuaW1hdGlvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfmqKHmnb90ZW1wbGF0ZScsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3RlbXBsYXRlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+i3r+eUsScsXG4gICAgICAgICAgICAgICAgaHJlZjogJ3JvdXRlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICd3ZWJwYWNr5a6e6Le1JyxcbiAgICAgICAgICAgICAgICBocmVmOiAncHJvamVjdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICfmnI3liqHlmajnq6/muLLmn5MnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICdzc3InXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICflhbblroMnLFxuICAgICAgICBzdWJDYXRhbG9nczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAn5pu05paw5pel5b+XJyxcbiAgICAgICAgICAgICAgICBocmVmOiAnY2hhbmdlbG9nJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcbmxldCBjdXJyZW50TmF2ID0ge307XG5cbmNvbnN0IFN1YnMgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChhdHRyLnN1YnMpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSA/XG4gICAgICAgIGgoJ3VsJywgbnVsbCwgX19tKGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChhdHRyLnN1YnMpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2xpJywgbnVsbCwgW1xuICAgICAgICAgICAgICAgIGgoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICdldi1jbGljayc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChzZWxmLnNjcm9sbFRvLmJpbmQoc2VsZiwgdmFsdWUudGl0bGUsIGF0dHIuc3Vicy5hY3RpdmUpKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcylcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUudGl0bGUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSksXG4gICAgICAgICAgICAgICAgaChTdWJzLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdWJzJzogZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHZhbHVlLnN1YnMpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgJ19jb250ZXh0JzogJHRoaXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSwgX2NsYXNzTmFtZShmdW5jdGlvbigpIHt0cnkge3JldHVybiAoe1xuICAgICAgICAgICAgYWN0aXZlOiBzZWxmLmdldChhdHRyLnN1YnMuYWN0aXZlKSA9PT0gdmFsdWUudGl0bGVcbiAgICAgICAgfSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpKSk7XG4gICAgICAgIH0sICR0aGlzKSwgJ3N1Yi1jYXRhbG9ncycpIDpcbiAgICAgICAgdW5kZWZpbmVkXG59O1xuICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfb2JqID0ge1xuICAgICAgICAgICAgJ25hdkluZGV4JzogJ2RvY3VtZW50JyxcbiAgICAgICAgICAgICdjbGFzc05hbWUnOiAnZG9jdW1lbnQtcGFnZScsXG4gICAgICAgICAgICAuLi5mdW5jdGlvbigpIHt0cnkge3JldHVybiAoc2NvcGUpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyZW50LmNhbGwoJHRoaXMsIF9vYmosIF9WZHQsIGZ1bmN0aW9uKGJsb2Nrcykge1xuICAgICAgICAgICAgdmFyIF9ibG9ja3MgPSB7fSwgX19ibG9ja3MgPSBleHRlbmQoe30sIGJsb2Nrcyk7XG4gICAgICAgICAgICByZXR1cm4gKChfYmxvY2tzWydjb250ZW50J10gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBoKCdhc2lkZScsIG51bGwsIGgoJ2RpdicsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fbShmdW5jdGlvbigpIHt0cnkge3JldHVybiAoY2F0YWxvZ3MpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKCdkaXYnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2g1JywgbnVsbCwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHZhbHVlLnRpdGxlKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCd1bCcsIG51bGwsIF9fbShmdW5jdGlvbigpIHt0cnkge3JldHVybiAodmFsdWUuc3ViQ2F0YWxvZ3MpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoJ2xpJywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICgoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaHJlZiA9PT0gc2VsZi5nZXQoJ3RpdGxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROYXYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHJlZic6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICgnIy9kb2N1bWVudC8nICsgdmFsdWUuaHJlZil9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHZhbHVlLnRpdGxlKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuICh2YWx1ZS5ocmVmID09PSBzZWxmLmdldCgndGl0bGUnKSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaChTdWJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Vicyc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChzZWxmLmdldCgnc3ViQ2F0YWxvZ3MnKSl9IGNhdGNoKGUpIHtfZShlKX19LmNhbGwoJHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ19jb250ZXh0JzogJHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sIF9jbGFzc05hbWUoZnVuY3Rpb24oKSB7dHJ5IHtyZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHZhbHVlLmhyZWYgPT09IHNlbGYuZ2V0KCd0aXRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgJHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sICdjYXRhbG9nLXNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICR0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsIG51bGwsICdhc2lkZS1ib3JkZXIgdHJhbnNpdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIF0sICdhc2lkZS13cmFwcGVyJykpLFxuICAgICAgICAgICAgICAgICAgICBoKCdhcnRpY2xlJywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgaCgnZGl2JywgbnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsIGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChjdXJyZW50TmF2LnRpdGxlKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcyksICd0aXRsZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2RpdicsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbiAgICAgICAgICAgICAgICAgICAg5aaC5p6c5L2g5Y+R546w5paH5qGj5pyJ6Zeu6aKY77yM6K+35biu5b+Z5ZyoXFxuICAgICAgICAgICAgICAgICAgICAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6ICdfYmxhbmsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hyZWYnOiBmdW5jdGlvbigpIHt0cnkge3JldHVybiAoYGh0dHBzOi8vZ2l0aHViLmNvbS9KYXZleS9JbnRhY3QvYmxvYi9tYXN0ZXIvZG9jcy8ke3NlbGYuZ2V0KCd0aXRsZScpfS5tZGApfSBjYXRjaChlKSB7X2UoZSl9fS5jYWxsKCR0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAnZ2l0aHViJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4gICAgICAgICAgICAgICAgICAgIOS4iuS/ruato+ivpeaWh+aho1xcbiAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgJ2VkaXQtbGluaycpXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCAnYXJ0aWNsZS1oZWFkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lubmVySFRNTCc6IGZ1bmN0aW9uKCkge3RyeSB7cmV0dXJuIChzZWxmLmdldCgnY29udGVudCcpKX0gY2F0Y2goZSkge19lKGUpfX0uY2FsbCgkdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pICYmIChfX2Jsb2Nrc1snY29udGVudCddID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2Nrc1snY29udGVudCddID8gYmxvY2tzWydjb250ZW50J10uYXBwbHkoJHRoaXMsIFtmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9ibG9ja3NbJ2NvbnRlbnQnXS5hcHBseSgkdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzLCAxKSkpIDogX2Jsb2Nrc1snY29udGVudCddLmFwcGx5KCR0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0pLCBfX2Jsb2Nrcyk7XG4gICAgICAgIH0uY2FsbCgkdGhpcywgYmxvY2tzKSwgcGFyZW50KVxuICAgIH0pLmNhbGwoJHRoaXMpXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC52ZHQiLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ2YXIgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgc2h1ZmZsZVNlbGYgPSByZXF1aXJlKCcuL19zaHVmZmxlU2VsZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U2h1ZmZsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheVNodWZmbGUuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUtleXMuanMiLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmFuZG9tO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VSYW5kb20uanMiLCJ2YXIgc2h1ZmZsZVNlbGYgPSByZXF1aXJlKCcuL19zaHVmZmxlU2VsZicpLFxuICAgIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2h1ZmZsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlU2h1ZmZsZS5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVZhbHVlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlVmFsdWVzLmpzIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRSYXdUYWcuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc0luZGV4LmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19ub2RlVXRpbC5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19vdmVyQXJnLmpzIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzU3ltYm9sLmpzIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9rZXlzLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvbm93LmpzIiwidmFyIGFycmF5U2h1ZmZsZSA9IHJlcXVpcmUoJy4vX2FycmF5U2h1ZmZsZScpLFxuICAgIGJhc2VTaHVmZmxlID0gcmVxdWlyZSgnLi9fYmFzZVNodWZmbGUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2h1ZmZsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3NodWZmbGUuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdGhyb3R0bGUuanMiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvTnVtYmVyLmpzIiwidmFyIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC92YWx1ZXMuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5obGpzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG4gIGNvbG9yOiAjNTI1MjUyO1xcbiAgcGFkZGluZzogMTVweDtcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG59XFxuLmhsanMtZG9jdHlwZSB7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuLmhsanMtdGFnIHtcXG4gIGNvbG9yOiAjM2U3NmY2O1xcbn1cXG4uaGxqcy1hdHRyaWJ1dGUge1xcbiAgY29sb3I6ICNlOTY5MDA7XFxufVxcbi5obGpzLXZhbHVlIHtcXG4gIGNvbG9yOiAjNDJiOTgzO1xcbn1cXG4uaGxqcy1rZXl3b3JkIHtcXG4gIGNvbG9yOiAjZTk2OTAwO1xcbn1cXG4uaGxqcy1zdHJpbmcge1xcbiAgY29sb3I6ICM0MmI5ODM7XFxufVxcbi5obGpzLWNvbW1lbnQge1xcbiAgY29sb3I6ICNiM2IzYjM7XFxufVxcbi5obGpzLW9wZXJhdG9yIC5obGpzLWNvbW1lbnQge1xcbiAgY29sb3I6ICM1MjUyNTI7XFxufVxcbi5obGpzLXJlZ2V4cCB7XFxuICBjb2xvcjogI2FmN2RmZjtcXG59XFxuLmhsanMtYnVpbHRfaW4ge1xcbiAgY29sb3I6ICMyZGI3ZjU7XFxufVxcbi5jc3MgLmhsanMtY2xhc3Mge1xcbiAgY29sb3I6ICNlOTY5MDA7XFxufVxcbi5jc3MgLmhsanMtbnVtYmVyLFxcbi5qYXZhc2NyaXB0IC5obGpzLW51bWJlciB7XFxuICBjb2xvcjogI2ZjMWU3MDtcXG59XFxuLmNzcyAuaGxqcy1hdHRyaWJ1dGUge1xcbiAgY29sb3I6ICNhZjdkZmY7XFxufVxcbi5jc3MgLmhsanMtaW1wb3J0YW50IHtcXG4gIGNvbG9yOiAjZDA0O1xcbn1cXG4uYWN0aW9uc2NyaXB0IC5obGpzLWxpdGVyYWwsXFxuLmphdmFzY3JpcHQgLmhsanMtbGl0ZXJhbCB7XFxuICBjb2xvcjogI2ZjMWU3MDtcXG59XFxucHJlIHtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxufVxcbmNvZGUge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYmFja2dyb3VuZDogI2Y3ZjdmNztcXG4gIGZvbnQtZmFtaWx5OiBDb25zb2xhcywgTW9uYWNvLCBBbmRhbGUgTW9ubywgVWJ1bnR1IE1vbm8sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogM3B4O1xcbiAgcGFkZGluZzogMXB4IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGNvbG9yOiAjNjY2O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSB7XFxuICBwYWRkaW5nLXRvcDogOTVweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIuZml4ZWQge1xcbiAgbWFyZ2luLWJvdHRvbTogMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlci5maXhlZCAuYXNpZGUtd3JhcHBlciB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDgwcHg7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA4MHB4KTtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHdpZHRoOiAyMDBweDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciB7XFxuICB3aWR0aDogMTA4MHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDFweCByZ2JhKDAsMCwwLDAuMDgpO1xcbiAgbWluLWhlaWdodDogY2FsYygxMDAlIC0gMTVweCk7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXNpZGUge1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2VlZTtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciAuYXNpZGUtd3JhcHBlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgaDUge1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgbWFyZ2luOiAyNXB4IDAgMTVweCAyMHB4O1xcbiAgY29sb3I6ICM5OTk7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgdWwge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgYSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGhlaWdodDogMzBweDtcXG4gIGxpbmUtaGVpZ2h0OiAzMHB4O1xcbiAgcGFkZGluZy1sZWZ0OiAyNXB4O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgYTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZjNmM2YzO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIC5hY3RpdmUgPiBhIHtcXG4gIGNvbG9yOiAjZmU0NDQ0O1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hc2lkZS13cmFwcGVyIC5zdWItY2F0YWxvZ3Mge1xcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICBmb250LXNpemU6IDEycHg7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFzaWRlLXdyYXBwZXIgLmFzaWRlLWJvcmRlciB7XFxuICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCAjZmU0NDQ0O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSB7XFxuICBmbGV4OiAxO1xcbiAgcGFkZGluZzogMTBweCAyMHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgLmFydGljbGUtaGVhZCAudGl0bGUge1xcbiAgcGFkZGluZzogMTBweCAwO1xcbiAgZm9udC1zaXplOiAyLjJlbTtcXG4gIGNvbG9yOiAjMDAwO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIC5hcnRpY2xlLWhlYWQgLmVkaXQtbGluayB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMjBweDtcXG4gIGNvbG9yOiAjOTk5O1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG4uZG9jdW1lbnQtcGFnZSAuY29udGVudC13cmFwcGVyIGFydGljbGUgaDEge1xcbiAgcGFkZGluZzogMTBweCAwO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XFxuICBtYXJnaW46IDIwcHggMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIGgyLFxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSBoMyB7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBtYXJnaW46IDE1cHggMDtcXG59XFxuLmRvY3VtZW50LXBhZ2UgLmNvbnRlbnQtd3JhcHBlciBhcnRpY2xlIHAge1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxufVxcbi5kb2N1bWVudC1wYWdlIC5jb250ZW50LXdyYXBwZXIgYXJ0aWNsZSAub3V0cHV0IHtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbWFyZ2luOiAyMHB4IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9zdHlsdXMtbG9hZGVyP3tcImluY2x1ZGUgY3NzXCI6dHJ1ZX0hLi9zaXRlL3BhZ2VzL2RvY3VtZW50L2RvY3VtZW50LnN0eWxcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2RvY3VtZW50LnN0eWxcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2RvY3VtZW50LnN0eWxcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTItMiEuL2RvY3VtZW50LnN0eWxcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2l0ZS9wYWdlcy9kb2N1bWVudC9kb2N1bWVudC5zdHlsXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJzb3VyY2VSb290IjoiIn0=